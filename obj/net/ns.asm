
obj/net/ns:     file format elf32-i386


Disassembly of section .text:

00800020 <_start>:
// starts us running when we are initially loaded into a new environment.
.text
.globl _start
_start:
	// See if we were started with arguments on the stack
	cmpl $USTACKTOP, %esp
  800020:	81 fc 00 e0 bf ee    	cmp    $0xeebfe000,%esp
	jne args_exist
  800026:	75 04                	jne    80002c <args_exist>

	// If not, push dummy argc/argv arguments.
	// This happens when we are loaded by the kernel,
	// because the kernel does not know about passing arguments.
	pushl $0
  800028:	6a 00                	push   $0x0
	pushl $0
  80002a:	6a 00                	push   $0x0

0080002c <args_exist>:

args_exist:
	call libmain
  80002c:	e8 ae e8 00 00       	call   80e8df <libmain>
1:	jmp 1b
  800031:	eb fe                	jmp    800031 <args_exist+0x5>

00800033 <tcpip_init_done>:
		panic("cannot create timer thread: %s", e2s(r));
}

static void
tcpip_init_done(void *arg)
{
  800033:	f3 0f 1e fb          	endbr32 
  800037:	55                   	push   %ebp
  800038:	89 e5                	mov    %esp,%ebp
  80003a:	83 ec 14             	sub    $0x14,%esp
  80003d:	8b 45 08             	mov    0x8(%ebp),%eax
	uint32_t *done = arg;
	*done = 1;
  800040:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
	thread_wakeup(done);
  800046:	50                   	push   %eax
  800047:	e8 65 a8 00 00       	call   80a8b1 <thread_wakeup>
}
  80004c:	83 c4 10             	add    $0x10,%esp
  80004f:	c9                   	leave  
  800050:	c3                   	ret    

00800051 <start_timer>:
{
  800051:	55                   	push   %ebp
  800052:	89 e5                	mov    %esp,%ebp
  800054:	53                   	push   %ebx
  800055:	83 ec 04             	sub    $0x4,%esp
	t->msec = msec;
  800058:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80005b:	89 18                	mov    %ebx,(%eax)
	t->func = func;
  80005d:	89 50 04             	mov    %edx,0x4(%eax)
	t->name = name;
  800060:	89 48 08             	mov    %ecx,0x8(%eax)
	int r = thread_create(0, name, &net_timer, (uint32_t)t);
  800063:	50                   	push   %eax
  800064:	68 98 00 80 00       	push   $0x800098
  800069:	51                   	push   %ecx
  80006a:	6a 00                	push   $0x0
  80006c:	e8 b7 a8 00 00       	call   80a928 <thread_create>
	if (r < 0)
  800071:	83 c4 10             	add    $0x10,%esp
  800074:	85 c0                	test   %eax,%eax
  800076:	78 05                	js     80007d <start_timer+0x2c>
}
  800078:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80007b:	c9                   	leave  
  80007c:	c3                   	ret    
		panic("cannot create timer thread: %s", e2s(r));
  80007d:	83 ec 0c             	sub    $0xc,%esp
  800080:	50                   	push   %eax
  800081:	e8 f7 ab 00 00       	call   80ac7d <e2s>
  800086:	50                   	push   %eax
  800087:	68 40 13 81 00       	push   $0x811340
  80008c:	6a 7a                	push   $0x7a
  80008e:	68 75 14 81 00       	push   $0x811475
  800093:	e8 af e8 00 00       	call   80e947 <_panic>

00800098 <net_timer>:
{
  800098:	f3 0f 1e fb          	endbr32 
  80009c:	55                   	push   %ebp
  80009d:	89 e5                	mov    %esp,%ebp
  80009f:	56                   	push   %esi
  8000a0:	53                   	push   %ebx
	struct timer_thread *t = (struct timer_thread *) arg;
  8000a1:	8b 75 08             	mov    0x8(%ebp),%esi
		uint32_t cur = sys_time_msec();
  8000a4:	e8 e2 f5 00 00       	call   80f68b <sys_time_msec>
  8000a9:	89 c3                	mov    %eax,%ebx
		lwip_core_lock();
  8000ab:	e8 c8 a7 00 00       	call   80a878 <lwip_core_lock>
		t->func();
  8000b0:	ff 56 04             	call   *0x4(%esi)
		lwip_core_unlock();
  8000b3:	e8 c5 a7 00 00       	call   80a87d <lwip_core_unlock>
		thread_wait(0, 0, cur + t->msec);
  8000b8:	83 ec 04             	sub    $0x4,%esp
  8000bb:	03 1e                	add    (%esi),%ebx
  8000bd:	53                   	push   %ebx
  8000be:	6a 00                	push   $0x0
  8000c0:	6a 00                	push   $0x0
  8000c2:	e8 15 aa 00 00       	call   80aadc <thread_wait>
  8000c7:	83 c4 10             	add    $0x10,%esp
  8000ca:	eb d8                	jmp    8000a4 <net_timer+0xc>

008000cc <serve_thread>:
	uint32_t whom;
	union Nsipc *req;
};

static void
serve_thread(uint32_t a) {
  8000cc:	f3 0f 1e fb          	endbr32 
  8000d0:	55                   	push   %ebp
  8000d1:	89 e5                	mov    %esp,%ebp
  8000d3:	57                   	push   %edi
  8000d4:	56                   	push   %esi
  8000d5:	53                   	push   %ebx
  8000d6:	83 ec 7c             	sub    $0x7c,%esp
  8000d9:	8b 5d 08             	mov    0x8(%ebp),%ebx
	struct st_args *args = (struct st_args *)a;
	union Nsipc *req = args->req;
  8000dc:	8b 7b 08             	mov    0x8(%ebx),%edi
  8000df:	83 3b 0a             	cmpl   $0xa,(%ebx)
  8000e2:	0f 87 50 01 00 00    	ja     800238 <serve_thread+0x16c>
  8000e8:	8b 03                	mov    (%ebx),%eax
  8000ea:	3e ff 24 85 20 15 81 	notrack jmp *0x811520(,%eax,4)
  8000f1:	00 

	switch (args->reqno) {
	case NSREQ_ACCEPT:
	{
		struct Nsret_accept ret;
		ret.ret_addrlen = req->accept.req_addrlen;
  8000f2:	8b 47 04             	mov    0x4(%edi),%eax
  8000f5:	89 45 94             	mov    %eax,-0x6c(%ebp)
		r = lwip_accept(req->accept.req_s, &ret.ret_addr,
  8000f8:	83 ec 04             	sub    $0x4,%esp
  8000fb:	8d 45 94             	lea    -0x6c(%ebp),%eax
  8000fe:	50                   	push   %eax
  8000ff:	8d 45 84             	lea    -0x7c(%ebp),%eax
  800102:	50                   	push   %eax
  800103:	ff 37                	pushl  (%edi)
  800105:	e8 28 0e 00 00       	call   800f32 <lwip_accept>
  80010a:	89 c6                	mov    %eax,%esi
				&ret.ret_addrlen);
		memmove(req, &ret, sizeof ret);
  80010c:	83 c4 0c             	add    $0xc,%esp
  80010f:	6a 14                	push   $0x14
  800111:	8d 45 84             	lea    -0x7c(%ebp),%eax
  800114:	50                   	push   %eax
  800115:	57                   	push   %edi
  800116:	e8 d3 f0 00 00       	call   80f1ee <memmove>
  80011b:	83 c4 10             	add    $0x10,%esp
		cprintf("Invalid request code %d from %08x\n", args->whom, args->req);
		r = -E_INVAL;
		break;
	}

	if (r == -1) {
  80011e:	83 fe ff             	cmp    $0xffffffff,%esi
  800121:	0f 84 2f 01 00 00    	je     800256 <serve_thread+0x18a>
		char buf[100];
		snprintf(buf, sizeof buf, "ns req type %d", args->reqno);
		perror(buf);
	}

	if (args->reqno != NSREQ_INPUT)
  800127:	83 3b 0a             	cmpl   $0xa,(%ebx)
  80012a:	0f 85 48 01 00 00    	jne    800278 <serve_thread+0x1ac>
		ipc_send(args->whom, r, 0, 0);

	put_buffer(args->req);
  800130:	8b 53 08             	mov    0x8(%ebx),%edx
	int i = ((uint32_t)va - REQVA) / PGSIZE;
  800133:	8d 82 00 50 01 f0    	lea    -0xffeb000(%edx),%eax
  800139:	c1 e8 0c             	shr    $0xc,%eax
	buse[i] = 0;
  80013c:	c6 80 00 50 81 00 00 	movb   $0x0,0x815000(%eax)
	sys_page_unmap(0, (void*) args->req);
  800143:	83 ec 08             	sub    $0x8,%esp
  800146:	52                   	push   %edx
  800147:	6a 00                	push   $0x0
  800149:	e8 b9 f3 00 00       	call   80f507 <sys_page_unmap>
	free(args);
  80014e:	89 1c 24             	mov    %ebx,(%esp)
  800151:	e8 fe 06 01 00       	call   810854 <free>
}
  800156:	83 c4 10             	add    $0x10,%esp
  800159:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80015c:	5b                   	pop    %ebx
  80015d:	5e                   	pop    %esi
  80015e:	5f                   	pop    %edi
  80015f:	5d                   	pop    %ebp
  800160:	c3                   	ret    
		r = lwip_bind(req->bind.req_s, &req->bind.req_name,
  800161:	83 ec 04             	sub    $0x4,%esp
  800164:	ff 77 14             	pushl  0x14(%edi)
  800167:	8d 47 04             	lea    0x4(%edi),%eax
  80016a:	50                   	push   %eax
  80016b:	ff 37                	pushl  (%edi)
  80016d:	e8 76 0f 00 00       	call   8010e8 <lwip_bind>
  800172:	89 c6                	mov    %eax,%esi
		break;
  800174:	83 c4 10             	add    $0x10,%esp
  800177:	eb a5                	jmp    80011e <serve_thread+0x52>
		r = lwip_shutdown(req->shutdown.req_s, req->shutdown.req_how);
  800179:	83 ec 08             	sub    $0x8,%esp
  80017c:	ff 77 04             	pushl  0x4(%edi)
  80017f:	ff 37                	pushl  (%edi)
  800181:	e8 ed 1a 00 00       	call   801c73 <lwip_shutdown>
  800186:	89 c6                	mov    %eax,%esi
		break;
  800188:	83 c4 10             	add    $0x10,%esp
  80018b:	eb 91                	jmp    80011e <serve_thread+0x52>
		r = lwip_close(req->close.req_s);
  80018d:	83 ec 0c             	sub    $0xc,%esp
  800190:	ff 37                	pushl  (%edi)
  800192:	e8 0b 10 00 00       	call   8011a2 <lwip_close>
  800197:	89 c6                	mov    %eax,%esi
		break;
  800199:	83 c4 10             	add    $0x10,%esp
  80019c:	eb 80                	jmp    80011e <serve_thread+0x52>
		r = lwip_connect(req->connect.req_s, &req->connect.req_name,
  80019e:	83 ec 04             	sub    $0x4,%esp
  8001a1:	ff 77 14             	pushl  0x14(%edi)
  8001a4:	8d 47 04             	lea    0x4(%edi),%eax
  8001a7:	50                   	push   %eax
  8001a8:	ff 37                	pushl  (%edi)
  8001aa:	e8 80 10 00 00       	call   80122f <lwip_connect>
  8001af:	89 c6                	mov    %eax,%esi
		break;
  8001b1:	83 c4 10             	add    $0x10,%esp
  8001b4:	e9 65 ff ff ff       	jmp    80011e <serve_thread+0x52>
		r = lwip_listen(req->listen.req_s, req->listen.req_backlog);
  8001b9:	83 ec 08             	sub    $0x8,%esp
  8001bc:	ff 77 04             	pushl  0x4(%edi)
  8001bf:	ff 37                	pushl  (%edi)
  8001c1:	e8 23 11 00 00       	call   8012e9 <lwip_listen>
  8001c6:	89 c6                	mov    %eax,%esi
		break;
  8001c8:	83 c4 10             	add    $0x10,%esp
  8001cb:	e9 4e ff ff ff       	jmp    80011e <serve_thread+0x52>
		r = lwip_recv(req->recv.req_s, req->recvRet.ret_buf,
  8001d0:	ff 77 08             	pushl  0x8(%edi)
  8001d3:	ff 77 04             	pushl  0x4(%edi)
  8001d6:	57                   	push   %edi
  8001d7:	ff 37                	pushl  (%edi)
  8001d9:	e8 02 14 00 00       	call   8015e0 <lwip_recv>
  8001de:	89 c6                	mov    %eax,%esi
		break;
  8001e0:	83 c4 10             	add    $0x10,%esp
  8001e3:	e9 36 ff ff ff       	jmp    80011e <serve_thread+0x52>
		r = lwip_send(req->send.req_s, &req->send.req_buf,
  8001e8:	ff 77 08             	pushl  0x8(%edi)
  8001eb:	ff 77 04             	pushl  0x4(%edi)
  8001ee:	8d 47 0c             	lea    0xc(%edi),%eax
  8001f1:	50                   	push   %eax
  8001f2:	ff 37                	pushl  (%edi)
  8001f4:	e8 81 15 00 00       	call   80177a <lwip_send>
  8001f9:	89 c6                	mov    %eax,%esi
		break;
  8001fb:	83 c4 10             	add    $0x10,%esp
  8001fe:	e9 1b ff ff ff       	jmp    80011e <serve_thread+0x52>
		r = lwip_socket(req->socket.req_domain, req->socket.req_type,
  800203:	83 ec 04             	sub    $0x4,%esp
  800206:	ff 77 08             	pushl  0x8(%edi)
  800209:	ff 77 04             	pushl  0x4(%edi)
  80020c:	ff 37                	pushl  (%edi)
  80020e:	e8 fc 15 00 00       	call   80180f <lwip_socket>
  800213:	89 c6                	mov    %eax,%esi
		break;
  800215:	83 c4 10             	add    $0x10,%esp
  800218:	e9 01 ff ff ff       	jmp    80011e <serve_thread+0x52>
		jif_input(&nif, (void *)&req->pkt);
  80021d:	83 ec 08             	sub    $0x8,%esp
  800220:	57                   	push   %edi
  800221:	68 00 b2 b3 00       	push   $0xb3b200
  800226:	e8 4d ab 00 00       	call   80ad78 <jif_input>
  80022b:	83 c4 10             	add    $0x10,%esp
		r = 0;
  80022e:	be 00 00 00 00       	mov    $0x0,%esi
  800233:	e9 ef fe ff ff       	jmp    800127 <serve_thread+0x5b>
		cprintf("Invalid request code %d from %08x\n", args->whom, args->req);
  800238:	83 ec 04             	sub    $0x4,%esp
  80023b:	57                   	push   %edi
  80023c:	ff 73 04             	pushl  0x4(%ebx)
  80023f:	68 60 13 81 00       	push   $0x811360
  800244:	e8 e5 e7 00 00       	call   80ea2e <cprintf>
  800249:	83 c4 10             	add    $0x10,%esp
		r = -E_INVAL;
  80024c:	be fd ff ff ff       	mov    $0xfffffffd,%esi
  800251:	e9 d1 fe ff ff       	jmp    800127 <serve_thread+0x5b>
		snprintf(buf, sizeof buf, "ns req type %d", args->reqno);
  800256:	ff 33                	pushl  (%ebx)
  800258:	68 80 14 81 00       	push   $0x811480
  80025d:	6a 64                	push   $0x64
  80025f:	8d 7d 84             	lea    -0x7c(%ebp),%edi
  800262:	57                   	push   %edi
  800263:	e8 6f ed 00 00       	call   80efd7 <snprintf>
		perror(buf);
  800268:	89 3c 24             	mov    %edi,(%esp)
  80026b:	e8 e5 a9 00 00       	call   80ac55 <perror>
  800270:	83 c4 10             	add    $0x10,%esp
  800273:	e9 af fe ff ff       	jmp    800127 <serve_thread+0x5b>
		ipc_send(args->whom, r, 0, 0);
  800278:	6a 00                	push   $0x0
  80027a:	6a 00                	push   $0x0
  80027c:	56                   	push   %esi
  80027d:	ff 73 04             	pushl  0x4(%ebx)
  800280:	e8 33 f8 00 00       	call   80fab8 <ipc_send>
  800285:	83 c4 10             	add    $0x10,%esp
  800288:	e9 a3 fe ff ff       	jmp    800130 <serve_thread+0x64>

0080028d <serve_init>:
{
  80028d:	f3 0f 1e fb          	endbr32 
  800291:	55                   	push   %ebp
  800292:	89 e5                	mov    %esp,%ebp
  800294:	56                   	push   %esi
  800295:	53                   	push   %ebx
  800296:	83 ec 10             	sub    $0x10,%esp
  800299:	8b 75 08             	mov    0x8(%ebp),%esi
	lwip_core_lock();
  80029c:	e8 d7 a5 00 00       	call   80a878 <lwip_core_lock>
	uint32_t done = 0;
  8002a1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	tcpip_init(&tcpip_init_done, &done);
  8002a8:	83 ec 08             	sub    $0x8,%esp
  8002ab:	8d 5d f4             	lea    -0xc(%ebp),%ebx
  8002ae:	53                   	push   %ebx
  8002af:	68 33 00 80 00       	push   $0x800033
  8002b4:	e8 97 22 00 00       	call   802550 <tcpip_init>
	lwip_core_unlock();
  8002b9:	e8 bf a5 00 00       	call   80a87d <lwip_core_unlock>
	thread_wait(&done, 0, (uint32_t)~0);
  8002be:	83 c4 0c             	add    $0xc,%esp
  8002c1:	6a ff                	push   $0xffffffff
  8002c3:	6a 00                	push   $0x0
  8002c5:	53                   	push   %ebx
  8002c6:	e8 11 a8 00 00       	call   80aadc <thread_wait>
	lwip_core_lock();
  8002cb:	e8 a8 a5 00 00       	call   80a878 <lwip_core_lock>
	ipaddr.addr  = init_addr;
  8002d0:	89 75 e8             	mov    %esi,-0x18(%ebp)
	netmask.addr = init_mask;
  8002d3:	8b 45 0c             	mov    0xc(%ebp),%eax
  8002d6:	89 45 ec             	mov    %eax,-0x14(%ebp)
	gateway.addr = init_gw;
  8002d9:	8b 45 10             	mov    0x10(%ebp),%eax
  8002dc:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (0 == netif_add(nif, &ipaddr, &netmask, &gateway,
  8002df:	83 c4 0c             	add    $0xc,%esp
  8002e2:	68 85 67 80 00       	push   $0x806785
  8002e7:	68 67 ae 80 00       	push   $0x80ae67
  8002ec:	68 14 50 81 00       	push   $0x815014
  8002f1:	8d 45 f0             	lea    -0x10(%ebp),%eax
  8002f4:	50                   	push   %eax
  8002f5:	8d 45 ec             	lea    -0x14(%ebp),%eax
  8002f8:	50                   	push   %eax
  8002f9:	8d 45 e8             	lea    -0x18(%ebp),%eax
  8002fc:	50                   	push   %eax
  8002fd:	68 00 b2 b3 00       	push   $0xb3b200
  800302:	e8 14 45 00 00       	call   80481b <netif_add>
  800307:	83 c4 20             	add    $0x20,%esp
  80030a:	85 c0                	test   %eax,%eax
  80030c:	0f 84 cc 00 00 00    	je     8003de <serve_init+0x151>
	netif_set_default(nif);
  800312:	83 ec 0c             	sub    $0xc,%esp
  800315:	68 00 b2 b3 00       	push   $0xb3b200
  80031a:	e8 ba 45 00 00       	call   8048d9 <netif_set_default>
	netif_set_up(nif);
  80031f:	c7 04 24 00 b2 b3 00 	movl   $0xb3b200,(%esp)
  800326:	e8 bf 45 00 00       	call   8048ea <netif_set_up>
	start_timer(&t_arp, &etharp_tmr, "arp timer", ARP_TMR_INTERVAL);
  80032b:	c7 04 24 88 13 00 00 	movl   $0x1388,(%esp)
  800332:	b9 8f 14 81 00       	mov    $0x81148f,%ecx
  800337:	ba 9d 97 80 00       	mov    $0x80979d,%edx
  80033c:	b8 34 50 81 00       	mov    $0x815034,%eax
  800341:	e8 0b fd ff ff       	call   800051 <start_timer>
	start_timer(&t_tcpf, &tcp_fasttmr, "tcp f timer", TCP_FAST_INTERVAL);
  800346:	c7 04 24 fa 00 00 00 	movl   $0xfa,(%esp)
  80034d:	b9 99 14 81 00       	mov    $0x811499,%ecx
  800352:	ba fc 58 80 00       	mov    $0x8058fc,%edx
  800357:	b8 28 50 81 00       	mov    $0x815028,%eax
  80035c:	e8 f0 fc ff ff       	call   800051 <start_timer>
	start_timer(&t_tcps, &tcp_slowtmr, "tcp s timer", TCP_SLOW_INTERVAL);
  800361:	c7 04 24 f4 01 00 00 	movl   $0x1f4,(%esp)
  800368:	b9 a5 14 81 00       	mov    $0x8114a5,%ecx
  80036d:	ba d3 5e 80 00       	mov    $0x805ed3,%edx
  800372:	b8 1c 50 81 00       	mov    $0x81501c,%eax
  800377:	e8 d5 fc ff ff       	call   800051 <start_timer>
	cprintf("ns: %02x:%02x:%02x:%02x:%02x:%02x"
  80037c:	89 34 24             	mov    %esi,(%esp)
  80037f:	e8 31 75 00 00       	call   8078b5 <inet_ntoa>
  800384:	50                   	push   %eax
  800385:	0f b6 05 2a b2 b3 00 	movzbl 0xb3b22a,%eax
  80038c:	50                   	push   %eax
  80038d:	0f b6 05 29 b2 b3 00 	movzbl 0xb3b229,%eax
  800394:	50                   	push   %eax
  800395:	0f b6 05 28 b2 b3 00 	movzbl 0xb3b228,%eax
  80039c:	50                   	push   %eax
  80039d:	0f b6 05 27 b2 b3 00 	movzbl 0xb3b227,%eax
  8003a4:	50                   	push   %eax
  8003a5:	0f b6 05 26 b2 b3 00 	movzbl 0xb3b226,%eax
  8003ac:	50                   	push   %eax
  8003ad:	0f b6 05 25 b2 b3 00 	movzbl 0xb3b225,%eax
  8003b4:	50                   	push   %eax
  8003b5:	68 a4 13 81 00       	push   $0x8113a4
  8003ba:	e8 6f e6 00 00       	call   80ea2e <cprintf>
	lwip_core_unlock();
  8003bf:	83 c4 30             	add    $0x30,%esp
  8003c2:	e8 b6 a4 00 00       	call   80a87d <lwip_core_unlock>
	cprintf("NS: TCP/IP initialized.\n");
  8003c7:	83 ec 0c             	sub    $0xc,%esp
  8003ca:	68 b1 14 81 00       	push   $0x8114b1
  8003cf:	e8 5a e6 00 00       	call   80ea2e <cprintf>
}
  8003d4:	83 c4 10             	add    $0x10,%esp
  8003d7:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8003da:	5b                   	pop    %ebx
  8003db:	5e                   	pop    %esi
  8003dc:	5d                   	pop    %ebp
  8003dd:	c3                   	ret    
		panic("lwip_init: error in netif_add\n");
  8003de:	83 ec 04             	sub    $0x4,%esp
  8003e1:	68 84 13 81 00       	push   $0x811384
  8003e6:	6a 5c                	push   $0x5c
  8003e8:	68 75 14 81 00       	push   $0x811475
  8003ed:	e8 55 e5 00 00       	call   80e947 <_panic>

008003f2 <serve>:

void
serve(void) {
  8003f2:	f3 0f 1e fb          	endbr32 
  8003f6:	55                   	push   %ebp
  8003f7:	89 e5                	mov    %esp,%ebp
  8003f9:	57                   	push   %edi
  8003fa:	56                   	push   %esi
  8003fb:	53                   	push   %ebx
  8003fc:	83 ec 2c             	sub    $0x2c,%esp
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
			thread_yield();

		perm = 0;
		va = get_buffer();
		reqno = ipc_recv((int32_t *) &whom, (void *) va, &perm);
  8003ff:	8d 7d e0             	lea    -0x20(%ebp),%edi
  800402:	e9 9d 00 00 00       	jmp    8004a4 <serve+0xb2>
		perm = 0;
  800407:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	for (i = 0; i < QUEUE_SIZE; i++)
  80040e:	b8 00 00 00 00       	mov    $0x0,%eax
		if (!buse[i]) break;
  800413:	80 b8 00 50 81 00 00 	cmpb   $0x0,0x815000(%eax)
  80041a:	74 1c                	je     800438 <serve+0x46>
	for (i = 0; i < QUEUE_SIZE; i++)
  80041c:	83 c0 01             	add    $0x1,%eax
  80041f:	83 f8 14             	cmp    $0x14,%eax
  800422:	75 ef                	jne    800413 <serve+0x21>
		panic("NS: buffer overflow");
  800424:	83 ec 04             	sub    $0x4,%esp
  800427:	68 ca 14 81 00       	push   $0x8114ca
  80042c:	6a 3f                	push   $0x3f
  80042e:	68 75 14 81 00       	push   $0x811475
  800433:	e8 0f e5 00 00       	call   80e947 <_panic>
	va = (void *)(REQVA + i * PGSIZE);
  800438:	8d 98 eb ff 00 00    	lea    0xffeb(%eax),%ebx
  80043e:	c1 e3 0c             	shl    $0xc,%ebx
	buse[i] = 1;
  800441:	c6 80 00 50 81 00 01 	movb   $0x1,0x815000(%eax)
		reqno = ipc_recv((int32_t *) &whom, (void *) va, &perm);
  800448:	83 ec 04             	sub    $0x4,%esp
  80044b:	57                   	push   %edi
  80044c:	53                   	push   %ebx
  80044d:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  800450:	50                   	push   %eax
  800451:	e8 dd f5 00 00       	call   80fa33 <ipc_recv>
  800456:	89 c6                	mov    %eax,%esi
		if (debug) {
			cprintf("ns req %d from %08x\n", reqno, whom);
		}

		// first take care of requests that do not contain an argument page
		if (reqno == NSREQ_TIMER) {
  800458:	83 c4 10             	add    $0x10,%esp
  80045b:	83 f8 0c             	cmp    $0xc,%eax
  80045e:	74 69                	je     8004c9 <serve+0xd7>
			put_buffer(va);
			continue;
		}

		// All remaining requests must contain an argument page
		if (!(perm & PTE_P)) {
  800460:	f6 45 e0 01          	testb  $0x1,-0x20(%ebp)
  800464:	0f 84 bb 00 00 00    	je     800525 <serve+0x133>
			continue; // just leave it hanging...
		}

		// Since some lwIP socket calls will block, create a thread and
		// process the rest of the request in the thread.
		struct st_args *args = malloc(sizeof(struct st_args));
  80046a:	83 ec 0c             	sub    $0xc,%esp
  80046d:	6a 0c                	push   $0xc
  80046f:	e8 90 04 01 00       	call   810904 <malloc>
		if (!args)
  800474:	83 c4 10             	add    $0x10,%esp
  800477:	85 c0                	test   %eax,%eax
  800479:	0f 84 be 00 00 00    	je     80053d <serve+0x14b>
			panic("could not allocate thread args structure");

		args->reqno = reqno;
  80047f:	89 30                	mov    %esi,(%eax)
		args->whom = whom;
  800481:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  800484:	89 50 04             	mov    %edx,0x4(%eax)
		args->req = va;
  800487:	89 58 08             	mov    %ebx,0x8(%eax)

		thread_create(0, "serve_thread", serve_thread, (uint32_t)args);
  80048a:	50                   	push   %eax
  80048b:	68 cc 00 80 00       	push   $0x8000cc
  800490:	68 de 14 81 00       	push   $0x8114de
  800495:	6a 00                	push   $0x0
  800497:	e8 8c a4 00 00       	call   80a928 <thread_create>
		thread_yield(); // let the thread created run
  80049c:	e8 b4 a5 00 00       	call   80aa55 <thread_yield>
  8004a1:	83 c4 10             	add    $0x10,%esp
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
  8004a4:	bb 00 00 00 00       	mov    $0x0,%ebx
  8004a9:	e8 28 a4 00 00       	call   80a8d6 <thread_wakeups_pending>
  8004ae:	85 c0                	test   %eax,%eax
  8004b0:	0f 84 51 ff ff ff    	je     800407 <serve+0x15>
  8004b6:	83 fb 1f             	cmp    $0x1f,%ebx
  8004b9:	0f 8f 48 ff ff ff    	jg     800407 <serve+0x15>
			thread_yield();
  8004bf:	e8 91 a5 00 00       	call   80aa55 <thread_yield>
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
  8004c4:	83 c3 01             	add    $0x1,%ebx
  8004c7:	eb e0                	jmp    8004a9 <serve+0xb7>
			process_timer(whom);
  8004c9:	8b 75 e4             	mov    -0x1c(%ebp),%esi
	if (envid != timer_envid) {
  8004cc:	3b 35 18 50 81 00    	cmp    0x815018,%esi
  8004d2:	74 23                	je     8004f7 <serve+0x105>
		cprintf("NS: received timer interrupt from envid %x not timer env\n", envid);
  8004d4:	83 ec 08             	sub    $0x8,%esp
  8004d7:	56                   	push   %esi
  8004d8:	68 e0 13 81 00       	push   $0x8113e0
  8004dd:	e8 4c e5 00 00       	call   80ea2e <cprintf>
		return;
  8004e2:	83 c4 10             	add    $0x10,%esp
	int i = ((uint32_t)va - REQVA) / PGSIZE;
  8004e5:	81 eb 00 b0 fe 0f    	sub    $0xffeb000,%ebx
  8004eb:	c1 eb 0c             	shr    $0xc,%ebx
	buse[i] = 0;
  8004ee:	c6 83 00 50 81 00 00 	movb   $0x0,0x815000(%ebx)
			continue;
  8004f5:	eb ad                	jmp    8004a4 <serve+0xb2>
	start = sys_time_msec();
  8004f7:	e8 8f f1 00 00       	call   80f68b <sys_time_msec>
  8004fc:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	thread_yield();
  8004ff:	e8 51 a5 00 00       	call   80aa55 <thread_yield>
	now = sys_time_msec();
  800504:	e8 82 f1 00 00       	call   80f68b <sys_time_msec>
  800509:	89 c2                	mov    %eax,%edx
	ipc_send(envid, to, 0, 0);
  80050b:	6a 00                	push   $0x0
  80050d:	6a 00                	push   $0x0
	to = TIMER_INTERVAL - (now - start);
  80050f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  800512:	05 fa 00 00 00       	add    $0xfa,%eax
  800517:	29 d0                	sub    %edx,%eax
	ipc_send(envid, to, 0, 0);
  800519:	50                   	push   %eax
  80051a:	56                   	push   %esi
  80051b:	e8 98 f5 00 00       	call   80fab8 <ipc_send>
  800520:	83 c4 10             	add    $0x10,%esp
  800523:	eb c0                	jmp    8004e5 <serve+0xf3>
			cprintf("Invalid request from %08x: no argument page\n", whom);
  800525:	83 ec 08             	sub    $0x8,%esp
  800528:	ff 75 e4             	pushl  -0x1c(%ebp)
  80052b:	68 1c 14 81 00       	push   $0x81141c
  800530:	e8 f9 e4 00 00       	call   80ea2e <cprintf>
			continue; // just leave it hanging...
  800535:	83 c4 10             	add    $0x10,%esp
  800538:	e9 67 ff ff ff       	jmp    8004a4 <serve+0xb2>
			panic("could not allocate thread args structure");
  80053d:	83 ec 04             	sub    $0x4,%esp
  800540:	68 4c 14 81 00       	push   $0x81144c
  800545:	68 27 01 00 00       	push   $0x127
  80054a:	68 75 14 81 00       	push   $0x811475
  80054f:	e8 f3 e3 00 00       	call   80e947 <_panic>

00800554 <tmain>:
	}
}

static void
tmain(uint32_t arg) {
  800554:	f3 0f 1e fb          	endbr32 
  800558:	55                   	push   %ebp
  800559:	89 e5                	mov    %esp,%ebp
  80055b:	56                   	push   %esi
  80055c:	53                   	push   %ebx
	serve_init(inet_addr(IP),
  80055d:	83 ec 0c             	sub    $0xc,%esp
  800560:	68 eb 14 81 00       	push   $0x8114eb
  800565:	e8 18 76 00 00       	call   807b82 <inet_addr>
  80056a:	89 c6                	mov    %eax,%esi
  80056c:	c7 04 24 f4 14 81 00 	movl   $0x8114f4,(%esp)
  800573:	e8 0a 76 00 00       	call   807b82 <inet_addr>
  800578:	89 c3                	mov    %eax,%ebx
  80057a:	c7 04 24 02 15 81 00 	movl   $0x811502,(%esp)
  800581:	e8 fc 75 00 00       	call   807b82 <inet_addr>
  800586:	83 c4 0c             	add    $0xc,%esp
  800589:	56                   	push   %esi
  80058a:	53                   	push   %ebx
  80058b:	50                   	push   %eax
  80058c:	e8 fc fc ff ff       	call   80028d <serve_init>
		   inet_addr(MASK),
		   inet_addr(DEFAULT));
	serve();
  800591:	e8 5c fe ff ff       	call   8003f2 <serve>

00800596 <umain>:
}

void
umain(int argc, char **argv)
{
  800596:	f3 0f 1e fb          	endbr32 
  80059a:	55                   	push   %ebp
  80059b:	89 e5                	mov    %esp,%ebp
  80059d:	53                   	push   %ebx
  80059e:	83 ec 04             	sub    $0x4,%esp
	envid_t ns_envid = sys_getenvid();
  8005a1:	e8 8e ee 00 00       	call   80f434 <sys_getenvid>
  8005a6:	89 c3                	mov    %eax,%ebx

	binaryname = "ns";
  8005a8:	c7 05 e8 42 81 00 63 	movl   $0x813e63,0x8142e8
  8005af:	3e 81 00 

	// fork off the timer thread which will send us periodic messages
	timer_envid = fork();
  8005b2:	e8 63 f2 00 00       	call   80f81a <fork>
  8005b7:	a3 18 50 81 00       	mov    %eax,0x815018
	if (timer_envid < 0)
  8005bc:	85 c0                	test   %eax,%eax
  8005be:	78 43                	js     800603 <umain+0x6d>
		panic("error forking");
	else if (timer_envid == 0) {
  8005c0:	74 58                	je     80061a <umain+0x84>
		return;
	}

	// fork off the input thread which will poll the NIC driver for input
	// packets
	input_envid = fork();
  8005c2:	e8 53 f2 00 00       	call   80f81a <fork>
	if (input_envid < 0)
  8005c7:	85 c0                	test   %eax,%eax
  8005c9:	78 65                	js     800630 <umain+0x9a>
		panic("error forking");
	else if (input_envid == 0) {
  8005cb:	74 7a                	je     800647 <umain+0xb1>
		return;
	}

	// fork off the output thread that will send the packets to the NIC
	// driver
	output_envid = fork();
  8005cd:	e8 48 f2 00 00       	call   80f81a <fork>
  8005d2:	a3 14 50 81 00       	mov    %eax,0x815014
	if (output_envid < 0)
  8005d7:	85 c0                	test   %eax,%eax
  8005d9:	78 7a                	js     800655 <umain+0xbf>
		panic("error forking");
	else if (output_envid == 0) {
  8005db:	0f 84 8b 00 00 00    	je     80066c <umain+0xd6>
		return;
	}

	// lwIP requires a user threading library; start the library and jump
	// into a thread to continue initialization.
	thread_init();
  8005e1:	e8 9c a2 00 00       	call   80a882 <thread_init>
	thread_create(0, "main", tmain, 0);
  8005e6:	6a 00                	push   $0x0
  8005e8:	68 54 05 80 00       	push   $0x800554
  8005ed:	68 1a 15 81 00       	push   $0x81151a
  8005f2:	6a 00                	push   $0x0
  8005f4:	e8 2f a3 00 00       	call   80a928 <thread_create>
	thread_yield();
  8005f9:	e8 57 a4 00 00       	call   80aa55 <thread_yield>
  8005fe:	83 c4 10             	add    $0x10,%esp
  800601:	eb 28                	jmp    80062b <umain+0x95>
		panic("error forking");
  800603:	83 ec 04             	sub    $0x4,%esp
  800606:	68 0c 15 81 00       	push   $0x81150c
  80060b:	68 44 01 00 00       	push   $0x144
  800610:	68 75 14 81 00       	push   $0x811475
  800615:	e8 2d e3 00 00       	call   80e947 <_panic>
		timer(ns_envid, TIMER_INTERVAL);
  80061a:	83 ec 08             	sub    $0x8,%esp
  80061d:	68 fa 00 00 00       	push   $0xfa
  800622:	53                   	push   %ebx
  800623:	e8 52 00 00 00       	call   80067a <timer>
		return;
  800628:	83 c4 10             	add    $0x10,%esp
	// never coming here!
}
  80062b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80062e:	c9                   	leave  
  80062f:	c3                   	ret    
		panic("error forking");
  800630:	83 ec 04             	sub    $0x4,%esp
  800633:	68 0c 15 81 00       	push   $0x81150c
  800638:	68 4e 01 00 00       	push   $0x14e
  80063d:	68 75 14 81 00       	push   $0x811475
  800642:	e8 00 e3 00 00       	call   80e947 <_panic>
		input(ns_envid);
  800647:	83 ec 0c             	sub    $0xc,%esp
  80064a:	53                   	push   %ebx
  80064b:	e8 04 01 00 00       	call   800754 <input>
		return;
  800650:	83 c4 10             	add    $0x10,%esp
  800653:	eb d6                	jmp    80062b <umain+0x95>
		panic("error forking");
  800655:	83 ec 04             	sub    $0x4,%esp
  800658:	68 0c 15 81 00       	push   $0x81150c
  80065d:	68 58 01 00 00       	push   $0x158
  800662:	68 75 14 81 00       	push   $0x811475
  800667:	e8 db e2 00 00       	call   80e947 <_panic>
		output(ns_envid);
  80066c:	83 ec 0c             	sub    $0xc,%esp
  80066f:	53                   	push   %ebx
  800670:	e8 4d 01 00 00       	call   8007c2 <output>
		return;
  800675:	83 c4 10             	add    $0x10,%esp
  800678:	eb b1                	jmp    80062b <umain+0x95>

0080067a <timer>:
#include "ns.h"

void
timer(envid_t ns_envid, uint32_t initial_to) {
  80067a:	f3 0f 1e fb          	endbr32 
  80067e:	55                   	push   %ebp
  80067f:	89 e5                	mov    %esp,%ebp
  800681:	57                   	push   %edi
  800682:	56                   	push   %esi
  800683:	53                   	push   %ebx
  800684:	83 ec 1c             	sub    $0x1c,%esp
  800687:	8b 75 08             	mov    0x8(%ebp),%esi
	int r;
	uint32_t stop = sys_time_msec() + initial_to;
  80068a:	e8 fc ef 00 00       	call   80f68b <sys_time_msec>
  80068f:	03 45 0c             	add    0xc(%ebp),%eax
  800692:	89 c3                	mov    %eax,%ebx

	binaryname = "ns_timer";
  800694:	c7 05 e8 42 81 00 4c 	movl   $0x81154c,0x8142e8
  80069b:	15 81 00 

		ipc_send(ns_envid, NSREQ_TIMER, 0, 0);

		while (1) {
			uint32_t to, whom;
			to = ipc_recv((int32_t *) &whom, 0, 0);
  80069e:	8d 7d e4             	lea    -0x1c(%ebp),%edi
  8006a1:	eb 33                	jmp    8006d6 <timer+0x5c>
		if (r < 0)
  8006a3:	85 c0                	test   %eax,%eax
  8006a5:	78 45                	js     8006ec <timer+0x72>
		ipc_send(ns_envid, NSREQ_TIMER, 0, 0);
  8006a7:	6a 00                	push   $0x0
  8006a9:	6a 00                	push   $0x0
  8006ab:	6a 0c                	push   $0xc
  8006ad:	56                   	push   %esi
  8006ae:	e8 05 f4 00 00       	call   80fab8 <ipc_send>
  8006b3:	83 c4 10             	add    $0x10,%esp
			to = ipc_recv((int32_t *) &whom, 0, 0);
  8006b6:	83 ec 04             	sub    $0x4,%esp
  8006b9:	6a 00                	push   $0x0
  8006bb:	6a 00                	push   $0x0
  8006bd:	57                   	push   %edi
  8006be:	e8 70 f3 00 00       	call   80fa33 <ipc_recv>
  8006c3:	89 c3                	mov    %eax,%ebx

			if (whom != ns_envid) {
  8006c5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8006c8:	83 c4 10             	add    $0x10,%esp
  8006cb:	39 f0                	cmp    %esi,%eax
  8006cd:	75 2f                	jne    8006fe <timer+0x84>
				cprintf("NS TIMER: timer thread got IPC message from env %x not NS\n", whom);
				continue;
			}

			stop = sys_time_msec() + to;
  8006cf:	e8 b7 ef 00 00       	call   80f68b <sys_time_msec>
  8006d4:	01 c3                	add    %eax,%ebx
		while((r = sys_time_msec()) < stop && r >= 0) {
  8006d6:	e8 b0 ef 00 00       	call   80f68b <sys_time_msec>
  8006db:	89 c2                	mov    %eax,%edx
  8006dd:	85 c0                	test   %eax,%eax
  8006df:	78 c2                	js     8006a3 <timer+0x29>
  8006e1:	39 d8                	cmp    %ebx,%eax
  8006e3:	73 be                	jae    8006a3 <timer+0x29>
			sys_yield();
  8006e5:	e8 6d ed 00 00       	call   80f457 <sys_yield>
  8006ea:	eb ea                	jmp    8006d6 <timer+0x5c>
			panic("sys_time_msec: %e", r);
  8006ec:	52                   	push   %edx
  8006ed:	68 55 15 81 00       	push   $0x811555
  8006f2:	6a 0f                	push   $0xf
  8006f4:	68 67 15 81 00       	push   $0x811567
  8006f9:	e8 49 e2 00 00       	call   80e947 <_panic>
				cprintf("NS TIMER: timer thread got IPC message from env %x not NS\n", whom);
  8006fe:	83 ec 08             	sub    $0x8,%esp
  800701:	50                   	push   %eax
  800702:	68 74 15 81 00       	push   $0x811574
  800707:	e8 22 e3 00 00       	call   80ea2e <cprintf>
				continue;
  80070c:	83 c4 10             	add    $0x10,%esp
  80070f:	eb a5                	jmp    8006b6 <timer+0x3c>

00800711 <sleep>:
extern union Nsipc nsipcbuf;


void
sleep(int msec)
{
  800711:	f3 0f 1e fb          	endbr32 
  800715:	55                   	push   %ebp
  800716:	89 e5                	mov    %esp,%ebp
  800718:	53                   	push   %ebx
  800719:	83 ec 04             	sub    $0x4,%esp
       unsigned now = sys_time_msec();
  80071c:	e8 6a ef 00 00       	call   80f68b <sys_time_msec>
       unsigned end = now + msec;
  800721:	89 c3                	mov    %eax,%ebx
  800723:	03 5d 08             	add    0x8(%ebp),%ebx

       if ((int)now < 0 && (int)now > -MAXERROR)
  800726:	85 c0                	test   %eax,%eax
  800728:	79 1c                	jns    800746 <sleep+0x35>
  80072a:	83 f8 f1             	cmp    $0xfffffff1,%eax
  80072d:	7c 17                	jl     800746 <sleep+0x35>
               panic("sys_time_msec: %e", (int)now);
  80072f:	50                   	push   %eax
  800730:	68 55 15 81 00       	push   $0x811555
  800735:	6a 0e                	push   $0xe
  800737:	68 af 15 81 00       	push   $0x8115af
  80073c:	e8 06 e2 00 00       	call   80e947 <_panic>

       while (sys_time_msec() < end)
               sys_yield();
  800741:	e8 11 ed 00 00       	call   80f457 <sys_yield>
       while (sys_time_msec() < end)
  800746:	e8 40 ef 00 00       	call   80f68b <sys_time_msec>
  80074b:	39 d8                	cmp    %ebx,%eax
  80074d:	72 f2                	jb     800741 <sleep+0x30>
}
  80074f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  800752:	c9                   	leave  
  800753:	c3                   	ret    

00800754 <input>:

void
input(envid_t ns_envid)
{
  800754:	f3 0f 1e fb          	endbr32 
  800758:	55                   	push   %ebp
  800759:	89 e5                	mov    %esp,%ebp
  80075b:	57                   	push   %edi
  80075c:	56                   	push   %esi
  80075d:	53                   	push   %ebx
  80075e:	81 ec 0c 06 00 00    	sub    $0x60c,%esp
  800764:	8b 7d 08             	mov    0x8(%ebp),%edi
	binaryname = "ns_input";
  800767:	c7 05 e8 42 81 00 bb 	movl   $0x8115bb,0x8142e8
  80076e:	15 81 00 
	// another packet in to the same physical page.

	size_t len;
	char buf[RX_PKT_SIZE];
	while (1) {
		if (sys_pkt_recv(buf, &len) < 0) {
  800771:	8d 75 e4             	lea    -0x1c(%ebp),%esi
  800774:	8d 9d f6 f9 ff ff    	lea    -0x60a(%ebp),%ebx
  80077a:	83 ec 08             	sub    $0x8,%esp
  80077d:	56                   	push   %esi
  80077e:	53                   	push   %ebx
  80077f:	e8 70 ef 00 00       	call   80f6f4 <sys_pkt_recv>
  800784:	83 c4 10             	add    $0x10,%esp
  800787:	85 c0                	test   %eax,%eax
  800789:	78 ef                	js     80077a <input+0x26>
			continue;
		}

		memcpy(nsipcbuf.pkt.jp_data, buf, len);
  80078b:	83 ec 04             	sub    $0x4,%esp
  80078e:	ff 75 e4             	pushl  -0x1c(%ebp)
  800791:	53                   	push   %ebx
  800792:	68 04 d0 b3 00       	push   $0xb3d004
  800797:	e8 b8 ea 00 00       	call   80f254 <memcpy>
		nsipcbuf.pkt.jp_len = len;
  80079c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80079f:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
		ipc_send(ns_envid, NSREQ_INPUT, &nsipcbuf, PTE_P|PTE_U|PTE_W);
  8007a4:	6a 07                	push   $0x7
  8007a6:	68 00 d0 b3 00       	push   $0xb3d000
  8007ab:	6a 0a                	push   $0xa
  8007ad:	57                   	push   %edi
  8007ae:	e8 05 f3 00 00       	call   80fab8 <ipc_send>
		sleep(50);
  8007b3:	83 c4 14             	add    $0x14,%esp
  8007b6:	6a 32                	push   $0x32
  8007b8:	e8 54 ff ff ff       	call   800711 <sleep>
  8007bd:	83 c4 10             	add    $0x10,%esp
  8007c0:	eb b8                	jmp    80077a <input+0x26>

008007c2 <output>:

extern union Nsipc nsipcbuf;

void
output(envid_t ns_envid)
{
  8007c2:	f3 0f 1e fb          	endbr32 
  8007c6:	55                   	push   %ebp
  8007c7:	89 e5                	mov    %esp,%ebp
  8007c9:	56                   	push   %esi
  8007ca:	53                   	push   %ebx
  8007cb:	83 ec 10             	sub    $0x10,%esp
	binaryname = "ns_output";
  8007ce:	c7 05 e8 42 81 00 c4 	movl   $0x8115c4,0x8142e8
  8007d5:	15 81 00 
	uint32_t whom;
	int perm;
	int32_t req;

	while (1) {
		req = ipc_recv((envid_t *)&whom, &nsipcbuf,  &perm);     //接收核心网络进程发来的请求
  8007d8:	8d 75 f0             	lea    -0x10(%ebp),%esi
  8007db:	8d 5d f4             	lea    -0xc(%ebp),%ebx
  8007de:	eb 1f                	jmp    8007ff <output+0x3d>
			continue;
		}

    	struct jif_pkt *pkt = &(nsipcbuf.pkt);
    	while (sys_pkt_send(pkt->jp_data, pkt->jp_len) < 0) {        //通过系统调用发送数据包
       		sys_yield();
  8007e0:	e8 72 ec 00 00       	call   80f457 <sys_yield>
    	while (sys_pkt_send(pkt->jp_data, pkt->jp_len) < 0) {        //通过系统调用发送数据包
  8007e5:	83 ec 08             	sub    $0x8,%esp
  8007e8:	ff 35 00 d0 b3 00    	pushl  0xb3d000
  8007ee:	68 04 d0 b3 00       	push   $0xb3d004
  8007f3:	e8 b6 ee 00 00       	call   80f6ae <sys_pkt_send>
  8007f8:	83 c4 10             	add    $0x10,%esp
  8007fb:	85 c0                	test   %eax,%eax
  8007fd:	78 e1                	js     8007e0 <output+0x1e>
		req = ipc_recv((envid_t *)&whom, &nsipcbuf,  &perm);     //接收核心网络进程发来的请求
  8007ff:	83 ec 04             	sub    $0x4,%esp
  800802:	56                   	push   %esi
  800803:	68 00 d0 b3 00       	push   $0xb3d000
  800808:	53                   	push   %ebx
  800809:	e8 25 f2 00 00       	call   80fa33 <ipc_recv>
		if (req != NSREQ_OUTPUT) {
  80080e:	83 c4 10             	add    $0x10,%esp
  800811:	83 f8 0b             	cmp    $0xb,%eax
  800814:	74 cf                	je     8007e5 <output+0x23>
			cprintf("not a nsreq output\n");
  800816:	83 ec 0c             	sub    $0xc,%esp
  800819:	68 ce 15 81 00       	push   $0x8115ce
  80081e:	e8 0b e2 00 00       	call   80ea2e <cprintf>
			continue;
  800823:	83 c4 10             	add    $0x10,%esp
  800826:	eb d7                	jmp    8007ff <output+0x3d>

00800828 <get_socket>:
static struct lwip_socket *
get_socket(int s)
{
  struct lwip_socket *sock;

  if ((s < 0) || (s >= NUM_SOCKETS)) {
  800828:	83 f8 1f             	cmp    $0x1f,%eax
  80082b:	77 1b                	ja     800848 <get_socket+0x20>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): invalid\n", s));
    set_errno(EBADF);
    return NULL;
  }

  sock = &sockets[s];
  80082d:	8d 14 80             	lea    (%eax,%eax,4),%edx
  800830:	8d 14 95 60 50 81 00 	lea    0x815060(,%edx,4),%edx

  if (!sock->conn) {
  800837:	8d 04 80             	lea    (%eax,%eax,4),%eax
  80083a:	8b 04 85 60 50 81 00 	mov    0x815060(,%eax,4),%eax
  800841:	85 c0                	test   %eax,%eax
  800843:	74 14                	je     800859 <get_socket+0x31>
    set_errno(EBADF);
    return NULL;
  }

  return sock;
}
  800845:	89 d0                	mov    %edx,%eax
  800847:	c3                   	ret    
    set_errno(EBADF);
  800848:	c7 05 e0 b1 b3 00 09 	movl   $0x9,0xb3b1e0
  80084f:	00 00 00 
    return NULL;
  800852:	ba 00 00 00 00       	mov    $0x0,%edx
  800857:	eb ec                	jmp    800845 <get_socket+0x1d>
    set_errno(EBADF);
  800859:	c7 05 e0 b1 b3 00 09 	movl   $0x9,0xb3b1e0
  800860:	00 00 00 
    return NULL;
  800863:	89 c2                	mov    %eax,%edx
  800865:	eb de                	jmp    800845 <get_socket+0x1d>

00800867 <lwip_selscan>:
 * @param exceptset not yet implemented
 * @return number of sockets that had events (read+write)
 */
static int
lwip_selscan(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset)
{
  800867:	55                   	push   %ebp
  800868:	89 e5                	mov    %esp,%ebp
  80086a:	57                   	push   %edi
  80086b:	56                   	push   %esi
  80086c:	53                   	push   %ebx
  80086d:	83 ec 40             	sub    $0x40,%esp
  800870:	89 45 d0             	mov    %eax,-0x30(%ebp)
  800873:	89 55 cc             	mov    %edx,-0x34(%ebp)
  800876:	89 4d c8             	mov    %ecx,-0x38(%ebp)
  int i, nready = 0;
  fd_set lreadset, lwriteset, lexceptset;
  struct lwip_socket *p_sock;
  
  FD_ZERO(&lreadset);
  800879:	6a 04                	push   $0x4
  80087b:	6a 00                	push   $0x0
  80087d:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  800880:	50                   	push   %eax
  800881:	e8 1c e9 00 00       	call   80f1a2 <memset>
  FD_ZERO(&lwriteset);
  800886:	83 c4 0c             	add    $0xc,%esp
  800889:	6a 04                	push   $0x4
  80088b:	6a 00                	push   $0x0
  80088d:	8d 45 e0             	lea    -0x20(%ebp),%eax
  800890:	50                   	push   %eax
  800891:	e8 0c e9 00 00       	call   80f1a2 <memset>
  FD_ZERO(&lexceptset);
  800896:	83 c4 0c             	add    $0xc,%esp
  800899:	6a 04                	push   $0x4
  80089b:	6a 00                	push   $0x0
  80089d:	8d 45 dc             	lea    -0x24(%ebp),%eax
  8008a0:	50                   	push   %eax
  8008a1:	e8 fc e8 00 00       	call   80f1a2 <memset>
  
  /* Go through each socket in each list to count number of sockets which
  currently match */
  for(i = 0; i < maxfdp1; i++) {
  8008a6:	83 c4 10             	add    $0x10,%esp
  int i, nready = 0;
  8008a9:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
  for(i = 0; i < maxfdp1; i++) {
  8008b0:	bf 00 00 00 00       	mov    $0x0,%edi
  8008b5:	eb 33                	jmp    8008ea <lwip_selscan+0x83>
    if (FD_ISSET(i, readset)) {
      /* See if netconn of this socket is ready for read */
      p_sock = get_socket(i);
  8008b7:	89 f8                	mov    %edi,%eax
  8008b9:	e8 6a ff ff ff       	call   800828 <get_socket>
      if (p_sock && (p_sock->lastdata || p_sock->rcvevent)) {
  8008be:	85 c0                	test   %eax,%eax
  8008c0:	74 4c                	je     80090e <lwip_selscan+0xa7>
  8008c2:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  8008c6:	74 16                	je     8008de <lwip_selscan+0x77>
        FD_SET(i, &lreadset);
  8008c8:	b8 01 00 00 00       	mov    $0x1,%eax
  8008cd:	89 f1                	mov    %esi,%ecx
  8008cf:	d3 e0                	shl    %cl,%eax
  8008d1:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  8008d4:	08 44 15 e4          	or     %al,-0x1c(%ebp,%edx,1)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for reading\n", i));
        nready++;
  8008d8:	83 45 c4 01          	addl   $0x1,-0x3c(%ebp)
  8008dc:	eb 30                	jmp    80090e <lwip_selscan+0xa7>
      if (p_sock && (p_sock->lastdata || p_sock->rcvevent)) {
  8008de:	66 83 78 0a 00       	cmpw   $0x0,0xa(%eax)
  8008e3:	74 29                	je     80090e <lwip_selscan+0xa7>
  8008e5:	eb e1                	jmp    8008c8 <lwip_selscan+0x61>
  for(i = 0; i < maxfdp1; i++) {
  8008e7:	83 c7 01             	add    $0x1,%edi
  8008ea:	3b 7d d0             	cmp    -0x30(%ebp),%edi
  8008ed:	7d 53                	jge    800942 <lwip_selscan+0xdb>
    if (FD_ISSET(i, readset)) {
  8008ef:	8d 5f 07             	lea    0x7(%edi),%ebx
  8008f2:	85 ff                	test   %edi,%edi
  8008f4:	0f 49 df             	cmovns %edi,%ebx
  8008f7:	c1 fb 03             	sar    $0x3,%ebx
  8008fa:	89 5d d4             	mov    %ebx,-0x2c(%ebp)
  8008fd:	89 fe                	mov    %edi,%esi
  8008ff:	83 e6 07             	and    $0x7,%esi
  800902:	8b 45 cc             	mov    -0x34(%ebp),%eax
  800905:	0f b6 04 18          	movzbl (%eax,%ebx,1),%eax
  800909:	0f a3 f0             	bt     %esi,%eax
  80090c:	72 a9                	jb     8008b7 <lwip_selscan+0x50>
      }
    }
    if (FD_ISSET(i, writeset)) {
  80090e:	8b 45 c8             	mov    -0x38(%ebp),%eax
  800911:	0f b6 04 18          	movzbl (%eax,%ebx,1),%eax
  800915:	0f a3 f0             	bt     %esi,%eax
  800918:	73 cd                	jae    8008e7 <lwip_selscan+0x80>
      /* See if netconn of this socket is ready for write */
      p_sock = get_socket(i);
  80091a:	89 f8                	mov    %edi,%eax
  80091c:	e8 07 ff ff ff       	call   800828 <get_socket>
      if (p_sock && p_sock->sendevent) {
  800921:	85 c0                	test   %eax,%eax
  800923:	74 c2                	je     8008e7 <lwip_selscan+0x80>
  800925:	66 83 78 0c 00       	cmpw   $0x0,0xc(%eax)
  80092a:	74 bb                	je     8008e7 <lwip_selscan+0x80>
        FD_SET(i, &lwriteset);
  80092c:	b8 01 00 00 00       	mov    $0x1,%eax
  800931:	89 f1                	mov    %esi,%ecx
  800933:	d3 e0                	shl    %cl,%eax
  800935:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  800938:	08 44 15 e0          	or     %al,-0x20(%ebp,%edx,1)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for writing\n", i));
        nready++;
  80093c:	83 45 c4 01          	addl   $0x1,-0x3c(%ebp)
  800940:	eb a5                	jmp    8008e7 <lwip_selscan+0x80>
      }
    }
  }
  *readset = lreadset;
  800942:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800945:	8b 55 cc             	mov    -0x34(%ebp),%edx
  800948:	89 02                	mov    %eax,(%edx)
  *writeset = lwriteset;
  80094a:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80094d:	8b 4d c8             	mov    -0x38(%ebp),%ecx
  800950:	89 01                	mov    %eax,(%ecx)
  FD_ZERO(exceptset);
  800952:	83 ec 04             	sub    $0x4,%esp
  800955:	6a 04                	push   $0x4
  800957:	6a 00                	push   $0x0
  800959:	ff 75 08             	pushl  0x8(%ebp)
  80095c:	e8 41 e8 00 00       	call   80f1a2 <memset>
  
  return nready;
}
  800961:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  800964:	8d 65 f4             	lea    -0xc(%ebp),%esp
  800967:	5b                   	pop    %ebx
  800968:	5e                   	pop    %esi
  800969:	5f                   	pop    %edi
  80096a:	5d                   	pop    %ebp
  80096b:	c3                   	ret    

0080096c <lwip_getaddrname>:
  return lwip_close(s); /* XXX temporary hack until proper implementation */
}

static int
lwip_getaddrname(int s, struct sockaddr *name, socklen_t *namelen, u8_t local)
{
  80096c:	55                   	push   %ebp
  80096d:	89 e5                	mov    %esp,%ebp
  80096f:	57                   	push   %edi
  800970:	56                   	push   %esi
  800971:	53                   	push   %ebx
  800972:	83 ec 3c             	sub    $0x3c,%esp
  800975:	89 55 c4             	mov    %edx,-0x3c(%ebp)
  800978:	89 ce                	mov    %ecx,%esi
  80097a:	8b 7d 08             	mov    0x8(%ebp),%edi
  struct lwip_socket *sock;
  struct sockaddr_in sin;
  struct ip_addr naddr;

  sock = get_socket(s);
  80097d:	e8 a6 fe ff ff       	call   800828 <get_socket>
  if (!sock)
  800982:	85 c0                	test   %eax,%eax
  800984:	0f 84 86 00 00 00    	je     800a10 <lwip_getaddrname+0xa4>
  80098a:	89 c3                	mov    %eax,%ebx
    return -1;

  memset(&sin, 0, sizeof(sin));
  80098c:	83 ec 04             	sub    $0x4,%esp
  80098f:	6a 10                	push   $0x10
  800991:	6a 00                	push   $0x0
  800993:	8d 45 d8             	lea    -0x28(%ebp),%eax
  800996:	50                   	push   %eax
  800997:	e8 06 e8 00 00       	call   80f1a2 <memset>
  sin.sin_len = sizeof(sin);
  80099c:	c6 45 d8 10          	movb   $0x10,-0x28(%ebp)
  sin.sin_family = AF_INET;
  8009a0:	c6 45 d9 02          	movb   $0x2,-0x27(%ebp)

  /* get the IP address and port */
  netconn_getaddr(sock->conn, &naddr, &sin.sin_port, local);
  8009a4:	89 f8                	mov    %edi,%eax
  8009a6:	0f b6 f8             	movzbl %al,%edi
  8009a9:	57                   	push   %edi
  8009aa:	8d 45 da             	lea    -0x26(%ebp),%eax
  8009ad:	50                   	push   %eax
  8009ae:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  8009b1:	50                   	push   %eax
  8009b2:	ff 33                	pushl  (%ebx)
  8009b4:	e8 ad a6 00 00       	call   80b066 <netconn_getaddr>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getaddrname(%d, addr=", s));
  //ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%d)\n", sin.sin_port));

  sin.sin_port = htons(sin.sin_port);
  8009b9:	83 c4 14             	add    $0x14,%esp
  8009bc:	0f b7 45 da          	movzwl -0x26(%ebp),%eax
  8009c0:	50                   	push   %eax
  8009c1:	e8 93 6f 00 00       	call   807959 <htons>
  8009c6:	66 89 45 da          	mov    %ax,-0x26(%ebp)
  sin.sin_addr.s_addr = naddr.addr;
  8009ca:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  8009cd:	89 45 dc             	mov    %eax,-0x24(%ebp)

  if (*namelen > sizeof(sin))
  8009d0:	83 c4 10             	add    $0x10,%esp
  8009d3:	83 3e 10             	cmpl   $0x10,(%esi)
  8009d6:	76 06                	jbe    8009de <lwip_getaddrname+0x72>
    *namelen = sizeof(sin);
  8009d8:	c7 06 10 00 00 00    	movl   $0x10,(%esi)

  SMEMCPY(name, &sin, *namelen);
  8009de:	83 ec 04             	sub    $0x4,%esp
  8009e1:	ff 36                	pushl  (%esi)
  8009e3:	8d 45 d8             	lea    -0x28(%ebp),%eax
  8009e6:	50                   	push   %eax
  8009e7:	ff 75 c4             	pushl  -0x3c(%ebp)
  8009ea:	e8 65 e8 00 00       	call   80f254 <memcpy>
  sock_set_errno(sock, 0);
  8009ef:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  8009f6:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  8009fd:	00 00 00 
  return 0;
  800a00:	83 c4 10             	add    $0x10,%esp
  800a03:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800a08:	8d 65 f4             	lea    -0xc(%ebp),%esp
  800a0b:	5b                   	pop    %ebx
  800a0c:	5e                   	pop    %esi
  800a0d:	5f                   	pop    %edi
  800a0e:	5d                   	pop    %ebp
  800a0f:	c3                   	ret    
    return -1;
  800a10:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800a15:	eb f1                	jmp    800a08 <lwip_getaddrname+0x9c>

00800a17 <event_callback>:
{
  800a17:	f3 0f 1e fb          	endbr32 
  800a1b:	55                   	push   %ebp
  800a1c:	89 e5                	mov    %esp,%ebp
  800a1e:	57                   	push   %edi
  800a1f:	56                   	push   %esi
  800a20:	53                   	push   %ebx
  800a21:	83 ec 1c             	sub    $0x1c,%esp
  800a24:	8b 7d 08             	mov    0x8(%ebp),%edi
  800a27:	8b 75 0c             	mov    0xc(%ebp),%esi
  if (conn) {
  800a2a:	85 ff                	test   %edi,%edi
  800a2c:	0f 84 80 01 00 00    	je     800bb2 <event_callback+0x19b>
    s = conn->socket;
  800a32:	8b 5f 1c             	mov    0x1c(%edi),%ebx
    if (s < 0) {
  800a35:	85 db                	test   %ebx,%ebx
  800a37:	78 3c                	js     800a75 <event_callback+0x5e>
    sock = get_socket(s);
  800a39:	89 d8                	mov    %ebx,%eax
  800a3b:	e8 e8 fd ff ff       	call   800828 <get_socket>
  800a40:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if (!sock) {
  800a43:	85 c0                	test   %eax,%eax
  800a45:	0f 84 67 01 00 00    	je     800bb2 <event_callback+0x19b>
  sys_sem_wait(selectsem);
  800a4b:	83 ec 0c             	sub    $0xc,%esp
  800a4e:	ff 35 40 50 81 00    	pushl  0x815040
  800a54:	e8 cd 48 00 00       	call   805326 <sys_sem_wait>
  switch (evt) {
  800a59:	83 c4 10             	add    $0x10,%esp
  800a5c:	83 fe 02             	cmp    $0x2,%esi
  800a5f:	0f 84 a0 00 00 00    	je     800b05 <event_callback+0xee>
  800a65:	77 59                	ja     800ac0 <event_callback+0xa9>
  800a67:	85 f6                	test   %esi,%esi
  800a69:	74 65                	je     800ad0 <event_callback+0xb9>
      sock->rcvevent--;
  800a6b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800a6e:	66 83 68 0a 01       	subw   $0x1,0xa(%eax)
      break;
  800a73:	eb 63                	jmp    800ad8 <event_callback+0xc1>
      sys_sem_wait(socksem);
  800a75:	83 ec 0c             	sub    $0xc,%esp
  800a78:	ff 35 44 50 81 00    	pushl  0x815044
  800a7e:	e8 a3 48 00 00       	call   805326 <sys_sem_wait>
      if (conn->socket < 0) {
  800a83:	8b 47 1c             	mov    0x1c(%edi),%eax
  800a86:	83 c4 10             	add    $0x10,%esp
  800a89:	85 c0                	test   %eax,%eax
  800a8b:	78 13                	js     800aa0 <event_callback+0x89>
      sys_sem_signal(socksem);
  800a8d:	83 ec 0c             	sub    $0xc,%esp
  800a90:	ff 35 44 50 81 00    	pushl  0x815044
  800a96:	e8 d8 98 00 00       	call   80a373 <sys_sem_signal>
  800a9b:	83 c4 10             	add    $0x10,%esp
  800a9e:	eb 99                	jmp    800a39 <event_callback+0x22>
        if (evt == NETCONN_EVT_RCVPLUS) {
  800aa0:	85 f6                	test   %esi,%esi
  800aa2:	75 06                	jne    800aaa <event_callback+0x93>
          conn->socket--;
  800aa4:	83 e8 01             	sub    $0x1,%eax
  800aa7:	89 47 1c             	mov    %eax,0x1c(%edi)
        sys_sem_signal(socksem);
  800aaa:	83 ec 0c             	sub    $0xc,%esp
  800aad:	ff 35 44 50 81 00    	pushl  0x815044
  800ab3:	e8 bb 98 00 00       	call   80a373 <sys_sem_signal>
        return;
  800ab8:	83 c4 10             	add    $0x10,%esp
  800abb:	e9 f2 00 00 00       	jmp    800bb2 <event_callback+0x19b>
  switch (evt) {
  800ac0:	83 fe 03             	cmp    $0x3,%esi
  800ac3:	75 4b                	jne    800b10 <event_callback+0xf9>
      sock->sendevent = 0;
  800ac5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800ac8:	66 c7 40 0c 00 00    	movw   $0x0,0xc(%eax)
      break;
  800ace:	eb 08                	jmp    800ad8 <event_callback+0xc1>
      sock->rcvevent++;
  800ad0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800ad3:	66 83 40 0a 01       	addw   $0x1,0xa(%eax)
  sys_sem_signal(selectsem);
  800ad8:	83 ec 0c             	sub    $0xc,%esp
  800adb:	ff 35 40 50 81 00    	pushl  0x815040
  800ae1:	e8 8d 98 00 00       	call   80a373 <sys_sem_signal>
        if (scb->readset && FD_ISSET(s, scb->readset))
  800ae6:	8d 73 07             	lea    0x7(%ebx),%esi
  800ae9:	83 c4 10             	add    $0x10,%esp
  800aec:	85 db                	test   %ebx,%ebx
  800aee:	0f 49 f3             	cmovns %ebx,%esi
  800af1:	c1 fe 03             	sar    $0x3,%esi
  800af4:	89 d9                	mov    %ebx,%ecx
  800af6:	83 e1 07             	and    $0x7,%ecx
  800af9:	bf 01 00 00 00       	mov    $0x1,%edi
  800afe:	d3 e7                	shl    %cl,%edi
  800b00:	e9 83 00 00 00       	jmp    800b88 <event_callback+0x171>
      sock->sendevent = 1;
  800b05:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800b08:	66 c7 40 0c 01 00    	movw   $0x1,0xc(%eax)
      break;
  800b0e:	eb c8                	jmp    800ad8 <event_callback+0xc1>
      LWIP_ASSERT("unknown event", 0);
  800b10:	83 ec 04             	sub    $0x4,%esp
  800b13:	68 e2 15 81 00       	push   $0x8115e2
  800b18:	68 17 04 00 00       	push   $0x417
  800b1d:	68 f0 15 81 00       	push   $0x8115f0
  800b22:	e8 20 de 00 00       	call   80e947 <_panic>
    for (scb = select_cb_list; scb; scb = scb->next) {
  800b27:	8b 1b                	mov    (%ebx),%ebx
  800b29:	85 db                	test   %ebx,%ebx
  800b2b:	74 74                	je     800ba1 <event_callback+0x18a>
      if (scb->sem_signalled == 0) {
  800b2d:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  800b31:	75 f4                	jne    800b27 <event_callback+0x110>
        if (scb->readset && FD_ISSET(s, scb->readset))
  800b33:	8b 43 04             	mov    0x4(%ebx),%eax
  800b36:	85 c0                	test   %eax,%eax
  800b38:	74 12                	je     800b4c <event_callback+0x135>
  800b3a:	0f b6 04 30          	movzbl (%eax,%esi,1),%eax
  800b3e:	85 f8                	test   %edi,%eax
  800b40:	74 0a                	je     800b4c <event_callback+0x135>
          if (sock->rcvevent)
  800b42:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800b45:	66 83 78 0a 00       	cmpw   $0x0,0xa(%eax)
  800b4a:	75 19                	jne    800b65 <event_callback+0x14e>
        if (scb->writeset && FD_ISSET(s, scb->writeset))
  800b4c:	8b 43 08             	mov    0x8(%ebx),%eax
  800b4f:	85 c0                	test   %eax,%eax
  800b51:	74 d4                	je     800b27 <event_callback+0x110>
  800b53:	0f b6 04 30          	movzbl (%eax,%esi,1),%eax
  800b57:	85 f8                	test   %edi,%eax
  800b59:	74 cc                	je     800b27 <event_callback+0x110>
          if (sock->sendevent)
  800b5b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800b5e:	66 83 78 0c 00       	cmpw   $0x0,0xc(%eax)
  800b63:	74 c2                	je     800b27 <event_callback+0x110>
      scb->sem_signalled = 1;
  800b65:	c7 43 10 01 00 00 00 	movl   $0x1,0x10(%ebx)
      sys_sem_signal(selectsem);
  800b6c:	83 ec 0c             	sub    $0xc,%esp
  800b6f:	ff 35 40 50 81 00    	pushl  0x815040
  800b75:	e8 f9 97 00 00       	call   80a373 <sys_sem_signal>
      sys_sem_signal(scb->sem);
  800b7a:	83 c4 04             	add    $0x4,%esp
  800b7d:	ff 73 14             	pushl  0x14(%ebx)
  800b80:	e8 ee 97 00 00       	call   80a373 <sys_sem_signal>
    sys_sem_wait(selectsem);
  800b85:	83 c4 10             	add    $0x10,%esp
  800b88:	83 ec 0c             	sub    $0xc,%esp
  800b8b:	ff 35 40 50 81 00    	pushl  0x815040
  800b91:	e8 90 47 00 00       	call   805326 <sys_sem_wait>
    for (scb = select_cb_list; scb; scb = scb->next) {
  800b96:	8b 1d 48 50 81 00    	mov    0x815048,%ebx
  800b9c:	83 c4 10             	add    $0x10,%esp
  800b9f:	eb 88                	jmp    800b29 <event_callback+0x112>
      sys_sem_signal(selectsem);
  800ba1:	83 ec 0c             	sub    $0xc,%esp
  800ba4:	ff 35 40 50 81 00    	pushl  0x815040
  800baa:	e8 c4 97 00 00       	call   80a373 <sys_sem_signal>
      break;
  800baf:	83 c4 10             	add    $0x10,%esp
}
  800bb2:	8d 65 f4             	lea    -0xc(%ebp),%esp
  800bb5:	5b                   	pop    %ebx
  800bb6:	5e                   	pop    %esi
  800bb7:	5f                   	pop    %edi
  800bb8:	5d                   	pop    %ebp
  800bb9:	c3                   	ret    

00800bba <alloc_socket>:
{
  800bba:	55                   	push   %ebp
  800bbb:	89 e5                	mov    %esp,%ebp
  800bbd:	56                   	push   %esi
  800bbe:	53                   	push   %ebx
  800bbf:	89 c6                	mov    %eax,%esi
  sys_sem_wait(socksem);
  800bc1:	83 ec 0c             	sub    $0xc,%esp
  800bc4:	ff 35 44 50 81 00    	pushl  0x815044
  800bca:	e8 57 47 00 00       	call   805326 <sys_sem_wait>
  800bcf:	b8 60 50 81 00       	mov    $0x815060,%eax
  800bd4:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < NUM_SOCKETS; ++i) {
  800bd7:	bb 00 00 00 00       	mov    $0x0,%ebx
    if (!sockets[i].conn) {
  800bdc:	83 38 00             	cmpl   $0x0,(%eax)
  800bdf:	74 23                	je     800c04 <alloc_socket+0x4a>
  for (i = 0; i < NUM_SOCKETS; ++i) {
  800be1:	83 c3 01             	add    $0x1,%ebx
  800be4:	83 c0 14             	add    $0x14,%eax
  800be7:	83 fb 20             	cmp    $0x20,%ebx
  800bea:	75 f0                	jne    800bdc <alloc_socket+0x22>
  sys_sem_signal(socksem);
  800bec:	83 ec 0c             	sub    $0xc,%esp
  800bef:	ff 35 44 50 81 00    	pushl  0x815044
  800bf5:	e8 79 97 00 00       	call   80a373 <sys_sem_signal>
  return -1;
  800bfa:	83 c4 10             	add    $0x10,%esp
  800bfd:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  800c02:	eb 55                	jmp    800c59 <alloc_socket+0x9f>
      sockets[i].conn       = newconn;
  800c04:	8d 14 9b             	lea    (%ebx,%ebx,4),%edx
  800c07:	c1 e2 02             	shl    $0x2,%edx
  800c0a:	89 b2 60 50 81 00    	mov    %esi,0x815060(%edx)
      sockets[i].lastdata   = NULL;
  800c10:	c7 82 64 50 81 00 00 	movl   $0x0,0x815064(%edx)
  800c17:	00 00 00 
      sockets[i].lastoffset = 0;
  800c1a:	66 c7 82 68 50 81 00 	movw   $0x0,0x815068(%edx)
  800c21:	00 00 
      sockets[i].rcvevent   = 0;
  800c23:	66 c7 82 6a 50 81 00 	movw   $0x0,0x81506a(%edx)
  800c2a:	00 00 
      sockets[i].sendevent  = 1; /* TCP send buf is empty */
  800c2c:	66 c7 82 6c 50 81 00 	movw   $0x1,0x81506c(%edx)
  800c33:	01 00 
      sockets[i].flags      = 0;
  800c35:	66 c7 82 6e 50 81 00 	movw   $0x0,0x81506e(%edx)
  800c3c:	00 00 
      sockets[i].err        = 0;
  800c3e:	c7 82 70 50 81 00 00 	movl   $0x0,0x815070(%edx)
  800c45:	00 00 00 
      sys_sem_signal(socksem);
  800c48:	83 ec 0c             	sub    $0xc,%esp
  800c4b:	ff 35 44 50 81 00    	pushl  0x815044
  800c51:	e8 1d 97 00 00       	call   80a373 <sys_sem_signal>
      return i;
  800c56:	83 c4 10             	add    $0x10,%esp
}
  800c59:	89 d8                	mov    %ebx,%eax
  800c5b:	8d 65 f8             	lea    -0x8(%ebp),%esp
  800c5e:	5b                   	pop    %ebx
  800c5f:	5e                   	pop    %esi
  800c60:	5d                   	pop    %ebp
  800c61:	c3                   	ret    

00800c62 <lwip_getsockopt_internal>:
  return err ? -1 : 0;
}

static void
lwip_getsockopt_internal(void *arg)
{
  800c62:	f3 0f 1e fb          	endbr32 
  800c66:	55                   	push   %ebp
  800c67:	89 e5                	mov    %esp,%ebp
  800c69:	56                   	push   %esi
  800c6a:	53                   	push   %ebx
  800c6b:	8b 45 08             	mov    0x8(%ebp),%eax
#endif /* LWIP_DEBUG */
  int level, optname;
  void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);
  800c6e:	85 c0                	test   %eax,%eax
  800c70:	74 3b                	je     800cad <lwip_getsockopt_internal+0x4b>

  data = (struct lwip_setgetsockopt_data*)arg;
  sock = data->sock;
  800c72:	8b 18                	mov    (%eax),%ebx
#ifdef LWIP_DEBUG
  s = data->s;
#endif /* LWIP_DEBUG */
  level = data->level;
  800c74:	8b 48 08             	mov    0x8(%eax),%ecx
  optname = data->optname;
  800c77:	8b 50 0c             	mov    0xc(%eax),%edx
  optval = data->optval;
  800c7a:	8b 70 10             	mov    0x10(%eax),%esi

  switch (level) {
  800c7d:	83 f9 06             	cmp    $0x6,%ecx
  800c80:	0f 84 39 01 00 00    	je     800dbf <lwip_getsockopt_internal+0x15d>
  800c86:	81 f9 ff 0f 00 00    	cmp    $0xfff,%ecx
  800c8c:	74 36                	je     800cc4 <lwip_getsockopt_internal+0x62>
  800c8e:	85 c9                	test   %ecx,%ecx
  800c90:	0f 84 fb 00 00 00    	je     800d91 <lwip_getsockopt_internal+0x12f>
      break;
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP */
  } /* switch (level) */
  sys_sem_signal(sock->conn->op_completed);
  800c96:	83 ec 0c             	sub    $0xc,%esp
  800c99:	8b 03                	mov    (%ebx),%eax
  800c9b:	ff 70 10             	pushl  0x10(%eax)
  800c9e:	e8 d0 96 00 00       	call   80a373 <sys_sem_signal>
}
  800ca3:	83 c4 10             	add    $0x10,%esp
  800ca6:	8d 65 f8             	lea    -0x8(%ebp),%esp
  800ca9:	5b                   	pop    %ebx
  800caa:	5e                   	pop    %esi
  800cab:	5d                   	pop    %ebp
  800cac:	c3                   	ret    
  LWIP_ASSERT("arg != NULL", arg != NULL);
  800cad:	83 ec 04             	sub    $0x4,%esp
  800cb0:	68 07 16 81 00       	push   $0x811607
  800cb5:	68 38 05 00 00       	push   $0x538
  800cba:	68 f0 15 81 00       	push   $0x8115f0
  800cbf:	e8 83 dc 00 00       	call   80e947 <_panic>
  800cc4:	81 fa 07 10 00 00    	cmp    $0x1007,%edx
  800cca:	0f 84 88 00 00 00    	je     800d58 <lwip_getsockopt_internal+0xf6>
  800cd0:	7e 20                	jle    800cf2 <lwip_getsockopt_internal+0x90>
  800cd2:	81 fa 08 10 00 00    	cmp    $0x1008,%edx
  800cd8:	74 40                	je     800d1a <lwip_getsockopt_internal+0xb8>
  800cda:	81 fa 0a 10 00 00    	cmp    $0x100a,%edx
  800ce0:	75 b4                	jne    800c96 <lwip_getsockopt_internal+0x34>
      *(int*)optval = (udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_NOCHKSUM) ? 1 : 0;
  800ce2:	8b 03                	mov    (%ebx),%eax
  800ce4:	8b 40 08             	mov    0x8(%eax),%eax
  800ce7:	0f b6 40 10          	movzbl 0x10(%eax),%eax
  800ceb:	83 e0 01             	and    $0x1,%eax
  800cee:	89 06                	mov    %eax,(%esi)
      break;
  800cf0:	eb a4                	jmp    800c96 <lwip_getsockopt_internal+0x34>
  800cf2:	8d 4a fe             	lea    -0x2(%edx),%ecx
  800cf5:	83 f9 1e             	cmp    $0x1e,%ecx
  800cf8:	77 9c                	ja     800c96 <lwip_getsockopt_internal+0x34>
  800cfa:	b8 01 00 00 00       	mov    $0x1,%eax
  800cff:	d3 e0                	shl    %cl,%eax
  800d01:	a9 41 00 00 40       	test   $0x40000041,%eax
  800d06:	74 8e                	je     800c96 <lwip_getsockopt_internal+0x34>
      *(int*)optval = sock->conn->pcb.ip->so_options & optname;
  800d08:	8b 03                	mov    (%ebx),%eax
  800d0a:	8b 40 08             	mov    0x8(%eax),%eax
  800d0d:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  800d11:	21 c2                	and    %eax,%edx
  800d13:	89 16                	mov    %edx,(%esi)
      break;
  800d15:	e9 7c ff ff ff       	jmp    800c96 <lwip_getsockopt_internal+0x34>
      switch (NETCONNTYPE_GROUP(sock->conn->type)) {
  800d1a:	8b 03                	mov    (%ebx),%eax
  800d1c:	8b 00                	mov    (%eax),%eax
  800d1e:	89 c2                	mov    %eax,%edx
  800d20:	81 e2 f0 00 00 00    	and    $0xf0,%edx
  800d26:	83 fa 20             	cmp    $0x20,%edx
  800d29:	74 22                	je     800d4d <lwip_getsockopt_internal+0xeb>
  800d2b:	83 fa 40             	cmp    $0x40,%edx
  800d2e:	74 12                	je     800d42 <lwip_getsockopt_internal+0xe0>
        *(int*)optval = sock->conn->type;
  800d30:	83 fa 10             	cmp    $0x10,%edx
  800d33:	ba 01 00 00 00       	mov    $0x1,%edx
  800d38:	0f 44 c2             	cmove  %edx,%eax
  800d3b:	89 06                	mov    %eax,(%esi)
  800d3d:	e9 54 ff ff ff       	jmp    800c96 <lwip_getsockopt_internal+0x34>
        *(int*)optval = SOCK_RAW;
  800d42:	c7 06 03 00 00 00    	movl   $0x3,(%esi)
        break;
  800d48:	e9 49 ff ff ff       	jmp    800c96 <lwip_getsockopt_internal+0x34>
        *(int*)optval = SOCK_DGRAM;
  800d4d:	c7 06 02 00 00 00    	movl   $0x2,(%esi)
        break;
  800d53:	e9 3e ff ff ff       	jmp    800c96 <lwip_getsockopt_internal+0x34>
      if (sock->err == 0) {
  800d58:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  800d5c:	75 22                	jne    800d80 <lwip_getsockopt_internal+0x11e>
        sock_set_errno(sock, err_to_errno(sock->conn->err));
  800d5e:	8b 03                	mov    (%ebx),%eax
  800d60:	0f be 40 0c          	movsbl 0xc(%eax),%eax
  800d64:	f7 d8                	neg    %eax
  800d66:	ba 05 00 00 00       	mov    $0x5,%edx
  800d6b:	83 f8 0e             	cmp    $0xe,%eax
  800d6e:	77 07                	ja     800d77 <lwip_getsockopt_internal+0x115>
  800d70:	8b 14 85 c0 16 81 00 	mov    0x8116c0(,%eax,4),%edx
  800d77:	89 53 10             	mov    %edx,0x10(%ebx)
  800d7a:	89 15 e0 b1 b3 00    	mov    %edx,0xb3b1e0
      *(int *)optval = sock->err;
  800d80:	8b 43 10             	mov    0x10(%ebx),%eax
  800d83:	89 06                	mov    %eax,(%esi)
      sock->err = 0;
  800d85:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
      break;
  800d8c:	e9 05 ff ff ff       	jmp    800c96 <lwip_getsockopt_internal+0x34>
  800d91:	83 fa 01             	cmp    $0x1,%edx
  800d94:	74 19                	je     800daf <lwip_getsockopt_internal+0x14d>
  800d96:	83 fa 02             	cmp    $0x2,%edx
  800d99:	0f 85 f7 fe ff ff    	jne    800c96 <lwip_getsockopt_internal+0x34>
      *(int*)optval = sock->conn->pcb.ip->ttl;
  800d9f:	8b 03                	mov    (%ebx),%eax
  800da1:	8b 40 08             	mov    0x8(%eax),%eax
  800da4:	0f b6 40 0b          	movzbl 0xb(%eax),%eax
  800da8:	89 06                	mov    %eax,(%esi)
      break;
  800daa:	e9 e7 fe ff ff       	jmp    800c96 <lwip_getsockopt_internal+0x34>
      *(int*)optval = sock->conn->pcb.ip->tos;
  800daf:	8b 03                	mov    (%ebx),%eax
  800db1:	8b 40 08             	mov    0x8(%eax),%eax
  800db4:	0f b6 40 0a          	movzbl 0xa(%eax),%eax
  800db8:	89 06                	mov    %eax,(%esi)
      break;
  800dba:	e9 d7 fe ff ff       	jmp    800c96 <lwip_getsockopt_internal+0x34>
  800dbf:	83 fa 01             	cmp    $0x1,%edx
  800dc2:	74 1b                	je     800ddf <lwip_getsockopt_internal+0x17d>
  800dc4:	83 fa 02             	cmp    $0x2,%edx
  800dc7:	0f 85 c9 fe ff ff    	jne    800c96 <lwip_getsockopt_internal+0x34>
      *(int*)optval = (int)sock->conn->pcb.tcp->keep_idle;
  800dcd:	8b 03                	mov    (%ebx),%eax
  800dcf:	8b 40 08             	mov    0x8(%eax),%eax
  800dd2:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
  800dd8:	89 06                	mov    %eax,(%esi)
      break;
  800dda:	e9 b7 fe ff ff       	jmp    800c96 <lwip_getsockopt_internal+0x34>
      *(int*)optval = (sock->conn->pcb.tcp->flags & TF_NODELAY);
  800ddf:	8b 03                	mov    (%ebx),%eax
  800de1:	8b 40 08             	mov    0x8(%eax),%eax
  800de4:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  800de8:	83 e0 40             	and    $0x40,%eax
  800deb:	0f b6 c0             	movzbl %al,%eax
  800dee:	89 06                	mov    %eax,(%esi)
      break;
  800df0:	e9 a1 fe ff ff       	jmp    800c96 <lwip_getsockopt_internal+0x34>

00800df5 <lwip_setsockopt_internal>:
  return err ? -1 : 0;
}

static void
lwip_setsockopt_internal(void *arg)
{
  800df5:	f3 0f 1e fb          	endbr32 
  800df9:	55                   	push   %ebp
  800dfa:	89 e5                	mov    %esp,%ebp
  800dfc:	53                   	push   %ebx
  800dfd:	83 ec 04             	sub    $0x4,%esp
  800e00:	8b 45 08             	mov    0x8(%ebp),%eax
#endif /* LWIP_DEBUG */
  int level, optname;
  const void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);
  800e03:	85 c0                	test   %eax,%eax
  800e05:	74 35                	je     800e3c <lwip_setsockopt_internal+0x47>

  data = (struct lwip_setgetsockopt_data*)arg;
  sock = data->sock;
  800e07:	8b 18                	mov    (%eax),%ebx
#ifdef LWIP_DEBUG
  s = data->s;
#endif /* LWIP_DEBUG */
  level = data->level;
  800e09:	8b 50 08             	mov    0x8(%eax),%edx
  optname = data->optname;
  800e0c:	8b 48 0c             	mov    0xc(%eax),%ecx
  optval = data->optval;
  800e0f:	8b 40 10             	mov    0x10(%eax),%eax

  switch (level) {
  800e12:	83 fa 06             	cmp    $0x6,%edx
  800e15:	0f 84 aa 00 00 00    	je     800ec5 <lwip_setsockopt_internal+0xd0>
  800e1b:	81 fa ff 0f 00 00    	cmp    $0xfff,%edx
  800e21:	74 30                	je     800e53 <lwip_setsockopt_internal+0x5e>
  800e23:	85 d2                	test   %edx,%edx
  800e25:	74 76                	je     800e9d <lwip_setsockopt_internal+0xa8>
      break;
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP */
  }  /* switch (level) */
  sys_sem_signal(sock->conn->op_completed);
  800e27:	83 ec 0c             	sub    $0xc,%esp
  800e2a:	8b 03                	mov    (%ebx),%eax
  800e2c:	ff 70 10             	pushl  0x10(%eax)
  800e2f:	e8 3f 95 00 00       	call   80a373 <sys_sem_signal>
}
  800e34:	83 c4 10             	add    $0x10,%esp
  800e37:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  800e3a:	c9                   	leave  
  800e3b:	c3                   	ret    
  LWIP_ASSERT("arg != NULL", arg != NULL);
  800e3c:	83 ec 04             	sub    $0x4,%esp
  800e3f:	68 07 16 81 00       	push   $0x811607
  800e44:	68 ae 06 00 00       	push   $0x6ae
  800e49:	68 f0 15 81 00       	push   $0x8115f0
  800e4e:	e8 f4 da 00 00       	call   80e947 <_panic>
  800e53:	83 f9 20             	cmp    $0x20,%ecx
  800e56:	74 0d                	je     800e65 <lwip_setsockopt_internal+0x70>
  800e58:	81 f9 0a 10 00 00    	cmp    $0x100a,%ecx
  800e5e:	74 22                	je     800e82 <lwip_setsockopt_internal+0x8d>
  800e60:	83 f9 08             	cmp    $0x8,%ecx
  800e63:	75 c2                	jne    800e27 <lwip_setsockopt_internal+0x32>
      if (*(int*)optval) {
  800e65:	83 38 00             	cmpl   $0x0,(%eax)
  800e68:	74 0b                	je     800e75 <lwip_setsockopt_internal+0x80>
        sock->conn->pcb.ip->so_options |= optname;
  800e6a:	8b 03                	mov    (%ebx),%eax
  800e6c:	8b 40 08             	mov    0x8(%eax),%eax
  800e6f:	66 09 48 08          	or     %cx,0x8(%eax)
  800e73:	eb b2                	jmp    800e27 <lwip_setsockopt_internal+0x32>
        sock->conn->pcb.ip->so_options &= ~optname;
  800e75:	8b 03                	mov    (%ebx),%eax
  800e77:	8b 40 08             	mov    0x8(%eax),%eax
  800e7a:	f7 d1                	not    %ecx
  800e7c:	66 21 48 08          	and    %cx,0x8(%eax)
  800e80:	eb a5                	jmp    800e27 <lwip_setsockopt_internal+0x32>
      if (*(int*)optval) {
  800e82:	83 38 00             	cmpl   $0x0,(%eax)
  800e85:	74 0b                	je     800e92 <lwip_setsockopt_internal+0x9d>
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) | UDP_FLAGS_NOCHKSUM);
  800e87:	8b 03                	mov    (%ebx),%eax
  800e89:	8b 40 08             	mov    0x8(%eax),%eax
  800e8c:	80 48 10 01          	orb    $0x1,0x10(%eax)
  800e90:	eb 95                	jmp    800e27 <lwip_setsockopt_internal+0x32>
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) & ~UDP_FLAGS_NOCHKSUM);
  800e92:	8b 03                	mov    (%ebx),%eax
  800e94:	8b 40 08             	mov    0x8(%eax),%eax
  800e97:	80 60 10 fe          	andb   $0xfe,0x10(%eax)
  800e9b:	eb 8a                	jmp    800e27 <lwip_setsockopt_internal+0x32>
  800e9d:	83 f9 01             	cmp    $0x1,%ecx
  800ea0:	74 14                	je     800eb6 <lwip_setsockopt_internal+0xc1>
  800ea2:	83 f9 02             	cmp    $0x2,%ecx
  800ea5:	75 80                	jne    800e27 <lwip_setsockopt_internal+0x32>
      sock->conn->pcb.ip->ttl = (u8_t)(*(int*)optval);
  800ea7:	8b 13                	mov    (%ebx),%edx
  800ea9:	8b 52 08             	mov    0x8(%edx),%edx
  800eac:	8b 00                	mov    (%eax),%eax
  800eae:	88 42 0b             	mov    %al,0xb(%edx)
      break;
  800eb1:	e9 71 ff ff ff       	jmp    800e27 <lwip_setsockopt_internal+0x32>
      sock->conn->pcb.ip->tos = (u8_t)(*(int*)optval);
  800eb6:	8b 13                	mov    (%ebx),%edx
  800eb8:	8b 52 08             	mov    0x8(%edx),%edx
  800ebb:	8b 00                	mov    (%eax),%eax
  800ebd:	88 42 0a             	mov    %al,0xa(%edx)
      break;
  800ec0:	e9 62 ff ff ff       	jmp    800e27 <lwip_setsockopt_internal+0x32>
  800ec5:	83 f9 01             	cmp    $0x1,%ecx
  800ec8:	74 1b                	je     800ee5 <lwip_setsockopt_internal+0xf0>
  800eca:	83 f9 02             	cmp    $0x2,%ecx
  800ecd:	0f 85 54 ff ff ff    	jne    800e27 <lwip_setsockopt_internal+0x32>
      sock->conn->pcb.tcp->keep_idle = (u32_t)(*(int*)optval);
  800ed3:	8b 13                	mov    (%ebx),%edx
  800ed5:	8b 52 08             	mov    0x8(%edx),%edx
  800ed8:	8b 00                	mov    (%eax),%eax
  800eda:	89 82 9c 00 00 00    	mov    %eax,0x9c(%edx)
      break;
  800ee0:	e9 42 ff ff ff       	jmp    800e27 <lwip_setsockopt_internal+0x32>
      if (*(int*)optval) {
  800ee5:	83 38 00             	cmpl   $0x0,(%eax)
  800ee8:	74 0e                	je     800ef8 <lwip_setsockopt_internal+0x103>
        sock->conn->pcb.tcp->flags |= TF_NODELAY;
  800eea:	8b 03                	mov    (%ebx),%eax
  800eec:	8b 40 08             	mov    0x8(%eax),%eax
  800eef:	80 48 20 40          	orb    $0x40,0x20(%eax)
  800ef3:	e9 2f ff ff ff       	jmp    800e27 <lwip_setsockopt_internal+0x32>
        sock->conn->pcb.tcp->flags &= ~TF_NODELAY;
  800ef8:	8b 03                	mov    (%ebx),%eax
  800efa:	8b 40 08             	mov    0x8(%eax),%eax
  800efd:	80 60 20 bf          	andb   $0xbf,0x20(%eax)
  800f01:	e9 21 ff ff ff       	jmp    800e27 <lwip_setsockopt_internal+0x32>

00800f06 <lwip_socket_init>:
{
  800f06:	f3 0f 1e fb          	endbr32 
  800f0a:	55                   	push   %ebp
  800f0b:	89 e5                	mov    %esp,%ebp
  800f0d:	83 ec 14             	sub    $0x14,%esp
  socksem   = sys_sem_new(1);
  800f10:	6a 01                	push   $0x1
  800f12:	e8 8f 91 00 00       	call   80a0a6 <sys_sem_new>
  800f17:	a3 44 50 81 00       	mov    %eax,0x815044
  selectsem = sys_sem_new(1);
  800f1c:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  800f23:	e8 7e 91 00 00       	call   80a0a6 <sys_sem_new>
  800f28:	a3 40 50 81 00       	mov    %eax,0x815040
}
  800f2d:	83 c4 10             	add    $0x10,%esp
  800f30:	c9                   	leave  
  800f31:	c3                   	ret    

00800f32 <lwip_accept>:
{
  800f32:	f3 0f 1e fb          	endbr32 
  800f36:	55                   	push   %ebp
  800f37:	89 e5                	mov    %esp,%ebp
  800f39:	57                   	push   %edi
  800f3a:	56                   	push   %esi
  800f3b:	53                   	push   %ebx
  800f3c:	83 ec 3c             	sub    $0x3c,%esp
  800f3f:	8b 7d 10             	mov    0x10(%ebp),%edi
  sock = get_socket(s);
  800f42:	8b 45 08             	mov    0x8(%ebp),%eax
  800f45:	e8 de f8 ff ff       	call   800828 <get_socket>
  if (!sock)
  800f4a:	85 c0                	test   %eax,%eax
  800f4c:	0f 84 8c 01 00 00    	je     8010de <lwip_accept+0x1ac>
  800f52:	89 c6                	mov    %eax,%esi
  newconn = netconn_accept(sock->conn);
  800f54:	83 ec 0c             	sub    $0xc,%esp
  800f57:	ff 30                	pushl  (%eax)
  800f59:	e8 d2 a2 00 00       	call   80b230 <netconn_accept>
  800f5e:	89 c3                	mov    %eax,%ebx
  if (!newconn) {
  800f60:	83 c4 10             	add    $0x10,%esp
  800f63:	85 c0                	test   %eax,%eax
  800f65:	0f 84 de 00 00 00    	je     801049 <lwip_accept+0x117>
  err = netconn_peer(newconn, &naddr, &port);
  800f6b:	6a 00                	push   $0x0
  800f6d:	8d 45 e2             	lea    -0x1e(%ebp),%eax
  800f70:	50                   	push   %eax
  800f71:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  800f74:	50                   	push   %eax
  800f75:	53                   	push   %ebx
  800f76:	e8 eb a0 00 00       	call   80b066 <netconn_getaddr>
  800f7b:	88 45 c7             	mov    %al,-0x39(%ebp)
  if (err != ERR_OK) {
  800f7e:	83 c4 10             	add    $0x10,%esp
  800f81:	84 c0                	test   %al,%al
  800f83:	0f 85 e9 00 00 00    	jne    801072 <lwip_accept+0x140>
  memset(&sin, 0, sizeof(sin));
  800f89:	83 ec 04             	sub    $0x4,%esp
  800f8c:	6a 10                	push   $0x10
  800f8e:	6a 00                	push   $0x0
  800f90:	8d 45 d0             	lea    -0x30(%ebp),%eax
  800f93:	50                   	push   %eax
  800f94:	e8 09 e2 00 00       	call   80f1a2 <memset>
  sin.sin_len = sizeof(sin);
  800f99:	c6 45 d0 10          	movb   $0x10,-0x30(%ebp)
  sin.sin_family = AF_INET;
  800f9d:	c6 45 d1 02          	movb   $0x2,-0x2f(%ebp)
  sin.sin_port = htons(port);
  800fa1:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  800fa5:	89 04 24             	mov    %eax,(%esp)
  800fa8:	e8 ac 69 00 00       	call   807959 <htons>
  800fad:	66 89 45 d2          	mov    %ax,-0x2e(%ebp)
  sin.sin_addr.s_addr = naddr.addr;
  800fb1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800fb4:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  if (*addrlen > sizeof(sin))
  800fb7:	83 c4 10             	add    $0x10,%esp
  800fba:	83 3f 10             	cmpl   $0x10,(%edi)
  800fbd:	76 06                	jbe    800fc5 <lwip_accept+0x93>
    *addrlen = sizeof(sin);
  800fbf:	c7 07 10 00 00 00    	movl   $0x10,(%edi)
  SMEMCPY(addr, &sin, *addrlen);
  800fc5:	83 ec 04             	sub    $0x4,%esp
  800fc8:	ff 37                	pushl  (%edi)
  800fca:	8d 45 d0             	lea    -0x30(%ebp),%eax
  800fcd:	50                   	push   %eax
  800fce:	ff 75 0c             	pushl  0xc(%ebp)
  800fd1:	e8 7e e2 00 00       	call   80f254 <memcpy>
  newsock = alloc_socket(newconn);
  800fd6:	89 d8                	mov    %ebx,%eax
  800fd8:	e8 dd fb ff ff       	call   800bba <alloc_socket>
  800fdd:	89 c7                	mov    %eax,%edi
  if (newsock == -1) {
  800fdf:	83 c4 10             	add    $0x10,%esp
  800fe2:	83 f8 ff             	cmp    $0xffffffff,%eax
  800fe5:	0f 84 ba 00 00 00    	je     8010a5 <lwip_accept+0x173>
  LWIP_ASSERT("invalid socket index", (newsock >= 0) && (newsock < NUM_SOCKETS));
  800feb:	83 f8 1f             	cmp    $0x1f,%eax
  800fee:	0f 87 d3 00 00 00    	ja     8010c7 <lwip_accept+0x195>
  newconn->callback = event_callback;
  800ff4:	c7 43 2c 17 0a 80 00 	movl   $0x800a17,0x2c(%ebx)
  sys_sem_wait(socksem);
  800ffb:	83 ec 0c             	sub    $0xc,%esp
  800ffe:	ff 35 44 50 81 00    	pushl  0x815044
  801004:	e8 1d 43 00 00       	call   805326 <sys_sem_wait>
  nsock->rcvevent += -1 - newconn->socket;
  801009:	8d 04 bf             	lea    (%edi,%edi,4),%eax
  80100c:	0f b7 53 1c          	movzwl 0x1c(%ebx),%edx
  801010:	f7 d2                	not    %edx
  801012:	66 01 14 85 6a 50 81 	add    %dx,0x81506a(,%eax,4)
  801019:	00 
  newconn->socket = newsock;
  80101a:	89 7b 1c             	mov    %edi,0x1c(%ebx)
  sys_sem_signal(socksem);
  80101d:	83 c4 04             	add    $0x4,%esp
  801020:	ff 35 44 50 81 00    	pushl  0x815044
  801026:	e8 48 93 00 00       	call   80a373 <sys_sem_signal>
  sock_set_errno(sock, 0);
  80102b:	c7 46 10 00 00 00 00 	movl   $0x0,0x10(%esi)
  801032:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  801039:	00 00 00 
  return newsock;
  80103c:	83 c4 10             	add    $0x10,%esp
}
  80103f:	89 f8                	mov    %edi,%eax
  801041:	8d 65 f4             	lea    -0xc(%ebp),%esp
  801044:	5b                   	pop    %ebx
  801045:	5e                   	pop    %esi
  801046:	5f                   	pop    %edi
  801047:	5d                   	pop    %ebp
  801048:	c3                   	ret    
    sock_set_errno(sock, err_to_errno(sock->conn->err));
  801049:	8b 06                	mov    (%esi),%eax
  80104b:	0f be 40 0c          	movsbl 0xc(%eax),%eax
  80104f:	f7 d8                	neg    %eax
  801051:	ba 05 00 00 00       	mov    $0x5,%edx
  801056:	83 f8 0e             	cmp    $0xe,%eax
  801059:	77 07                	ja     801062 <lwip_accept+0x130>
  80105b:	8b 14 85 c0 16 81 00 	mov    0x8116c0(,%eax,4),%edx
  801062:	89 56 10             	mov    %edx,0x10(%esi)
  801065:	89 15 e0 b1 b3 00    	mov    %edx,0xb3b1e0
    return -1;
  80106b:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  801070:	eb cd                	jmp    80103f <lwip_accept+0x10d>
    netconn_delete(newconn);
  801072:	83 ec 0c             	sub    $0xc,%esp
  801075:	53                   	push   %ebx
  801076:	e8 7b 9f 00 00       	call   80aff6 <netconn_delete>
    sock_set_errno(sock, err_to_errno(err));
  80107b:	0f be 45 c7          	movsbl -0x39(%ebp),%eax
  80107f:	f7 d8                	neg    %eax
  801081:	83 c4 10             	add    $0x10,%esp
  801084:	ba 05 00 00 00       	mov    $0x5,%edx
  801089:	83 f8 0e             	cmp    $0xe,%eax
  80108c:	77 07                	ja     801095 <lwip_accept+0x163>
  80108e:	8b 14 85 c0 16 81 00 	mov    0x8116c0(,%eax,4),%edx
  801095:	89 56 10             	mov    %edx,0x10(%esi)
  801098:	89 15 e0 b1 b3 00    	mov    %edx,0xb3b1e0
    return -1;
  80109e:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  8010a3:	eb 9a                	jmp    80103f <lwip_accept+0x10d>
    netconn_delete(newconn);
  8010a5:	83 ec 0c             	sub    $0xc,%esp
  8010a8:	53                   	push   %ebx
  8010a9:	e8 48 9f 00 00       	call   80aff6 <netconn_delete>
    sock_set_errno(sock, ENFILE);
  8010ae:	c7 46 10 17 00 00 00 	movl   $0x17,0x10(%esi)
  8010b5:	c7 05 e0 b1 b3 00 17 	movl   $0x17,0xb3b1e0
  8010bc:	00 00 00 
    return -1;
  8010bf:	83 c4 10             	add    $0x10,%esp
  8010c2:	e9 78 ff ff ff       	jmp    80103f <lwip_accept+0x10d>
  LWIP_ASSERT("invalid socket index", (newsock >= 0) && (newsock < NUM_SOCKETS));
  8010c7:	83 ec 04             	sub    $0x4,%esp
  8010ca:	68 13 16 81 00       	push   $0x811613
  8010cf:	68 25 01 00 00       	push   $0x125
  8010d4:	68 f0 15 81 00       	push   $0x8115f0
  8010d9:	e8 69 d8 00 00       	call   80e947 <_panic>
    return -1;
  8010de:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  8010e3:	e9 57 ff ff ff       	jmp    80103f <lwip_accept+0x10d>

008010e8 <lwip_bind>:
{
  8010e8:	f3 0f 1e fb          	endbr32 
  8010ec:	55                   	push   %ebp
  8010ed:	89 e5                	mov    %esp,%ebp
  8010ef:	56                   	push   %esi
  8010f0:	53                   	push   %ebx
  8010f1:	83 ec 10             	sub    $0x10,%esp
  8010f4:	8b 75 0c             	mov    0xc(%ebp),%esi
  sock = get_socket(s);
  8010f7:	8b 45 08             	mov    0x8(%ebp),%eax
  8010fa:	e8 29 f7 ff ff       	call   800828 <get_socket>
  if (!sock)
  8010ff:	85 c0                	test   %eax,%eax
  801101:	0f 84 94 00 00 00    	je     80119b <lwip_bind+0xb3>
  801107:	89 c3                	mov    %eax,%ebx
  LWIP_ERROR("lwip_bind: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  801109:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
  80110d:	75 4f                	jne    80115e <lwip_bind+0x76>
  80110f:	80 7e 01 02          	cmpb   $0x2,0x1(%esi)
  801113:	75 49                	jne    80115e <lwip_bind+0x76>
  local_addr.addr = ((struct sockaddr_in *)name)->sin_addr.s_addr;
  801115:	8b 46 04             	mov    0x4(%esi),%eax
  801118:	89 45 f4             	mov    %eax,-0xc(%ebp)
  err = netconn_bind(sock->conn, &local_addr, ntohs(local_port));
  80111b:	83 ec 0c             	sub    $0xc,%esp
  80111e:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  801122:	50                   	push   %eax
  801123:	e8 42 68 00 00       	call   80796a <ntohs>
  801128:	83 c4 0c             	add    $0xc,%esp
  80112b:	0f b7 c0             	movzwl %ax,%eax
  80112e:	50                   	push   %eax
  80112f:	8d 45 f4             	lea    -0xc(%ebp),%eax
  801132:	50                   	push   %eax
  801133:	ff 33                	pushl  (%ebx)
  801135:	e8 bc 9f 00 00       	call   80b0f6 <netconn_bind>
  if (err != ERR_OK) {
  80113a:	83 c4 10             	add    $0x10,%esp
  80113d:	84 c0                	test   %al,%al
  80113f:	75 34                	jne    801175 <lwip_bind+0x8d>
  sock_set_errno(sock, 0);
  801141:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  801148:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  80114f:	00 00 00 
  return 0;
  801152:	b8 00 00 00 00       	mov    $0x0,%eax
}
  801157:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80115a:	5b                   	pop    %ebx
  80115b:	5e                   	pop    %esi
  80115c:	5d                   	pop    %ebp
  80115d:	c3                   	ret    
  LWIP_ERROR("lwip_bind: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  80115e:	83 ec 04             	sub    $0x4,%esp
  801161:	68 28 16 81 00       	push   $0x811628
  801166:	68 48 01 00 00       	push   $0x148
  80116b:	68 f0 15 81 00       	push   $0x8115f0
  801170:	e8 d2 d7 00 00       	call   80e947 <_panic>
    sock_set_errno(sock, err_to_errno(err));
  801175:	0f be c0             	movsbl %al,%eax
  801178:	f7 d8                	neg    %eax
  80117a:	ba 05 00 00 00       	mov    $0x5,%edx
  80117f:	83 f8 0e             	cmp    $0xe,%eax
  801182:	77 07                	ja     80118b <lwip_bind+0xa3>
  801184:	8b 14 85 c0 16 81 00 	mov    0x8116c0(,%eax,4),%edx
  80118b:	89 53 10             	mov    %edx,0x10(%ebx)
  80118e:	89 15 e0 b1 b3 00    	mov    %edx,0xb3b1e0
    return -1;
  801194:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801199:	eb bc                	jmp    801157 <lwip_bind+0x6f>
    return -1;
  80119b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8011a0:	eb b5                	jmp    801157 <lwip_bind+0x6f>

008011a2 <lwip_close>:
{
  8011a2:	f3 0f 1e fb          	endbr32 
  8011a6:	55                   	push   %ebp
  8011a7:	89 e5                	mov    %esp,%ebp
  8011a9:	53                   	push   %ebx
  8011aa:	83 ec 04             	sub    $0x4,%esp
  sock = get_socket(s);
  8011ad:	8b 45 08             	mov    0x8(%ebp),%eax
  8011b0:	e8 73 f6 ff ff       	call   800828 <get_socket>
  if (!sock) {
  8011b5:	85 c0                	test   %eax,%eax
  8011b7:	74 6f                	je     801228 <lwip_close+0x86>
  8011b9:	89 c3                	mov    %eax,%ebx
  netconn_delete(sock->conn);
  8011bb:	83 ec 0c             	sub    $0xc,%esp
  8011be:	ff 30                	pushl  (%eax)
  8011c0:	e8 31 9e 00 00       	call   80aff6 <netconn_delete>
  sys_sem_wait(socksem);
  8011c5:	83 c4 04             	add    $0x4,%esp
  8011c8:	ff 35 44 50 81 00    	pushl  0x815044
  8011ce:	e8 53 41 00 00       	call   805326 <sys_sem_wait>
  if (sock->lastdata) {
  8011d3:	8b 43 04             	mov    0x4(%ebx),%eax
  8011d6:	83 c4 10             	add    $0x10,%esp
  8011d9:	85 c0                	test   %eax,%eax
  8011db:	74 0c                	je     8011e9 <lwip_close+0x47>
    netbuf_delete(sock->lastdata);
  8011dd:	83 ec 0c             	sub    $0xc,%esp
  8011e0:	50                   	push   %eax
  8011e1:	e8 1b 14 00 00       	call   802601 <netbuf_delete>
  8011e6:	83 c4 10             	add    $0x10,%esp
  sock->lastdata   = NULL;
  8011e9:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  sock->lastoffset = 0;
  8011f0:	66 c7 43 08 00 00    	movw   $0x0,0x8(%ebx)
  sock->conn       = NULL;
  8011f6:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  sock_set_errno(sock, 0);
  8011fc:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  801203:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  80120a:	00 00 00 
  sys_sem_signal(socksem);
  80120d:	83 ec 0c             	sub    $0xc,%esp
  801210:	ff 35 44 50 81 00    	pushl  0x815044
  801216:	e8 58 91 00 00       	call   80a373 <sys_sem_signal>
  return 0;
  80121b:	83 c4 10             	add    $0x10,%esp
  80121e:	b8 00 00 00 00       	mov    $0x0,%eax
}
  801223:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  801226:	c9                   	leave  
  801227:	c3                   	ret    
    return -1;
  801228:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80122d:	eb f4                	jmp    801223 <lwip_close+0x81>

0080122f <lwip_connect>:
{
  80122f:	f3 0f 1e fb          	endbr32 
  801233:	55                   	push   %ebp
  801234:	89 e5                	mov    %esp,%ebp
  801236:	56                   	push   %esi
  801237:	53                   	push   %ebx
  801238:	83 ec 10             	sub    $0x10,%esp
  80123b:	8b 75 0c             	mov    0xc(%ebp),%esi
  sock = get_socket(s);
  80123e:	8b 45 08             	mov    0x8(%ebp),%eax
  801241:	e8 e2 f5 ff ff       	call   800828 <get_socket>
  if (!sock)
  801246:	85 c0                	test   %eax,%eax
  801248:	0f 84 94 00 00 00    	je     8012e2 <lwip_connect+0xb3>
  80124e:	89 c3                	mov    %eax,%ebx
  LWIP_ERROR("lwip_connect: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  801250:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
  801254:	75 4f                	jne    8012a5 <lwip_connect+0x76>
  801256:	80 7e 01 02          	cmpb   $0x2,0x1(%esi)
  80125a:	75 49                	jne    8012a5 <lwip_connect+0x76>
    remote_addr.addr = ((struct sockaddr_in *)name)->sin_addr.s_addr;
  80125c:	8b 46 04             	mov    0x4(%esi),%eax
  80125f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    err = netconn_connect(sock->conn, &remote_addr, ntohs(remote_port));
  801262:	83 ec 0c             	sub    $0xc,%esp
  801265:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  801269:	50                   	push   %eax
  80126a:	e8 fb 66 00 00       	call   80796a <ntohs>
  80126f:	83 c4 0c             	add    $0xc,%esp
  801272:	0f b7 c0             	movzwl %ax,%eax
  801275:	50                   	push   %eax
  801276:	8d 45 f4             	lea    -0xc(%ebp),%eax
  801279:	50                   	push   %eax
  80127a:	ff 33                	pushl  (%ebx)
  80127c:	e8 ca 9e 00 00       	call   80b14b <netconn_connect>
  if (err != ERR_OK) {
  801281:	83 c4 10             	add    $0x10,%esp
  801284:	84 c0                	test   %al,%al
  801286:	75 34                	jne    8012bc <lwip_connect+0x8d>
  sock_set_errno(sock, 0);
  801288:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  80128f:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  801296:	00 00 00 
  return 0;
  801299:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80129e:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8012a1:	5b                   	pop    %ebx
  8012a2:	5e                   	pop    %esi
  8012a3:	5d                   	pop    %ebp
  8012a4:	c3                   	ret    
  LWIP_ERROR("lwip_connect: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  8012a5:	83 ec 04             	sub    $0x4,%esp
  8012a8:	68 43 16 81 00       	push   $0x811643
  8012ad:	68 84 01 00 00       	push   $0x184
  8012b2:	68 f0 15 81 00       	push   $0x8115f0
  8012b7:	e8 8b d6 00 00       	call   80e947 <_panic>
    sock_set_errno(sock, err_to_errno(err));
  8012bc:	0f be c0             	movsbl %al,%eax
  8012bf:	f7 d8                	neg    %eax
  8012c1:	ba 05 00 00 00       	mov    $0x5,%edx
  8012c6:	83 f8 0e             	cmp    $0xe,%eax
  8012c9:	77 07                	ja     8012d2 <lwip_connect+0xa3>
  8012cb:	8b 14 85 c0 16 81 00 	mov    0x8116c0(,%eax,4),%edx
  8012d2:	89 53 10             	mov    %edx,0x10(%ebx)
  8012d5:	89 15 e0 b1 b3 00    	mov    %edx,0xb3b1e0
    return -1;
  8012db:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8012e0:	eb bc                	jmp    80129e <lwip_connect+0x6f>
    return -1;
  8012e2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8012e7:	eb b5                	jmp    80129e <lwip_connect+0x6f>

008012e9 <lwip_listen>:
{
  8012e9:	f3 0f 1e fb          	endbr32 
  8012ed:	55                   	push   %ebp
  8012ee:	89 e5                	mov    %esp,%ebp
  8012f0:	56                   	push   %esi
  8012f1:	53                   	push   %ebx
  8012f2:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  sock = get_socket(s);
  8012f5:	8b 45 08             	mov    0x8(%ebp),%eax
  8012f8:	e8 2b f5 ff ff       	call   800828 <get_socket>
  if (!sock)
  8012fd:	85 c0                	test   %eax,%eax
  8012ff:	74 6f                	je     801370 <lwip_listen+0x87>
  801301:	89 c6                	mov    %eax,%esi
  801303:	81 fb ff 00 00 00    	cmp    $0xff,%ebx
  801309:	b8 ff 00 00 00       	mov    $0xff,%eax
  80130e:	0f 4f d8             	cmovg  %eax,%ebx
  err = netconn_listen_with_backlog(sock->conn, backlog);
  801311:	83 ec 08             	sub    $0x8,%esp
  801314:	85 db                	test   %ebx,%ebx
  801316:	b8 00 00 00 00       	mov    $0x0,%eax
  80131b:	0f 48 d8             	cmovs  %eax,%ebx
  80131e:	53                   	push   %ebx
  80131f:	ff 36                	pushl  (%esi)
  801321:	e8 c2 9e 00 00       	call   80b1e8 <netconn_listen_with_backlog>
  if (err != ERR_OK) {
  801326:	83 c4 10             	add    $0x10,%esp
  801329:	84 c0                	test   %al,%al
  80132b:	75 1d                	jne    80134a <lwip_listen+0x61>
  sock_set_errno(sock, 0);
  80132d:	c7 46 10 00 00 00 00 	movl   $0x0,0x10(%esi)
  801334:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  80133b:	00 00 00 
  return 0;
  80133e:	b8 00 00 00 00       	mov    $0x0,%eax
}
  801343:	8d 65 f8             	lea    -0x8(%ebp),%esp
  801346:	5b                   	pop    %ebx
  801347:	5e                   	pop    %esi
  801348:	5d                   	pop    %ebp
  801349:	c3                   	ret    
    sock_set_errno(sock, err_to_errno(err));
  80134a:	0f be c0             	movsbl %al,%eax
  80134d:	f7 d8                	neg    %eax
  80134f:	ba 05 00 00 00       	mov    $0x5,%edx
  801354:	83 f8 0e             	cmp    $0xe,%eax
  801357:	77 07                	ja     801360 <lwip_listen+0x77>
  801359:	8b 14 85 c0 16 81 00 	mov    0x8116c0(,%eax,4),%edx
  801360:	89 56 10             	mov    %edx,0x10(%esi)
  801363:	89 15 e0 b1 b3 00    	mov    %edx,0xb3b1e0
    return -1;
  801369:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80136e:	eb d3                	jmp    801343 <lwip_listen+0x5a>
    return -1;
  801370:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801375:	eb cc                	jmp    801343 <lwip_listen+0x5a>

00801377 <lwip_recvfrom>:
{
  801377:	f3 0f 1e fb          	endbr32 
  80137b:	55                   	push   %ebp
  80137c:	89 e5                	mov    %esp,%ebp
  80137e:	57                   	push   %edi
  80137f:	56                   	push   %esi
  801380:	53                   	push   %ebx
  801381:	83 ec 3c             	sub    $0x3c,%esp
  sock = get_socket(s);
  801384:	8b 45 08             	mov    0x8(%ebp),%eax
  801387:	e8 9c f4 ff ff       	call   800828 <get_socket>
  if (!sock)
  80138c:	85 c0                	test   %eax,%eax
  80138e:	0f 84 22 02 00 00    	je     8015b6 <lwip_recvfrom+0x23f>
  801394:	89 c7                	mov    %eax,%edi
  u16_t               buflen, copylen, off = 0;
  801396:	66 c7 45 c4 00 00    	movw   $0x0,-0x3c(%ebp)
      if (((flags & MSG_DONTWAIT) || (sock->flags & O_NONBLOCK)) && !sock->rcvevent) {
  80139c:	8b 45 14             	mov    0x14(%ebp),%eax
  80139f:	83 e0 08             	and    $0x8,%eax
  8013a2:	89 45 b8             	mov    %eax,-0x48(%ebp)
  8013a5:	e9 a7 00 00 00       	jmp    801451 <lwip_recvfrom+0xda>
  8013aa:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
  8013ae:	75 06                	jne    8013b6 <lwip_recvfrom+0x3f>
  8013b0:	f6 47 0f 08          	testb  $0x8,0xf(%edi)
  8013b4:	74 07                	je     8013bd <lwip_recvfrom+0x46>
  8013b6:	66 83 7f 0a 00       	cmpw   $0x0,0xa(%edi)
  8013bb:	74 56                	je     801413 <lwip_recvfrom+0x9c>
      sock->lastdata = buf = netconn_recv(sock->conn);
  8013bd:	83 ec 0c             	sub    $0xc,%esp
  8013c0:	ff 37                	pushl  (%edi)
  8013c2:	e8 df 9e 00 00       	call   80b2a6 <netconn_recv>
  8013c7:	89 c6                	mov    %eax,%esi
  8013c9:	89 47 04             	mov    %eax,0x4(%edi)
      if (!buf) {
  8013cc:	83 c4 10             	add    $0x10,%esp
  8013cf:	85 c0                	test   %eax,%eax
  8013d1:	0f 85 85 00 00 00    	jne    80145c <lwip_recvfrom+0xe5>
        sock_set_errno(sock, (((sock->conn->pcb.ip!=NULL) && (sock->conn->err==ERR_OK))?ETIMEDOUT:err_to_errno(sock->conn->err)));
  8013d7:	8b 17                	mov    (%edi),%edx
  8013d9:	83 7a 08 00          	cmpl   $0x0,0x8(%edx)
  8013dd:	74 0b                	je     8013ea <lwip_recvfrom+0x73>
  8013df:	b8 6e 00 00 00       	mov    $0x6e,%eax
  8013e4:	80 7a 0c 00          	cmpb   $0x0,0xc(%edx)
  8013e8:	74 17                	je     801401 <lwip_recvfrom+0x8a>
  8013ea:	0f be 52 0c          	movsbl 0xc(%edx),%edx
  8013ee:	f7 da                	neg    %edx
  8013f0:	b8 05 00 00 00       	mov    $0x5,%eax
  8013f5:	83 fa 0e             	cmp    $0xe,%edx
  8013f8:	77 07                	ja     801401 <lwip_recvfrom+0x8a>
  8013fa:	8b 04 95 c0 16 81 00 	mov    0x8116c0(,%edx,4),%eax
  801401:	89 47 10             	mov    %eax,0x10(%edi)
  801404:	a3 e0 b1 b3 00       	mov    %eax,0xb3b1e0
        return 0;
  801409:	b8 00 00 00 00       	mov    $0x0,%eax
  80140e:	e9 0b 01 00 00       	jmp    80151e <lwip_recvfrom+0x1a7>
        sock_set_errno(sock, EWOULDBLOCK);
  801413:	c7 47 10 0b 00 00 00 	movl   $0xb,0x10(%edi)
  80141a:	c7 05 e0 b1 b3 00 0b 	movl   $0xb,0xb3b1e0
  801421:	00 00 00 
        return -1;
  801424:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801429:	e9 f0 00 00 00       	jmp    80151e <lwip_recvfrom+0x1a7>
        sock->lastdata = NULL;
  80142e:	c7 47 04 00 00 00 00 	movl   $0x0,0x4(%edi)
        sock->lastoffset = 0;
  801435:	66 c7 47 08 00 00    	movw   $0x0,0x8(%edi)
        netbuf_delete(buf);
  80143b:	83 ec 0c             	sub    $0xc,%esp
  80143e:	56                   	push   %esi
  80143f:	e8 bd 11 00 00       	call   802601 <netbuf_delete>
  801444:	83 c4 10             	add    $0x10,%esp
  } while (!done);
  801447:	80 7d c7 00          	cmpb   $0x0,-0x39(%ebp)
  80144b:	0f 85 ac 00 00 00    	jne    8014fd <lwip_recvfrom+0x186>
    if (sock->lastdata) {
  801451:	8b 77 04             	mov    0x4(%edi),%esi
  801454:	85 f6                	test   %esi,%esi
  801456:	0f 84 4e ff ff ff    	je     8013aa <lwip_recvfrom+0x33>
    buflen = netbuf_len(buf);
  80145c:	8b 16                	mov    (%esi),%edx
  80145e:	0f b7 4a 08          	movzwl 0x8(%edx),%ecx
    buflen -= sock->lastoffset;
  801462:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  801466:	89 cb                	mov    %ecx,%ebx
  801468:	29 c3                	sub    %eax,%ebx
    if (len > buflen) {
  80146a:	0f b7 db             	movzwl %bx,%ebx
  80146d:	89 5d bc             	mov    %ebx,-0x44(%ebp)
      copylen = len;
  801470:	29 c1                	sub    %eax,%ecx
  801472:	3b 5d 10             	cmp    0x10(%ebp),%ebx
  801475:	66 0f 4d 4d 10       	cmovge 0x10(%ebp),%cx
  80147a:	89 cb                	mov    %ecx,%ebx
    netbuf_copy_partial(buf, (u8_t*)mem + off, copylen, sock->lastoffset);
  80147c:	0f b7 c9             	movzwl %cx,%ecx
  80147f:	0f b7 c0             	movzwl %ax,%eax
  801482:	50                   	push   %eax
  801483:	89 4d c0             	mov    %ecx,-0x40(%ebp)
  801486:	51                   	push   %ecx
  801487:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
  80148b:	03 45 0c             	add    0xc(%ebp),%eax
  80148e:	50                   	push   %eax
  80148f:	52                   	push   %edx
  801490:	e8 15 3d 00 00       	call   8051aa <pbuf_copy_partial>
    off += copylen;
  801495:	66 01 5d c4          	add    %bx,-0x3c(%ebp)
    if (netconn_type(sock->conn) == NETCONN_TCP) {
  801499:	83 c4 04             	add    $0x4,%esp
  80149c:	ff 37                	pushl  (%edi)
  80149e:	e8 97 9b 00 00       	call   80b03a <netconn_type>
  8014a3:	83 c4 10             	add    $0x10,%esp
      done = 1;
  8014a6:	c6 45 c7 01          	movb   $0x1,-0x39(%ebp)
    if (netconn_type(sock->conn) == NETCONN_TCP) {
  8014aa:	83 f8 10             	cmp    $0x10,%eax
  8014ad:	75 23                	jne    8014d2 <lwip_recvfrom+0x15b>
      len -= copylen;
  8014af:	8b 4d c0             	mov    -0x40(%ebp),%ecx
  8014b2:	29 4d 10             	sub    %ecx,0x10(%ebp)
      if ( (len <= 0) || (buf->p->flags & PBUF_FLAG_PUSH) || !sock->rcvevent) {
  8014b5:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  8014b9:	7e 17                	jle    8014d2 <lwip_recvfrom+0x15b>
  8014bb:	8b 06                	mov    (%esi),%eax
  8014bd:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
  8014c1:	83 e0 01             	and    $0x1,%eax
  8014c4:	88 45 c7             	mov    %al,-0x39(%ebp)
  8014c7:	75 09                	jne    8014d2 <lwip_recvfrom+0x15b>
  8014c9:	66 83 7f 0a 00       	cmpw   $0x0,0xa(%edi)
  8014ce:	0f 94 45 c7          	sete   -0x39(%ebp)
    if ((flags & MSG_PEEK)==0) {
  8014d2:	f6 45 14 01          	testb  $0x1,0x14(%ebp)
  8014d6:	75 25                	jne    8014fd <lwip_recvfrom+0x186>
      if ((sock->conn->type == NETCONN_TCP) && (buflen - copylen > 0)) {
  8014d8:	8b 07                	mov    (%edi),%eax
  8014da:	83 38 10             	cmpl   $0x10,(%eax)
  8014dd:	0f 85 4b ff ff ff    	jne    80142e <lwip_recvfrom+0xb7>
  8014e3:	8b 45 bc             	mov    -0x44(%ebp),%eax
  8014e6:	2b 45 c0             	sub    -0x40(%ebp),%eax
  8014e9:	85 c0                	test   %eax,%eax
  8014eb:	0f 8e 3d ff ff ff    	jle    80142e <lwip_recvfrom+0xb7>
        sock->lastdata = buf;
  8014f1:	89 77 04             	mov    %esi,0x4(%edi)
        sock->lastoffset += copylen;
  8014f4:	66 01 5f 08          	add    %bx,0x8(%edi)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: lastdata now netbuf=%p\n", (void*)buf));
  8014f8:	e9 4a ff ff ff       	jmp    801447 <lwip_recvfrom+0xd0>
  if (from && fromlen) {
  8014fd:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  801501:	74 06                	je     801509 <lwip_recvfrom+0x192>
  801503:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  801507:	75 1d                	jne    801526 <lwip_recvfrom+0x1af>
  sock_set_errno(sock, 0);
  801509:	c7 47 10 00 00 00 00 	movl   $0x0,0x10(%edi)
  801510:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  801517:	00 00 00 
  return off;
  80151a:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
}
  80151e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  801521:	5b                   	pop    %ebx
  801522:	5e                   	pop    %esi
  801523:	5f                   	pop    %edi
  801524:	5d                   	pop    %ebp
  801525:	c3                   	ret    
    if (netconn_type(sock->conn) == NETCONN_TCP) {
  801526:	83 ec 0c             	sub    $0xc,%esp
  801529:	ff 37                	pushl  (%edi)
  80152b:	e8 0a 9b 00 00       	call   80b03a <netconn_type>
  801530:	83 c4 10             	add    $0x10,%esp
  801533:	83 f8 10             	cmp    $0x10,%eax
  801536:	74 65                	je     80159d <lwip_recvfrom+0x226>
      addr = netbuf_fromaddr(buf);
  801538:	8b 5e 08             	mov    0x8(%esi),%ebx
      port = netbuf_fromport(buf);
  80153b:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  80153f:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
    memset(&sin, 0, sizeof(sin));
  801543:	83 ec 04             	sub    $0x4,%esp
  801546:	6a 10                	push   $0x10
  801548:	6a 00                	push   $0x0
  80154a:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  80154d:	50                   	push   %eax
  80154e:	e8 4f dc 00 00       	call   80f1a2 <memset>
    sin.sin_len = sizeof(sin);
  801553:	c6 45 d4 10          	movb   $0x10,-0x2c(%ebp)
    sin.sin_family = AF_INET;
  801557:	c6 45 d5 02          	movb   $0x2,-0x2b(%ebp)
    sin.sin_port = htons(port);
  80155b:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  80155f:	89 04 24             	mov    %eax,(%esp)
  801562:	e8 f2 63 00 00       	call   807959 <htons>
  801567:	66 89 45 d6          	mov    %ax,-0x2a(%ebp)
    sin.sin_addr.s_addr = addr->addr;
  80156b:	8b 03                	mov    (%ebx),%eax
  80156d:	89 45 d8             	mov    %eax,-0x28(%ebp)
    if (*fromlen > sizeof(sin))
  801570:	83 c4 10             	add    $0x10,%esp
  801573:	8b 45 1c             	mov    0x1c(%ebp),%eax
  801576:	83 38 10             	cmpl   $0x10,(%eax)
  801579:	76 06                	jbe    801581 <lwip_recvfrom+0x20a>
      *fromlen = sizeof(sin);
  80157b:	c7 00 10 00 00 00    	movl   $0x10,(%eax)
    SMEMCPY(from, &sin, *fromlen);
  801581:	83 ec 04             	sub    $0x4,%esp
  801584:	8b 45 1c             	mov    0x1c(%ebp),%eax
  801587:	ff 30                	pushl  (%eax)
  801589:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  80158c:	50                   	push   %eax
  80158d:	ff 75 18             	pushl  0x18(%ebp)
  801590:	e8 bf dc 00 00       	call   80f254 <memcpy>
  801595:	83 c4 10             	add    $0x10,%esp
  801598:	e9 6c ff ff ff       	jmp    801509 <lwip_recvfrom+0x192>
      netconn_getaddr(sock->conn, addr, &port, 0);
  80159d:	6a 00                	push   $0x0
  80159f:	8d 45 e6             	lea    -0x1a(%ebp),%eax
  8015a2:	50                   	push   %eax
  8015a3:	8d 45 d8             	lea    -0x28(%ebp),%eax
  8015a6:	50                   	push   %eax
  8015a7:	ff 37                	pushl  (%edi)
  8015a9:	e8 b8 9a 00 00       	call   80b066 <netconn_getaddr>
  8015ae:	83 c4 10             	add    $0x10,%esp
      addr = (struct ip_addr*)&(sin.sin_addr.s_addr);
  8015b1:	8d 5d d8             	lea    -0x28(%ebp),%ebx
  8015b4:	eb 8d                	jmp    801543 <lwip_recvfrom+0x1cc>
    return -1;
  8015b6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8015bb:	e9 5e ff ff ff       	jmp    80151e <lwip_recvfrom+0x1a7>

008015c0 <lwip_read>:
{
  8015c0:	f3 0f 1e fb          	endbr32 
  8015c4:	55                   	push   %ebp
  8015c5:	89 e5                	mov    %esp,%ebp
  8015c7:	83 ec 10             	sub    $0x10,%esp
  return lwip_recvfrom(s, mem, len, 0, NULL, NULL);
  8015ca:	6a 00                	push   $0x0
  8015cc:	6a 00                	push   $0x0
  8015ce:	6a 00                	push   $0x0
  8015d0:	ff 75 10             	pushl  0x10(%ebp)
  8015d3:	ff 75 0c             	pushl  0xc(%ebp)
  8015d6:	ff 75 08             	pushl  0x8(%ebp)
  8015d9:	e8 99 fd ff ff       	call   801377 <lwip_recvfrom>
}
  8015de:	c9                   	leave  
  8015df:	c3                   	ret    

008015e0 <lwip_recv>:
{
  8015e0:	f3 0f 1e fb          	endbr32 
  8015e4:	55                   	push   %ebp
  8015e5:	89 e5                	mov    %esp,%ebp
  8015e7:	83 ec 10             	sub    $0x10,%esp
  return lwip_recvfrom(s, mem, len, flags, NULL, NULL);
  8015ea:	6a 00                	push   $0x0
  8015ec:	6a 00                	push   $0x0
  8015ee:	ff 75 14             	pushl  0x14(%ebp)
  8015f1:	ff 75 10             	pushl  0x10(%ebp)
  8015f4:	ff 75 0c             	pushl  0xc(%ebp)
  8015f7:	ff 75 08             	pushl  0x8(%ebp)
  8015fa:	e8 78 fd ff ff       	call   801377 <lwip_recvfrom>
}
  8015ff:	c9                   	leave  
  801600:	c3                   	ret    

00801601 <lwip_sendto>:
{
  801601:	f3 0f 1e fb          	endbr32 
  801605:	55                   	push   %ebp
  801606:	89 e5                	mov    %esp,%ebp
  801608:	57                   	push   %edi
  801609:	56                   	push   %esi
  80160a:	53                   	push   %ebx
  80160b:	83 ec 2c             	sub    $0x2c,%esp
  80160e:	8b 75 10             	mov    0x10(%ebp),%esi
  801611:	8b 7d 18             	mov    0x18(%ebp),%edi
  sock = get_socket(s);
  801614:	8b 45 08             	mov    0x8(%ebp),%eax
  801617:	e8 0c f2 ff ff       	call   800828 <get_socket>
  if (!sock)
  80161c:	85 c0                	test   %eax,%eax
  80161e:	0f 84 28 01 00 00    	je     80174c <lwip_sendto+0x14b>
  801624:	89 c3                	mov    %eax,%ebx
  if (sock->conn->type==NETCONN_TCP) {
  801626:	8b 00                	mov    (%eax),%eax
  801628:	83 38 10             	cmpl   $0x10,(%eax)
  80162b:	0f 84 be 00 00 00    	je     8016ef <lwip_sendto+0xee>
  LWIP_ASSERT("lwip_sendto: size must fit in u16_t",
  801631:	81 fe ff ff 00 00    	cmp    $0xffff,%esi
  801637:	0f 87 c8 00 00 00    	ja     801705 <lwip_sendto+0x104>
  LWIP_ERROR("lwip_sendto: invalid address", (((to == NULL) && (tolen == 0)) ||
  80163d:	89 f8                	mov    %edi,%eax
  80163f:	0b 45 1c             	or     0x1c(%ebp),%eax
  801642:	0f 84 0b 01 00 00    	je     801753 <lwip_sendto+0x152>
  801648:	83 7d 1c 10          	cmpl   $0x10,0x1c(%ebp)
  80164c:	0f 85 ca 00 00 00    	jne    80171c <lwip_sendto+0x11b>
  801652:	80 7f 01 02          	cmpb   $0x2,0x1(%edi)
  801656:	0f 85 c0 00 00 00    	jne    80171c <lwip_sendto+0x11b>
  buf.p = buf.ptr = NULL;
  80165c:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  801663:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
    remote_addr.addr = ((struct sockaddr_in *)to)->sin_addr.s_addr;
  80166a:	8b 47 04             	mov    0x4(%edi),%eax
  80166d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    remote_port      = ntohs(((struct sockaddr_in *)to)->sin_port);
  801670:	83 ec 0c             	sub    $0xc,%esp
  801673:	0f b7 47 02          	movzwl 0x2(%edi),%eax
  801677:	50                   	push   %eax
  801678:	e8 ed 62 00 00       	call   80796a <ntohs>
    buf.addr         = &remote_addr;
  80167d:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  801680:	89 55 dc             	mov    %edx,-0x24(%ebp)
    buf.port         = remote_port;
  801683:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
  801687:	83 c4 10             	add    $0x10,%esp
  if ((err = netbuf_ref(&buf, data, size)) == ERR_OK) {
  80168a:	83 ec 04             	sub    $0x4,%esp
  80168d:	0f b7 c6             	movzwl %si,%eax
  801690:	50                   	push   %eax
  801691:	ff 75 0c             	pushl  0xc(%ebp)
  801694:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  801697:	50                   	push   %eax
  801698:	e8 6b 10 00 00       	call   802708 <netbuf_ref>
  80169d:	0f be f8             	movsbl %al,%edi
  8016a0:	83 c4 10             	add    $0x10,%esp
  8016a3:	85 ff                	test   %edi,%edi
  8016a5:	0f 84 88 00 00 00    	je     801733 <lwip_sendto+0x132>
  if (buf.p != NULL) {
  8016ab:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  8016ae:	85 c0                	test   %eax,%eax
  8016b0:	74 0c                	je     8016be <lwip_sendto+0xbd>
    pbuf_free(buf.p);
  8016b2:	83 ec 0c             	sub    $0xc,%esp
  8016b5:	50                   	push   %eax
  8016b6:	e8 66 33 00 00       	call   804a21 <pbuf_free>
  8016bb:	83 c4 10             	add    $0x10,%esp
  sock_set_errno(sock, err_to_errno(err));
  8016be:	89 fa                	mov    %edi,%edx
  8016c0:	f7 da                	neg    %edx
  8016c2:	b8 05 00 00 00       	mov    $0x5,%eax
  8016c7:	83 fa 0e             	cmp    $0xe,%edx
  8016ca:	77 07                	ja     8016d3 <lwip_sendto+0xd2>
  8016cc:	8b 04 95 c0 16 81 00 	mov    0x8116c0(,%edx,4),%eax
  8016d3:	89 43 10             	mov    %eax,0x10(%ebx)
  8016d6:	a3 e0 b1 b3 00       	mov    %eax,0xb3b1e0
  return (err==ERR_OK?size:-1);
  8016db:	85 ff                	test   %edi,%edi
  8016dd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8016e2:	0f 45 f0             	cmovne %eax,%esi
}
  8016e5:	89 f0                	mov    %esi,%eax
  8016e7:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8016ea:	5b                   	pop    %ebx
  8016eb:	5e                   	pop    %esi
  8016ec:	5f                   	pop    %edi
  8016ed:	5d                   	pop    %ebp
  8016ee:	c3                   	ret    
    return lwip_send(s, data, size, flags);
  8016ef:	ff 75 14             	pushl  0x14(%ebp)
  8016f2:	56                   	push   %esi
  8016f3:	ff 75 0c             	pushl  0xc(%ebp)
  8016f6:	ff 75 08             	pushl  0x8(%ebp)
  8016f9:	e8 7c 00 00 00       	call   80177a <lwip_send>
  8016fe:	89 c6                	mov    %eax,%esi
  801700:	83 c4 10             	add    $0x10,%esp
  801703:	eb e0                	jmp    8016e5 <lwip_sendto+0xe4>
  LWIP_ASSERT("lwip_sendto: size must fit in u16_t",
  801705:	83 ec 04             	sub    $0x4,%esp
  801708:	68 80 16 81 00       	push   $0x811680
  80170d:	68 96 02 00 00       	push   $0x296
  801712:	68 f0 15 81 00       	push   $0x8115f0
  801717:	e8 2b d2 00 00       	call   80e947 <_panic>
  LWIP_ERROR("lwip_sendto: invalid address", (((to == NULL) && (tolen == 0)) ||
  80171c:	83 ec 04             	sub    $0x4,%esp
  80171f:	68 61 16 81 00       	push   $0x811661
  801724:	68 98 02 00 00       	push   $0x298
  801729:	68 f0 15 81 00       	push   $0x8115f0
  80172e:	e8 14 d2 00 00       	call   80e947 <_panic>
    err = netconn_send(sock->conn, &buf);
  801733:	83 ec 08             	sub    $0x8,%esp
  801736:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  801739:	50                   	push   %eax
  80173a:	ff 33                	pushl  (%ebx)
  80173c:	e8 fe 9c 00 00       	call   80b43f <netconn_send>
  801741:	0f be f8             	movsbl %al,%edi
  801744:	83 c4 10             	add    $0x10,%esp
  801747:	e9 5f ff ff ff       	jmp    8016ab <lwip_sendto+0xaa>
    return -1;
  80174c:	be ff ff ff ff       	mov    $0xffffffff,%esi
  801751:	eb 92                	jmp    8016e5 <lwip_sendto+0xe4>
  buf.p = buf.ptr = NULL;
  801753:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  80175a:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
    remote_addr.addr = 0;
  801761:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    buf.addr         = NULL;
  801768:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
    buf.port         = 0;
  80176f:	66 c7 45 e0 00 00    	movw   $0x0,-0x20(%ebp)
  801775:	e9 10 ff ff ff       	jmp    80168a <lwip_sendto+0x89>

0080177a <lwip_send>:
{
  80177a:	f3 0f 1e fb          	endbr32 
  80177e:	55                   	push   %ebp
  80177f:	89 e5                	mov    %esp,%ebp
  801781:	57                   	push   %edi
  801782:	56                   	push   %esi
  801783:	53                   	push   %ebx
  801784:	83 ec 0c             	sub    $0xc,%esp
  801787:	8b 7d 08             	mov    0x8(%ebp),%edi
  80178a:	8b 75 10             	mov    0x10(%ebp),%esi
  sock = get_socket(s);
  80178d:	89 f8                	mov    %edi,%eax
  80178f:	e8 94 f0 ff ff       	call   800828 <get_socket>
  if (!sock)
  801794:	85 c0                	test   %eax,%eax
  801796:	74 70                	je     801808 <lwip_send+0x8e>
  801798:	89 c3                	mov    %eax,%ebx
  if (sock->conn->type!=NETCONN_TCP) {
  80179a:	8b 10                	mov    (%eax),%edx
  80179c:	83 3a 10             	cmpl   $0x10,(%edx)
  80179f:	74 1f                	je     8017c0 <lwip_send+0x46>
    return lwip_sendto(s, data, size, flags, NULL, 0);
  8017a1:	83 ec 08             	sub    $0x8,%esp
  8017a4:	6a 00                	push   $0x0
  8017a6:	6a 00                	push   $0x0
  8017a8:	ff 75 14             	pushl  0x14(%ebp)
  8017ab:	56                   	push   %esi
  8017ac:	ff 75 0c             	pushl  0xc(%ebp)
  8017af:	57                   	push   %edi
  8017b0:	e8 4c fe ff ff       	call   801601 <lwip_sendto>
  8017b5:	83 c4 20             	add    $0x20,%esp
}
  8017b8:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8017bb:	5b                   	pop    %ebx
  8017bc:	5e                   	pop    %esi
  8017bd:	5f                   	pop    %edi
  8017be:	5d                   	pop    %ebp
  8017bf:	c3                   	ret    
  err = netconn_write(sock->conn, data, size, NETCONN_COPY | ((flags & MSG_MORE)?NETCONN_MORE:0));
  8017c0:	8b 45 14             	mov    0x14(%ebp),%eax
  8017c3:	c1 e8 03             	shr    $0x3,%eax
  8017c6:	83 e0 02             	and    $0x2,%eax
  8017c9:	83 c8 01             	or     $0x1,%eax
  8017cc:	0f b6 c0             	movzbl %al,%eax
  8017cf:	50                   	push   %eax
  8017d0:	56                   	push   %esi
  8017d1:	ff 75 0c             	pushl  0xc(%ebp)
  8017d4:	52                   	push   %edx
  8017d5:	e8 e9 9c 00 00       	call   80b4c3 <netconn_write>
  sock_set_errno(sock, err_to_errno(err));
  8017da:	0f be d0             	movsbl %al,%edx
  8017dd:	f7 da                	neg    %edx
  8017df:	83 c4 10             	add    $0x10,%esp
  8017e2:	b9 05 00 00 00       	mov    $0x5,%ecx
  8017e7:	83 fa 0e             	cmp    $0xe,%edx
  8017ea:	77 07                	ja     8017f3 <lwip_send+0x79>
  8017ec:	8b 0c 95 c0 16 81 00 	mov    0x8116c0(,%edx,4),%ecx
  8017f3:	89 4b 10             	mov    %ecx,0x10(%ebx)
  8017f6:	89 0d e0 b1 b3 00    	mov    %ecx,0xb3b1e0
  return (err==ERR_OK?size:-1);
  8017fc:	84 c0                	test   %al,%al
  8017fe:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801803:	0f 44 c6             	cmove  %esi,%eax
  801806:	eb b0                	jmp    8017b8 <lwip_send+0x3e>
    return -1;
  801808:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80180d:	eb a9                	jmp    8017b8 <lwip_send+0x3e>

0080180f <lwip_socket>:
{
  80180f:	f3 0f 1e fb          	endbr32 
  801813:	55                   	push   %ebp
  801814:	89 e5                	mov    %esp,%ebp
  801816:	56                   	push   %esi
  801817:	53                   	push   %ebx
  801818:	8b 45 0c             	mov    0xc(%ebp),%eax
  switch (type) {
  80181b:	83 f8 02             	cmp    $0x2,%eax
  80181e:	74 5c                	je     80187c <lwip_socket+0x6d>
  801820:	83 f8 03             	cmp    $0x3,%eax
  801823:	74 16                	je     80183b <lwip_socket+0x2c>
  801825:	83 f8 01             	cmp    $0x1,%eax
  801828:	74 79                	je     8018a3 <lwip_socket+0x94>
    set_errno(EINVAL);
  80182a:	c7 05 e0 b1 b3 00 16 	movl   $0x16,0xb3b1e0
  801831:	00 00 00 
    return -1;
  801834:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  801839:	eb 38                	jmp    801873 <lwip_socket+0x64>
    conn = netconn_new_with_proto_and_callback(NETCONN_RAW, (u8_t)protocol, event_callback);
  80183b:	83 ec 04             	sub    $0x4,%esp
  80183e:	68 17 0a 80 00       	push   $0x800a17
  801843:	0f b6 45 10          	movzbl 0x10(%ebp),%eax
  801847:	50                   	push   %eax
  801848:	6a 40                	push   $0x40
  80184a:	e8 c8 96 00 00       	call   80af17 <netconn_new_with_proto_and_callback>
  80184f:	89 c6                	mov    %eax,%esi
    break;
  801851:	83 c4 10             	add    $0x10,%esp
  if (!conn) {
  801854:	85 f6                	test   %esi,%esi
  801856:	74 63                	je     8018bb <lwip_socket+0xac>
  i = alloc_socket(conn);
  801858:	89 f0                	mov    %esi,%eax
  80185a:	e8 5b f3 ff ff       	call   800bba <alloc_socket>
  80185f:	89 c3                	mov    %eax,%ebx
  if (i == -1) {
  801861:	83 f8 ff             	cmp    $0xffffffff,%eax
  801864:	74 66                	je     8018cc <lwip_socket+0xbd>
  conn->socket = i;
  801866:	89 46 1c             	mov    %eax,0x1c(%esi)
  set_errno(0);
  801869:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  801870:	00 00 00 
}
  801873:	89 d8                	mov    %ebx,%eax
  801875:	8d 65 f8             	lea    -0x8(%ebp),%esp
  801878:	5b                   	pop    %ebx
  801879:	5e                   	pop    %esi
  80187a:	5d                   	pop    %ebp
  80187b:	c3                   	ret    
    conn = netconn_new_with_callback( (protocol == IPPROTO_UDPLITE) ?
  80187c:	81 7d 10 88 00 00 00 	cmpl   $0x88,0x10(%ebp)
  801883:	0f 94 c0             	sete   %al
  801886:	0f b6 c0             	movzbl %al,%eax
  801889:	83 c0 20             	add    $0x20,%eax
  80188c:	83 ec 04             	sub    $0x4,%esp
  80188f:	68 17 0a 80 00       	push   $0x800a17
  801894:	6a 00                	push   $0x0
  801896:	50                   	push   %eax
  801897:	e8 7b 96 00 00       	call   80af17 <netconn_new_with_proto_and_callback>
  80189c:	89 c6                	mov    %eax,%esi
    break;
  80189e:	83 c4 10             	add    $0x10,%esp
  8018a1:	eb b1                	jmp    801854 <lwip_socket+0x45>
    conn = netconn_new_with_callback(NETCONN_TCP, event_callback);
  8018a3:	83 ec 04             	sub    $0x4,%esp
  8018a6:	68 17 0a 80 00       	push   $0x800a17
  8018ab:	6a 00                	push   $0x0
  8018ad:	6a 10                	push   $0x10
  8018af:	e8 63 96 00 00       	call   80af17 <netconn_new_with_proto_and_callback>
  8018b4:	89 c6                	mov    %eax,%esi
    break;
  8018b6:	83 c4 10             	add    $0x10,%esp
  8018b9:	eb 99                	jmp    801854 <lwip_socket+0x45>
    set_errno(ENOBUFS);
  8018bb:	c7 05 e0 b1 b3 00 69 	movl   $0x69,0xb3b1e0
  8018c2:	00 00 00 
    return -1;
  8018c5:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  8018ca:	eb a7                	jmp    801873 <lwip_socket+0x64>
    netconn_delete(conn);
  8018cc:	83 ec 0c             	sub    $0xc,%esp
  8018cf:	56                   	push   %esi
  8018d0:	e8 21 97 00 00       	call   80aff6 <netconn_delete>
    set_errno(ENFILE);
  8018d5:	c7 05 e0 b1 b3 00 17 	movl   $0x17,0xb3b1e0
  8018dc:	00 00 00 
    return -1;
  8018df:	83 c4 10             	add    $0x10,%esp
  8018e2:	eb 8f                	jmp    801873 <lwip_socket+0x64>

008018e4 <lwip_write>:
{
  8018e4:	f3 0f 1e fb          	endbr32 
  8018e8:	55                   	push   %ebp
  8018e9:	89 e5                	mov    %esp,%ebp
  8018eb:	83 ec 08             	sub    $0x8,%esp
  return lwip_send(s, data, size, 0);
  8018ee:	6a 00                	push   $0x0
  8018f0:	ff 75 10             	pushl  0x10(%ebp)
  8018f3:	ff 75 0c             	pushl  0xc(%ebp)
  8018f6:	ff 75 08             	pushl  0x8(%ebp)
  8018f9:	e8 7c fe ff ff       	call   80177a <lwip_send>
}
  8018fe:	c9                   	leave  
  8018ff:	c3                   	ret    

00801900 <lwip_select>:
{
  801900:	f3 0f 1e fb          	endbr32 
  801904:	55                   	push   %ebp
  801905:	89 e5                	mov    %esp,%ebp
  801907:	57                   	push   %edi
  801908:	56                   	push   %esi
  801909:	53                   	push   %ebx
  80190a:	83 ec 58             	sub    $0x58,%esp
  80190d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  801910:	8b 75 10             	mov    0x10(%ebp),%esi
  801913:	8b 7d 14             	mov    0x14(%ebp),%edi
  select_cb.next = 0;
  801916:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
  select_cb.readset = readset;
  80191d:	89 5d c8             	mov    %ebx,-0x38(%ebp)
  select_cb.writeset = writeset;
  801920:	89 75 cc             	mov    %esi,-0x34(%ebp)
  select_cb.exceptset = exceptset;
  801923:	89 7d d0             	mov    %edi,-0x30(%ebp)
  select_cb.sem_signalled = 0;
  801926:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  sys_sem_wait(selectsem);
  80192d:	ff 35 40 50 81 00    	pushl  0x815040
  801933:	e8 ee 39 00 00       	call   805326 <sys_sem_wait>
  if (readset)
  801938:	83 c4 10             	add    $0x10,%esp
  80193b:	85 db                	test   %ebx,%ebx
  80193d:	0f 84 0b 01 00 00    	je     801a4e <lwip_select+0x14e>
    lreadset = *readset;
  801943:	8b 03                	mov    (%ebx),%eax
  801945:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if (writeset)
  801948:	85 f6                	test   %esi,%esi
  80194a:	0f 84 16 01 00 00    	je     801a66 <lwip_select+0x166>
    lwriteset = *writeset;
  801950:	8b 06                	mov    (%esi),%eax
  801952:	89 45 e0             	mov    %eax,-0x20(%ebp)
  if (exceptset)
  801955:	85 ff                	test   %edi,%edi
  801957:	0f 84 21 01 00 00    	je     801a7e <lwip_select+0x17e>
    lexceptset = *exceptset;
  80195d:	8b 07                	mov    (%edi),%eax
  80195f:	89 45 dc             	mov    %eax,-0x24(%ebp)
  nready = lwip_selscan(maxfdp1, &lreadset, &lwriteset, &lexceptset);
  801962:	83 ec 0c             	sub    $0xc,%esp
  801965:	8d 45 dc             	lea    -0x24(%ebp),%eax
  801968:	50                   	push   %eax
  801969:	8d 4d e0             	lea    -0x20(%ebp),%ecx
  80196c:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  80196f:	8b 45 08             	mov    0x8(%ebp),%eax
  801972:	e8 f0 ee ff ff       	call   800867 <lwip_selscan>
  801977:	89 45 b4             	mov    %eax,-0x4c(%ebp)
  if (!nready) {
  80197a:	83 c4 10             	add    $0x10,%esp
  80197d:	85 c0                	test   %eax,%eax
  80197f:	0f 85 a0 02 00 00    	jne    801c25 <lwip_select+0x325>
    if (timeout && timeout->tv_sec == 0 && timeout->tv_usec == 0) {
  801985:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  801989:	0f 84 ac 02 00 00    	je     801c3b <lwip_select+0x33b>
  80198f:	8b 45 18             	mov    0x18(%ebp),%eax
  801992:	83 38 00             	cmpl   $0x0,(%eax)
  801995:	75 0e                	jne    8019a5 <lwip_select+0xa5>
  801997:	8b 40 04             	mov    0x4(%eax),%eax
  80199a:	89 45 b4             	mov    %eax,-0x4c(%ebp)
  80199d:	85 c0                	test   %eax,%eax
  80199f:	0f 84 f1 00 00 00    	je     801a96 <lwip_select+0x196>
    select_cb.sem = sys_sem_new(0);
  8019a5:	83 ec 0c             	sub    $0xc,%esp
  8019a8:	6a 00                	push   $0x0
  8019aa:	e8 f7 86 00 00       	call   80a0a6 <sys_sem_new>
  8019af:	89 45 d8             	mov    %eax,-0x28(%ebp)
    select_cb.next = select_cb_list;
  8019b2:	a1 48 50 81 00       	mov    0x815048,%eax
  8019b7:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    select_cb_list = &select_cb;
  8019ba:	8d 45 c4             	lea    -0x3c(%ebp),%eax
  8019bd:	a3 48 50 81 00       	mov    %eax,0x815048
    sys_sem_signal(selectsem);
  8019c2:	83 c4 04             	add    $0x4,%esp
  8019c5:	ff 35 40 50 81 00    	pushl  0x815040
  8019cb:	e8 a3 89 00 00       	call   80a373 <sys_sem_signal>
      msectimeout =  ((timeout->tv_sec * 1000) + ((timeout->tv_usec + 500)/1000));
  8019d0:	8b 45 18             	mov    0x18(%ebp),%eax
  8019d3:	8b 40 04             	mov    0x4(%eax),%eax
  8019d6:	89 45 b4             	mov    %eax,-0x4c(%ebp)
  8019d9:	8d 88 f4 01 00 00    	lea    0x1f4(%eax),%ecx
  8019df:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  8019e4:	89 c8                	mov    %ecx,%eax
  8019e6:	f7 ea                	imul   %edx
  8019e8:	c1 fa 06             	sar    $0x6,%edx
  8019eb:	c1 f9 1f             	sar    $0x1f,%ecx
  8019ee:	29 ca                	sub    %ecx,%edx
  8019f0:	8b 45 18             	mov    0x18(%ebp),%eax
  8019f3:	69 00 e8 03 00 00    	imul   $0x3e8,(%eax),%eax
  8019f9:	83 c4 10             	add    $0x10,%esp
  8019fc:	01 d0                	add    %edx,%eax
  8019fe:	ba 01 00 00 00       	mov    $0x1,%edx
  801a03:	0f 44 c2             	cmove  %edx,%eax
    i = sys_sem_wait_timeout(select_cb.sem, msectimeout);
  801a06:	83 ec 08             	sub    $0x8,%esp
  801a09:	50                   	push   %eax
  801a0a:	ff 75 d8             	pushl  -0x28(%ebp)
  801a0d:	e8 ee 3a 00 00       	call   805500 <sys_sem_wait_timeout>
  801a12:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    sys_sem_wait(selectsem);
  801a15:	83 c4 04             	add    $0x4,%esp
  801a18:	ff 35 40 50 81 00    	pushl  0x815040
  801a1e:	e8 03 39 00 00       	call   805326 <sys_sem_wait>
    if (select_cb_list == &select_cb)
  801a23:	a1 48 50 81 00       	mov    0x815048,%eax
  801a28:	8d 55 c4             	lea    -0x3c(%ebp),%edx
  801a2b:	83 c4 10             	add    $0x10,%esp
        if (p_selcb->next == &select_cb) {
  801a2e:	89 d1                	mov    %edx,%ecx
    if (select_cb_list == &select_cb)
  801a30:	39 d0                	cmp    %edx,%eax
  801a32:	0f 84 ba 00 00 00    	je     801af2 <lwip_select+0x1f2>
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
  801a38:	85 c0                	test   %eax,%eax
  801a3a:	0f 84 c1 00 00 00    	je     801b01 <lwip_select+0x201>
        if (p_selcb->next == &select_cb) {
  801a40:	8b 10                	mov    (%eax),%edx
  801a42:	39 ca                	cmp    %ecx,%edx
  801a44:	0f 84 b2 00 00 00    	je     801afc <lwip_select+0x1fc>
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
  801a4a:	89 d0                	mov    %edx,%eax
  801a4c:	eb ea                	jmp    801a38 <lwip_select+0x138>
    FD_ZERO(&lreadset);
  801a4e:	83 ec 04             	sub    $0x4,%esp
  801a51:	6a 04                	push   $0x4
  801a53:	6a 00                	push   $0x0
  801a55:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  801a58:	50                   	push   %eax
  801a59:	e8 44 d7 00 00       	call   80f1a2 <memset>
  801a5e:	83 c4 10             	add    $0x10,%esp
  801a61:	e9 e2 fe ff ff       	jmp    801948 <lwip_select+0x48>
    FD_ZERO(&lwriteset);
  801a66:	83 ec 04             	sub    $0x4,%esp
  801a69:	6a 04                	push   $0x4
  801a6b:	6a 00                	push   $0x0
  801a6d:	8d 45 e0             	lea    -0x20(%ebp),%eax
  801a70:	50                   	push   %eax
  801a71:	e8 2c d7 00 00       	call   80f1a2 <memset>
  801a76:	83 c4 10             	add    $0x10,%esp
  801a79:	e9 d7 fe ff ff       	jmp    801955 <lwip_select+0x55>
    FD_ZERO(&lexceptset);
  801a7e:	83 ec 04             	sub    $0x4,%esp
  801a81:	6a 04                	push   $0x4
  801a83:	6a 00                	push   $0x0
  801a85:	8d 45 dc             	lea    -0x24(%ebp),%eax
  801a88:	50                   	push   %eax
  801a89:	e8 14 d7 00 00       	call   80f1a2 <memset>
  801a8e:	83 c4 10             	add    $0x10,%esp
  801a91:	e9 cc fe ff ff       	jmp    801962 <lwip_select+0x62>
      sys_sem_signal(selectsem);
  801a96:	83 ec 0c             	sub    $0xc,%esp
  801a99:	ff 35 40 50 81 00    	pushl  0x815040
  801a9f:	e8 cf 88 00 00       	call   80a373 <sys_sem_signal>
      if (readset)
  801aa4:	83 c4 10             	add    $0x10,%esp
  801aa7:	85 db                	test   %ebx,%ebx
  801aa9:	74 10                	je     801abb <lwip_select+0x1bb>
        FD_ZERO(readset);
  801aab:	83 ec 04             	sub    $0x4,%esp
  801aae:	6a 04                	push   $0x4
  801ab0:	6a 00                	push   $0x0
  801ab2:	53                   	push   %ebx
  801ab3:	e8 ea d6 00 00       	call   80f1a2 <memset>
  801ab8:	83 c4 10             	add    $0x10,%esp
      if (writeset)
  801abb:	85 f6                	test   %esi,%esi
  801abd:	74 10                	je     801acf <lwip_select+0x1cf>
        FD_ZERO(writeset);
  801abf:	83 ec 04             	sub    $0x4,%esp
  801ac2:	6a 04                	push   $0x4
  801ac4:	6a 00                	push   $0x0
  801ac6:	56                   	push   %esi
  801ac7:	e8 d6 d6 00 00       	call   80f1a2 <memset>
  801acc:	83 c4 10             	add    $0x10,%esp
      if (exceptset)
  801acf:	85 ff                	test   %edi,%edi
  801ad1:	74 10                	je     801ae3 <lwip_select+0x1e3>
        FD_ZERO(exceptset);
  801ad3:	83 ec 04             	sub    $0x4,%esp
  801ad6:	6a 04                	push   $0x4
  801ad8:	6a 00                	push   $0x0
  801ada:	57                   	push   %edi
  801adb:	e8 c2 d6 00 00       	call   80f1a2 <memset>
  801ae0:	83 c4 10             	add    $0x10,%esp
      set_errno(0);
  801ae3:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  801aea:	00 00 00 
      return 0;
  801aed:	e9 98 00 00 00       	jmp    801b8a <lwip_select+0x28a>
      select_cb_list = select_cb.next;
  801af2:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  801af5:	a3 48 50 81 00       	mov    %eax,0x815048
  801afa:	eb 05                	jmp    801b01 <lwip_select+0x201>
          p_selcb->next = select_cb.next;
  801afc:	8b 55 c4             	mov    -0x3c(%ebp),%edx
  801aff:	89 10                	mov    %edx,(%eax)
    sys_sem_signal(selectsem);
  801b01:	83 ec 0c             	sub    $0xc,%esp
  801b04:	ff 35 40 50 81 00    	pushl  0x815040
  801b0a:	e8 64 88 00 00       	call   80a373 <sys_sem_signal>
    sys_sem_free(select_cb.sem);
  801b0f:	83 c4 04             	add    $0x4,%esp
  801b12:	ff 75 d8             	pushl  -0x28(%ebp)
  801b15:	e8 11 86 00 00       	call   80a12b <sys_sem_free>
    if (i == 0)  {
  801b1a:	83 c4 10             	add    $0x10,%esp
  801b1d:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
  801b21:	74 72                	je     801b95 <lwip_select+0x295>
    if (readset)
  801b23:	85 db                	test   %ebx,%ebx
  801b25:	0f 84 b2 00 00 00    	je     801bdd <lwip_select+0x2dd>
      lreadset = *readset;
  801b2b:	8b 03                	mov    (%ebx),%eax
  801b2d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if (writeset)
  801b30:	85 f6                	test   %esi,%esi
  801b32:	0f 84 bd 00 00 00    	je     801bf5 <lwip_select+0x2f5>
      lwriteset = *writeset;
  801b38:	8b 06                	mov    (%esi),%eax
  801b3a:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if (exceptset)
  801b3d:	85 ff                	test   %edi,%edi
  801b3f:	0f 84 c8 00 00 00    	je     801c0d <lwip_select+0x30d>
      lexceptset = *exceptset;
  801b45:	8b 07                	mov    (%edi),%eax
  801b47:	89 45 dc             	mov    %eax,-0x24(%ebp)
    nready = lwip_selscan(maxfdp1, &lreadset, &lwriteset, &lexceptset);
  801b4a:	83 ec 0c             	sub    $0xc,%esp
  801b4d:	8d 45 dc             	lea    -0x24(%ebp),%eax
  801b50:	50                   	push   %eax
  801b51:	8d 4d e0             	lea    -0x20(%ebp),%ecx
  801b54:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  801b57:	8b 45 08             	mov    0x8(%ebp),%eax
  801b5a:	e8 08 ed ff ff       	call   800867 <lwip_selscan>
  801b5f:	89 45 b4             	mov    %eax,-0x4c(%ebp)
  801b62:	83 c4 10             	add    $0x10,%esp
  if (readset)
  801b65:	85 db                	test   %ebx,%ebx
  801b67:	74 05                	je     801b6e <lwip_select+0x26e>
    *readset = lreadset;
  801b69:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  801b6c:	89 03                	mov    %eax,(%ebx)
  if (writeset)
  801b6e:	85 f6                	test   %esi,%esi
  801b70:	74 05                	je     801b77 <lwip_select+0x277>
    *writeset = lwriteset;
  801b72:	8b 45 e0             	mov    -0x20(%ebp),%eax
  801b75:	89 06                	mov    %eax,(%esi)
  if (exceptset)
  801b77:	85 ff                	test   %edi,%edi
  801b79:	74 05                	je     801b80 <lwip_select+0x280>
    *exceptset = lexceptset;
  801b7b:	8b 45 dc             	mov    -0x24(%ebp),%eax
  801b7e:	89 07                	mov    %eax,(%edi)
  set_errno(0);
  801b80:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  801b87:	00 00 00 
}
  801b8a:	8b 45 b4             	mov    -0x4c(%ebp),%eax
  801b8d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  801b90:	5b                   	pop    %ebx
  801b91:	5e                   	pop    %esi
  801b92:	5f                   	pop    %edi
  801b93:	5d                   	pop    %ebp
  801b94:	c3                   	ret    
      if (readset)
  801b95:	85 db                	test   %ebx,%ebx
  801b97:	74 10                	je     801ba9 <lwip_select+0x2a9>
        FD_ZERO(readset);
  801b99:	83 ec 04             	sub    $0x4,%esp
  801b9c:	6a 04                	push   $0x4
  801b9e:	6a 00                	push   $0x0
  801ba0:	53                   	push   %ebx
  801ba1:	e8 fc d5 00 00       	call   80f1a2 <memset>
  801ba6:	83 c4 10             	add    $0x10,%esp
      if (writeset)
  801ba9:	85 f6                	test   %esi,%esi
  801bab:	74 10                	je     801bbd <lwip_select+0x2bd>
        FD_ZERO(writeset);
  801bad:	83 ec 04             	sub    $0x4,%esp
  801bb0:	6a 04                	push   $0x4
  801bb2:	6a 00                	push   $0x0
  801bb4:	56                   	push   %esi
  801bb5:	e8 e8 d5 00 00       	call   80f1a2 <memset>
  801bba:	83 c4 10             	add    $0x10,%esp
      if (exceptset)
  801bbd:	85 ff                	test   %edi,%edi
  801bbf:	74 10                	je     801bd1 <lwip_select+0x2d1>
        FD_ZERO(exceptset);
  801bc1:	83 ec 04             	sub    $0x4,%esp
  801bc4:	6a 04                	push   $0x4
  801bc6:	6a 00                	push   $0x0
  801bc8:	57                   	push   %edi
  801bc9:	e8 d4 d5 00 00       	call   80f1a2 <memset>
  801bce:	83 c4 10             	add    $0x10,%esp
      set_errno(0);
  801bd1:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  801bd8:	00 00 00 
      return 0;
  801bdb:	eb ad                	jmp    801b8a <lwip_select+0x28a>
      FD_ZERO(&lreadset);
  801bdd:	83 ec 04             	sub    $0x4,%esp
  801be0:	6a 04                	push   $0x4
  801be2:	6a 00                	push   $0x0
  801be4:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  801be7:	50                   	push   %eax
  801be8:	e8 b5 d5 00 00       	call   80f1a2 <memset>
  801bed:	83 c4 10             	add    $0x10,%esp
  801bf0:	e9 3b ff ff ff       	jmp    801b30 <lwip_select+0x230>
      FD_ZERO(&lwriteset);
  801bf5:	83 ec 04             	sub    $0x4,%esp
  801bf8:	6a 04                	push   $0x4
  801bfa:	6a 00                	push   $0x0
  801bfc:	8d 45 e0             	lea    -0x20(%ebp),%eax
  801bff:	50                   	push   %eax
  801c00:	e8 9d d5 00 00       	call   80f1a2 <memset>
  801c05:	83 c4 10             	add    $0x10,%esp
  801c08:	e9 30 ff ff ff       	jmp    801b3d <lwip_select+0x23d>
      FD_ZERO(&lexceptset);
  801c0d:	83 ec 04             	sub    $0x4,%esp
  801c10:	6a 04                	push   $0x4
  801c12:	6a 00                	push   $0x0
  801c14:	8d 45 dc             	lea    -0x24(%ebp),%eax
  801c17:	50                   	push   %eax
  801c18:	e8 85 d5 00 00       	call   80f1a2 <memset>
  801c1d:	83 c4 10             	add    $0x10,%esp
  801c20:	e9 25 ff ff ff       	jmp    801b4a <lwip_select+0x24a>
    sys_sem_signal(selectsem);
  801c25:	83 ec 0c             	sub    $0xc,%esp
  801c28:	ff 35 40 50 81 00    	pushl  0x815040
  801c2e:	e8 40 87 00 00       	call   80a373 <sys_sem_signal>
  801c33:	83 c4 10             	add    $0x10,%esp
  801c36:	e9 2a ff ff ff       	jmp    801b65 <lwip_select+0x265>
    select_cb.sem = sys_sem_new(0);
  801c3b:	83 ec 0c             	sub    $0xc,%esp
  801c3e:	6a 00                	push   $0x0
  801c40:	e8 61 84 00 00       	call   80a0a6 <sys_sem_new>
  801c45:	89 45 d8             	mov    %eax,-0x28(%ebp)
    select_cb.next = select_cb_list;
  801c48:	a1 48 50 81 00       	mov    0x815048,%eax
  801c4d:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    select_cb_list = &select_cb;
  801c50:	8d 45 c4             	lea    -0x3c(%ebp),%eax
  801c53:	a3 48 50 81 00       	mov    %eax,0x815048
    sys_sem_signal(selectsem);
  801c58:	83 c4 04             	add    $0x4,%esp
  801c5b:	ff 35 40 50 81 00    	pushl  0x815040
  801c61:	e8 0d 87 00 00       	call   80a373 <sys_sem_signal>
  801c66:	83 c4 10             	add    $0x10,%esp
      msectimeout = 0;
  801c69:	b8 00 00 00 00       	mov    $0x0,%eax
  801c6e:	e9 93 fd ff ff       	jmp    801a06 <lwip_select+0x106>

00801c73 <lwip_shutdown>:
{
  801c73:	f3 0f 1e fb          	endbr32 
  801c77:	55                   	push   %ebp
  801c78:	89 e5                	mov    %esp,%ebp
  801c7a:	83 ec 14             	sub    $0x14,%esp
  return lwip_close(s); /* XXX temporary hack until proper implementation */
  801c7d:	ff 75 08             	pushl  0x8(%ebp)
  801c80:	e8 1d f5 ff ff       	call   8011a2 <lwip_close>
}
  801c85:	c9                   	leave  
  801c86:	c3                   	ret    

00801c87 <lwip_getpeername>:
{
  801c87:	f3 0f 1e fb          	endbr32 
  801c8b:	55                   	push   %ebp
  801c8c:	89 e5                	mov    %esp,%ebp
  801c8e:	83 ec 14             	sub    $0x14,%esp
  return lwip_getaddrname(s, name, namelen, 0);
  801c91:	6a 00                	push   $0x0
  801c93:	8b 4d 10             	mov    0x10(%ebp),%ecx
  801c96:	8b 55 0c             	mov    0xc(%ebp),%edx
  801c99:	8b 45 08             	mov    0x8(%ebp),%eax
  801c9c:	e8 cb ec ff ff       	call   80096c <lwip_getaddrname>
}
  801ca1:	c9                   	leave  
  801ca2:	c3                   	ret    

00801ca3 <lwip_getsockname>:
{
  801ca3:	f3 0f 1e fb          	endbr32 
  801ca7:	55                   	push   %ebp
  801ca8:	89 e5                	mov    %esp,%ebp
  801caa:	83 ec 14             	sub    $0x14,%esp
  return lwip_getaddrname(s, name, namelen, 1);
  801cad:	6a 01                	push   $0x1
  801caf:	8b 4d 10             	mov    0x10(%ebp),%ecx
  801cb2:	8b 55 0c             	mov    0xc(%ebp),%edx
  801cb5:	8b 45 08             	mov    0x8(%ebp),%eax
  801cb8:	e8 af ec ff ff       	call   80096c <lwip_getaddrname>
}
  801cbd:	c9                   	leave  
  801cbe:	c3                   	ret    

00801cbf <lwip_getsockopt>:
{
  801cbf:	f3 0f 1e fb          	endbr32 
  801cc3:	55                   	push   %ebp
  801cc4:	89 e5                	mov    %esp,%ebp
  801cc6:	57                   	push   %edi
  801cc7:	56                   	push   %esi
  801cc8:	53                   	push   %ebx
  801cc9:	83 ec 2c             	sub    $0x2c,%esp
  801ccc:	8b 75 0c             	mov    0xc(%ebp),%esi
  801ccf:	8b 7d 18             	mov    0x18(%ebp),%edi
  struct lwip_socket *sock = get_socket(s);
  801cd2:	8b 45 08             	mov    0x8(%ebp),%eax
  801cd5:	e8 4e eb ff ff       	call   800828 <get_socket>
  if (!sock)
  801cda:	85 c0                	test   %eax,%eax
  801cdc:	0f 84 b0 01 00 00    	je     801e92 <lwip_getsockopt+0x1d3>
  801ce2:	89 c3                	mov    %eax,%ebx
  if ((NULL == optval) || (NULL == optlen)) {
  801ce4:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  801ce8:	74 37                	je     801d21 <lwip_getsockopt+0x62>
  801cea:	85 ff                	test   %edi,%edi
  801cec:	74 33                	je     801d21 <lwip_getsockopt+0x62>
  switch (level) {
  801cee:	83 fe 06             	cmp    $0x6,%esi
  801cf1:	0f 84 39 01 00 00    	je     801e30 <lwip_getsockopt+0x171>
  801cf7:	81 fe ff 0f 00 00    	cmp    $0xfff,%esi
  801cfd:	74 3d                	je     801d3c <lwip_getsockopt+0x7d>
  801cff:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801d04:	85 f6                	test   %esi,%esi
  801d06:	0f 84 ac 00 00 00    	je     801db8 <lwip_getsockopt+0xf9>
    sock_set_errno(sock, err);
  801d0c:	0f be c0             	movsbl %al,%eax
  801d0f:	89 43 10             	mov    %eax,0x10(%ebx)
  801d12:	a3 e0 b1 b3 00       	mov    %eax,0xb3b1e0
    return -1;
  801d17:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801d1c:	e9 07 01 00 00       	jmp    801e28 <lwip_getsockopt+0x169>
    sock_set_errno(sock, EFAULT);
  801d21:	c7 43 10 0e 00 00 00 	movl   $0xe,0x10(%ebx)
  801d28:	c7 05 e0 b1 b3 00 0e 	movl   $0xe,0xb3b1e0
  801d2f:	00 00 00 
    return -1;
  801d32:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801d37:	e9 ec 00 00 00       	jmp    801e28 <lwip_getsockopt+0x169>
  801d3c:	81 7d 10 08 10 00 00 	cmpl   $0x1008,0x10(%ebp)
  801d43:	7e 34                	jle    801d79 <lwip_getsockopt+0xba>
  801d45:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801d4a:	81 7d 10 0a 10 00 00 	cmpl   $0x100a,0x10(%ebp)
  801d51:	75 b9                	jne    801d0c <lwip_getsockopt+0x4d>
        err = EINVAL;
  801d53:	83 3f 04             	cmpl   $0x4,(%edi)
  801d56:	19 c0                	sbb    %eax,%eax
  801d58:	83 e0 16             	and    $0x16,%eax
      if ((sock->conn->type != NETCONN_UDP) ||
  801d5b:	8b 13                	mov    (%ebx),%edx
  801d5d:	83 3a 20             	cmpl   $0x20,(%edx)
  801d60:	0f 85 fa 00 00 00    	jne    801e60 <lwip_getsockopt+0x1a1>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
  801d66:	8b 52 08             	mov    0x8(%edx),%edx
      if ((sock->conn->type != NETCONN_UDP) ||
  801d69:	f6 42 10 02          	testb  $0x2,0x10(%edx)
  801d6d:	0f 85 f7 00 00 00    	jne    801e6a <lwip_getsockopt+0x1ab>
  if (err != ERR_OK) {
  801d73:	84 c0                	test   %al,%al
  801d75:	74 59                	je     801dd0 <lwip_getsockopt+0x111>
  801d77:	eb 93                	jmp    801d0c <lwip_getsockopt+0x4d>
  801d79:	81 7d 10 06 10 00 00 	cmpl   $0x1006,0x10(%ebp)
  801d80:	7f 27                	jg     801da9 <lwip_getsockopt+0xea>
  801d82:	8b 45 10             	mov    0x10(%ebp),%eax
  801d85:	8d 48 fe             	lea    -0x2(%eax),%ecx
  801d88:	83 f9 1e             	cmp    $0x1e,%ecx
  801d8b:	0f 87 c5 00 00 00    	ja     801e56 <lwip_getsockopt+0x197>
  801d91:	b8 01 00 00 00       	mov    $0x1,%eax
  801d96:	d3 e0                	shl    %cl,%eax
  801d98:	a9 41 00 00 40       	test   $0x40000041,%eax
  801d9d:	75 0a                	jne    801da9 <lwip_getsockopt+0xea>
  801d9f:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801da4:	e9 63 ff ff ff       	jmp    801d0c <lwip_getsockopt+0x4d>
      if (*optlen < sizeof(int)) {
  801da9:	83 3f 03             	cmpl   $0x3,(%edi)
  801dac:	77 22                	ja     801dd0 <lwip_getsockopt+0x111>
        err = EINVAL;
  801dae:	b8 16 00 00 00       	mov    $0x16,%eax
  801db3:	e9 54 ff ff ff       	jmp    801d0c <lwip_getsockopt+0x4d>
  801db8:	8b 45 10             	mov    0x10(%ebp),%eax
  801dbb:	83 e8 01             	sub    $0x1,%eax
  801dbe:	83 f8 01             	cmp    $0x1,%eax
  801dc1:	0f 87 ad 00 00 00    	ja     801e74 <lwip_getsockopt+0x1b5>
      if (*optlen < sizeof(int)) {
  801dc7:	83 3f 03             	cmpl   $0x3,(%edi)
  801dca:	0f 86 ae 00 00 00    	jbe    801e7e <lwip_getsockopt+0x1bf>
  data.sock = sock;
  801dd0:	89 5d cc             	mov    %ebx,-0x34(%ebp)
  data.level = level;
  801dd3:	89 75 d4             	mov    %esi,-0x2c(%ebp)
  data.optname = optname;
  801dd6:	8b 45 10             	mov    0x10(%ebp),%eax
  801dd9:	89 45 d8             	mov    %eax,-0x28(%ebp)
  data.optval = optval;
  801ddc:	8b 45 14             	mov    0x14(%ebp),%eax
  801ddf:	89 45 dc             	mov    %eax,-0x24(%ebp)
  data.optlen = optlen;
  801de2:	89 7d e0             	mov    %edi,-0x20(%ebp)
  data.err = err;
  801de5:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  tcpip_callback(lwip_getsockopt_internal, &data);
  801de9:	83 ec 04             	sub    $0x4,%esp
  801dec:	6a 01                	push   $0x1
  801dee:	8d 45 cc             	lea    -0x34(%ebp),%eax
  801df1:	50                   	push   %eax
  801df2:	68 62 0c 80 00       	push   $0x800c62
  801df7:	e8 09 06 00 00       	call   802405 <tcpip_callback_with_block>
  sys_arch_sem_wait(sock->conn->op_completed, 0);
  801dfc:	83 c4 08             	add    $0x8,%esp
  801dff:	6a 00                	push   $0x0
  801e01:	8b 03                	mov    (%ebx),%eax
  801e03:	ff 70 10             	pushl  0x10(%eax)
  801e06:	e8 dc 85 00 00       	call   80a3e7 <sys_arch_sem_wait>
  err = data.err;
  801e0b:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  sock_set_errno(sock, err);
  801e0f:	0f be d0             	movsbl %al,%edx
  801e12:	89 53 10             	mov    %edx,0x10(%ebx)
  801e15:	89 15 e0 b1 b3 00    	mov    %edx,0xb3b1e0
  return err ? -1 : 0;
  801e1b:	83 c4 10             	add    $0x10,%esp
  801e1e:	84 c0                	test   %al,%al
  801e20:	0f 95 c0             	setne  %al
  801e23:	0f b6 c0             	movzbl %al,%eax
  801e26:	f7 d8                	neg    %eax
}
  801e28:	8d 65 f4             	lea    -0xc(%ebp),%esp
  801e2b:	5b                   	pop    %ebx
  801e2c:	5e                   	pop    %esi
  801e2d:	5f                   	pop    %edi
  801e2e:	5d                   	pop    %ebp
  801e2f:	c3                   	ret    
    if (*optlen < sizeof(int)) {
  801e30:	83 3f 03             	cmpl   $0x3,(%edi)
  801e33:	76 53                	jbe    801e88 <lwip_getsockopt+0x1c9>
    if (sock->conn->type != NETCONN_TCP)
  801e35:	8b 10                	mov    (%eax),%edx
      return 0;
  801e37:	b8 00 00 00 00       	mov    $0x0,%eax
    if (sock->conn->type != NETCONN_TCP)
  801e3c:	83 3a 10             	cmpl   $0x10,(%edx)
  801e3f:	75 e7                	jne    801e28 <lwip_getsockopt+0x169>
  801e41:	8b 45 10             	mov    0x10(%ebp),%eax
  801e44:	83 e8 01             	sub    $0x1,%eax
  801e47:	83 f8 01             	cmp    $0x1,%eax
  801e4a:	76 84                	jbe    801dd0 <lwip_getsockopt+0x111>
      err = ENOPROTOOPT;
  801e4c:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801e51:	e9 b6 fe ff ff       	jmp    801d0c <lwip_getsockopt+0x4d>
  801e56:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801e5b:	e9 ac fe ff ff       	jmp    801d0c <lwip_getsockopt+0x4d>
        err = EAFNOSUPPORT;
  801e60:	b8 61 00 00 00       	mov    $0x61,%eax
  801e65:	e9 a2 fe ff ff       	jmp    801d0c <lwip_getsockopt+0x4d>
  801e6a:	b8 61 00 00 00       	mov    $0x61,%eax
  801e6f:	e9 98 fe ff ff       	jmp    801d0c <lwip_getsockopt+0x4d>
      err = ENOPROTOOPT;
  801e74:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801e79:	e9 8e fe ff ff       	jmp    801d0c <lwip_getsockopt+0x4d>
        err = EINVAL;
  801e7e:	b8 16 00 00 00       	mov    $0x16,%eax
  801e83:	e9 84 fe ff ff       	jmp    801d0c <lwip_getsockopt+0x4d>
      err = EINVAL;
  801e88:	b8 16 00 00 00       	mov    $0x16,%eax
  801e8d:	e9 7a fe ff ff       	jmp    801d0c <lwip_getsockopt+0x4d>
    return -1;
  801e92:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801e97:	eb 8f                	jmp    801e28 <lwip_getsockopt+0x169>

00801e99 <lwip_setsockopt>:
{
  801e99:	f3 0f 1e fb          	endbr32 
  801e9d:	55                   	push   %ebp
  801e9e:	89 e5                	mov    %esp,%ebp
  801ea0:	57                   	push   %edi
  801ea1:	56                   	push   %esi
  801ea2:	53                   	push   %ebx
  801ea3:	83 ec 2c             	sub    $0x2c,%esp
  801ea6:	8b 75 0c             	mov    0xc(%ebp),%esi
  801ea9:	8b 7d 14             	mov    0x14(%ebp),%edi
  struct lwip_socket *sock = get_socket(s);
  801eac:	8b 45 08             	mov    0x8(%ebp),%eax
  801eaf:	e8 74 e9 ff ff       	call   800828 <get_socket>
  if (!sock)
  801eb4:	85 c0                	test   %eax,%eax
  801eb6:	0f 84 69 01 00 00    	je     802025 <lwip_setsockopt+0x18c>
  801ebc:	89 c3                	mov    %eax,%ebx
  if (NULL == optval) {
  801ebe:	85 ff                	test   %edi,%edi
  801ec0:	74 2c                	je     801eee <lwip_setsockopt+0x55>
  switch (level) {
  801ec2:	83 fe 06             	cmp    $0x6,%esi
  801ec5:	0f 84 01 01 00 00    	je     801fcc <lwip_setsockopt+0x133>
  801ecb:	81 fe ff 0f 00 00    	cmp    $0xfff,%esi
  801ed1:	74 36                	je     801f09 <lwip_setsockopt+0x70>
  801ed3:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801ed8:	85 f6                	test   %esi,%esi
  801eda:	74 7b                	je     801f57 <lwip_setsockopt+0xbe>
    sock_set_errno(sock, err);
  801edc:	89 43 10             	mov    %eax,0x10(%ebx)
  801edf:	a3 e0 b1 b3 00       	mov    %eax,0xb3b1e0
    return -1;
  801ee4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801ee9:	e9 d6 00 00 00       	jmp    801fc4 <lwip_setsockopt+0x12b>
    sock_set_errno(sock, EFAULT);
  801eee:	c7 40 10 0e 00 00 00 	movl   $0xe,0x10(%eax)
  801ef5:	c7 05 e0 b1 b3 00 0e 	movl   $0xe,0xb3b1e0
  801efc:	00 00 00 
    return -1;
  801eff:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801f04:	e9 bb 00 00 00       	jmp    801fc4 <lwip_setsockopt+0x12b>
  801f09:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
  801f0d:	74 14                	je     801f23 <lwip_setsockopt+0x8a>
  801f0f:	81 7d 10 0a 10 00 00 	cmpl   $0x100a,0x10(%ebp)
  801f16:	74 18                	je     801f30 <lwip_setsockopt+0x97>
  801f18:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801f1d:	83 7d 10 08          	cmpl   $0x8,0x10(%ebp)
  801f21:	75 b9                	jne    801edc <lwip_setsockopt+0x43>
      if (optlen < sizeof(int)) {
  801f23:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  801f27:	77 47                	ja     801f70 <lwip_setsockopt+0xd7>
        err = EINVAL;
  801f29:	b8 16 00 00 00       	mov    $0x16,%eax
  801f2e:	eb ac                	jmp    801edc <lwip_setsockopt+0x43>
        err = EINVAL;
  801f30:	83 7d 18 04          	cmpl   $0x4,0x18(%ebp)
  801f34:	19 c0                	sbb    %eax,%eax
  801f36:	83 e0 16             	and    $0x16,%eax
      if ((sock->conn->type != NETCONN_UDP) ||
  801f39:	8b 13                	mov    (%ebx),%edx
  801f3b:	83 3a 20             	cmpl   $0x20,(%edx)
  801f3e:	0f 85 af 00 00 00    	jne    801ff3 <lwip_setsockopt+0x15a>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
  801f44:	8b 52 08             	mov    0x8(%edx),%edx
      if ((sock->conn->type != NETCONN_UDP) ||
  801f47:	f6 42 10 02          	testb  $0x2,0x10(%edx)
  801f4b:	0f 85 ac 00 00 00    	jne    801ffd <lwip_setsockopt+0x164>
  if (err != ERR_OK) {
  801f51:	85 c0                	test   %eax,%eax
  801f53:	74 1b                	je     801f70 <lwip_setsockopt+0xd7>
  801f55:	eb 85                	jmp    801edc <lwip_setsockopt+0x43>
  801f57:	8b 45 10             	mov    0x10(%ebp),%eax
  801f5a:	83 e8 01             	sub    $0x1,%eax
  801f5d:	83 f8 01             	cmp    $0x1,%eax
  801f60:	0f 87 a1 00 00 00    	ja     802007 <lwip_setsockopt+0x16e>
      if (optlen < sizeof(int)) {
  801f66:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  801f6a:	0f 86 a1 00 00 00    	jbe    802011 <lwip_setsockopt+0x178>
  data.sock = sock;
  801f70:	89 5d cc             	mov    %ebx,-0x34(%ebp)
  data.level = level;
  801f73:	89 75 d4             	mov    %esi,-0x2c(%ebp)
  data.optname = optname;
  801f76:	8b 45 10             	mov    0x10(%ebp),%eax
  801f79:	89 45 d8             	mov    %eax,-0x28(%ebp)
  data.optval = (void*)optval;
  801f7c:	89 7d dc             	mov    %edi,-0x24(%ebp)
  data.optlen = &optlen;
  801f7f:	8d 45 18             	lea    0x18(%ebp),%eax
  801f82:	89 45 e0             	mov    %eax,-0x20(%ebp)
  data.err = err;
  801f85:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  tcpip_callback(lwip_setsockopt_internal, &data);
  801f89:	83 ec 04             	sub    $0x4,%esp
  801f8c:	6a 01                	push   $0x1
  801f8e:	8d 45 cc             	lea    -0x34(%ebp),%eax
  801f91:	50                   	push   %eax
  801f92:	68 f5 0d 80 00       	push   $0x800df5
  801f97:	e8 69 04 00 00       	call   802405 <tcpip_callback_with_block>
  sys_arch_sem_wait(sock->conn->op_completed, 0);
  801f9c:	83 c4 08             	add    $0x8,%esp
  801f9f:	6a 00                	push   $0x0
  801fa1:	8b 03                	mov    (%ebx),%eax
  801fa3:	ff 70 10             	pushl  0x10(%eax)
  801fa6:	e8 3c 84 00 00       	call   80a3e7 <sys_arch_sem_wait>
  err = data.err;
  801fab:	0f be 45 e4          	movsbl -0x1c(%ebp),%eax
  sock_set_errno(sock, err);
  801faf:	89 43 10             	mov    %eax,0x10(%ebx)
  801fb2:	a3 e0 b1 b3 00       	mov    %eax,0xb3b1e0
  return err ? -1 : 0;
  801fb7:	83 c4 10             	add    $0x10,%esp
  801fba:	85 c0                	test   %eax,%eax
  801fbc:	0f 95 c0             	setne  %al
  801fbf:	0f b6 c0             	movzbl %al,%eax
  801fc2:	f7 d8                	neg    %eax
}
  801fc4:	8d 65 f4             	lea    -0xc(%ebp),%esp
  801fc7:	5b                   	pop    %ebx
  801fc8:	5e                   	pop    %esi
  801fc9:	5f                   	pop    %edi
  801fca:	5d                   	pop    %ebp
  801fcb:	c3                   	ret    
    if (optlen < sizeof(int)) {
  801fcc:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  801fd0:	76 49                	jbe    80201b <lwip_setsockopt+0x182>
    if (sock->conn->type != NETCONN_TCP)
  801fd2:	8b 10                	mov    (%eax),%edx
      return 0;
  801fd4:	b8 00 00 00 00       	mov    $0x0,%eax
    if (sock->conn->type != NETCONN_TCP)
  801fd9:	83 3a 10             	cmpl   $0x10,(%edx)
  801fdc:	75 e6                	jne    801fc4 <lwip_setsockopt+0x12b>
  801fde:	8b 45 10             	mov    0x10(%ebp),%eax
  801fe1:	83 e8 01             	sub    $0x1,%eax
  801fe4:	83 f8 01             	cmp    $0x1,%eax
  801fe7:	76 87                	jbe    801f70 <lwip_setsockopt+0xd7>
      err = ENOPROTOOPT;
  801fe9:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801fee:	e9 e9 fe ff ff       	jmp    801edc <lwip_setsockopt+0x43>
        err = EAFNOSUPPORT;
  801ff3:	b8 61 00 00 00       	mov    $0x61,%eax
  801ff8:	e9 df fe ff ff       	jmp    801edc <lwip_setsockopt+0x43>
  801ffd:	b8 61 00 00 00       	mov    $0x61,%eax
  802002:	e9 d5 fe ff ff       	jmp    801edc <lwip_setsockopt+0x43>
        err = ENOPROTOOPT;
  802007:	b8 5c 00 00 00       	mov    $0x5c,%eax
  80200c:	e9 cb fe ff ff       	jmp    801edc <lwip_setsockopt+0x43>
        err = EINVAL;
  802011:	b8 16 00 00 00       	mov    $0x16,%eax
  802016:	e9 c1 fe ff ff       	jmp    801edc <lwip_setsockopt+0x43>
      err = EINVAL;
  80201b:	b8 16 00 00 00       	mov    $0x16,%eax
  802020:	e9 b7 fe ff ff       	jmp    801edc <lwip_setsockopt+0x43>
    return -1;
  802025:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80202a:	eb 98                	jmp    801fc4 <lwip_setsockopt+0x12b>

0080202c <lwip_ioctl>:

int
lwip_ioctl(int s, long cmd, void *argp)
{
  80202c:	f3 0f 1e fb          	endbr32 
  802030:	55                   	push   %ebp
  802031:	89 e5                	mov    %esp,%ebp
  802033:	56                   	push   %esi
  802034:	53                   	push   %ebx
  802035:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  802038:	8b 75 10             	mov    0x10(%ebp),%esi
  struct lwip_socket *sock = get_socket(s);
  80203b:	8b 45 08             	mov    0x8(%ebp),%eax
  80203e:	e8 e5 e7 ff ff       	call   800828 <get_socket>
  u16_t buflen = 0;

  if (!sock)
  802043:	85 c0                	test   %eax,%eax
  802045:	0f 84 b4 00 00 00    	je     8020ff <lwip_ioctl+0xd3>
    return -1;

  switch (cmd) {
  80204b:	81 fb 7e 66 04 80    	cmp    $0x8004667e,%ebx
  802051:	74 5d                	je     8020b0 <lwip_ioctl+0x84>
  802053:	81 fb 7f 66 04 40    	cmp    $0x4004667f,%ebx
  802059:	0f 85 88 00 00 00    	jne    8020e7 <lwip_ioctl+0xbb>
  case FIONREAD:
    if (!argp) {
  80205f:	85 f6                	test   %esi,%esi
  802061:	74 35                	je     802098 <lwip_ioctl+0x6c>
      sock_set_errno(sock, EINVAL);
      return -1;
    }

    SYS_ARCH_GET(sock->conn->recv_avail, *((u16_t*)argp));
  802063:	8b 10                	mov    (%eax),%edx
  802065:	0f b7 52 20          	movzwl 0x20(%edx),%edx
  802069:	66 89 16             	mov    %dx,(%esi)

    /* Check if there is data left from the last recv operation. /maq 041215 */
    if (sock->lastdata) {
  80206c:	8b 48 04             	mov    0x4(%eax),%ecx
  80206f:	85 c9                	test   %ecx,%ecx
  802071:	74 0d                	je     802080 <lwip_ioctl+0x54>
      buflen = netbuf_len(sock->lastdata);
  802073:	8b 09                	mov    (%ecx),%ecx
      buflen -= sock->lastoffset;

      *((u16_t*)argp) += buflen;
  802075:	66 2b 50 08          	sub    0x8(%eax),%dx
  802079:	66 03 51 08          	add    0x8(%ecx),%dx
  80207d:	66 89 16             	mov    %dx,(%esi)
    }

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONREAD, %p) = %u\n", s, argp, *((u16_t*)argp)));
    sock_set_errno(sock, 0);
  802080:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  802087:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  80208e:	00 00 00 
    return 0;
  802091:	b8 00 00 00 00       	mov    $0x0,%eax
  802096:	eb 4b                	jmp    8020e3 <lwip_ioctl+0xb7>
      sock_set_errno(sock, EINVAL);
  802098:	c7 40 10 16 00 00 00 	movl   $0x16,0x10(%eax)
  80209f:	c7 05 e0 b1 b3 00 16 	movl   $0x16,0xb3b1e0
  8020a6:	00 00 00 
      return -1;
  8020a9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8020ae:	eb 33                	jmp    8020e3 <lwip_ioctl+0xb7>

  case FIONBIO:
    if (argp && *(u32_t*)argp)
  8020b0:	85 f6                	test   %esi,%esi
  8020b2:	74 0e                	je     8020c2 <lwip_ioctl+0x96>
  8020b4:	83 3e 00             	cmpl   $0x0,(%esi)
  8020b7:	74 09                	je     8020c2 <lwip_ioctl+0x96>
      sock->flags |= O_NONBLOCK;
  8020b9:	0f b7 50 0e          	movzwl 0xe(%eax),%edx
  8020bd:	80 ce 08             	or     $0x8,%dh
  8020c0:	eb 07                	jmp    8020c9 <lwip_ioctl+0x9d>
    else
      sock->flags &= ~O_NONBLOCK;
  8020c2:	0f b7 50 0e          	movzwl 0xe(%eax),%edx
  8020c6:	80 e6 f7             	and    $0xf7,%dh
  8020c9:	66 89 50 0e          	mov    %dx,0xe(%eax)
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONBIO, %d)\n", s, !!(sock->flags & O_NONBLOCK)));
    sock_set_errno(sock, 0);
  8020cd:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  8020d4:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  8020db:	00 00 00 
    return 0;
  8020de:	b8 00 00 00 00       	mov    $0x0,%eax
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, UNIMPL: 0x%lx, %p)\n", s, cmd, argp));
    sock_set_errno(sock, ENOSYS); /* not yet implemented */
    return -1;
  } /* switch (cmd) */
}
  8020e3:	5b                   	pop    %ebx
  8020e4:	5e                   	pop    %esi
  8020e5:	5d                   	pop    %ebp
  8020e6:	c3                   	ret    
    sock_set_errno(sock, ENOSYS); /* not yet implemented */
  8020e7:	c7 40 10 26 00 00 00 	movl   $0x26,0x10(%eax)
  8020ee:	c7 05 e0 b1 b3 00 26 	movl   $0x26,0xb3b1e0
  8020f5:	00 00 00 
    return -1;
  8020f8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8020fd:	eb e4                	jmp    8020e3 <lwip_ioctl+0xb7>
    return -1;
  8020ff:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  802104:	eb dd                	jmp    8020e3 <lwip_ioctl+0xb7>

00802106 <tcpip_tcp_timer>:
 *
 * @param arg unused argument
 */
static void
tcpip_tcp_timer(void *arg)
{
  802106:	f3 0f 1e fb          	endbr32 
  80210a:	55                   	push   %ebp
  80210b:	89 e5                	mov    %esp,%ebp
  80210d:	83 ec 08             	sub    $0x8,%esp
  LWIP_UNUSED_ARG(arg);

  /* call TCP timer handler */
  tcp_tmr();
  802110:	e8 26 42 00 00       	call   80633b <tcp_tmr>
  /* timer still needed? */
  if (tcp_active_pcbs || tcp_tw_pcbs) {
  802115:	83 3d 3c b2 b3 00 00 	cmpl   $0x0,0xb3b23c
  80211c:	74 19                	je     802137 <tcpip_tcp_timer+0x31>
    /* restart timer */
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  80211e:	83 ec 04             	sub    $0x4,%esp
  802121:	6a 00                	push   $0x0
  802123:	68 06 21 80 00       	push   $0x802106
  802128:	68 fa 00 00 00       	push   $0xfa
  80212d:	e8 89 32 00 00       	call   8053bb <sys_timeout>
  802132:	83 c4 10             	add    $0x10,%esp
  } else {
    /* disable timer */
    tcpip_tcp_timer_active = 0;
  }
}
  802135:	c9                   	leave  
  802136:	c3                   	ret    
  if (tcp_active_pcbs || tcp_tw_pcbs) {
  802137:	83 3d 50 b2 b3 00 00 	cmpl   $0x0,0xb3b250
  80213e:	75 de                	jne    80211e <tcpip_tcp_timer+0x18>
    tcpip_tcp_timer_active = 0;
  802140:	c7 05 e0 52 81 00 00 	movl   $0x0,0x8152e0
  802147:	00 00 00 
}
  80214a:	eb e9                	jmp    802135 <tcpip_tcp_timer+0x2f>

0080214c <tcpip_thread>:
 *
 * @param arg unused argument
 */
static void
tcpip_thread(void *arg)
{
  80214c:	f3 0f 1e fb          	endbr32 
  802150:	55                   	push   %ebp
  802151:	89 e5                	mov    %esp,%ebp
  802153:	53                   	push   %ebx
  802154:	83 ec 18             	sub    $0x18,%esp
  struct tcpip_msg *msg;
  LWIP_UNUSED_ARG(arg);

#if IP_REASSEMBLY
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
  802157:	6a 00                	push   $0x0
  802159:	68 0d 23 80 00       	push   $0x80230d
  80215e:	68 e8 03 00 00       	push   $0x3e8
  802163:	e8 53 32 00 00       	call   8053bb <sys_timeout>
#endif /* IP_REASSEMBLY */
#if LWIP_ARP
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
  802168:	83 c4 0c             	add    $0xc,%esp
  80216b:	6a 00                	push   $0x0
  80216d:	68 e5 22 80 00       	push   $0x8022e5
  802172:	68 88 13 00 00       	push   $0x1388
  802177:	e8 3f 32 00 00       	call   8053bb <sys_timeout>
#endif /* LWIP_ARP */
#if LWIP_DHCP
  sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
  80217c:	83 c4 0c             	add    $0xc,%esp
  80217f:	6a 00                	push   $0x0
  802181:	68 bd 22 80 00       	push   $0x8022bd
  802186:	68 60 ea 00 00       	push   $0xea60
  80218b:	e8 2b 32 00 00       	call   8053bb <sys_timeout>
  sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
  802190:	83 c4 0c             	add    $0xc,%esp
  802193:	6a 00                	push   $0x0
  802195:	68 95 22 80 00       	push   $0x802295
  80219a:	68 f4 01 00 00       	push   $0x1f4
  80219f:	e8 17 32 00 00       	call   8053bb <sys_timeout>
#endif /* LWIP_IGMP */
#if LWIP_DNS
  sys_timeout(DNS_TMR_INTERVAL, dns_timer, NULL);
#endif /* LWIP_DNS */

  if (tcpip_init_done != NULL) {
  8021a4:	a1 e8 52 81 00       	mov    0x8152e8,%eax
  8021a9:	83 c4 10             	add    $0x10,%esp
  8021ac:	85 c0                	test   %eax,%eax
  8021ae:	74 0e                	je     8021be <tcpip_thread+0x72>
    tcpip_init_done(tcpip_init_done_arg);
  8021b0:	83 ec 0c             	sub    $0xc,%esp
  8021b3:	ff 35 e4 52 81 00    	pushl  0x8152e4
  8021b9:	ff d0                	call   *%eax
  8021bb:	83 c4 10             	add    $0x10,%esp
  }

  LOCK_TCPIP_CORE();
  while (1) {                          /* MAIN Loop */
    sys_mbox_fetch(mbox, (void *)&msg);
  8021be:	8d 5d f4             	lea    -0xc(%ebp),%ebx
  8021c1:	eb 44                	jmp    802207 <tcpip_thread+0xbb>
    switch (msg->type) {
  8021c3:	83 f8 03             	cmp    $0x3,%eax
  8021c6:	75 3f                	jne    802207 <tcpip_thread+0xbb>
      break;

    case TCPIP_MSG_TIMEOUT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: TIMEOUT %p\n", (void *)msg));

      if(msg->msg.tmo.msecs != 0xffffffff)
  8021c8:	8b 42 08             	mov    0x8(%edx),%eax
  8021cb:	83 f8 ff             	cmp    $0xffffffff,%eax
  8021ce:	0f 84 ab 00 00 00    	je     80227f <tcpip_thread+0x133>
        sys_timeout (msg->msg.tmo.msecs, msg->msg.tmo.h, msg->msg.tmo.arg);
  8021d4:	83 ec 04             	sub    $0x4,%esp
  8021d7:	ff 72 10             	pushl  0x10(%edx)
  8021da:	ff 72 0c             	pushl  0xc(%edx)
  8021dd:	50                   	push   %eax
  8021de:	e8 d8 31 00 00       	call   8053bb <sys_timeout>
  8021e3:	83 c4 10             	add    $0x10,%esp
      else
        sys_untimeout (msg->msg.tmo.h, msg->msg.tmo.arg);
      memp_free(MEMP_TCPIP_MSG_API, msg);
  8021e6:	83 ec 08             	sub    $0x8,%esp
  8021e9:	ff 75 f4             	pushl  -0xc(%ebp)
  8021ec:	6a 08                	push   $0x8
  8021ee:	e8 ab 24 00 00       	call   80469e <memp_free>
      break;
  8021f3:	83 c4 10             	add    $0x10,%esp
  8021f6:	eb 0f                	jmp    802207 <tcpip_thread+0xbb>
      msg->msg.apimsg->function(&(msg->msg.apimsg->msg));
  8021f8:	8b 42 08             	mov    0x8(%edx),%eax
  8021fb:	83 ec 0c             	sub    $0xc,%esp
  8021fe:	8d 50 04             	lea    0x4(%eax),%edx
  802201:	52                   	push   %edx
  802202:	ff 10                	call   *(%eax)
      break;
  802204:	83 c4 10             	add    $0x10,%esp
    sys_mbox_fetch(mbox, (void *)&msg);
  802207:	83 ec 08             	sub    $0x8,%esp
  80220a:	53                   	push   %ebx
  80220b:	ff 35 00 40 81 00    	pushl  0x814000
  802211:	e8 75 30 00 00       	call   80528b <sys_mbox_fetch>
    switch (msg->type) {
  802216:	8b 55 f4             	mov    -0xc(%ebp),%edx
  802219:	8b 02                	mov    (%edx),%eax
  80221b:	83 c4 10             	add    $0x10,%esp
  80221e:	83 f8 02             	cmp    $0x2,%eax
  802221:	74 41                	je     802264 <tcpip_thread+0x118>
  802223:	77 9e                	ja     8021c3 <tcpip_thread+0x77>
  802225:	85 c0                	test   %eax,%eax
  802227:	74 cf                	je     8021f8 <tcpip_thread+0xac>
      if (msg->msg.inp.netif->flags & NETIF_FLAG_ETHARP) {
  802229:	8b 42 0c             	mov    0xc(%edx),%eax
  80222c:	f6 40 2e 20          	testb  $0x20,0x2e(%eax)
  802230:	74 21                	je     802253 <tcpip_thread+0x107>
        ethernet_input(msg->msg.inp.p, msg->msg.inp.netif);
  802232:	83 ec 08             	sub    $0x8,%esp
  802235:	50                   	push   %eax
  802236:	ff 72 08             	pushl  0x8(%edx)
  802239:	e8 af 7c 00 00       	call   809eed <ethernet_input>
  80223e:	83 c4 10             	add    $0x10,%esp
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
  802241:	83 ec 08             	sub    $0x8,%esp
  802244:	ff 75 f4             	pushl  -0xc(%ebp)
  802247:	6a 09                	push   $0x9
  802249:	e8 50 24 00 00       	call   80469e <memp_free>
      break;
  80224e:	83 c4 10             	add    $0x10,%esp
  802251:	eb b4                	jmp    802207 <tcpip_thread+0xbb>
      { ip_input(msg->msg.inp.p, msg->msg.inp.netif);
  802253:	83 ec 08             	sub    $0x8,%esp
  802256:	50                   	push   %eax
  802257:	ff 72 08             	pushl  0x8(%edx)
  80225a:	e8 26 45 00 00       	call   806785 <ip_input>
  80225f:	83 c4 10             	add    $0x10,%esp
  802262:	eb dd                	jmp    802241 <tcpip_thread+0xf5>
      msg->msg.cb.f(msg->msg.cb.ctx);
  802264:	83 ec 0c             	sub    $0xc,%esp
  802267:	ff 72 0c             	pushl  0xc(%edx)
  80226a:	ff 52 08             	call   *0x8(%edx)
      memp_free(MEMP_TCPIP_MSG_API, msg);
  80226d:	83 c4 08             	add    $0x8,%esp
  802270:	ff 75 f4             	pushl  -0xc(%ebp)
  802273:	6a 08                	push   $0x8
  802275:	e8 24 24 00 00       	call   80469e <memp_free>
      break;
  80227a:	83 c4 10             	add    $0x10,%esp
  80227d:	eb 88                	jmp    802207 <tcpip_thread+0xbb>
        sys_untimeout (msg->msg.tmo.h, msg->msg.tmo.arg);
  80227f:	83 ec 08             	sub    $0x8,%esp
  802282:	ff 72 10             	pushl  0x10(%edx)
  802285:	ff 72 0c             	pushl  0xc(%edx)
  802288:	e8 ed 31 00 00       	call   80547a <sys_untimeout>
  80228d:	83 c4 10             	add    $0x10,%esp
  802290:	e9 51 ff ff ff       	jmp    8021e6 <tcpip_thread+0x9a>

00802295 <dhcp_timer_fine>:
{
  802295:	f3 0f 1e fb          	endbr32 
  802299:	55                   	push   %ebp
  80229a:	89 e5                	mov    %esp,%ebp
  80229c:	83 ec 08             	sub    $0x8,%esp
  dhcp_fine_tmr();
  80229f:	e8 a1 1b 00 00       	call   803e45 <dhcp_fine_tmr>
  sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
  8022a4:	83 ec 04             	sub    $0x4,%esp
  8022a7:	6a 00                	push   $0x0
  8022a9:	68 95 22 80 00       	push   $0x802295
  8022ae:	68 f4 01 00 00       	push   $0x1f4
  8022b3:	e8 03 31 00 00       	call   8053bb <sys_timeout>
}
  8022b8:	83 c4 10             	add    $0x10,%esp
  8022bb:	c9                   	leave  
  8022bc:	c3                   	ret    

008022bd <dhcp_timer_coarse>:
{
  8022bd:	f3 0f 1e fb          	endbr32 
  8022c1:	55                   	push   %ebp
  8022c2:	89 e5                	mov    %esp,%ebp
  8022c4:	83 ec 08             	sub    $0x8,%esp
  dhcp_coarse_tmr();
  8022c7:	e8 a5 19 00 00       	call   803c71 <dhcp_coarse_tmr>
  sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
  8022cc:	83 ec 04             	sub    $0x4,%esp
  8022cf:	6a 00                	push   $0x0
  8022d1:	68 bd 22 80 00       	push   $0x8022bd
  8022d6:	68 60 ea 00 00       	push   $0xea60
  8022db:	e8 db 30 00 00       	call   8053bb <sys_timeout>
}
  8022e0:	83 c4 10             	add    $0x10,%esp
  8022e3:	c9                   	leave  
  8022e4:	c3                   	ret    

008022e5 <arp_timer>:
{
  8022e5:	f3 0f 1e fb          	endbr32 
  8022e9:	55                   	push   %ebp
  8022ea:	89 e5                	mov    %esp,%ebp
  8022ec:	83 ec 08             	sub    $0x8,%esp
  etharp_tmr();
  8022ef:	e8 a9 74 00 00       	call   80979d <etharp_tmr>
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
  8022f4:	83 ec 04             	sub    $0x4,%esp
  8022f7:	6a 00                	push   $0x0
  8022f9:	68 e5 22 80 00       	push   $0x8022e5
  8022fe:	68 88 13 00 00       	push   $0x1388
  802303:	e8 b3 30 00 00       	call   8053bb <sys_timeout>
}
  802308:	83 c4 10             	add    $0x10,%esp
  80230b:	c9                   	leave  
  80230c:	c3                   	ret    

0080230d <ip_reass_timer>:
{
  80230d:	f3 0f 1e fb          	endbr32 
  802311:	55                   	push   %ebp
  802312:	89 e5                	mov    %esp,%ebp
  802314:	83 ec 08             	sub    $0x8,%esp
  ip_reass_tmr();
  802317:	e8 59 4b 00 00       	call   806e75 <ip_reass_tmr>
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
  80231c:	83 ec 04             	sub    $0x4,%esp
  80231f:	6a 00                	push   $0x0
  802321:	68 0d 23 80 00       	push   $0x80230d
  802326:	68 e8 03 00 00       	push   $0x3e8
  80232b:	e8 8b 30 00 00       	call   8053bb <sys_timeout>
}
  802330:	83 c4 10             	add    $0x10,%esp
  802333:	c9                   	leave  
  802334:	c3                   	ret    

00802335 <pbuf_free_int>:
 *
 * @param p The pbuf (chain) to be dereferenced.
 */
static void
pbuf_free_int(void *p)
{
  802335:	f3 0f 1e fb          	endbr32 
  802339:	55                   	push   %ebp
  80233a:	89 e5                	mov    %esp,%ebp
  80233c:	83 ec 14             	sub    $0x14,%esp
  struct pbuf *q = p;
  pbuf_free(q);
  80233f:	ff 75 08             	pushl  0x8(%ebp)
  802342:	e8 da 26 00 00       	call   804a21 <pbuf_free>
}
  802347:	83 c4 10             	add    $0x10,%esp
  80234a:	c9                   	leave  
  80234b:	c3                   	ret    

0080234c <tcp_timer_needed>:
{
  80234c:	f3 0f 1e fb          	endbr32 
  if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
  802350:	83 3d e0 52 81 00 00 	cmpl   $0x0,0x8152e0
  802357:	75 38                	jne    802391 <tcp_timer_needed+0x45>
  802359:	83 3d 3c b2 b3 00 00 	cmpl   $0x0,0xb3b23c
  802360:	74 26                	je     802388 <tcp_timer_needed+0x3c>
{
  802362:	55                   	push   %ebp
  802363:	89 e5                	mov    %esp,%ebp
  802365:	83 ec 0c             	sub    $0xc,%esp
    tcpip_tcp_timer_active = 1;
  802368:	c7 05 e0 52 81 00 01 	movl   $0x1,0x8152e0
  80236f:	00 00 00 
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  802372:	6a 00                	push   $0x0
  802374:	68 06 21 80 00       	push   $0x802106
  802379:	68 fa 00 00 00       	push   $0xfa
  80237e:	e8 38 30 00 00       	call   8053bb <sys_timeout>
  802383:	83 c4 10             	add    $0x10,%esp
}
  802386:	c9                   	leave  
  802387:	c3                   	ret    
  if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
  802388:	83 3d 50 b2 b3 00 00 	cmpl   $0x0,0xb3b250
  80238f:	75 d1                	jne    802362 <tcp_timer_needed+0x16>
  802391:	c3                   	ret    

00802392 <tcpip_input>:
{
  802392:	f3 0f 1e fb          	endbr32 
  if (mbox != SYS_MBOX_NULL) {
  802396:	83 3d 00 40 81 00 ff 	cmpl   $0xffffffff,0x814000
  80239d:	74 59                	je     8023f8 <tcpip_input+0x66>
{
  80239f:	55                   	push   %ebp
  8023a0:	89 e5                	mov    %esp,%ebp
  8023a2:	53                   	push   %ebx
  8023a3:	83 ec 10             	sub    $0x10,%esp
    msg = memp_malloc(MEMP_TCPIP_MSG_INPKT);
  8023a6:	6a 09                	push   $0x9
  8023a8:	e8 97 22 00 00       	call   804644 <memp_malloc>
  8023ad:	89 c3                	mov    %eax,%ebx
    if (msg == NULL) {
  8023af:	83 c4 10             	add    $0x10,%esp
  8023b2:	85 c0                	test   %eax,%eax
  8023b4:	74 48                	je     8023fe <tcpip_input+0x6c>
    msg->type = TCPIP_MSG_INPKT;
  8023b6:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    msg->msg.inp.p = p;
  8023bc:	8b 45 08             	mov    0x8(%ebp),%eax
  8023bf:	89 43 08             	mov    %eax,0x8(%ebx)
    msg->msg.inp.netif = inp;
  8023c2:	8b 45 0c             	mov    0xc(%ebp),%eax
  8023c5:	89 43 0c             	mov    %eax,0xc(%ebx)
    if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
  8023c8:	83 ec 08             	sub    $0x8,%esp
  8023cb:	53                   	push   %ebx
  8023cc:	ff 35 00 40 81 00    	pushl  0x814000
  8023d2:	e8 24 81 00 00       	call   80a4fb <sys_mbox_trypost>
  8023d7:	83 c4 10             	add    $0x10,%esp
  8023da:	84 c0                	test   %al,%al
  8023dc:	75 05                	jne    8023e3 <tcpip_input+0x51>
}
  8023de:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8023e1:	c9                   	leave  
  8023e2:	c3                   	ret    
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
  8023e3:	83 ec 08             	sub    $0x8,%esp
  8023e6:	53                   	push   %ebx
  8023e7:	6a 09                	push   $0x9
  8023e9:	e8 b0 22 00 00       	call   80469e <memp_free>
      return ERR_MEM;
  8023ee:	83 c4 10             	add    $0x10,%esp
  8023f1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8023f6:	eb e6                	jmp    8023de <tcpip_input+0x4c>
  return ERR_VAL;
  8023f8:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  8023fd:	c3                   	ret    
      return ERR_MEM;
  8023fe:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  802403:	eb d9                	jmp    8023de <tcpip_input+0x4c>

00802405 <tcpip_callback_with_block>:
{
  802405:	f3 0f 1e fb          	endbr32 
  802409:	55                   	push   %ebp
  80240a:	89 e5                	mov    %esp,%ebp
  80240c:	56                   	push   %esi
  80240d:	53                   	push   %ebx
  80240e:	8b 75 10             	mov    0x10(%ebp),%esi
  if (mbox != SYS_MBOX_NULL) {
  802411:	83 3d 00 40 81 00 ff 	cmpl   $0xffffffff,0x814000
  802418:	74 76                	je     802490 <tcpip_callback_with_block+0x8b>
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
  80241a:	83 ec 0c             	sub    $0xc,%esp
  80241d:	6a 08                	push   $0x8
  80241f:	e8 20 22 00 00       	call   804644 <memp_malloc>
  802424:	89 c3                	mov    %eax,%ebx
    if (msg == NULL) {
  802426:	83 c4 10             	add    $0x10,%esp
  802429:	85 c0                	test   %eax,%eax
  80242b:	74 6a                	je     802497 <tcpip_callback_with_block+0x92>
    msg->type = TCPIP_MSG_CALLBACK;
  80242d:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
    msg->msg.cb.f = f;
  802433:	8b 45 08             	mov    0x8(%ebp),%eax
  802436:	89 43 08             	mov    %eax,0x8(%ebx)
    msg->msg.cb.ctx = ctx;
  802439:	8b 45 0c             	mov    0xc(%ebp),%eax
  80243c:	89 43 0c             	mov    %eax,0xc(%ebx)
    if (block) {
  80243f:	89 f0                	mov    %esi,%eax
  802441:	84 c0                	test   %al,%al
  802443:	75 1d                	jne    802462 <tcpip_callback_with_block+0x5d>
      if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
  802445:	83 ec 08             	sub    $0x8,%esp
  802448:	53                   	push   %ebx
  802449:	ff 35 00 40 81 00    	pushl  0x814000
  80244f:	e8 a7 80 00 00       	call   80a4fb <sys_mbox_trypost>
  802454:	83 c4 10             	add    $0x10,%esp
  802457:	84 c0                	test   %al,%al
  802459:	75 20                	jne    80247b <tcpip_callback_with_block+0x76>
}
  80245b:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80245e:	5b                   	pop    %ebx
  80245f:	5e                   	pop    %esi
  802460:	5d                   	pop    %ebp
  802461:	c3                   	ret    
      sys_mbox_post(mbox, msg);
  802462:	83 ec 08             	sub    $0x8,%esp
  802465:	53                   	push   %ebx
  802466:	ff 35 00 40 81 00    	pushl  0x814000
  80246c:	e8 53 81 00 00       	call   80a5c4 <sys_mbox_post>
  802471:	83 c4 10             	add    $0x10,%esp
    return ERR_OK;
  802474:	b8 00 00 00 00       	mov    $0x0,%eax
  802479:	eb e0                	jmp    80245b <tcpip_callback_with_block+0x56>
        memp_free(MEMP_TCPIP_MSG_API, msg);
  80247b:	83 ec 08             	sub    $0x8,%esp
  80247e:	53                   	push   %ebx
  80247f:	6a 08                	push   $0x8
  802481:	e8 18 22 00 00       	call   80469e <memp_free>
        return ERR_MEM;
  802486:	83 c4 10             	add    $0x10,%esp
  802489:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80248e:	eb cb                	jmp    80245b <tcpip_callback_with_block+0x56>
  return ERR_VAL;
  802490:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  802495:	eb c4                	jmp    80245b <tcpip_callback_with_block+0x56>
      return ERR_MEM;
  802497:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80249c:	eb bd                	jmp    80245b <tcpip_callback_with_block+0x56>

0080249e <tcpip_timeout>:
{
  80249e:	f3 0f 1e fb          	endbr32 
  if (mbox != SYS_MBOX_NULL) {
  8024a2:	83 3d 00 40 81 00 ff 	cmpl   $0xffffffff,0x814000
  8024a9:	74 45                	je     8024f0 <tcpip_timeout+0x52>
{
  8024ab:	55                   	push   %ebp
  8024ac:	89 e5                	mov    %esp,%ebp
  8024ae:	83 ec 14             	sub    $0x14,%esp
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
  8024b1:	6a 08                	push   $0x8
  8024b3:	e8 8c 21 00 00       	call   804644 <memp_malloc>
    if (msg == NULL) {
  8024b8:	83 c4 10             	add    $0x10,%esp
  8024bb:	85 c0                	test   %eax,%eax
  8024bd:	74 37                	je     8024f6 <tcpip_timeout+0x58>
    msg->type = TCPIP_MSG_TIMEOUT;
  8024bf:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
    msg->msg.tmo.msecs = msecs;
  8024c5:	8b 55 08             	mov    0x8(%ebp),%edx
  8024c8:	89 50 08             	mov    %edx,0x8(%eax)
    msg->msg.tmo.h = h;
  8024cb:	8b 55 0c             	mov    0xc(%ebp),%edx
  8024ce:	89 50 0c             	mov    %edx,0xc(%eax)
    msg->msg.tmo.arg = arg;
  8024d1:	8b 55 10             	mov    0x10(%ebp),%edx
  8024d4:	89 50 10             	mov    %edx,0x10(%eax)
    sys_mbox_post(mbox, msg);
  8024d7:	83 ec 08             	sub    $0x8,%esp
  8024da:	50                   	push   %eax
  8024db:	ff 35 00 40 81 00    	pushl  0x814000
  8024e1:	e8 de 80 00 00       	call   80a5c4 <sys_mbox_post>
    return ERR_OK;
  8024e6:	83 c4 10             	add    $0x10,%esp
  8024e9:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8024ee:	c9                   	leave  
  8024ef:	c3                   	ret    
  return ERR_VAL;
  8024f0:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  8024f5:	c3                   	ret    
      return ERR_MEM;
  8024f6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8024fb:	eb f1                	jmp    8024ee <tcpip_timeout+0x50>

008024fd <tcpip_apimsg>:
{
  8024fd:	f3 0f 1e fb          	endbr32 
  802501:	55                   	push   %ebp
  802502:	89 e5                	mov    %esp,%ebp
  802504:	53                   	push   %ebx
  802505:	83 ec 24             	sub    $0x24,%esp
  802508:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (mbox != SYS_MBOX_NULL) {
  80250b:	a1 00 40 81 00       	mov    0x814000,%eax
  802510:	83 f8 ff             	cmp    $0xffffffff,%eax
  802513:	74 34                	je     802549 <tcpip_apimsg+0x4c>
    msg.type = TCPIP_MSG_API;
  802515:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    msg.msg.apimsg = apimsg;
  80251c:	89 5d ec             	mov    %ebx,-0x14(%ebp)
    sys_mbox_post(mbox, &msg);
  80251f:	83 ec 08             	sub    $0x8,%esp
  802522:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  802525:	52                   	push   %edx
  802526:	50                   	push   %eax
  802527:	e8 98 80 00 00       	call   80a5c4 <sys_mbox_post>
    sys_arch_sem_wait(apimsg->msg.conn->op_completed, 0);
  80252c:	83 c4 08             	add    $0x8,%esp
  80252f:	6a 00                	push   $0x0
  802531:	8b 43 04             	mov    0x4(%ebx),%eax
  802534:	ff 70 10             	pushl  0x10(%eax)
  802537:	e8 ab 7e 00 00       	call   80a3e7 <sys_arch_sem_wait>
    return ERR_OK;
  80253c:	83 c4 10             	add    $0x10,%esp
  80253f:	b8 00 00 00 00       	mov    $0x0,%eax
}
  802544:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  802547:	c9                   	leave  
  802548:	c3                   	ret    
  return ERR_VAL;
  802549:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  80254e:	eb f4                	jmp    802544 <tcpip_apimsg+0x47>

00802550 <tcpip_init>:
{
  802550:	f3 0f 1e fb          	endbr32 
  802554:	55                   	push   %ebp
  802555:	89 e5                	mov    %esp,%ebp
  802557:	83 ec 08             	sub    $0x8,%esp
  lwip_init();
  80255a:	e8 96 03 00 00       	call   8028f5 <lwip_init>
  tcpip_init_done = initfunc;
  80255f:	8b 45 08             	mov    0x8(%ebp),%eax
  802562:	a3 e8 52 81 00       	mov    %eax,0x8152e8
  tcpip_init_done_arg = arg;
  802567:	8b 45 0c             	mov    0xc(%ebp),%eax
  80256a:	a3 e4 52 81 00       	mov    %eax,0x8152e4
  mbox = sys_mbox_new(TCPIP_MBOX_SIZE);
  80256f:	83 ec 0c             	sub    $0xc,%esp
  802572:	6a 00                	push   $0x0
  802574:	e8 e2 7c 00 00       	call   80a25b <sys_mbox_new>
  802579:	a3 00 40 81 00       	mov    %eax,0x814000
  sys_thread_new(TCPIP_THREAD_NAME, tcpip_thread, NULL, TCPIP_THREAD_STACKSIZE, TCPIP_THREAD_PRIO);
  80257e:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  802585:	6a 00                	push   $0x0
  802587:	6a 00                	push   $0x0
  802589:	68 4c 21 80 00       	push   $0x80214c
  80258e:	68 fc 16 81 00       	push   $0x8116fc
  802593:	e8 6b 81 00 00       	call   80a703 <sys_thread_new>
}
  802598:	83 c4 20             	add    $0x20,%esp
  80259b:	c9                   	leave  
  80259c:	c3                   	ret    

0080259d <pbuf_free_callback>:
 * @param p The pbuf (chain) to be dereferenced.
 * @return ERR_OK if callback could be enqueued, an err_t if not
 */
err_t
pbuf_free_callback(struct pbuf *p)
{
  80259d:	f3 0f 1e fb          	endbr32 
  8025a1:	55                   	push   %ebp
  8025a2:	89 e5                	mov    %esp,%ebp
  8025a4:	83 ec 0c             	sub    $0xc,%esp
  return tcpip_callback_with_block(pbuf_free_int, p, 0);
  8025a7:	6a 00                	push   $0x0
  8025a9:	ff 75 08             	pushl  0x8(%ebp)
  8025ac:	68 35 23 80 00       	push   $0x802335
  8025b1:	e8 4f fe ff ff       	call   802405 <tcpip_callback_with_block>
}
  8025b6:	c9                   	leave  
  8025b7:	c3                   	ret    

008025b8 <mem_free_callback>:
 * @param m the heap memory to free
 * @return ERR_OK if callback could be enqueued, an err_t if not
 */
err_t
mem_free_callback(void *m)
{
  8025b8:	f3 0f 1e fb          	endbr32 
  8025bc:	55                   	push   %ebp
  8025bd:	89 e5                	mov    %esp,%ebp
  8025bf:	83 ec 0c             	sub    $0xc,%esp
  return tcpip_callback_with_block(mem_free, m, 0);
  8025c2:	6a 00                	push   $0x0
  8025c4:	ff 75 08             	pushl  0x8(%ebp)
  8025c7:	68 ec 40 80 00       	push   $0x8040ec
  8025cc:	e8 34 fe ff ff       	call   802405 <tcpip_callback_with_block>
}
  8025d1:	c9                   	leave  
  8025d2:	c3                   	ret    

008025d3 <netbuf_new>:
 * @return a pointer to a new netbuf
 *         NULL on lack of memory
 */
struct
netbuf *netbuf_new(void)
{
  8025d3:	f3 0f 1e fb          	endbr32 
  8025d7:	55                   	push   %ebp
  8025d8:	89 e5                	mov    %esp,%ebp
  8025da:	83 ec 14             	sub    $0x14,%esp
  struct netbuf *buf;

  buf = memp_malloc(MEMP_NETBUF);
  8025dd:	6a 06                	push   $0x6
  8025df:	e8 60 20 00 00       	call   804644 <memp_malloc>
  if (buf != NULL) {
  8025e4:	83 c4 10             	add    $0x10,%esp
  8025e7:	85 c0                	test   %eax,%eax
  8025e9:	74 14                	je     8025ff <netbuf_new+0x2c>
    buf->p = NULL;
  8025eb:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    buf->ptr = NULL;
  8025f1:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    buf->addr = NULL;
  8025f8:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    return buf;
  } else {
    return NULL;
  }
}
  8025ff:	c9                   	leave  
  802600:	c3                   	ret    

00802601 <netbuf_delete>:
 *
 * @param buf pointer to a netbuf allocated by netbuf_new()
 */
void
netbuf_delete(struct netbuf *buf)
{
  802601:	f3 0f 1e fb          	endbr32 
  802605:	55                   	push   %ebp
  802606:	89 e5                	mov    %esp,%ebp
  802608:	53                   	push   %ebx
  802609:	83 ec 04             	sub    $0x4,%esp
  80260c:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (buf != NULL) {
  80260f:	85 db                	test   %ebx,%ebx
  802611:	74 2d                	je     802640 <netbuf_delete+0x3f>
    if (buf->p != NULL) {
  802613:	8b 03                	mov    (%ebx),%eax
  802615:	85 c0                	test   %eax,%eax
  802617:	74 19                	je     802632 <netbuf_delete+0x31>
      pbuf_free(buf->p);
  802619:	83 ec 0c             	sub    $0xc,%esp
  80261c:	50                   	push   %eax
  80261d:	e8 ff 23 00 00       	call   804a21 <pbuf_free>
      buf->p = buf->ptr = NULL;
  802622:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  802629:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  80262f:	83 c4 10             	add    $0x10,%esp
    }
    memp_free(MEMP_NETBUF, buf);
  802632:	83 ec 08             	sub    $0x8,%esp
  802635:	53                   	push   %ebx
  802636:	6a 06                	push   $0x6
  802638:	e8 61 20 00 00       	call   80469e <memp_free>
  80263d:	83 c4 10             	add    $0x10,%esp
  }
}
  802640:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  802643:	c9                   	leave  
  802644:	c3                   	ret    

00802645 <netbuf_alloc>:
 * @return pointer to the allocated memory
 *         NULL if no memory could be allocated
 */
void *
netbuf_alloc(struct netbuf *buf, u16_t size)
{
  802645:	f3 0f 1e fb          	endbr32 
  802649:	55                   	push   %ebp
  80264a:	89 e5                	mov    %esp,%ebp
  80264c:	56                   	push   %esi
  80264d:	53                   	push   %ebx
  80264e:	8b 5d 08             	mov    0x8(%ebp),%ebx
  802651:	8b 75 0c             	mov    0xc(%ebp),%esi
  LWIP_ERROR("netbuf_alloc: invalid buf", (buf != NULL), return NULL;);
  802654:	85 db                	test   %ebx,%ebx
  802656:	74 3e                	je     802696 <netbuf_alloc+0x51>

  /* Deallocate any previously allocated memory. */
  if (buf->p != NULL) {
  802658:	8b 03                	mov    (%ebx),%eax
  80265a:	85 c0                	test   %eax,%eax
  80265c:	74 0c                	je     80266a <netbuf_alloc+0x25>
    pbuf_free(buf->p);
  80265e:	83 ec 0c             	sub    $0xc,%esp
  802661:	50                   	push   %eax
  802662:	e8 ba 23 00 00       	call   804a21 <pbuf_free>
  802667:	83 c4 10             	add    $0x10,%esp
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, size, PBUF_RAM);
  80266a:	83 ec 04             	sub    $0x4,%esp
  80266d:	6a 00                	push   $0x0
  80266f:	0f b7 c6             	movzwl %si,%eax
  802672:	50                   	push   %eax
  802673:	6a 00                	push   $0x0
  802675:	e8 71 24 00 00       	call   804aeb <pbuf_alloc>
  80267a:	89 03                	mov    %eax,(%ebx)
  if (buf->p == NULL) {
  80267c:	83 c4 10             	add    $0x10,%esp
  80267f:	85 c0                	test   %eax,%eax
  802681:	74 0c                	je     80268f <netbuf_alloc+0x4a>
     return NULL;
  }
  LWIP_ASSERT("check that first pbuf can hold size",
  802683:	66 39 70 0a          	cmp    %si,0xa(%eax)
  802687:	72 21                	jb     8026aa <netbuf_alloc+0x65>
             (buf->p->len >= size));
  buf->ptr = buf->p;
  802689:	89 43 04             	mov    %eax,0x4(%ebx)
  return buf->p->payload;
  80268c:	8b 40 04             	mov    0x4(%eax),%eax
}
  80268f:	8d 65 f8             	lea    -0x8(%ebp),%esp
  802692:	5b                   	pop    %ebx
  802693:	5e                   	pop    %esi
  802694:	5d                   	pop    %ebp
  802695:	c3                   	ret    
  LWIP_ERROR("netbuf_alloc: invalid buf", (buf != NULL), return NULL;);
  802696:	83 ec 04             	sub    $0x4,%esp
  802699:	68 09 17 81 00       	push   $0x811709
  80269e:	6a 63                	push   $0x63
  8026a0:	68 23 17 81 00       	push   $0x811723
  8026a5:	e8 9d c2 00 00       	call   80e947 <_panic>
  LWIP_ASSERT("check that first pbuf can hold size",
  8026aa:	83 ec 04             	sub    $0x4,%esp
  8026ad:	68 f0 17 81 00       	push   $0x8117f0
  8026b2:	6a 6d                	push   $0x6d
  8026b4:	68 23 17 81 00       	push   $0x811723
  8026b9:	e8 89 c2 00 00       	call   80e947 <_panic>

008026be <netbuf_free>:
 *
 * @param buf pointer to the netbuf which contains the packet buffer to free
 */
void
netbuf_free(struct netbuf *buf)
{
  8026be:	f3 0f 1e fb          	endbr32 
  8026c2:	55                   	push   %ebp
  8026c3:	89 e5                	mov    %esp,%ebp
  8026c5:	53                   	push   %ebx
  8026c6:	83 ec 04             	sub    $0x4,%esp
  8026c9:	8b 5d 08             	mov    0x8(%ebp),%ebx
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  8026cc:	85 db                	test   %ebx,%ebx
  8026ce:	74 24                	je     8026f4 <netbuf_free+0x36>
  if (buf->p != NULL) {
  8026d0:	8b 03                	mov    (%ebx),%eax
  8026d2:	85 c0                	test   %eax,%eax
  8026d4:	74 0c                	je     8026e2 <netbuf_free+0x24>
    pbuf_free(buf->p);
  8026d6:	83 ec 0c             	sub    $0xc,%esp
  8026d9:	50                   	push   %eax
  8026da:	e8 42 23 00 00       	call   804a21 <pbuf_free>
  8026df:	83 c4 10             	add    $0x10,%esp
  }
  buf->p = buf->ptr = NULL;
  8026e2:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  8026e9:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
}
  8026ef:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8026f2:	c9                   	leave  
  8026f3:	c3                   	ret    
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  8026f4:	83 ec 04             	sub    $0x4,%esp
  8026f7:	68 39 17 81 00       	push   $0x811739
  8026fc:	6a 7b                	push   $0x7b
  8026fe:	68 23 17 81 00       	push   $0x811723
  802703:	e8 3f c2 00 00       	call   80e947 <_panic>

00802708 <netbuf_ref>:
 * @return ERR_OK if data is referenced
 *         ERR_MEM if data couldn't be referenced due to lack of memory
 */
err_t
netbuf_ref(struct netbuf *buf, const void *dataptr, u16_t size)
{
  802708:	f3 0f 1e fb          	endbr32 
  80270c:	55                   	push   %ebp
  80270d:	89 e5                	mov    %esp,%ebp
  80270f:	56                   	push   %esi
  802710:	53                   	push   %ebx
  802711:	8b 5d 08             	mov    0x8(%ebp),%ebx
  802714:	8b 75 10             	mov    0x10(%ebp),%esi
  LWIP_ERROR("netbuf_ref: invalid buf", (buf != NULL), return ERR_ARG;);
  802717:	85 db                	test   %ebx,%ebx
  802719:	74 4c                	je     802767 <netbuf_ref+0x5f>
  if (buf->p != NULL) {
  80271b:	8b 03                	mov    (%ebx),%eax
  80271d:	85 c0                	test   %eax,%eax
  80271f:	74 0c                	je     80272d <netbuf_ref+0x25>
    pbuf_free(buf->p);
  802721:	83 ec 0c             	sub    $0xc,%esp
  802724:	50                   	push   %eax
  802725:	e8 f7 22 00 00       	call   804a21 <pbuf_free>
  80272a:	83 c4 10             	add    $0x10,%esp
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_REF);
  80272d:	83 ec 04             	sub    $0x4,%esp
  802730:	6a 02                	push   $0x2
  802732:	6a 00                	push   $0x0
  802734:	6a 00                	push   $0x0
  802736:	e8 b0 23 00 00       	call   804aeb <pbuf_alloc>
  80273b:	89 03                	mov    %eax,(%ebx)
  if (buf->p == NULL) {
  80273d:	83 c4 10             	add    $0x10,%esp
  802740:	85 c0                	test   %eax,%eax
  802742:	74 3a                	je     80277e <netbuf_ref+0x76>
    buf->ptr = NULL;
    return ERR_MEM;
  }
  buf->p->payload = (void*)dataptr;
  802744:	8b 55 0c             	mov    0xc(%ebp),%edx
  802747:	89 50 04             	mov    %edx,0x4(%eax)
  buf->p->len = buf->p->tot_len = size;
  80274a:	8b 03                	mov    (%ebx),%eax
  80274c:	66 89 70 08          	mov    %si,0x8(%eax)
  802750:	8b 03                	mov    (%ebx),%eax
  802752:	66 89 70 0a          	mov    %si,0xa(%eax)
  buf->ptr = buf->p;
  802756:	8b 03                	mov    (%ebx),%eax
  802758:	89 43 04             	mov    %eax,0x4(%ebx)
  return ERR_OK;
  80275b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  802760:	8d 65 f8             	lea    -0x8(%ebp),%esp
  802763:	5b                   	pop    %ebx
  802764:	5e                   	pop    %esi
  802765:	5d                   	pop    %ebp
  802766:	c3                   	ret    
  LWIP_ERROR("netbuf_ref: invalid buf", (buf != NULL), return ERR_ARG;);
  802767:	83 ec 04             	sub    $0x4,%esp
  80276a:	68 52 17 81 00       	push   $0x811752
  80276f:	68 8e 00 00 00       	push   $0x8e
  802774:	68 23 17 81 00       	push   $0x811723
  802779:	e8 c9 c1 00 00       	call   80e947 <_panic>
    buf->ptr = NULL;
  80277e:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    return ERR_MEM;
  802785:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80278a:	eb d4                	jmp    802760 <netbuf_ref+0x58>

0080278c <netbuf_chain>:
 * @param head the first netbuf
 * @param tail netbuf to chain after head
 */
void
netbuf_chain(struct netbuf *head, struct netbuf *tail)
{
  80278c:	f3 0f 1e fb          	endbr32 
  802790:	55                   	push   %ebp
  802791:	89 e5                	mov    %esp,%ebp
  802793:	56                   	push   %esi
  802794:	53                   	push   %ebx
  802795:	8b 5d 08             	mov    0x8(%ebp),%ebx
  802798:	8b 75 0c             	mov    0xc(%ebp),%esi
  LWIP_ERROR("netbuf_ref: invalid head", (head != NULL), return;);
  80279b:	85 db                	test   %ebx,%ebx
  80279d:	74 2a                	je     8027c9 <netbuf_chain+0x3d>
  LWIP_ERROR("netbuf_chain: invalid tail", (tail != NULL), return;);
  80279f:	85 f6                	test   %esi,%esi
  8027a1:	74 3d                	je     8027e0 <netbuf_chain+0x54>
  pbuf_chain(head->p, tail->p);
  8027a3:	83 ec 08             	sub    $0x8,%esp
  8027a6:	ff 36                	pushl  (%esi)
  8027a8:	ff 33                	pushl  (%ebx)
  8027aa:	e8 54 27 00 00       	call   804f03 <pbuf_chain>
  head->ptr = head->p;
  8027af:	8b 03                	mov    (%ebx),%eax
  8027b1:	89 43 04             	mov    %eax,0x4(%ebx)
  memp_free(MEMP_NETBUF, tail);
  8027b4:	83 c4 08             	add    $0x8,%esp
  8027b7:	56                   	push   %esi
  8027b8:	6a 06                	push   $0x6
  8027ba:	e8 df 1e 00 00       	call   80469e <memp_free>
  8027bf:	83 c4 10             	add    $0x10,%esp
}
  8027c2:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8027c5:	5b                   	pop    %ebx
  8027c6:	5e                   	pop    %esi
  8027c7:	5d                   	pop    %ebp
  8027c8:	c3                   	ret    
  LWIP_ERROR("netbuf_ref: invalid head", (head != NULL), return;);
  8027c9:	83 ec 04             	sub    $0x4,%esp
  8027cc:	68 6a 17 81 00       	push   $0x81176a
  8027d1:	68 a6 00 00 00       	push   $0xa6
  8027d6:	68 23 17 81 00       	push   $0x811723
  8027db:	e8 67 c1 00 00       	call   80e947 <_panic>
  LWIP_ERROR("netbuf_chain: invalid tail", (tail != NULL), return;);
  8027e0:	83 ec 04             	sub    $0x4,%esp
  8027e3:	68 83 17 81 00       	push   $0x811783
  8027e8:	68 a7 00 00 00       	push   $0xa7
  8027ed:	68 23 17 81 00       	push   $0x811723
  8027f2:	e8 50 c1 00 00       	call   80e947 <_panic>

008027f7 <netbuf_data>:
 * @return ERR_OK if the information was retreived,
 *         ERR_BUF on error.
 */
err_t
netbuf_data(struct netbuf *buf, void **dataptr, u16_t *len)
{
  8027f7:	f3 0f 1e fb          	endbr32 
  8027fb:	55                   	push   %ebp
  8027fc:	89 e5                	mov    %esp,%ebp
  8027fe:	53                   	push   %ebx
  8027ff:	83 ec 04             	sub    $0x4,%esp
  802802:	8b 45 08             	mov    0x8(%ebp),%eax
  802805:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  802808:	8b 55 10             	mov    0x10(%ebp),%edx
  LWIP_ERROR("netbuf_data: invalid buf", (buf != NULL), return ERR_ARG;);
  80280b:	85 c0                	test   %eax,%eax
  80280d:	74 28                	je     802837 <netbuf_data+0x40>
  LWIP_ERROR("netbuf_data: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
  80280f:	85 c9                	test   %ecx,%ecx
  802811:	74 3b                	je     80284e <netbuf_data+0x57>
  LWIP_ERROR("netbuf_data: invalid len", (len != NULL), return ERR_ARG;);
  802813:	85 d2                	test   %edx,%edx
  802815:	74 4e                	je     802865 <netbuf_data+0x6e>

  if (buf->ptr == NULL) {
  802817:	8b 58 04             	mov    0x4(%eax),%ebx
  80281a:	85 db                	test   %ebx,%ebx
  80281c:	74 5e                	je     80287c <netbuf_data+0x85>
    return ERR_BUF;
  }
  *dataptr = buf->ptr->payload;
  80281e:	8b 5b 04             	mov    0x4(%ebx),%ebx
  802821:	89 19                	mov    %ebx,(%ecx)
  *len = buf->ptr->len;
  802823:	8b 40 04             	mov    0x4(%eax),%eax
  802826:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  80282a:	66 89 02             	mov    %ax,(%edx)
  return ERR_OK;
  80282d:	b8 00 00 00 00       	mov    $0x0,%eax
}
  802832:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  802835:	c9                   	leave  
  802836:	c3                   	ret    
  LWIP_ERROR("netbuf_data: invalid buf", (buf != NULL), return ERR_ARG;);
  802837:	83 ec 04             	sub    $0x4,%esp
  80283a:	68 9e 17 81 00       	push   $0x81179e
  80283f:	68 b9 00 00 00       	push   $0xb9
  802844:	68 23 17 81 00       	push   $0x811723
  802849:	e8 f9 c0 00 00       	call   80e947 <_panic>
  LWIP_ERROR("netbuf_data: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
  80284e:	83 ec 04             	sub    $0x4,%esp
  802851:	68 b7 17 81 00       	push   $0x8117b7
  802856:	68 ba 00 00 00       	push   $0xba
  80285b:	68 23 17 81 00       	push   $0x811723
  802860:	e8 e2 c0 00 00       	call   80e947 <_panic>
  LWIP_ERROR("netbuf_data: invalid len", (len != NULL), return ERR_ARG;);
  802865:	83 ec 04             	sub    $0x4,%esp
  802868:	68 d4 17 81 00       	push   $0x8117d4
  80286d:	68 bb 00 00 00       	push   $0xbb
  802872:	68 23 17 81 00       	push   $0x811723
  802877:	e8 cb c0 00 00       	call   80e947 <_panic>
    return ERR_BUF;
  80287c:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  802881:	eb af                	jmp    802832 <netbuf_data+0x3b>

00802883 <netbuf_next>:
 *         1  if moved to the next part but now there is no next part
 *         0  if moved to the next part and there are still more parts
 */
s8_t
netbuf_next(struct netbuf *buf)
{
  802883:	f3 0f 1e fb          	endbr32 
  802887:	55                   	push   %ebp
  802888:	89 e5                	mov    %esp,%ebp
  80288a:	83 ec 08             	sub    $0x8,%esp
  80288d:	8b 45 08             	mov    0x8(%ebp),%eax
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return -1;);
  802890:	85 c0                	test   %eax,%eax
  802892:	74 14                	je     8028a8 <netbuf_next+0x25>
  if (buf->ptr->next == NULL) {
  802894:	8b 50 04             	mov    0x4(%eax),%edx
  802897:	8b 12                	mov    (%edx),%edx
  802899:	85 d2                	test   %edx,%edx
  80289b:	74 22                	je     8028bf <netbuf_next+0x3c>
    return -1;
  }
  buf->ptr = buf->ptr->next;
  80289d:	89 50 04             	mov    %edx,0x4(%eax)
  if (buf->ptr->next == NULL) {
  8028a0:	83 3a 00             	cmpl   $0x0,(%edx)
  8028a3:	0f 94 c0             	sete   %al
    return 1;
  }
  return 0;
}
  8028a6:	c9                   	leave  
  8028a7:	c3                   	ret    
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return -1;);
  8028a8:	83 ec 04             	sub    $0x4,%esp
  8028ab:	68 39 17 81 00       	push   $0x811739
  8028b0:	68 d2 00 00 00       	push   $0xd2
  8028b5:	68 23 17 81 00       	push   $0x811723
  8028ba:	e8 88 c0 00 00       	call   80e947 <_panic>
    return -1;
  8028bf:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8028c4:	eb e0                	jmp    8028a6 <netbuf_next+0x23>

008028c6 <netbuf_first>:
 *
 * @param buf the netbuf to modify
 */
void
netbuf_first(struct netbuf *buf)
{
  8028c6:	f3 0f 1e fb          	endbr32 
  8028ca:	55                   	push   %ebp
  8028cb:	89 e5                	mov    %esp,%ebp
  8028cd:	83 ec 08             	sub    $0x8,%esp
  8028d0:	8b 45 08             	mov    0x8(%ebp),%eax
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  8028d3:	85 c0                	test   %eax,%eax
  8028d5:	74 07                	je     8028de <netbuf_first+0x18>
  buf->ptr = buf->p;
  8028d7:	8b 10                	mov    (%eax),%edx
  8028d9:	89 50 04             	mov    %edx,0x4(%eax)
}
  8028dc:	c9                   	leave  
  8028dd:	c3                   	ret    
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  8028de:	83 ec 04             	sub    $0x4,%esp
  8028e1:	68 39 17 81 00       	push   $0x811739
  8028e6:	68 e7 00 00 00       	push   $0xe7
  8028eb:	68 23 17 81 00       	push   $0x811723
  8028f0:	e8 52 c0 00 00       	call   80e947 <_panic>

008028f5 <lwip_init>:
/**
 * Perform Sanity check of user-configurable values, and initialize all modules.
 */
void
lwip_init(void)
{
  8028f5:	f3 0f 1e fb          	endbr32 
  8028f9:	55                   	push   %ebp
  8028fa:	89 e5                	mov    %esp,%ebp
  8028fc:	83 ec 08             	sub    $0x8,%esp
  /* Sanity check user-configurable values */
  lwip_sanity_check();

  /* Modules initialization */
  stats_init();
  sys_init();
  8028ff:	e8 01 77 00 00       	call   80a005 <sys_init>
  mem_init();
  802904:	e8 79 17 00 00       	call   804082 <mem_init>
  memp_init();
  802909:	e8 d6 1c 00 00       	call   8045e4 <memp_init>
  pbuf_init();
  netif_init();
#if LWIP_SOCKET
  lwip_socket_init();
  80290e:	e8 f3 e5 ff ff       	call   800f06 <lwip_socket_init>
  igmp_init();
#endif /* LWIP_IGMP */
#if LWIP_DNS
  dns_init();
#endif /* LWIP_DNS */
}
  802913:	c9                   	leave  
  802914:	c3                   	ret    

00802915 <dhcp_set_state>:
 * TODO: we might also want to reset the timeout here?
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  if (new_state != dhcp->state) {
  802915:	38 10                	cmp    %dl,(%eax)
  802917:	74 06                	je     80291f <dhcp_set_state+0xa>
    dhcp->state = new_state;
  802919:	88 10                	mov    %dl,(%eax)
    dhcp->tries = 0;
  80291b:	c6 40 01 00          	movb   $0x0,0x1(%eax)
  }
}
  80291f:	c3                   	ret    

00802920 <dhcp_get_option_ptr>:
 *
 * @return a byte offset into the UDP message where the option was found, or
 * zero if the given option was not found.
 */
static u8_t *dhcp_get_option_ptr(struct dhcp *dhcp, u8_t option_type)
{
  802920:	55                   	push   %ebp
  802921:	89 e5                	mov    %esp,%ebp
  802923:	57                   	push   %edi
  802924:	56                   	push   %esi
  802925:	53                   	push   %ebx
  802926:	83 ec 0c             	sub    $0xc,%esp
  802929:	89 45 e8             	mov    %eax,-0x18(%ebp)
  u8_t overload = DHCP_OVERLOAD_NONE;

  /* options available? */
  if ((dhcp->options_in != NULL) && (dhcp->options_in_len > 0)) {
  80292c:	8b 48 14             	mov    0x14(%eax),%ecx
  80292f:	85 c9                	test   %ecx,%ecx
  802931:	74 19                	je     80294c <dhcp_get_option_ptr+0x2c>
  802933:	89 d6                	mov    %edx,%esi
  802935:	0f b7 78 18          	movzwl 0x18(%eax),%edi
    /* start with options field */
    u8_t *options = (u8_t *)dhcp->options_in;
    u16_t offset = 0;
  802939:	b8 00 00 00 00       	mov    $0x0,%eax
  u8_t overload = DHCP_OVERLOAD_NONE;
  80293e:	c6 45 ef 00          	movb   $0x0,-0x11(%ebp)
  if ((dhcp->options_in != NULL) && (dhcp->options_in_len > 0)) {
  802942:	66 85 ff             	test   %di,%di
  802945:	75 2f                	jne    802976 <dhcp_get_option_ptr+0x56>
          offset += 1 + options[offset];
        }
      }
    }
  }
  return NULL;
  802947:	b9 00 00 00 00       	mov    $0x0,%ecx
}
  80294c:	89 c8                	mov    %ecx,%eax
  80294e:	83 c4 0c             	add    $0xc,%esp
  802951:	5b                   	pop    %ebx
  802952:	5e                   	pop    %esi
  802953:	5f                   	pop    %edi
  802954:	5d                   	pop    %ebp
  802955:	c3                   	ret    
        offset += 2;
  802956:	8d 50 02             	lea    0x2(%eax),%edx
        overload = options[offset++];
  802959:	83 c0 03             	add    $0x3,%eax
  80295c:	0f b7 d2             	movzwl %dx,%edx
  80295f:	0f b6 1c 11          	movzbl (%ecx,%edx,1),%ebx
  802963:	88 5d ef             	mov    %bl,-0x11(%ebp)
  802966:	eb 0e                	jmp    802976 <dhcp_get_option_ptr+0x56>
        offset++;
  802968:	8d 50 01             	lea    0x1(%eax),%edx
        offset += 1 + options[offset];
  80296b:	0f b7 d2             	movzwl %dx,%edx
  80296e:	0f b6 14 11          	movzbl (%ecx,%edx,1),%edx
  802972:	8d 44 02 02          	lea    0x2(%edx,%eax,1),%eax
    while ((offset < dhcp->options_in_len) && (options[offset] != DHCP_OPTION_END)) {
  802976:	66 39 c7             	cmp    %ax,%di
  802979:	76 22                	jbe    80299d <dhcp_get_option_ptr+0x7d>
  80297b:	0f b7 d8             	movzwl %ax,%ebx
  80297e:	01 cb                	add    %ecx,%ebx
  802980:	89 5d f0             	mov    %ebx,-0x10(%ebp)
  802983:	0f b6 13             	movzbl (%ebx),%edx
  802986:	80 fa ff             	cmp    $0xff,%dl
  802989:	74 12                	je     80299d <dhcp_get_option_ptr+0x7d>
      if (options[offset] == DHCP_OPTION_OVERLOAD) {
  80298b:	80 fa 34             	cmp    $0x34,%dl
  80298e:	74 c6                	je     802956 <dhcp_get_option_ptr+0x36>
      else if (options[offset] == option_type) {
  802990:	89 f3                	mov    %esi,%ebx
  802992:	38 da                	cmp    %bl,%dl
  802994:	75 d2                	jne    802968 <dhcp_get_option_ptr+0x48>
  802996:	8b 5d f0             	mov    -0x10(%ebp),%ebx
    while ((offset < dhcp->options_in_len) && (options[offset] != DHCP_OPTION_END)) {
  802999:	89 d9                	mov    %ebx,%ecx
  80299b:	eb af                	jmp    80294c <dhcp_get_option_ptr+0x2c>
  return NULL;
  80299d:	b9 00 00 00 00       	mov    $0x0,%ecx
    if (overload != DHCP_OVERLOAD_NONE) {
  8029a2:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
  8029a6:	84 c0                	test   %al,%al
  8029a8:	74 a2                	je     80294c <dhcp_get_option_ptr+0x2c>
      if (overload == DHCP_OVERLOAD_FILE) {
  8029aa:	3c 01                	cmp    $0x1,%al
  8029ac:	74 54                	je     802a02 <dhcp_get_option_ptr+0xe2>
      } else if (overload == DHCP_OVERLOAD_SNAME) {
  8029ae:	80 7d ef 02          	cmpb   $0x2,-0x11(%ebp)
  8029b2:	74 5e                	je     802a12 <dhcp_get_option_ptr+0xf2>
        options = (u8_t *)&dhcp->msg_in->sname;
  8029b4:	8b 45 e8             	mov    -0x18(%ebp),%eax
  8029b7:	8b 58 10             	mov    0x10(%eax),%ebx
  8029ba:	83 c3 2c             	add    $0x2c,%ebx
        field_len = DHCP_FILE_LEN + DHCP_SNAME_LEN;
  8029bd:	bf c0 00 00 00       	mov    $0xc0,%edi
      offset = 0;
  8029c2:	ba 00 00 00 00       	mov    $0x0,%edx
  8029c7:	89 f0                	mov    %esi,%eax
  8029c9:	88 45 f0             	mov    %al,-0x10(%ebp)
      while ((offset < field_len) && (options[offset] != DHCP_OPTION_END)) {
  8029cc:	0f b7 ca             	movzwl %dx,%ecx
  8029cf:	01 d9                	add    %ebx,%ecx
  8029d1:	0f b6 31             	movzbl (%ecx),%esi
  8029d4:	89 f0                	mov    %esi,%eax
  8029d6:	3c ff                	cmp    $0xff,%al
  8029d8:	74 48                	je     802a22 <dhcp_get_option_ptr+0x102>
        if (options[offset] == option_type) {
  8029da:	89 f0                	mov    %esi,%eax
  8029dc:	3a 45 f0             	cmp    -0x10(%ebp),%al
  8029df:	0f 84 67 ff ff ff    	je     80294c <dhcp_get_option_ptr+0x2c>
          offset++;
  8029e5:	8d 4a 01             	lea    0x1(%edx),%ecx
          offset += 1 + options[offset];
  8029e8:	0f b7 c9             	movzwl %cx,%ecx
  8029eb:	0f b6 0c 0b          	movzbl (%ebx,%ecx,1),%ecx
  8029ef:	8d 54 0a 02          	lea    0x2(%edx,%ecx,1),%edx
      while ((offset < field_len) && (options[offset] != DHCP_OPTION_END)) {
  8029f3:	66 39 d7             	cmp    %dx,%di
  8029f6:	77 d4                	ja     8029cc <dhcp_get_option_ptr+0xac>
  return NULL;
  8029f8:	b9 00 00 00 00       	mov    $0x0,%ecx
  8029fd:	e9 4a ff ff ff       	jmp    80294c <dhcp_get_option_ptr+0x2c>
        options = (u8_t *)&dhcp->msg_in->file;
  802a02:	8b 45 e8             	mov    -0x18(%ebp),%eax
  802a05:	8b 58 10             	mov    0x10(%eax),%ebx
  802a08:	83 c3 6c             	add    $0x6c,%ebx
        field_len = DHCP_FILE_LEN;
  802a0b:	bf 80 00 00 00       	mov    $0x80,%edi
  802a10:	eb b0                	jmp    8029c2 <dhcp_get_option_ptr+0xa2>
        options = (u8_t *)&dhcp->msg_in->sname;
  802a12:	8b 45 e8             	mov    -0x18(%ebp),%eax
  802a15:	8b 58 10             	mov    0x10(%eax),%ebx
  802a18:	83 c3 2c             	add    $0x2c,%ebx
        field_len = DHCP_SNAME_LEN;
  802a1b:	bf 40 00 00 00       	mov    $0x40,%edi
  802a20:	eb a0                	jmp    8029c2 <dhcp_get_option_ptr+0xa2>
  return NULL;
  802a22:	b9 00 00 00 00       	mov    $0x0,%ecx
  802a27:	e9 20 ff ff ff       	jmp    80294c <dhcp_get_option_ptr+0x2c>

00802a2c <dhcp_get_option_long>:
 * @param ptr pointer obtained by dhcp_get_option_ptr().
 *
 * @return byte value at the given address.
 */
static u32_t dhcp_get_option_long(u8_t *ptr)
{
  802a2c:	89 c2                	mov    %eax,%edx
  u32_t value;
  value = (u32_t)(*ptr++) << 24;
  802a2e:	0f b6 00             	movzbl (%eax),%eax
  802a31:	c1 e0 18             	shl    $0x18,%eax
  802a34:	89 c1                	mov    %eax,%ecx
  value |= (u32_t)(*ptr++) << 16;
  802a36:	0f b6 42 01          	movzbl 0x1(%edx),%eax
  802a3a:	c1 e0 10             	shl    $0x10,%eax
  802a3d:	09 c8                	or     %ecx,%eax
  value |= (u32_t)(*ptr++) << 8;
  value |= (u32_t)(*ptr++);
  802a3f:	0f b6 4a 03          	movzbl 0x3(%edx),%ecx
  802a43:	09 c8                	or     %ecx,%eax
  value |= (u32_t)(*ptr++) << 8;
  802a45:	0f b6 52 02          	movzbl 0x2(%edx),%edx
  802a49:	c1 e2 08             	shl    $0x8,%edx
  value |= (u32_t)(*ptr++);
  802a4c:	09 d0                	or     %edx,%eax
  LWIP_DEBUGF(DHCP_DEBUG, ("option long value=%"U32_F"\n", value));
  return value;
}
  802a4e:	c3                   	ret    

00802a4f <dhcp_option_byte>:
{
  802a4f:	55                   	push   %ebp
  802a50:	89 e5                	mov    %esp,%ebp
  802a52:	56                   	push   %esi
  802a53:	53                   	push   %ebx
  LWIP_ASSERT("dhcp_option_byte: dhcp->options_out_len < DHCP_OPTIONS_LEN", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  802a54:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802a58:	66 83 f9 43          	cmp    $0x43,%cx
  802a5c:	77 1b                	ja     802a79 <dhcp_option_byte+0x2a>
  dhcp->msg_out->options[dhcp->options_out_len++] = value;
  802a5e:	8b 58 20             	mov    0x20(%eax),%ebx
  802a61:	8d 71 01             	lea    0x1(%ecx),%esi
  802a64:	66 89 70 24          	mov    %si,0x24(%eax)
  802a68:	0f b7 c9             	movzwl %cx,%ecx
  802a6b:	88 94 0b f0 00 00 00 	mov    %dl,0xf0(%ebx,%ecx,1)
}
  802a72:	8d 65 f8             	lea    -0x8(%ebp),%esp
  802a75:	5b                   	pop    %ebx
  802a76:	5e                   	pop    %esi
  802a77:	5d                   	pop    %ebp
  802a78:	c3                   	ret    
  LWIP_ASSERT("dhcp_option_byte: dhcp->options_out_len < DHCP_OPTIONS_LEN", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  802a79:	83 ec 04             	sub    $0x4,%esp
  802a7c:	68 14 18 81 00       	push   $0x811814
  802a81:	68 65 04 00 00       	push   $0x465
  802a86:	68 62 1b 81 00       	push   $0x811b62
  802a8b:	e8 b7 be 00 00       	call   80e947 <_panic>

00802a90 <dhcp_option>:
{
  802a90:	55                   	push   %ebp
  802a91:	89 e5                	mov    %esp,%ebp
  802a93:	57                   	push   %edi
  802a94:	56                   	push   %esi
  802a95:	53                   	push   %ebx
  802a96:	83 ec 0c             	sub    $0xc,%esp
  LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
  802a99:	0f b7 58 24          	movzwl 0x24(%eax),%ebx
  802a9d:	0f b6 f9             	movzbl %cl,%edi
  802aa0:	0f b7 f3             	movzwl %bx,%esi
  802aa3:	8d 74 37 02          	lea    0x2(%edi,%esi,1),%esi
  802aa7:	83 fe 44             	cmp    $0x44,%esi
  802aaa:	77 34                	ja     802ae0 <dhcp_option+0x50>
  dhcp->msg_out->options[dhcp->options_out_len++] = option_type;
  802aac:	8b 70 20             	mov    0x20(%eax),%esi
  802aaf:	8d 7b 01             	lea    0x1(%ebx),%edi
  802ab2:	66 89 78 24          	mov    %di,0x24(%eax)
  802ab6:	0f b7 db             	movzwl %bx,%ebx
  802ab9:	88 94 1e f0 00 00 00 	mov    %dl,0xf0(%esi,%ebx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = option_len;
  802ac0:	8b 58 20             	mov    0x20(%eax),%ebx
  802ac3:	0f b7 50 24          	movzwl 0x24(%eax),%edx
  802ac7:	8d 72 01             	lea    0x1(%edx),%esi
  802aca:	66 89 70 24          	mov    %si,0x24(%eax)
  802ace:	0f b7 d2             	movzwl %dx,%edx
  802ad1:	88 8c 13 f0 00 00 00 	mov    %cl,0xf0(%ebx,%edx,1)
}
  802ad8:	8d 65 f4             	lea    -0xc(%ebp),%esp
  802adb:	5b                   	pop    %ebx
  802adc:	5e                   	pop    %esi
  802add:	5f                   	pop    %edi
  802ade:	5d                   	pop    %ebp
  802adf:	c3                   	ret    
  LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
  802ae0:	83 ec 04             	sub    $0x4,%esp
  802ae3:	68 50 18 81 00       	push   $0x811850
  802ae8:	68 5a 04 00 00       	push   $0x45a
  802aed:	68 62 1b 81 00       	push   $0x811b62
  802af2:	e8 50 be 00 00       	call   80e947 <_panic>

00802af7 <dhcp_option_short>:
{
  802af7:	55                   	push   %ebp
  802af8:	89 e5                	mov    %esp,%ebp
  802afa:	56                   	push   %esi
  802afb:	53                   	push   %ebx
  LWIP_ASSERT("dhcp_option_short: dhcp->options_out_len + 2 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U <= DHCP_OPTIONS_LEN);
  802afc:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802b00:	0f b7 d9             	movzwl %cx,%ebx
  802b03:	83 c3 02             	add    $0x2,%ebx
  802b06:	83 fb 44             	cmp    $0x44,%ebx
  802b09:	77 33                	ja     802b3e <dhcp_option_short+0x47>
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff00U) >> 8);
  802b0b:	8b 58 20             	mov    0x20(%eax),%ebx
  802b0e:	8d 71 01             	lea    0x1(%ecx),%esi
  802b11:	66 89 70 24          	mov    %si,0x24(%eax)
  802b15:	0f b7 c9             	movzwl %cx,%ecx
  802b18:	88 b4 0b f0 00 00 00 	mov    %dh,0xf0(%ebx,%ecx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t) (value & 0x00ffU);
  802b1f:	8b 58 20             	mov    0x20(%eax),%ebx
  802b22:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802b26:	8d 71 01             	lea    0x1(%ecx),%esi
  802b29:	66 89 70 24          	mov    %si,0x24(%eax)
  802b2d:	0f b7 c9             	movzwl %cx,%ecx
  802b30:	88 94 0b f0 00 00 00 	mov    %dl,0xf0(%ebx,%ecx,1)
}
  802b37:	8d 65 f8             	lea    -0x8(%ebp),%esp
  802b3a:	5b                   	pop    %ebx
  802b3b:	5e                   	pop    %esi
  802b3c:	5d                   	pop    %ebp
  802b3d:	c3                   	ret    
  LWIP_ASSERT("dhcp_option_short: dhcp->options_out_len + 2 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U <= DHCP_OPTIONS_LEN);
  802b3e:	83 ec 04             	sub    $0x4,%esp
  802b41:	68 98 18 81 00       	push   $0x811898
  802b46:	68 6c 04 00 00       	push   $0x46c
  802b4b:	68 62 1b 81 00       	push   $0x811b62
  802b50:	e8 f2 bd 00 00       	call   80e947 <_panic>

00802b55 <dhcp_option_trailer>:
{
  802b55:	55                   	push   %ebp
  802b56:	89 e5                	mov    %esp,%ebp
  802b58:	53                   	push   %ebx
  802b59:	83 ec 04             	sub    $0x4,%esp
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  802b5c:	85 c0                	test   %eax,%eax
  802b5e:	74 25                	je     802b85 <dhcp_option_trailer+0x30>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  802b60:	8b 48 20             	mov    0x20(%eax),%ecx
  802b63:	85 c9                	test   %ecx,%ecx
  802b65:	74 35                	je     802b9c <dhcp_option_trailer+0x47>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  802b67:	0f b7 50 24          	movzwl 0x24(%eax),%edx
  802b6b:	66 83 fa 43          	cmp    $0x43,%dx
  802b6f:	77 42                	ja     802bb3 <dhcp_option_trailer+0x5e>
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
  802b71:	8d 5a 01             	lea    0x1(%edx),%ebx
  802b74:	66 89 58 24          	mov    %bx,0x24(%eax)
  802b78:	0f b7 d2             	movzwl %dx,%edx
  802b7b:	c6 84 11 f0 00 00 00 	movb   $0xff,0xf0(%ecx,%edx,1)
  802b82:	ff 
  while ((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) {
  802b83:	eb 5a                	jmp    802bdf <dhcp_option_trailer+0x8a>
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  802b85:	83 ec 04             	sub    $0x4,%esp
  802b88:	68 dc 18 81 00       	push   $0x8118dc
  802b8d:	68 80 05 00 00       	push   $0x580
  802b92:	68 62 1b 81 00       	push   $0x811b62
  802b97:	e8 ab bd 00 00       	call   80e947 <_panic>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  802b9c:	83 ec 04             	sub    $0x4,%esp
  802b9f:	68 00 19 81 00       	push   $0x811900
  802ba4:	68 81 05 00 00       	push   $0x581
  802ba9:	68 62 1b 81 00       	push   $0x811b62
  802bae:	e8 94 bd 00 00       	call   80e947 <_panic>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  802bb3:	83 ec 04             	sub    $0x4,%esp
  802bb6:	68 2c 19 81 00       	push   $0x81192c
  802bbb:	68 82 05 00 00       	push   $0x582
  802bc0:	68 62 1b 81 00       	push   $0x811b62
  802bc5:	e8 7d bd 00 00       	call   80e947 <_panic>
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
  802bca:	8b 48 20             	mov    0x20(%eax),%ecx
  802bcd:	8d 5a 01             	lea    0x1(%edx),%ebx
  802bd0:	66 89 58 24          	mov    %bx,0x24(%eax)
  802bd4:	0f b7 d2             	movzwl %dx,%edx
  802bd7:	c6 84 11 f0 00 00 00 	movb   $0x0,0xf0(%ecx,%edx,1)
  802bde:	00 
  while ((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) {
  802bdf:	0f b7 50 24          	movzwl 0x24(%eax),%edx
  802be3:	66 83 fa 43          	cmp    $0x43,%dx
  802be7:	76 e1                	jbe    802bca <dhcp_option_trailer+0x75>
  802be9:	f6 c2 03             	test   $0x3,%dl
  802bec:	74 17                	je     802c05 <dhcp_option_trailer+0xb0>
    LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  802bee:	83 ec 04             	sub    $0x4,%esp
  802bf1:	68 2c 19 81 00       	push   $0x81192c
  802bf6:	68 87 05 00 00       	push   $0x587
  802bfb:	68 62 1b 81 00       	push   $0x811b62
  802c00:	e8 42 bd 00 00       	call   80e947 <_panic>
}
  802c05:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  802c08:	c9                   	leave  
  802c09:	c3                   	ret    

00802c0a <dhcp_option_long>:
{
  802c0a:	55                   	push   %ebp
  802c0b:	89 e5                	mov    %esp,%ebp
  802c0d:	56                   	push   %esi
  802c0e:	53                   	push   %ebx
  LWIP_ASSERT("dhcp_option_long: dhcp->options_out_len + 4 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 4U <= DHCP_OPTIONS_LEN);
  802c0f:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802c13:	0f b7 d9             	movzwl %cx,%ebx
  802c16:	83 c3 04             	add    $0x4,%ebx
  802c19:	83 fb 44             	cmp    $0x44,%ebx
  802c1c:	77 6d                	ja     802c8b <dhcp_option_long+0x81>
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff000000UL) >> 24);
  802c1e:	8d 71 01             	lea    0x1(%ecx),%esi
  802c21:	66 89 70 24          	mov    %si,0x24(%eax)
  802c25:	0f b7 c9             	movzwl %cx,%ecx
  802c28:	89 d3                	mov    %edx,%ebx
  802c2a:	c1 eb 18             	shr    $0x18,%ebx
  802c2d:	8b 70 20             	mov    0x20(%eax),%esi
  802c30:	88 9c 0e f0 00 00 00 	mov    %bl,0xf0(%esi,%ecx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x00ff0000UL) >> 16);
  802c37:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802c3b:	8d 71 01             	lea    0x1(%ecx),%esi
  802c3e:	66 89 70 24          	mov    %si,0x24(%eax)
  802c42:	0f b7 c9             	movzwl %cx,%ecx
  802c45:	89 d3                	mov    %edx,%ebx
  802c47:	c1 eb 10             	shr    $0x10,%ebx
  802c4a:	8b 70 20             	mov    0x20(%eax),%esi
  802c4d:	88 9c 0e f0 00 00 00 	mov    %bl,0xf0(%esi,%ecx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x0000ff00UL) >> 8);
  802c54:	8b 58 20             	mov    0x20(%eax),%ebx
  802c57:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802c5b:	8d 71 01             	lea    0x1(%ecx),%esi
  802c5e:	66 89 70 24          	mov    %si,0x24(%eax)
  802c62:	0f b7 c9             	movzwl %cx,%ecx
  802c65:	88 b4 0b f0 00 00 00 	mov    %dh,0xf0(%ebx,%ecx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x000000ffUL));
  802c6c:	8b 58 20             	mov    0x20(%eax),%ebx
  802c6f:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802c73:	8d 71 01             	lea    0x1(%ecx),%esi
  802c76:	66 89 70 24          	mov    %si,0x24(%eax)
  802c7a:	0f b7 c9             	movzwl %cx,%ecx
  802c7d:	88 94 0b f0 00 00 00 	mov    %dl,0xf0(%ebx,%ecx,1)
}
  802c84:	8d 65 f8             	lea    -0x8(%ebp),%esp
  802c87:	5b                   	pop    %ebx
  802c88:	5e                   	pop    %esi
  802c89:	5d                   	pop    %ebp
  802c8a:	c3                   	ret    
  LWIP_ASSERT("dhcp_option_long: dhcp->options_out_len + 4 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 4U <= DHCP_OPTIONS_LEN);
  802c8b:	83 ec 04             	sub    $0x4,%esp
  802c8e:	68 6c 19 81 00       	push   $0x81196c
  802c93:	68 74 04 00 00       	push   $0x474
  802c98:	68 62 1b 81 00       	push   $0x811b62
  802c9d:	e8 a5 bc 00 00       	call   80e947 <_panic>

00802ca2 <dhcp_create_request>:
{
  802ca2:	55                   	push   %ebp
  802ca3:	89 e5                	mov    %esp,%ebp
  802ca5:	57                   	push   %edi
  802ca6:	56                   	push   %esi
  802ca7:	53                   	push   %ebx
  802ca8:	83 ec 0c             	sub    $0xc,%esp
  LWIP_ERROR("dhcp_create_request: netif != NULL", (netif != NULL), return ERR_ARG;);
  802cab:	85 c0                	test   %eax,%eax
  802cad:	0f 84 d8 00 00 00    	je     802d8b <dhcp_create_request+0xe9>
  802cb3:	89 c6                	mov    %eax,%esi
  dhcp = netif->dhcp;
  802cb5:	8b 58 20             	mov    0x20(%eax),%ebx
  LWIP_ERROR("dhcp_create_request: dhcp != NULL", (dhcp != NULL), return ERR_VAL;);
  802cb8:	85 db                	test   %ebx,%ebx
  802cba:	0f 84 e2 00 00 00    	je     802da2 <dhcp_create_request+0x100>
  LWIP_ASSERT("dhcp_create_request: dhcp->p_out == NULL", dhcp->p_out == NULL);
  802cc0:	83 7b 1c 00          	cmpl   $0x0,0x1c(%ebx)
  802cc4:	0f 85 ef 00 00 00    	jne    802db9 <dhcp_create_request+0x117>
  LWIP_ASSERT("dhcp_create_request: dhcp->msg_out == NULL", dhcp->msg_out == NULL);
  802cca:	83 7b 20 00          	cmpl   $0x0,0x20(%ebx)
  802cce:	0f 85 fc 00 00 00    	jne    802dd0 <dhcp_create_request+0x12e>
  dhcp->p_out = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct dhcp_msg), PBUF_RAM);
  802cd4:	83 ec 04             	sub    $0x4,%esp
  802cd7:	6a 00                	push   $0x0
  802cd9:	68 34 01 00 00       	push   $0x134
  802cde:	6a 00                	push   $0x0
  802ce0:	e8 06 1e 00 00       	call   804aeb <pbuf_alloc>
  802ce5:	89 43 1c             	mov    %eax,0x1c(%ebx)
  if (dhcp->p_out == NULL) {
  802ce8:	83 c4 10             	add    $0x10,%esp
  802ceb:	85 c0                	test   %eax,%eax
  802ced:	0f 84 9b 01 00 00    	je     802e8e <dhcp_create_request+0x1ec>
  LWIP_ASSERT("dhcp_create_request: check that first pbuf can hold struct dhcp_msg",
  802cf3:	66 81 78 0a 33 01    	cmpw   $0x133,0xa(%eax)
  802cf9:	0f 86 e8 00 00 00    	jbe    802de7 <dhcp_create_request+0x145>
  dhcp->xid = xid++;
  802cff:	8b 15 04 40 81 00    	mov    0x814004,%edx
  802d05:	8d 4a 01             	lea    0x1(%edx),%ecx
  802d08:	89 0d 04 40 81 00    	mov    %ecx,0x814004
  802d0e:	89 53 04             	mov    %edx,0x4(%ebx)
  dhcp->msg_out = (struct dhcp_msg *)dhcp->p_out->payload;
  802d11:	8b 40 04             	mov    0x4(%eax),%eax
  802d14:	89 43 20             	mov    %eax,0x20(%ebx)
  dhcp->msg_out->op = DHCP_BOOTREQUEST;
  802d17:	c6 00 01             	movb   $0x1,(%eax)
  dhcp->msg_out->htype = DHCP_HTYPE_ETH;
  802d1a:	8b 43 20             	mov    0x20(%ebx),%eax
  802d1d:	c6 40 01 01          	movb   $0x1,0x1(%eax)
  dhcp->msg_out->hlen = DHCP_HLEN_ETH;
  802d21:	8b 43 20             	mov    0x20(%ebx),%eax
  802d24:	c6 40 02 06          	movb   $0x6,0x2(%eax)
  dhcp->msg_out->hops = 0;
  802d28:	8b 43 20             	mov    0x20(%ebx),%eax
  802d2b:	c6 40 03 00          	movb   $0x0,0x3(%eax)
  dhcp->msg_out->xid = htonl(dhcp->xid);
  802d2f:	8b 7b 20             	mov    0x20(%ebx),%edi
  802d32:	83 ec 0c             	sub    $0xc,%esp
  802d35:	ff 73 04             	pushl  0x4(%ebx)
  802d38:	e8 3e 4c 00 00       	call   80797b <htonl>
  802d3d:	89 47 04             	mov    %eax,0x4(%edi)
  dhcp->msg_out->secs = 0;
  802d40:	8b 43 20             	mov    0x20(%ebx),%eax
  802d43:	66 c7 40 08 00 00    	movw   $0x0,0x8(%eax)
  dhcp->msg_out->flags = 0;
  802d49:	8b 43 20             	mov    0x20(%ebx),%eax
  802d4c:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%eax)
  dhcp->msg_out->ciaddr.addr = netif->ip_addr.addr;
  802d52:	8b 43 20             	mov    0x20(%ebx),%eax
  802d55:	8b 56 04             	mov    0x4(%esi),%edx
  802d58:	89 50 0c             	mov    %edx,0xc(%eax)
  dhcp->msg_out->yiaddr.addr = 0;
  802d5b:	8b 43 20             	mov    0x20(%ebx),%eax
  802d5e:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  dhcp->msg_out->siaddr.addr = 0;
  802d65:	8b 43 20             	mov    0x20(%ebx),%eax
  802d68:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
  dhcp->msg_out->giaddr.addr = 0;
  802d6f:	8b 43 20             	mov    0x20(%ebx),%eax
  802d72:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
  802d79:	83 c4 10             	add    $0x10,%esp
  802d7c:	b8 00 00 00 00       	mov    $0x0,%eax
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  802d81:	bf 00 00 00 00       	mov    $0x0,%edi
  802d86:	e9 82 00 00 00       	jmp    802e0d <dhcp_create_request+0x16b>
  LWIP_ERROR("dhcp_create_request: netif != NULL", (netif != NULL), return ERR_ARG;);
  802d8b:	83 ec 04             	sub    $0x4,%esp
  802d8e:	68 ac 19 81 00       	push   $0x8119ac
  802d93:	68 2d 05 00 00       	push   $0x52d
  802d98:	68 62 1b 81 00       	push   $0x811b62
  802d9d:	e8 a5 bb 00 00       	call   80e947 <_panic>
  LWIP_ERROR("dhcp_create_request: dhcp != NULL", (dhcp != NULL), return ERR_VAL;);
  802da2:	83 ec 04             	sub    $0x4,%esp
  802da5:	68 d0 19 81 00       	push   $0x8119d0
  802daa:	68 2f 05 00 00       	push   $0x52f
  802daf:	68 62 1b 81 00       	push   $0x811b62
  802db4:	e8 8e bb 00 00       	call   80e947 <_panic>
  LWIP_ASSERT("dhcp_create_request: dhcp->p_out == NULL", dhcp->p_out == NULL);
  802db9:	83 ec 04             	sub    $0x4,%esp
  802dbc:	68 f4 19 81 00       	push   $0x8119f4
  802dc1:	68 30 05 00 00       	push   $0x530
  802dc6:	68 62 1b 81 00       	push   $0x811b62
  802dcb:	e8 77 bb 00 00       	call   80e947 <_panic>
  LWIP_ASSERT("dhcp_create_request: dhcp->msg_out == NULL", dhcp->msg_out == NULL);
  802dd0:	83 ec 04             	sub    $0x4,%esp
  802dd3:	68 20 1a 81 00       	push   $0x811a20
  802dd8:	68 31 05 00 00       	push   $0x531
  802ddd:	68 62 1b 81 00       	push   $0x811b62
  802de2:	e8 60 bb 00 00       	call   80e947 <_panic>
  LWIP_ASSERT("dhcp_create_request: check that first pbuf can hold struct dhcp_msg",
  802de7:	83 ec 04             	sub    $0x4,%esp
  802dea:	68 4c 1a 81 00       	push   $0x811a4c
  802def:	68 37 05 00 00       	push   $0x537
  802df4:	68 62 1b 81 00       	push   $0x811b62
  802df9:	e8 49 bb 00 00       	call   80e947 <_panic>
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  802dfe:	8b 4b 20             	mov    0x20(%ebx),%ecx
  802e01:	88 54 01 1c          	mov    %dl,0x1c(%ecx,%eax,1)
  802e05:	83 c0 01             	add    $0x1,%eax
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
  802e08:	83 f8 10             	cmp    $0x10,%eax
  802e0b:	74 12                	je     802e1f <dhcp_create_request+0x17d>
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  802e0d:	0f b6 4e 24          	movzbl 0x24(%esi),%ecx
  802e11:	89 fa                	mov    %edi,%edx
  802e13:	66 39 c1             	cmp    %ax,%cx
  802e16:	76 e6                	jbe    802dfe <dhcp_create_request+0x15c>
  802e18:	0f b6 54 06 25       	movzbl 0x25(%esi,%eax,1),%edx
  802e1d:	eb df                	jmp    802dfe <dhcp_create_request+0x15c>
  802e1f:	b8 00 00 00 00       	mov    $0x0,%eax
    dhcp->msg_out->sname[i] = 0;
  802e24:	8b 53 20             	mov    0x20(%ebx),%edx
  802e27:	c6 44 02 2c 00       	movb   $0x0,0x2c(%edx,%eax,1)
  802e2c:	83 c0 01             	add    $0x1,%eax
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
  802e2f:	83 f8 40             	cmp    $0x40,%eax
  802e32:	75 f0                	jne    802e24 <dhcp_create_request+0x182>
  802e34:	b8 00 00 00 00       	mov    $0x0,%eax
    dhcp->msg_out->file[i] = 0;
  802e39:	8b 53 20             	mov    0x20(%ebx),%edx
  802e3c:	c6 44 02 6c 00       	movb   $0x0,0x6c(%edx,%eax,1)
  802e41:	83 c0 01             	add    $0x1,%eax
  for (i = 0; i < DHCP_FILE_LEN; i++) {
  802e44:	3d 80 00 00 00       	cmp    $0x80,%eax
  802e49:	75 ee                	jne    802e39 <dhcp_create_request+0x197>
  dhcp->msg_out->cookie = htonl(0x63825363UL);
  802e4b:	8b 73 20             	mov    0x20(%ebx),%esi
  802e4e:	83 ec 0c             	sub    $0xc,%esp
  802e51:	68 63 53 82 63       	push   $0x63825363
  802e56:	e8 20 4b 00 00       	call   80797b <htonl>
  802e5b:	89 86 ec 00 00 00    	mov    %eax,0xec(%esi)
  dhcp->options_out_len = 0;
  802e61:	66 c7 43 24 00 00    	movw   $0x0,0x24(%ebx)
  802e67:	83 c4 10             	add    $0x10,%esp
  802e6a:	b8 00 00 00 00       	mov    $0x0,%eax
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
  802e6f:	8b 53 20             	mov    0x20(%ebx),%edx
  802e72:	88 84 02 f0 00 00 00 	mov    %al,0xf0(%edx,%eax,1)
  802e79:	83 c0 01             	add    $0x1,%eax
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
  802e7c:	83 f8 44             	cmp    $0x44,%eax
  802e7f:	75 ee                	jne    802e6f <dhcp_create_request+0x1cd>
  return ERR_OK;
  802e81:	b8 00 00 00 00       	mov    $0x0,%eax
}
  802e86:	8d 65 f4             	lea    -0xc(%ebp),%esp
  802e89:	5b                   	pop    %ebx
  802e8a:	5e                   	pop    %esi
  802e8b:	5f                   	pop    %edi
  802e8c:	5d                   	pop    %ebp
  802e8d:	c3                   	ret    
    return ERR_MEM;
  802e8e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  802e93:	eb f1                	jmp    802e86 <dhcp_create_request+0x1e4>

00802e95 <dhcp_delete_request>:
{
  802e95:	55                   	push   %ebp
  802e96:	89 e5                	mov    %esp,%ebp
  802e98:	53                   	push   %ebx
  802e99:	83 ec 04             	sub    $0x4,%esp
  LWIP_ERROR("dhcp_delete_request: netif != NULL", (netif != NULL), return;);
  802e9c:	85 c0                	test   %eax,%eax
  802e9e:	74 33                	je     802ed3 <dhcp_delete_request+0x3e>
  dhcp = netif->dhcp;
  802ea0:	8b 58 20             	mov    0x20(%eax),%ebx
  LWIP_ERROR("dhcp_delete_request: dhcp != NULL", (dhcp != NULL), return;);
  802ea3:	85 db                	test   %ebx,%ebx
  802ea5:	74 43                	je     802eea <dhcp_delete_request+0x55>
  LWIP_ASSERT("dhcp_delete_request: dhcp->p_out != NULL", dhcp->p_out != NULL);
  802ea7:	8b 43 1c             	mov    0x1c(%ebx),%eax
  802eaa:	85 c0                	test   %eax,%eax
  802eac:	74 53                	je     802f01 <dhcp_delete_request+0x6c>
  LWIP_ASSERT("dhcp_delete_request: dhcp->msg_out != NULL", dhcp->msg_out != NULL);
  802eae:	83 7b 20 00          	cmpl   $0x0,0x20(%ebx)
  802eb2:	74 64                	je     802f18 <dhcp_delete_request+0x83>
    pbuf_free(dhcp->p_out);
  802eb4:	83 ec 0c             	sub    $0xc,%esp
  802eb7:	50                   	push   %eax
  802eb8:	e8 64 1b 00 00       	call   804a21 <pbuf_free>
  dhcp->p_out = NULL;
  802ebd:	c7 43 1c 00 00 00 00 	movl   $0x0,0x1c(%ebx)
  dhcp->msg_out = NULL;
  802ec4:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
  802ecb:	83 c4 10             	add    $0x10,%esp
}
  802ece:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  802ed1:	c9                   	leave  
  802ed2:	c3                   	ret    
  LWIP_ERROR("dhcp_delete_request: netif != NULL", (netif != NULL), return;);
  802ed3:	83 ec 04             	sub    $0x4,%esp
  802ed6:	68 90 1a 81 00       	push   $0x811a90
  802edb:	68 69 05 00 00       	push   $0x569
  802ee0:	68 62 1b 81 00       	push   $0x811b62
  802ee5:	e8 5d ba 00 00       	call   80e947 <_panic>
  LWIP_ERROR("dhcp_delete_request: dhcp != NULL", (dhcp != NULL), return;);
  802eea:	83 ec 04             	sub    $0x4,%esp
  802eed:	68 b4 1a 81 00       	push   $0x811ab4
  802ef2:	68 6b 05 00 00       	push   $0x56b
  802ef7:	68 62 1b 81 00       	push   $0x811b62
  802efc:	e8 46 ba 00 00       	call   80e947 <_panic>
  LWIP_ASSERT("dhcp_delete_request: dhcp->p_out != NULL", dhcp->p_out != NULL);
  802f01:	83 ec 04             	sub    $0x4,%esp
  802f04:	68 d8 1a 81 00       	push   $0x811ad8
  802f09:	68 6c 05 00 00       	push   $0x56c
  802f0e:	68 62 1b 81 00       	push   $0x811b62
  802f13:	e8 2f ba 00 00       	call   80e947 <_panic>
  LWIP_ASSERT("dhcp_delete_request: dhcp->msg_out != NULL", dhcp->msg_out != NULL);
  802f18:	83 ec 04             	sub    $0x4,%esp
  802f1b:	68 04 1b 81 00       	push   $0x811b04
  802f20:	68 6d 05 00 00       	push   $0x56d
  802f25:	68 62 1b 81 00       	push   $0x811b62
  802f2a:	e8 18 ba 00 00       	call   80e947 <_panic>

00802f2f <dhcp_rebind>:
{
  802f2f:	55                   	push   %ebp
  802f30:	89 e5                	mov    %esp,%ebp
  802f32:	57                   	push   %edi
  802f33:	56                   	push   %esi
  802f34:	53                   	push   %ebx
  802f35:	83 ec 0c             	sub    $0xc,%esp
  802f38:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp = netif->dhcp;
  802f3a:	8b 58 20             	mov    0x20(%eax),%ebx
  dhcp_set_state(dhcp, DHCP_REBINDING);
  802f3d:	ba 04 00 00 00       	mov    $0x4,%edx
  802f42:	89 d8                	mov    %ebx,%eax
  802f44:	e8 cc f9 ff ff       	call   802915 <dhcp_set_state>
  result = dhcp_create_request(netif);
  802f49:	89 f8                	mov    %edi,%eax
  802f4b:	e8 52 fd ff ff       	call   802ca2 <dhcp_create_request>
  802f50:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  802f52:	84 c0                	test   %al,%al
  802f54:	74 3e                	je     802f94 <dhcp_rebind+0x65>
  dhcp->tries++;
  802f56:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  802f5a:	83 c0 01             	add    $0x1,%eax
  802f5d:	88 43 01             	mov    %al,0x1(%ebx)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
  802f60:	ba 10 27 00 00       	mov    $0x2710,%edx
  802f65:	3c 09                	cmp    $0x9,%al
  802f67:	77 08                	ja     802f71 <dhcp_rebind+0x42>
  802f69:	0f b6 d0             	movzbl %al,%edx
  802f6c:	66 69 d2 e8 03       	imul   $0x3e8,%dx,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  802f71:	0f b7 d2             	movzwl %dx,%edx
  802f74:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  802f7a:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  802f7f:	89 d0                	mov    %edx,%eax
  802f81:	f7 e9                	imul   %ecx
  802f83:	c1 fa 05             	sar    $0x5,%edx
  802f86:	66 89 53 26          	mov    %dx,0x26(%ebx)
}
  802f8a:	89 f0                	mov    %esi,%eax
  802f8c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  802f8f:	5b                   	pop    %ebx
  802f90:	5e                   	pop    %esi
  802f91:	5f                   	pop    %edi
  802f92:	5d                   	pop    %ebp
  802f93:	c3                   	ret    
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  802f94:	b9 01 00 00 00       	mov    $0x1,%ecx
  802f99:	ba 35 00 00 00       	mov    $0x35,%edx
  802f9e:	89 d8                	mov    %ebx,%eax
  802fa0:	e8 eb fa ff ff       	call   802a90 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  802fa5:	ba 03 00 00 00       	mov    $0x3,%edx
  802faa:	89 d8                	mov    %ebx,%eax
  802fac:	e8 9e fa ff ff       	call   802a4f <dhcp_option_byte>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  802fb1:	b9 02 00 00 00       	mov    $0x2,%ecx
  802fb6:	ba 39 00 00 00       	mov    $0x39,%edx
  802fbb:	89 d8                	mov    %ebx,%eax
  802fbd:	e8 ce fa ff ff       	call   802a90 <dhcp_option>
    dhcp_option_short(dhcp, 576);
  802fc2:	ba 40 02 00 00       	mov    $0x240,%edx
  802fc7:	89 d8                	mov    %ebx,%eax
  802fc9:	e8 29 fb ff ff       	call   802af7 <dhcp_option_short>
    dhcp_option_trailer(dhcp);
  802fce:	89 d8                	mov    %ebx,%eax
  802fd0:	e8 80 fb ff ff       	call   802b55 <dhcp_option_trailer>
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  802fd5:	83 ec 08             	sub    $0x8,%esp
  802fd8:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  802fdc:	66 05 f0 00          	add    $0xf0,%ax
  802fe0:	0f b7 c0             	movzwl %ax,%eax
  802fe3:	50                   	push   %eax
  802fe4:	ff 73 1c             	pushl  0x1c(%ebx)
  802fe7:	e8 5e 1d 00 00       	call   804d4a <pbuf_realloc>
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  802fec:	83 c4 0c             	add    $0xc,%esp
  802fef:	6a 43                	push   $0x43
  802ff1:	68 08 24 81 00       	push   $0x812408
  802ff6:	ff 73 08             	pushl  0x8(%ebx)
  802ff9:	e8 c0 61 00 00       	call   8091be <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  802ffe:	89 3c 24             	mov    %edi,(%esp)
  803001:	6a 43                	push   $0x43
  803003:	68 04 24 81 00       	push   $0x812404
  803008:	ff 73 1c             	pushl  0x1c(%ebx)
  80300b:	ff 73 08             	pushl  0x8(%ebx)
  80300e:	e8 aa 5f 00 00       	call   808fbd <udp_sendto_if>
    dhcp_delete_request(netif);
  803013:	83 c4 20             	add    $0x20,%esp
  803016:	89 f8                	mov    %edi,%eax
  803018:	e8 78 fe ff ff       	call   802e95 <dhcp_delete_request>
  80301d:	e9 34 ff ff ff       	jmp    802f56 <dhcp_rebind+0x27>

00803022 <dhcp_discover>:
{
  803022:	55                   	push   %ebp
  803023:	89 e5                	mov    %esp,%ebp
  803025:	57                   	push   %edi
  803026:	56                   	push   %esi
  803027:	53                   	push   %ebx
  803028:	83 ec 0c             	sub    $0xc,%esp
  80302b:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp = netif->dhcp;
  80302d:	8b 58 20             	mov    0x20(%eax),%ebx
  ip_addr_set(&dhcp->offered_ip_addr, IP_ADDR_ANY);
  803030:	a1 08 24 81 00       	mov    0x812408,%eax
  803035:	89 43 30             	mov    %eax,0x30(%ebx)
  result = dhcp_create_request(netif);
  803038:	89 f8                	mov    %edi,%eax
  80303a:	e8 63 fc ff ff       	call   802ca2 <dhcp_create_request>
  80303f:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  803041:	84 c0                	test   %al,%al
  803043:	74 41                	je     803086 <dhcp_discover+0x64>
  dhcp->tries++;
  803045:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  803049:	83 c0 01             	add    $0x1,%eax
  80304c:	88 43 01             	mov    %al,0x1(%ebx)
  msecs = dhcp->tries < 4 ? (dhcp->tries + 1) * 1000 : 10 * 1000;
  80304f:	ba 10 27 00 00       	mov    $0x2710,%edx
  803054:	3c 03                	cmp    $0x3,%al
  803056:	77 0b                	ja     803063 <dhcp_discover+0x41>
  803058:	0f b6 d0             	movzbl %al,%edx
  80305b:	83 c2 01             	add    $0x1,%edx
  80305e:	66 69 d2 e8 03       	imul   $0x3e8,%dx,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  803063:	0f b7 d2             	movzwl %dx,%edx
  803066:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  80306c:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  803071:	89 d0                	mov    %edx,%eax
  803073:	f7 e9                	imul   %ecx
  803075:	c1 fa 05             	sar    $0x5,%edx
  803078:	66 89 53 26          	mov    %dx,0x26(%ebx)
}
  80307c:	89 f0                	mov    %esi,%eax
  80307e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  803081:	5b                   	pop    %ebx
  803082:	5e                   	pop    %esi
  803083:	5f                   	pop    %edi
  803084:	5d                   	pop    %ebp
  803085:	c3                   	ret    
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  803086:	b9 01 00 00 00       	mov    $0x1,%ecx
  80308b:	ba 35 00 00 00       	mov    $0x35,%edx
  803090:	89 d8                	mov    %ebx,%eax
  803092:	e8 f9 f9 ff ff       	call   802a90 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_DISCOVER);
  803097:	ba 01 00 00 00       	mov    $0x1,%edx
  80309c:	89 d8                	mov    %ebx,%eax
  80309e:	e8 ac f9 ff ff       	call   802a4f <dhcp_option_byte>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  8030a3:	b9 02 00 00 00       	mov    $0x2,%ecx
  8030a8:	ba 39 00 00 00       	mov    $0x39,%edx
  8030ad:	89 d8                	mov    %ebx,%eax
  8030af:	e8 dc f9 ff ff       	call   802a90 <dhcp_option>
    dhcp_option_short(dhcp, 576);
  8030b4:	ba 40 02 00 00       	mov    $0x240,%edx
  8030b9:	89 d8                	mov    %ebx,%eax
  8030bb:	e8 37 fa ff ff       	call   802af7 <dhcp_option_short>
    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
  8030c0:	b9 04 00 00 00       	mov    $0x4,%ecx
  8030c5:	ba 37 00 00 00       	mov    $0x37,%edx
  8030ca:	89 d8                	mov    %ebx,%eax
  8030cc:	e8 bf f9 ff ff       	call   802a90 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
  8030d1:	ba 01 00 00 00       	mov    $0x1,%edx
  8030d6:	89 d8                	mov    %ebx,%eax
  8030d8:	e8 72 f9 ff ff       	call   802a4f <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
  8030dd:	ba 03 00 00 00       	mov    $0x3,%edx
  8030e2:	89 d8                	mov    %ebx,%eax
  8030e4:	e8 66 f9 ff ff       	call   802a4f <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
  8030e9:	ba 1c 00 00 00       	mov    $0x1c,%edx
  8030ee:	89 d8                	mov    %ebx,%eax
  8030f0:	e8 5a f9 ff ff       	call   802a4f <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
  8030f5:	ba 06 00 00 00       	mov    $0x6,%edx
  8030fa:	89 d8                	mov    %ebx,%eax
  8030fc:	e8 4e f9 ff ff       	call   802a4f <dhcp_option_byte>
    dhcp_option_trailer(dhcp);
  803101:	89 d8                	mov    %ebx,%eax
  803103:	e8 4d fa ff ff       	call   802b55 <dhcp_option_trailer>
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  803108:	83 ec 08             	sub    $0x8,%esp
  80310b:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  80310f:	66 05 f0 00          	add    $0xf0,%ax
  803113:	0f b7 c0             	movzwl %ax,%eax
  803116:	50                   	push   %eax
  803117:	ff 73 1c             	pushl  0x1c(%ebx)
  80311a:	e8 2b 1c 00 00       	call   804d4a <pbuf_realloc>
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  80311f:	83 c4 0c             	add    $0xc,%esp
  803122:	6a 43                	push   $0x43
  803124:	68 08 24 81 00       	push   $0x812408
  803129:	ff 73 08             	pushl  0x8(%ebx)
  80312c:	e8 8d 60 00 00       	call   8091be <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  803131:	89 3c 24             	mov    %edi,(%esp)
  803134:	6a 43                	push   $0x43
  803136:	68 04 24 81 00       	push   $0x812404
  80313b:	ff 73 1c             	pushl  0x1c(%ebx)
  80313e:	ff 73 08             	pushl  0x8(%ebx)
  803141:	e8 77 5e 00 00       	call   808fbd <udp_sendto_if>
    dhcp_delete_request(netif);
  803146:	83 c4 20             	add    $0x20,%esp
  803149:	89 f8                	mov    %edi,%eax
  80314b:	e8 45 fd ff ff       	call   802e95 <dhcp_delete_request>
    dhcp_set_state(dhcp, DHCP_SELECTING);
  803150:	ba 06 00 00 00       	mov    $0x6,%edx
  803155:	89 d8                	mov    %ebx,%eax
  803157:	e8 b9 f7 ff ff       	call   802915 <dhcp_set_state>
  80315c:	e9 e4 fe ff ff       	jmp    803045 <dhcp_discover+0x23>

00803161 <dhcp_select>:
{
  803161:	55                   	push   %ebp
  803162:	89 e5                	mov    %esp,%ebp
  803164:	57                   	push   %edi
  803165:	56                   	push   %esi
  803166:	53                   	push   %ebx
  803167:	83 ec 0c             	sub    $0xc,%esp
  80316a:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp = netif->dhcp;
  80316c:	8b 58 20             	mov    0x20(%eax),%ebx
  result = dhcp_create_request(netif);
  80316f:	e8 2e fb ff ff       	call   802ca2 <dhcp_create_request>
  803174:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  803176:	84 c0                	test   %al,%al
  803178:	74 3e                	je     8031b8 <dhcp_select+0x57>
  dhcp->tries++;
  80317a:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  80317e:	83 c0 01             	add    $0x1,%eax
  803181:	88 43 01             	mov    %al,0x1(%ebx)
  msecs = dhcp->tries < 4 ? dhcp->tries * 1000 : 4 * 1000;
  803184:	ba a0 0f 00 00       	mov    $0xfa0,%edx
  803189:	3c 03                	cmp    $0x3,%al
  80318b:	77 08                	ja     803195 <dhcp_select+0x34>
  80318d:	0f b6 d0             	movzbl %al,%edx
  803190:	66 69 d2 e8 03       	imul   $0x3e8,%dx,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  803195:	0f b7 d2             	movzwl %dx,%edx
  803198:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  80319e:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  8031a3:	89 d0                	mov    %edx,%eax
  8031a5:	f7 e9                	imul   %ecx
  8031a7:	c1 fa 05             	sar    $0x5,%edx
  8031aa:	66 89 53 26          	mov    %dx,0x26(%ebx)
}
  8031ae:	89 f0                	mov    %esi,%eax
  8031b0:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8031b3:	5b                   	pop    %ebx
  8031b4:	5e                   	pop    %esi
  8031b5:	5f                   	pop    %edi
  8031b6:	5d                   	pop    %ebp
  8031b7:	c3                   	ret    
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  8031b8:	b9 01 00 00 00       	mov    $0x1,%ecx
  8031bd:	ba 35 00 00 00       	mov    $0x35,%edx
  8031c2:	89 d8                	mov    %ebx,%eax
  8031c4:	e8 c7 f8 ff ff       	call   802a90 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  8031c9:	ba 03 00 00 00       	mov    $0x3,%edx
  8031ce:	89 d8                	mov    %ebx,%eax
  8031d0:	e8 7a f8 ff ff       	call   802a4f <dhcp_option_byte>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  8031d5:	b9 02 00 00 00       	mov    $0x2,%ecx
  8031da:	ba 39 00 00 00       	mov    $0x39,%edx
  8031df:	89 d8                	mov    %ebx,%eax
  8031e1:	e8 aa f8 ff ff       	call   802a90 <dhcp_option>
    dhcp_option_short(dhcp, 576);
  8031e6:	ba 40 02 00 00       	mov    $0x240,%edx
  8031eb:	89 d8                	mov    %ebx,%eax
  8031ed:	e8 05 f9 ff ff       	call   802af7 <dhcp_option_short>
    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
  8031f2:	b9 04 00 00 00       	mov    $0x4,%ecx
  8031f7:	ba 32 00 00 00       	mov    $0x32,%edx
  8031fc:	89 d8                	mov    %ebx,%eax
  8031fe:	e8 8d f8 ff ff       	call   802a90 <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->offered_ip_addr.addr));
  803203:	83 ec 0c             	sub    $0xc,%esp
  803206:	ff 73 30             	pushl  0x30(%ebx)
  803209:	e8 9a 49 00 00       	call   807ba8 <ntohl>
  80320e:	89 c2                	mov    %eax,%edx
  803210:	89 d8                	mov    %ebx,%eax
  803212:	e8 f3 f9 ff ff       	call   802c0a <dhcp_option_long>
    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
  803217:	b9 04 00 00 00       	mov    $0x4,%ecx
  80321c:	ba 36 00 00 00       	mov    $0x36,%edx
  803221:	89 d8                	mov    %ebx,%eax
  803223:	e8 68 f8 ff ff       	call   802a90 <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
  803228:	83 c4 04             	add    $0x4,%esp
  80322b:	ff 73 2c             	pushl  0x2c(%ebx)
  80322e:	e8 75 49 00 00       	call   807ba8 <ntohl>
  803233:	89 c2                	mov    %eax,%edx
  803235:	89 d8                	mov    %ebx,%eax
  803237:	e8 ce f9 ff ff       	call   802c0a <dhcp_option_long>
    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
  80323c:	b9 04 00 00 00       	mov    $0x4,%ecx
  803241:	ba 37 00 00 00       	mov    $0x37,%edx
  803246:	89 d8                	mov    %ebx,%eax
  803248:	e8 43 f8 ff ff       	call   802a90 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
  80324d:	ba 01 00 00 00       	mov    $0x1,%edx
  803252:	89 d8                	mov    %ebx,%eax
  803254:	e8 f6 f7 ff ff       	call   802a4f <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
  803259:	ba 03 00 00 00       	mov    $0x3,%edx
  80325e:	89 d8                	mov    %ebx,%eax
  803260:	e8 ea f7 ff ff       	call   802a4f <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
  803265:	ba 1c 00 00 00       	mov    $0x1c,%edx
  80326a:	89 d8                	mov    %ebx,%eax
  80326c:	e8 de f7 ff ff       	call   802a4f <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
  803271:	ba 06 00 00 00       	mov    $0x6,%edx
  803276:	89 d8                	mov    %ebx,%eax
  803278:	e8 d2 f7 ff ff       	call   802a4f <dhcp_option_byte>
    dhcp_option_trailer(dhcp);
  80327d:	89 d8                	mov    %ebx,%eax
  80327f:	e8 d1 f8 ff ff       	call   802b55 <dhcp_option_trailer>
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  803284:	83 c4 08             	add    $0x8,%esp
  803287:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  80328b:	66 05 f0 00          	add    $0xf0,%ax
  80328f:	0f b7 c0             	movzwl %ax,%eax
  803292:	50                   	push   %eax
  803293:	ff 73 1c             	pushl  0x1c(%ebx)
  803296:	e8 af 1a 00 00       	call   804d4a <pbuf_realloc>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  80329b:	89 3c 24             	mov    %edi,(%esp)
  80329e:	6a 43                	push   $0x43
  8032a0:	68 04 24 81 00       	push   $0x812404
  8032a5:	ff 73 1c             	pushl  0x1c(%ebx)
  8032a8:	ff 73 08             	pushl  0x8(%ebx)
  8032ab:	e8 0d 5d 00 00       	call   808fbd <udp_sendto_if>
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  8032b0:	83 c4 1c             	add    $0x1c,%esp
  8032b3:	6a 43                	push   $0x43
  8032b5:	68 08 24 81 00       	push   $0x812408
  8032ba:	ff 73 08             	pushl  0x8(%ebx)
  8032bd:	e8 fc 5e 00 00       	call   8091be <udp_connect>
    dhcp_delete_request(netif);
  8032c2:	89 f8                	mov    %edi,%eax
  8032c4:	e8 cc fb ff ff       	call   802e95 <dhcp_delete_request>
    dhcp_set_state(dhcp, DHCP_REQUESTING);
  8032c9:	ba 01 00 00 00       	mov    $0x1,%edx
  8032ce:	89 d8                	mov    %ebx,%eax
  8032d0:	e8 40 f6 ff ff       	call   802915 <dhcp_set_state>
  8032d5:	83 c4 10             	add    $0x10,%esp
  8032d8:	e9 9d fe ff ff       	jmp    80317a <dhcp_select+0x19>

008032dd <dhcp_check>:
{
  8032dd:	55                   	push   %ebp
  8032de:	89 e5                	mov    %esp,%ebp
  8032e0:	53                   	push   %ebx
  8032e1:	83 ec 08             	sub    $0x8,%esp
  struct dhcp *dhcp = netif->dhcp;
  8032e4:	8b 58 20             	mov    0x20(%eax),%ebx
  result = etharp_query(netif, &dhcp->offered_ip_addr, NULL);
  8032e7:	6a 00                	push   $0x0
  8032e9:	8d 53 30             	lea    0x30(%ebx),%edx
  8032ec:	52                   	push   %edx
  8032ed:	50                   	push   %eax
  8032ee:	e8 cc 68 00 00       	call   809bbf <etharp_query>
  dhcp->tries++;
  8032f3:	80 43 01 01          	addb   $0x1,0x1(%ebx)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  8032f7:	66 c7 43 26 01 00    	movw   $0x1,0x26(%ebx)
  dhcp_set_state(dhcp, DHCP_CHECKING);
  8032fd:	ba 08 00 00 00       	mov    $0x8,%edx
  803302:	89 d8                	mov    %ebx,%eax
  803304:	e8 0c f6 ff ff       	call   802915 <dhcp_set_state>
}
  803309:	83 c4 10             	add    $0x10,%esp
  80330c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80330f:	c9                   	leave  
  803310:	c3                   	ret    

00803311 <dhcp_bind>:
{
  803311:	55                   	push   %ebp
  803312:	89 e5                	mov    %esp,%ebp
  803314:	56                   	push   %esi
  803315:	53                   	push   %ebx
  803316:	83 ec 10             	sub    $0x10,%esp
  LWIP_ERROR("dhcp_bind: netif != NULL", (netif != NULL), return;);
  803319:	85 c0                	test   %eax,%eax
  80331b:	0f 84 d9 00 00 00    	je     8033fa <dhcp_bind+0xe9>
  803321:	89 c6                	mov    %eax,%esi
  dhcp = netif->dhcp;
  803323:	8b 58 20             	mov    0x20(%eax),%ebx
  LWIP_ERROR("dhcp_bind: dhcp != NULL", (dhcp != NULL), return;);
  803326:	85 db                	test   %ebx,%ebx
  803328:	0f 84 e3 00 00 00    	je     803411 <dhcp_bind+0x100>
  if (dhcp->offered_t1_renew != 0xffffffffUL) {
  80332e:	8b 53 50             	mov    0x50(%ebx),%edx
  803331:	83 fa ff             	cmp    $0xffffffff,%edx
  803334:	74 2f                	je     803365 <dhcp_bind+0x54>
    timeout = (dhcp->offered_t1_renew + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  803336:	83 c2 1e             	add    $0x1e,%edx
    if(timeout > 0xffff) {
  803339:	81 fa ff ff 3b 00    	cmp    $0x3bffff,%edx
  80333f:	0f 87 7e 01 00 00    	ja     8034c3 <dhcp_bind+0x1b2>
    timeout = (dhcp->offered_t1_renew + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  803345:	b9 89 88 88 88       	mov    $0x88888889,%ecx
  80334a:	89 d0                	mov    %edx,%eax
  80334c:	f7 e1                	mul    %ecx
  80334e:	89 d0                	mov    %edx,%eax
  803350:	c1 e8 05             	shr    $0x5,%eax
    if (dhcp->t1_timeout == 0) {
  803353:	f7 c2 e0 ff 1f 00    	test   $0x1fffe0,%edx
  803359:	0f 85 c9 00 00 00    	jne    803428 <dhcp_bind+0x117>
      dhcp->t1_timeout = 1;
  80335f:	66 c7 43 28 01 00    	movw   $0x1,0x28(%ebx)
  if (dhcp->offered_t2_rebind != 0xffffffffUL) {
  803365:	8b 53 54             	mov    0x54(%ebx),%edx
  803368:	83 fa ff             	cmp    $0xffffffff,%edx
  80336b:	74 2f                	je     80339c <dhcp_bind+0x8b>
    timeout = (dhcp->offered_t2_rebind + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  80336d:	83 c2 1e             	add    $0x1e,%edx
    if(timeout > 0xffff) {
  803370:	81 fa ff ff 3b 00    	cmp    $0x3bffff,%edx
  803376:	0f 87 3c 01 00 00    	ja     8034b8 <dhcp_bind+0x1a7>
    timeout = (dhcp->offered_t2_rebind + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  80337c:	b9 89 88 88 88       	mov    $0x88888889,%ecx
  803381:	89 d0                	mov    %edx,%eax
  803383:	f7 e1                	mul    %ecx
  803385:	89 d0                	mov    %edx,%eax
  803387:	c1 e8 05             	shr    $0x5,%eax
    if (dhcp->t2_timeout == 0) {
  80338a:	f7 c2 e0 ff 1f 00    	test   $0x1fffe0,%edx
  803390:	0f 85 9b 00 00 00    	jne    803431 <dhcp_bind+0x120>
      dhcp->t2_timeout = 1;
  803396:	66 c7 43 2a 01 00    	movw   $0x1,0x2a(%ebx)
  ip_addr_set(&sn_mask, &dhcp->offered_sn_mask);
  80339c:	8b 43 34             	mov    0x34(%ebx),%eax
  80339f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (sn_mask.addr == 0) {
  8033a2:	85 c0                	test   %eax,%eax
  8033a4:	0f 84 90 00 00 00    	je     80343a <dhcp_bind+0x129>
  ip_addr_set(&gw_addr, &dhcp->offered_gw_addr);
  8033aa:	8b 43 38             	mov    0x38(%ebx),%eax
  8033ad:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (gw_addr.addr == 0) {
  8033b0:	85 c0                	test   %eax,%eax
  8033b2:	0f 84 e2 00 00 00    	je     80349a <dhcp_bind+0x189>
  netif_set_ipaddr(netif, &dhcp->offered_ip_addr);
  8033b8:	83 ec 08             	sub    $0x8,%esp
  8033bb:	8d 43 30             	lea    0x30(%ebx),%eax
  8033be:	50                   	push   %eax
  8033bf:	56                   	push   %esi
  8033c0:	e8 a2 13 00 00       	call   804767 <netif_set_ipaddr>
  netif_set_netmask(netif, &sn_mask);
  8033c5:	83 c4 08             	add    $0x8,%esp
  8033c8:	8d 45 f4             	lea    -0xc(%ebp),%eax
  8033cb:	50                   	push   %eax
  8033cc:	56                   	push   %esi
  8033cd:	e8 ea 14 00 00       	call   8048bc <netif_set_netmask>
  netif_set_gw(netif, &gw_addr);
  8033d2:	83 c4 08             	add    $0x8,%esp
  8033d5:	8d 45 f0             	lea    -0x10(%ebp),%eax
  8033d8:	50                   	push   %eax
  8033d9:	56                   	push   %esi
  8033da:	e8 c0 14 00 00       	call   80489f <netif_set_gw>
  netif_set_up(netif);
  8033df:	89 34 24             	mov    %esi,(%esp)
  8033e2:	e8 03 15 00 00       	call   8048ea <netif_set_up>
  dhcp_set_state(dhcp, DHCP_BOUND);
  8033e7:	ba 0a 00 00 00       	mov    $0xa,%edx
  8033ec:	89 d8                	mov    %ebx,%eax
  8033ee:	e8 22 f5 ff ff       	call   802915 <dhcp_set_state>
}
  8033f3:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8033f6:	5b                   	pop    %ebx
  8033f7:	5e                   	pop    %esi
  8033f8:	5d                   	pop    %ebp
  8033f9:	c3                   	ret    
  LWIP_ERROR("dhcp_bind: netif != NULL", (netif != NULL), return;);
  8033fa:	83 ec 04             	sub    $0x4,%esp
  8033fd:	68 77 1b 81 00       	push   $0x811b77
  803402:	68 3d 03 00 00       	push   $0x33d
  803407:	68 62 1b 81 00       	push   $0x811b62
  80340c:	e8 36 b5 00 00       	call   80e947 <_panic>
  LWIP_ERROR("dhcp_bind: dhcp != NULL", (dhcp != NULL), return;);
  803411:	83 ec 04             	sub    $0x4,%esp
  803414:	68 90 1b 81 00       	push   $0x811b90
  803419:	68 3f 03 00 00       	push   $0x33f
  80341e:	68 62 1b 81 00       	push   $0x811b62
  803423:	e8 1f b5 00 00       	call   80e947 <_panic>
    dhcp->t1_timeout = (u16_t)timeout;
  803428:	66 89 43 28          	mov    %ax,0x28(%ebx)
  80342c:	e9 34 ff ff ff       	jmp    803365 <dhcp_bind+0x54>
    dhcp->t2_timeout = (u16_t)timeout;
  803431:	66 89 43 2a          	mov    %ax,0x2a(%ebx)
  803435:	e9 62 ff ff ff       	jmp    80339c <dhcp_bind+0x8b>
    u8_t first_octet = ip4_addr1(&sn_mask);
  80343a:	83 ec 0c             	sub    $0xc,%esp
  80343d:	6a 00                	push   $0x0
  80343f:	e8 64 47 00 00       	call   807ba8 <ntohl>
  803444:	c1 e8 18             	shr    $0x18,%eax
    if (first_octet <= 127) {
  803447:	83 c4 10             	add    $0x10,%esp
  80344a:	84 c0                	test   %al,%al
  80344c:	79 1c                	jns    80346a <dhcp_bind+0x159>
    } else if (first_octet >= 192) {
  80344e:	3c bf                	cmp    $0xbf,%al
  803450:	76 30                	jbe    803482 <dhcp_bind+0x171>
      sn_mask.addr = htonl(0xffffff00);
  803452:	83 ec 0c             	sub    $0xc,%esp
  803455:	68 00 ff ff ff       	push   $0xffffff00
  80345a:	e8 1c 45 00 00       	call   80797b <htonl>
  80345f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  803462:	83 c4 10             	add    $0x10,%esp
  803465:	e9 40 ff ff ff       	jmp    8033aa <dhcp_bind+0x99>
      sn_mask.addr = htonl(0xff000000);
  80346a:	83 ec 0c             	sub    $0xc,%esp
  80346d:	68 00 00 00 ff       	push   $0xff000000
  803472:	e8 04 45 00 00       	call   80797b <htonl>
  803477:	89 45 f4             	mov    %eax,-0xc(%ebp)
  80347a:	83 c4 10             	add    $0x10,%esp
  80347d:	e9 28 ff ff ff       	jmp    8033aa <dhcp_bind+0x99>
      sn_mask.addr = htonl(0xffff0000);
  803482:	83 ec 0c             	sub    $0xc,%esp
  803485:	68 00 00 ff ff       	push   $0xffff0000
  80348a:	e8 ec 44 00 00       	call   80797b <htonl>
  80348f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  803492:	83 c4 10             	add    $0x10,%esp
  803495:	e9 10 ff ff ff       	jmp    8033aa <dhcp_bind+0x99>
    gw_addr.addr = (dhcp->offered_ip_addr.addr & sn_mask.addr);
  80349a:	8b 43 30             	mov    0x30(%ebx),%eax
  80349d:	23 45 f4             	and    -0xc(%ebp),%eax
  8034a0:	89 45 f0             	mov    %eax,-0x10(%ebp)
    gw_addr.addr |= htonl(0x00000001);
  8034a3:	83 ec 0c             	sub    $0xc,%esp
  8034a6:	6a 01                	push   $0x1
  8034a8:	e8 ce 44 00 00       	call   80797b <htonl>
  8034ad:	09 45 f0             	or     %eax,-0x10(%ebp)
  8034b0:	83 c4 10             	add    $0x10,%esp
  8034b3:	e9 00 ff ff ff       	jmp    8033b8 <dhcp_bind+0xa7>
    dhcp->t2_timeout = (u16_t)timeout;
  8034b8:	66 c7 43 2a ff ff    	movw   $0xffff,0x2a(%ebx)
  8034be:	e9 d9 fe ff ff       	jmp    80339c <dhcp_bind+0x8b>
    dhcp->t1_timeout = (u16_t)timeout;
  8034c3:	66 c7 43 28 ff ff    	movw   $0xffff,0x28(%ebx)
  8034c9:	e9 97 fe ff ff       	jmp    803365 <dhcp_bind+0x54>

008034ce <dhcp_free_reply>:
{
  8034ce:	55                   	push   %ebp
  8034cf:	89 e5                	mov    %esp,%ebp
  8034d1:	53                   	push   %ebx
  8034d2:	83 ec 04             	sub    $0x4,%esp
  8034d5:	89 c3                	mov    %eax,%ebx
  if (dhcp->msg_in != NULL) {
  8034d7:	8b 40 10             	mov    0x10(%eax),%eax
  8034da:	85 c0                	test   %eax,%eax
  8034dc:	74 13                	je     8034f1 <dhcp_free_reply+0x23>
    mem_free((void *)dhcp->msg_in);
  8034de:	83 ec 0c             	sub    $0xc,%esp
  8034e1:	50                   	push   %eax
  8034e2:	e8 05 0c 00 00       	call   8040ec <mem_free>
    dhcp->msg_in = NULL;
  8034e7:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  8034ee:	83 c4 10             	add    $0x10,%esp
  if (dhcp->options_in) {
  8034f1:	8b 43 14             	mov    0x14(%ebx),%eax
  8034f4:	85 c0                	test   %eax,%eax
  8034f6:	74 19                	je     803511 <dhcp_free_reply+0x43>
    mem_free((void *)dhcp->options_in);
  8034f8:	83 ec 0c             	sub    $0xc,%esp
  8034fb:	50                   	push   %eax
  8034fc:	e8 eb 0b 00 00       	call   8040ec <mem_free>
    dhcp->options_in = NULL;
  803501:	c7 43 14 00 00 00 00 	movl   $0x0,0x14(%ebx)
    dhcp->options_in_len = 0;
  803508:	66 c7 43 18 00 00    	movw   $0x0,0x18(%ebx)
  80350e:	83 c4 10             	add    $0x10,%esp
}
  803511:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  803514:	c9                   	leave  
  803515:	c3                   	ret    

00803516 <dhcp_recv>:
{
  803516:	f3 0f 1e fb          	endbr32 
  80351a:	55                   	push   %ebp
  80351b:	89 e5                	mov    %esp,%ebp
  80351d:	57                   	push   %edi
  80351e:	56                   	push   %esi
  80351f:	53                   	push   %ebx
  803520:	83 ec 1c             	sub    $0x1c,%esp
  struct dhcp *dhcp = netif->dhcp;
  803523:	8b 45 08             	mov    0x8(%ebp),%eax
  803526:	8b 78 20             	mov    0x20(%eax),%edi
  struct dhcp_msg *reply_msg = (struct dhcp_msg *)p->payload;
  803529:	8b 45 10             	mov    0x10(%ebp),%eax
  80352c:	8b 70 04             	mov    0x4(%eax),%esi
  80352f:	89 75 e4             	mov    %esi,-0x1c(%ebp)
  dhcp->p = p;
  803532:	89 47 0c             	mov    %eax,0xc(%edi)
  if (reply_msg->op != DHCP_BOOTREPLY) {
  803535:	80 3e 02             	cmpb   $0x2,(%esi)
  803538:	75 26                	jne    803560 <dhcp_recv+0x4a>
  80353a:	8b 45 08             	mov    0x8(%ebp),%eax
  80353d:	83 c0 25             	add    $0x25,%eax
  803540:	8d 56 1c             	lea    0x1c(%esi),%edx
  803543:	8b 4d 08             	mov    0x8(%ebp),%ecx
  803546:	0f b6 71 24          	movzbl 0x24(%ecx),%esi
  80354a:	01 c6                	add    %eax,%esi
  for (i = 0; i < netif->hwaddr_len; i++) {
  80354c:	39 f0                	cmp    %esi,%eax
  80354e:	74 2a                	je     80357a <dhcp_recv+0x64>
    if (netif->hwaddr[i] != reply_msg->chaddr[i]) {
  803550:	0f b6 18             	movzbl (%eax),%ebx
  803553:	0f b6 0a             	movzbl (%edx),%ecx
  803556:	83 c0 01             	add    $0x1,%eax
  803559:	83 c2 01             	add    $0x1,%edx
  80355c:	38 cb                	cmp    %cl,%bl
  80355e:	74 ec                	je     80354c <dhcp_recv+0x36>
  pbuf_free(p);
  803560:	83 ec 0c             	sub    $0xc,%esp
  803563:	ff 75 10             	pushl  0x10(%ebp)
  803566:	e8 b6 14 00 00       	call   804a21 <pbuf_free>
  dhcp->p = NULL;
  80356b:	c7 47 0c 00 00 00 00 	movl   $0x0,0xc(%edi)
}
  803572:	8d 65 f4             	lea    -0xc(%ebp),%esp
  803575:	5b                   	pop    %ebx
  803576:	5e                   	pop    %esi
  803577:	5f                   	pop    %edi
  803578:	5d                   	pop    %ebp
  803579:	c3                   	ret    
  if (ntohl(reply_msg->xid) != dhcp->xid) {
  80357a:	83 ec 0c             	sub    $0xc,%esp
  80357d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  803580:	ff 70 04             	pushl  0x4(%eax)
  803583:	e8 20 46 00 00       	call   807ba8 <ntohl>
  803588:	83 c4 10             	add    $0x10,%esp
  80358b:	3b 47 04             	cmp    0x4(%edi),%eax
  80358e:	75 d0                	jne    803560 <dhcp_recv+0x4a>
  LWIP_ERROR("dhcp->p != NULL", (dhcp->p != NULL), return ERR_VAL;);
  803590:	83 7f 0c 00          	cmpl   $0x0,0xc(%edi)
  803594:	0f 84 17 01 00 00    	je     8036b1 <dhcp_recv+0x19b>
  dhcp_free_reply(dhcp);
  80359a:	89 f8                	mov    %edi,%eax
  80359c:	e8 2d ff ff ff       	call   8034ce <dhcp_free_reply>
  if (dhcp->p->tot_len > (sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN)) {
  8035a1:	8b 47 0c             	mov    0xc(%edi),%eax
  8035a4:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  8035a8:	66 3d f0 00          	cmp    $0xf0,%ax
  8035ac:	76 1e                	jbe    8035cc <dhcp_recv+0xb6>
    dhcp->options_in_len = dhcp->p->tot_len - (sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  8035ae:	66 2d f0 00          	sub    $0xf0,%ax
  8035b2:	66 89 47 18          	mov    %ax,0x18(%edi)
    dhcp->options_in = mem_malloc(dhcp->options_in_len);
  8035b6:	83 ec 0c             	sub    $0xc,%esp
  8035b9:	0f b7 c0             	movzwl %ax,%eax
  8035bc:	50                   	push   %eax
  8035bd:	e8 21 0e 00 00       	call   8043e3 <mem_malloc>
  8035c2:	89 47 14             	mov    %eax,0x14(%edi)
    if (dhcp->options_in == NULL) {
  8035c5:	83 c4 10             	add    $0x10,%esp
  8035c8:	85 c0                	test   %eax,%eax
  8035ca:	74 94                	je     803560 <dhcp_recv+0x4a>
  dhcp->msg_in = mem_malloc(sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  8035cc:	83 ec 0c             	sub    $0xc,%esp
  8035cf:	68 f0 00 00 00       	push   $0xf0
  8035d4:	e8 0a 0e 00 00       	call   8043e3 <mem_malloc>
  8035d9:	89 47 10             	mov    %eax,0x10(%edi)
  if (dhcp->msg_in == NULL) {
  8035dc:	83 c4 10             	add    $0x10,%esp
  8035df:	85 c0                	test   %eax,%eax
  8035e1:	0f 84 e1 00 00 00    	je     8036c8 <dhcp_recv+0x1b2>
  ret = pbuf_copy_partial(dhcp->p, dhcp->msg_in, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN, 0);
  8035e7:	6a 00                	push   $0x0
  8035e9:	68 f0 00 00 00       	push   $0xf0
  8035ee:	50                   	push   %eax
  8035ef:	ff 77 0c             	pushl  0xc(%edi)
  8035f2:	e8 b3 1b 00 00       	call   8051aa <pbuf_copy_partial>
  LWIP_ASSERT("ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN", ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  8035f7:	83 c4 10             	add    $0x10,%esp
  8035fa:	66 3d f0 00          	cmp    $0xf0,%ax
  8035fe:	0f 85 de 00 00 00    	jne    8036e2 <dhcp_recv+0x1cc>
  if (dhcp->options_in != NULL) {
  803604:	8b 47 14             	mov    0x14(%edi),%eax
  803607:	85 c0                	test   %eax,%eax
  803609:	74 20                	je     80362b <dhcp_recv+0x115>
    ret = pbuf_copy_partial(dhcp->p, dhcp->options_in, dhcp->options_in_len, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  80360b:	68 f0 00 00 00       	push   $0xf0
  803610:	0f b7 57 18          	movzwl 0x18(%edi),%edx
  803614:	52                   	push   %edx
  803615:	50                   	push   %eax
  803616:	ff 77 0c             	pushl  0xc(%edi)
  803619:	e8 8c 1b 00 00       	call   8051aa <pbuf_copy_partial>
    LWIP_ASSERT("ret == dhcp->options_in_len", ret == dhcp->options_in_len);
  80361e:	83 c4 10             	add    $0x10,%esp
  803621:	66 3b 47 18          	cmp    0x18(%edi),%ax
  803625:	0f 85 ce 00 00 00    	jne    8036f9 <dhcp_recv+0x1e3>
  options_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_MESSAGE_TYPE);
  80362b:	ba 35 00 00 00       	mov    $0x35,%edx
  803630:	89 f8                	mov    %edi,%eax
  803632:	e8 e9 f2 ff ff       	call   802920 <dhcp_get_option_ptr>
  if (options_ptr == NULL) {
  803637:	85 c0                	test   %eax,%eax
  803639:	0f 84 21 ff ff ff    	je     803560 <dhcp_recv+0x4a>
  return *ptr;
  80363f:	0f b6 40 02          	movzbl 0x2(%eax),%eax
  if (msg_type == DHCP_ACK) {
  803643:	3c 05                	cmp    $0x5,%al
  803645:	0f 84 c5 00 00 00    	je     803710 <dhcp_recv+0x1fa>
  else if ((msg_type == DHCP_NAK) &&
  80364b:	3c 06                	cmp    $0x6,%al
  80364d:	0f 84 5a 02 00 00    	je     8038ad <dhcp_recv+0x397>
  else if ((msg_type == DHCP_OFFER) && (dhcp->state == DHCP_SELECTING)) {
  803653:	3c 02                	cmp    $0x2,%al
  803655:	0f 85 05 ff ff ff    	jne    803560 <dhcp_recv+0x4a>
  80365b:	80 3f 06             	cmpb   $0x6,(%edi)
  80365e:	0f 85 fc fe ff ff    	jne    803560 <dhcp_recv+0x4a>
    dhcp->request_timeout = 0;
  803664:	66 c7 47 26 00 00    	movw   $0x0,0x26(%edi)
  struct dhcp *dhcp = netif->dhcp;
  80366a:	8b 45 08             	mov    0x8(%ebp),%eax
  80366d:	8b 58 20             	mov    0x20(%eax),%ebx
  u8_t *option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_SERVER_ID);
  803670:	ba 36 00 00 00       	mov    $0x36,%edx
  803675:	89 d8                	mov    %ebx,%eax
  803677:	e8 a4 f2 ff ff       	call   802920 <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  80367c:	85 c0                	test   %eax,%eax
  80367e:	0f 84 dc fe ff ff    	je     803560 <dhcp_recv+0x4a>
    dhcp->server_ip_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  803684:	83 c0 02             	add    $0x2,%eax
  803687:	e8 a0 f3 ff ff       	call   802a2c <dhcp_get_option_long>
  80368c:	83 ec 0c             	sub    $0xc,%esp
  80368f:	50                   	push   %eax
  803690:	e8 e6 42 00 00       	call   80797b <htonl>
  803695:	89 43 2c             	mov    %eax,0x2c(%ebx)
    ip_addr_set(&dhcp->offered_ip_addr, (struct ip_addr *)&dhcp->msg_in->yiaddr);
  803698:	8b 43 10             	mov    0x10(%ebx),%eax
  80369b:	8b 40 10             	mov    0x10(%eax),%eax
  80369e:	89 43 30             	mov    %eax,0x30(%ebx)
    dhcp_select(netif);
  8036a1:	8b 45 08             	mov    0x8(%ebp),%eax
  8036a4:	e8 b8 fa ff ff       	call   803161 <dhcp_select>
  8036a9:	83 c4 10             	add    $0x10,%esp
  8036ac:	e9 af fe ff ff       	jmp    803560 <dhcp_recv+0x4a>
  LWIP_ERROR("dhcp->p != NULL", (dhcp->p != NULL), return ERR_VAL;);
  8036b1:	83 ec 04             	sub    $0x4,%esp
  8036b4:	68 a8 1b 81 00       	push   $0x811ba8
  8036b9:	68 8a 04 00 00       	push   $0x48a
  8036be:	68 62 1b 81 00       	push   $0x811b62
  8036c3:	e8 7f b2 00 00       	call   80e947 <_panic>
    mem_free((void *)dhcp->options_in);
  8036c8:	83 ec 0c             	sub    $0xc,%esp
  8036cb:	ff 77 14             	pushl  0x14(%edi)
  8036ce:	e8 19 0a 00 00       	call   8040ec <mem_free>
    dhcp->options_in = NULL;
  8036d3:	c7 47 14 00 00 00 00 	movl   $0x0,0x14(%edi)
    return ERR_MEM;
  8036da:	83 c4 10             	add    $0x10,%esp
  8036dd:	e9 7e fe ff ff       	jmp    803560 <dhcp_recv+0x4a>
  LWIP_ASSERT("ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN", ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  8036e2:	83 ec 04             	sub    $0x4,%esp
  8036e5:	68 30 1b 81 00       	push   $0x811b30
  8036ea:	68 a0 04 00 00       	push   $0x4a0
  8036ef:	68 62 1b 81 00       	push   $0x811b62
  8036f4:	e8 4e b2 00 00       	call   80e947 <_panic>
    LWIP_ASSERT("ret == dhcp->options_in_len", ret == dhcp->options_in_len);
  8036f9:	83 ec 04             	sub    $0x4,%esp
  8036fc:	68 b8 1b 81 00       	push   $0x811bb8
  803701:	68 a7 04 00 00       	push   $0x4a7
  803706:	68 62 1b 81 00       	push   $0x811b62
  80370b:	e8 37 b2 00 00       	call   80e947 <_panic>
    if (dhcp->state == DHCP_REQUESTING) {
  803710:	0f b6 07             	movzbl (%edi),%eax
  803713:	3c 01                	cmp    $0x1,%al
  803715:	74 1e                	je     803735 <dhcp_recv+0x21f>
    else if ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING)) {
  803717:	83 e8 03             	sub    $0x3,%eax
  80371a:	3c 02                	cmp    $0x2,%al
  80371c:	0f 87 3e fe ff ff    	ja     803560 <dhcp_recv+0x4a>
      dhcp->request_timeout = 0;
  803722:	66 c7 47 26 00 00    	movw   $0x0,0x26(%edi)
      dhcp_bind(netif);
  803728:	8b 45 08             	mov    0x8(%ebp),%eax
  80372b:	e8 e1 fb ff ff       	call   803311 <dhcp_bind>
  803730:	e9 2b fe ff ff       	jmp    803560 <dhcp_recv+0x4a>
  struct dhcp *dhcp = netif->dhcp;
  803735:	8b 45 08             	mov    0x8(%ebp),%eax
  803738:	8b 70 20             	mov    0x20(%eax),%esi
  dhcp->offered_sn_mask.addr = 0;
  80373b:	c7 46 34 00 00 00 00 	movl   $0x0,0x34(%esi)
  dhcp->offered_gw_addr.addr = 0;
  803742:	c7 46 38 00 00 00 00 	movl   $0x0,0x38(%esi)
  dhcp->offered_bc_addr.addr = 0;
  803749:	c7 46 3c 00 00 00 00 	movl   $0x0,0x3c(%esi)
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_LEASE_TIME);
  803750:	ba 33 00 00 00       	mov    $0x33,%edx
  803755:	89 f0                	mov    %esi,%eax
  803757:	e8 c4 f1 ff ff       	call   802920 <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  80375c:	85 c0                	test   %eax,%eax
  80375e:	74 0b                	je     80376b <dhcp_recv+0x255>
    dhcp->offered_t0_lease = dhcp_get_option_long(option_ptr + 2);
  803760:	83 c0 02             	add    $0x2,%eax
  803763:	e8 c4 f2 ff ff       	call   802a2c <dhcp_get_option_long>
  803768:	89 46 4c             	mov    %eax,0x4c(%esi)
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_T1);
  80376b:	ba 3a 00 00 00       	mov    $0x3a,%edx
  803770:	89 f0                	mov    %esi,%eax
  803772:	e8 a9 f1 ff ff       	call   802920 <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  803777:	85 c0                	test   %eax,%eax
  803779:	0f 84 dc 00 00 00    	je     80385b <dhcp_recv+0x345>
    dhcp->offered_t1_renew = dhcp_get_option_long(option_ptr + 2);
  80377f:	83 c0 02             	add    $0x2,%eax
  803782:	e8 a5 f2 ff ff       	call   802a2c <dhcp_get_option_long>
  803787:	89 46 50             	mov    %eax,0x50(%esi)
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_T2);
  80378a:	ba 3b 00 00 00       	mov    $0x3b,%edx
  80378f:	89 f0                	mov    %esi,%eax
  803791:	e8 8a f1 ff ff       	call   802920 <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  803796:	85 c0                	test   %eax,%eax
  803798:	0f 84 c7 00 00 00    	je     803865 <dhcp_recv+0x34f>
    dhcp->offered_t2_rebind = dhcp_get_option_long(option_ptr + 2);
  80379e:	83 c0 02             	add    $0x2,%eax
  8037a1:	e8 86 f2 ff ff       	call   802a2c <dhcp_get_option_long>
  8037a6:	89 46 54             	mov    %eax,0x54(%esi)
  ip_addr_set(&dhcp->offered_ip_addr, &dhcp->msg_in->yiaddr);
  8037a9:	8b 46 10             	mov    0x10(%esi),%eax
  8037ac:	8b 40 10             	mov    0x10(%eax),%eax
  8037af:	89 46 30             	mov    %eax,0x30(%esi)
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_SUBNET_MASK);
  8037b2:	ba 01 00 00 00       	mov    $0x1,%edx
  8037b7:	89 f0                	mov    %esi,%eax
  8037b9:	e8 62 f1 ff ff       	call   802920 <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  8037be:	85 c0                	test   %eax,%eax
  8037c0:	74 17                	je     8037d9 <dhcp_recv+0x2c3>
    dhcp->offered_sn_mask.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  8037c2:	83 c0 02             	add    $0x2,%eax
  8037c5:	e8 62 f2 ff ff       	call   802a2c <dhcp_get_option_long>
  8037ca:	83 ec 0c             	sub    $0xc,%esp
  8037cd:	50                   	push   %eax
  8037ce:	e8 a8 41 00 00       	call   80797b <htonl>
  8037d3:	89 46 34             	mov    %eax,0x34(%esi)
  8037d6:	83 c4 10             	add    $0x10,%esp
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_ROUTER);
  8037d9:	ba 03 00 00 00       	mov    $0x3,%edx
  8037de:	89 f0                	mov    %esi,%eax
  8037e0:	e8 3b f1 ff ff       	call   802920 <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  8037e5:	85 c0                	test   %eax,%eax
  8037e7:	74 17                	je     803800 <dhcp_recv+0x2ea>
    dhcp->offered_gw_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  8037e9:	83 c0 02             	add    $0x2,%eax
  8037ec:	e8 3b f2 ff ff       	call   802a2c <dhcp_get_option_long>
  8037f1:	83 ec 0c             	sub    $0xc,%esp
  8037f4:	50                   	push   %eax
  8037f5:	e8 81 41 00 00       	call   80797b <htonl>
  8037fa:	89 46 38             	mov    %eax,0x38(%esi)
  8037fd:	83 c4 10             	add    $0x10,%esp
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_BROADCAST);
  803800:	ba 1c 00 00 00       	mov    $0x1c,%edx
  803805:	89 f0                	mov    %esi,%eax
  803807:	e8 14 f1 ff ff       	call   802920 <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  80380c:	85 c0                	test   %eax,%eax
  80380e:	74 17                	je     803827 <dhcp_recv+0x311>
    dhcp->offered_bc_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  803810:	83 c0 02             	add    $0x2,%eax
  803813:	e8 14 f2 ff ff       	call   802a2c <dhcp_get_option_long>
  803818:	83 ec 0c             	sub    $0xc,%esp
  80381b:	50                   	push   %eax
  80381c:	e8 5a 41 00 00       	call   80797b <htonl>
  803821:	89 46 3c             	mov    %eax,0x3c(%esi)
  803824:	83 c4 10             	add    $0x10,%esp
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_DNS_SERVER);
  803827:	ba 06 00 00 00       	mov    $0x6,%edx
  80382c:	89 f0                	mov    %esi,%eax
  80382e:	e8 ed f0 ff ff       	call   802920 <dhcp_get_option_ptr>
  803833:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if (option_ptr != NULL) {
  803836:	85 c0                	test   %eax,%eax
  803838:	74 60                	je     80389a <dhcp_recv+0x384>
    dhcp->dns_count = dhcp_get_option_byte(&option_ptr[1]) / (u32_t)sizeof(struct ip_addr);
  80383a:	0f b6 40 01          	movzbl 0x1(%eax),%eax
  80383e:	c0 e8 02             	shr    $0x2,%al
  803841:	0f b6 d0             	movzbl %al,%edx
  803844:	3c 02                	cmp    $0x2,%al
  803846:	b8 02 00 00 00       	mov    $0x2,%eax
  80384b:	0f 46 c2             	cmovbe %edx,%eax
  80384e:	89 46 40             	mov    %eax,0x40(%esi)
{
  803851:	bb 00 00 00 00       	mov    $0x0,%ebx
  803856:	89 7d e0             	mov    %edi,-0x20(%ebp)
  803859:	eb 34                	jmp    80388f <dhcp_recv+0x379>
    dhcp->offered_t1_renew = dhcp->offered_t0_lease / 2;
  80385b:	8b 46 4c             	mov    0x4c(%esi),%eax
  80385e:	d1 e8                	shr    %eax
  803860:	e9 22 ff ff ff       	jmp    803787 <dhcp_recv+0x271>
    dhcp->offered_t2_rebind = dhcp->offered_t0_lease;
  803865:	8b 46 4c             	mov    0x4c(%esi),%eax
  803868:	e9 39 ff ff ff       	jmp    8037a6 <dhcp_recv+0x290>
      dhcp->offered_dns_addr[n].addr = htonl(dhcp_get_option_long(&option_ptr[2 + n * 4]));
  80386d:	0f b6 fb             	movzbl %bl,%edi
  803870:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  803873:	8d 44 b8 02          	lea    0x2(%eax,%edi,4),%eax
  803877:	e8 b0 f1 ff ff       	call   802a2c <dhcp_get_option_long>
  80387c:	83 ec 0c             	sub    $0xc,%esp
  80387f:	50                   	push   %eax
  803880:	e8 f6 40 00 00       	call   80797b <htonl>
  803885:	89 44 be 44          	mov    %eax,0x44(%esi,%edi,4)
    for (n = 0; n < dhcp->dns_count; n++) {
  803889:	83 c3 01             	add    $0x1,%ebx
  80388c:	83 c4 10             	add    $0x10,%esp
  80388f:	0f b6 c3             	movzbl %bl,%eax
  803892:	3b 46 40             	cmp    0x40(%esi),%eax
  803895:	72 d6                	jb     80386d <dhcp_recv+0x357>
  803897:	8b 7d e0             	mov    -0x20(%ebp),%edi
      dhcp->request_timeout = 0;
  80389a:	66 c7 47 26 00 00    	movw   $0x0,0x26(%edi)
      dhcp_check(netif);
  8038a0:	8b 45 08             	mov    0x8(%ebp),%eax
  8038a3:	e8 35 fa ff ff       	call   8032dd <dhcp_check>
  8038a8:	e9 b3 fc ff ff       	jmp    803560 <dhcp_recv+0x4a>
    ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
  8038ad:	0f b6 07             	movzbl (%edi),%eax
  8038b0:	8d 50 fd             	lea    -0x3(%eax),%edx
     (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING  ))) {
  8038b3:	80 fa 02             	cmp    $0x2,%dl
  8038b6:	76 08                	jbe    8038c0 <dhcp_recv+0x3aa>
  8038b8:	3c 01                	cmp    $0x1,%al
  8038ba:	0f 85 a0 fc ff ff    	jne    803560 <dhcp_recv+0x4a>
    dhcp->request_timeout = 0;
  8038c0:	66 c7 47 26 00 00    	movw   $0x0,0x26(%edi)
  struct dhcp *dhcp = netif->dhcp;
  8038c6:	8b 45 08             	mov    0x8(%ebp),%eax
  8038c9:	8b 58 20             	mov    0x20(%eax),%ebx
  netif_set_down(netif);
  8038cc:	83 ec 0c             	sub    $0xc,%esp
  8038cf:	50                   	push   %eax
  8038d0:	e8 4c 10 00 00       	call   804921 <netif_set_down>
  netif_set_ipaddr(netif, IP_ADDR_ANY);
  8038d5:	83 c4 08             	add    $0x8,%esp
  8038d8:	68 08 24 81 00       	push   $0x812408
  8038dd:	ff 75 08             	pushl  0x8(%ebp)
  8038e0:	e8 82 0e 00 00       	call   804767 <netif_set_ipaddr>
  netif_set_gw(netif, IP_ADDR_ANY);
  8038e5:	83 c4 08             	add    $0x8,%esp
  8038e8:	68 08 24 81 00       	push   $0x812408
  8038ed:	ff 75 08             	pushl  0x8(%ebp)
  8038f0:	e8 aa 0f 00 00       	call   80489f <netif_set_gw>
  netif_set_netmask(netif, IP_ADDR_ANY); 
  8038f5:	83 c4 08             	add    $0x8,%esp
  8038f8:	68 08 24 81 00       	push   $0x812408
  8038fd:	ff 75 08             	pushl  0x8(%ebp)
  803900:	e8 b7 0f 00 00       	call   8048bc <netif_set_netmask>
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
  803905:	ba 0c 00 00 00       	mov    $0xc,%edx
  80390a:	89 d8                	mov    %ebx,%eax
  80390c:	e8 04 f0 ff ff       	call   802915 <dhcp_set_state>
  dhcp_discover(netif);
  803911:	8b 45 08             	mov    0x8(%ebp),%eax
  803914:	e8 09 f7 ff ff       	call   803022 <dhcp_discover>
}
  803919:	83 c4 10             	add    $0x10,%esp
  80391c:	e9 3f fc ff ff       	jmp    803560 <dhcp_recv+0x4a>

00803921 <dhcp_inform>:
{
  803921:	f3 0f 1e fb          	endbr32 
  803925:	55                   	push   %ebp
  803926:	89 e5                	mov    %esp,%ebp
  803928:	57                   	push   %edi
  803929:	56                   	push   %esi
  80392a:	53                   	push   %ebx
  80392b:	83 ec 18             	sub    $0x18,%esp
  80392e:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp, *old_dhcp = netif->dhcp;
  803931:	8b 7e 20             	mov    0x20(%esi),%edi
  dhcp = mem_malloc(sizeof(struct dhcp));
  803934:	6a 58                	push   $0x58
  803936:	e8 a8 0a 00 00       	call   8043e3 <mem_malloc>
  if (dhcp == NULL) {
  80393b:	83 c4 10             	add    $0x10,%esp
  80393e:	85 c0                	test   %eax,%eax
  803940:	74 55                	je     803997 <dhcp_inform+0x76>
  803942:	89 c3                	mov    %eax,%ebx
  netif->dhcp = dhcp;
  803944:	89 46 20             	mov    %eax,0x20(%esi)
  memset(dhcp, 0, sizeof(struct dhcp));
  803947:	83 ec 04             	sub    $0x4,%esp
  80394a:	6a 58                	push   $0x58
  80394c:	6a 00                	push   $0x0
  80394e:	50                   	push   %eax
  80394f:	e8 4e b8 00 00       	call   80f1a2 <memset>
  dhcp->pcb = udp_new();
  803954:	e8 59 59 00 00       	call   8092b2 <udp_new>
  803959:	89 43 08             	mov    %eax,0x8(%ebx)
  if (dhcp->pcb == NULL) {
  80395c:	83 c4 10             	add    $0x10,%esp
  80395f:	85 c0                	test   %eax,%eax
  803961:	74 3c                	je     80399f <dhcp_inform+0x7e>
  result = dhcp_create_request(netif);
  803963:	89 f0                	mov    %esi,%eax
  803965:	e8 38 f3 ff ff       	call   802ca2 <dhcp_create_request>
  if (result == ERR_OK) {
  80396a:	84 c0                	test   %al,%al
  80396c:	74 3f                	je     8039ad <dhcp_inform+0x8c>
    if (dhcp->pcb != NULL) {
  80396e:	8b 43 08             	mov    0x8(%ebx),%eax
  803971:	85 c0                	test   %eax,%eax
  803973:	74 0c                	je     803981 <dhcp_inform+0x60>
      udp_remove(dhcp->pcb);
  803975:	83 ec 0c             	sub    $0xc,%esp
  803978:	50                   	push   %eax
  803979:	e8 ec 58 00 00       	call   80926a <udp_remove>
  80397e:	83 c4 10             	add    $0x10,%esp
    dhcp->pcb = NULL;
  803981:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    mem_free((void *)dhcp);
  803988:	83 ec 0c             	sub    $0xc,%esp
  80398b:	53                   	push   %ebx
  80398c:	e8 5b 07 00 00       	call   8040ec <mem_free>
    netif->dhcp = old_dhcp;
  803991:	89 7e 20             	mov    %edi,0x20(%esi)
  803994:	83 c4 10             	add    $0x10,%esp
}
  803997:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80399a:	5b                   	pop    %ebx
  80399b:	5e                   	pop    %esi
  80399c:	5f                   	pop    %edi
  80399d:	5d                   	pop    %ebp
  80399e:	c3                   	ret    
    mem_free((void *)dhcp);
  80399f:	83 ec 0c             	sub    $0xc,%esp
  8039a2:	53                   	push   %ebx
  8039a3:	e8 44 07 00 00       	call   8040ec <mem_free>
    return;
  8039a8:	83 c4 10             	add    $0x10,%esp
  8039ab:	eb ea                	jmp    803997 <dhcp_inform+0x76>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  8039ad:	b9 01 00 00 00       	mov    $0x1,%ecx
  8039b2:	ba 35 00 00 00       	mov    $0x35,%edx
  8039b7:	89 d8                	mov    %ebx,%eax
  8039b9:	e8 d2 f0 ff ff       	call   802a90 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_INFORM);
  8039be:	ba 08 00 00 00       	mov    $0x8,%edx
  8039c3:	89 d8                	mov    %ebx,%eax
  8039c5:	e8 85 f0 ff ff       	call   802a4f <dhcp_option_byte>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  8039ca:	b9 02 00 00 00       	mov    $0x2,%ecx
  8039cf:	ba 39 00 00 00       	mov    $0x39,%edx
  8039d4:	89 d8                	mov    %ebx,%eax
  8039d6:	e8 b5 f0 ff ff       	call   802a90 <dhcp_option>
    dhcp_option_short(dhcp, 576);
  8039db:	ba 40 02 00 00       	mov    $0x240,%edx
  8039e0:	89 d8                	mov    %ebx,%eax
  8039e2:	e8 10 f1 ff ff       	call   802af7 <dhcp_option_short>
    dhcp_option_trailer(dhcp);
  8039e7:	89 d8                	mov    %ebx,%eax
  8039e9:	e8 67 f1 ff ff       	call   802b55 <dhcp_option_trailer>
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  8039ee:	83 ec 08             	sub    $0x8,%esp
  8039f1:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  8039f5:	66 05 f0 00          	add    $0xf0,%ax
  8039f9:	0f b7 c0             	movzwl %ax,%eax
  8039fc:	50                   	push   %eax
  8039fd:	ff 73 1c             	pushl  0x1c(%ebx)
  803a00:	e8 45 13 00 00       	call   804d4a <pbuf_realloc>
    udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
  803a05:	83 c4 0c             	add    $0xc,%esp
  803a08:	6a 44                	push   $0x44
  803a0a:	68 08 24 81 00       	push   $0x812408
  803a0f:	ff 73 08             	pushl  0x8(%ebx)
  803a12:	e8 e7 54 00 00       	call   808efe <udp_bind>
    udp_connect(dhcp->pcb, IP_ADDR_BROADCAST, DHCP_SERVER_PORT);
  803a17:	83 c4 0c             	add    $0xc,%esp
  803a1a:	6a 43                	push   $0x43
  803a1c:	68 04 24 81 00       	push   $0x812404
  803a21:	ff 73 08             	pushl  0x8(%ebx)
  803a24:	e8 95 57 00 00       	call   8091be <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  803a29:	89 34 24             	mov    %esi,(%esp)
  803a2c:	6a 43                	push   $0x43
  803a2e:	68 04 24 81 00       	push   $0x812404
  803a33:	ff 73 1c             	pushl  0x1c(%ebx)
  803a36:	ff 73 08             	pushl  0x8(%ebx)
  803a39:	e8 7f 55 00 00       	call   808fbd <udp_sendto_if>
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  803a3e:	83 c4 1c             	add    $0x1c,%esp
  803a41:	6a 43                	push   $0x43
  803a43:	68 08 24 81 00       	push   $0x812408
  803a48:	ff 73 08             	pushl  0x8(%ebx)
  803a4b:	e8 6e 57 00 00       	call   8091be <udp_connect>
    dhcp_delete_request(netif);
  803a50:	89 f0                	mov    %esi,%eax
  803a52:	e8 3e f4 ff ff       	call   802e95 <dhcp_delete_request>
  803a57:	83 c4 10             	add    $0x10,%esp
  803a5a:	e9 0f ff ff ff       	jmp    80396e <dhcp_inform+0x4d>

00803a5f <dhcp_arp_reply>:
{
  803a5f:	f3 0f 1e fb          	endbr32 
  803a63:	55                   	push   %ebp
  803a64:	89 e5                	mov    %esp,%ebp
  803a66:	56                   	push   %esi
  803a67:	53                   	push   %ebx
  803a68:	8b 75 08             	mov    0x8(%ebp),%esi
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  803a6b:	85 f6                	test   %esi,%esi
  803a6d:	74 13                	je     803a82 <dhcp_arp_reply+0x23>
  if ((netif->dhcp != NULL) && (netif->dhcp->state == DHCP_CHECKING)) {
  803a6f:	8b 5e 20             	mov    0x20(%esi),%ebx
  803a72:	85 db                	test   %ebx,%ebx
  803a74:	74 05                	je     803a7b <dhcp_arp_reply+0x1c>
  803a76:	80 3b 08             	cmpb   $0x8,(%ebx)
  803a79:	74 1e                	je     803a99 <dhcp_arp_reply+0x3a>
}
  803a7b:	8d 65 f8             	lea    -0x8(%ebp),%esp
  803a7e:	5b                   	pop    %ebx
  803a7f:	5e                   	pop    %esi
  803a80:	5d                   	pop    %ebp
  803a81:	c3                   	ret    
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  803a82:	83 ec 04             	sub    $0x4,%esp
  803a85:	68 82 1b 81 00       	push   $0x811b82
  803a8a:	68 b5 02 00 00       	push   $0x2b5
  803a8f:	68 62 1b 81 00       	push   $0x811b62
  803a94:	e8 ae ae 00 00       	call   80e947 <_panic>
    if (ip_addr_cmp(addr, &netif->dhcp->offered_ip_addr)) {
  803a99:	8b 45 0c             	mov    0xc(%ebp),%eax
  803a9c:	8b 4b 30             	mov    0x30(%ebx),%ecx
  803a9f:	39 08                	cmp    %ecx,(%eax)
  803aa1:	75 d8                	jne    803a7b <dhcp_arp_reply+0x1c>
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
  803aa3:	ba 0c 00 00 00       	mov    $0xc,%edx
  803aa8:	89 d8                	mov    %ebx,%eax
  803aaa:	e8 66 ee ff ff       	call   802915 <dhcp_set_state>
  result = dhcp_create_request(netif);
  803aaf:	89 f0                	mov    %esi,%eax
  803ab1:	e8 ec f1 ff ff       	call   802ca2 <dhcp_create_request>
  if (result == ERR_OK) {
  803ab6:	84 c0                	test   %al,%al
  803ab8:	74 0c                	je     803ac6 <dhcp_arp_reply+0x67>
  dhcp->tries++;
  803aba:	80 43 01 01          	addb   $0x1,0x1(%ebx)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  803abe:	66 c7 43 26 14 00    	movw   $0x14,0x26(%ebx)
  return result;
  803ac4:	eb b5                	jmp    803a7b <dhcp_arp_reply+0x1c>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  803ac6:	b9 01 00 00 00       	mov    $0x1,%ecx
  803acb:	ba 35 00 00 00       	mov    $0x35,%edx
  803ad0:	89 d8                	mov    %ebx,%eax
  803ad2:	e8 b9 ef ff ff       	call   802a90 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_DECLINE);
  803ad7:	ba 04 00 00 00       	mov    $0x4,%edx
  803adc:	89 d8                	mov    %ebx,%eax
  803ade:	e8 6c ef ff ff       	call   802a4f <dhcp_option_byte>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  803ae3:	b9 02 00 00 00       	mov    $0x2,%ecx
  803ae8:	ba 39 00 00 00       	mov    $0x39,%edx
  803aed:	89 d8                	mov    %ebx,%eax
  803aef:	e8 9c ef ff ff       	call   802a90 <dhcp_option>
    dhcp_option_short(dhcp, 576);
  803af4:	ba 40 02 00 00       	mov    $0x240,%edx
  803af9:	89 d8                	mov    %ebx,%eax
  803afb:	e8 f7 ef ff ff       	call   802af7 <dhcp_option_short>
    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
  803b00:	b9 04 00 00 00       	mov    $0x4,%ecx
  803b05:	ba 32 00 00 00       	mov    $0x32,%edx
  803b0a:	89 d8                	mov    %ebx,%eax
  803b0c:	e8 7f ef ff ff       	call   802a90 <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->offered_ip_addr.addr));
  803b11:	83 ec 0c             	sub    $0xc,%esp
  803b14:	ff 73 30             	pushl  0x30(%ebx)
  803b17:	e8 8c 40 00 00       	call   807ba8 <ntohl>
  803b1c:	89 c2                	mov    %eax,%edx
  803b1e:	89 d8                	mov    %ebx,%eax
  803b20:	e8 e5 f0 ff ff       	call   802c0a <dhcp_option_long>
    dhcp_option_trailer(dhcp);
  803b25:	89 d8                	mov    %ebx,%eax
  803b27:	e8 29 f0 ff ff       	call   802b55 <dhcp_option_trailer>
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  803b2c:	83 c4 08             	add    $0x8,%esp
  803b2f:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  803b33:	66 05 f0 00          	add    $0xf0,%ax
  803b37:	0f b7 c0             	movzwl %ax,%eax
  803b3a:	50                   	push   %eax
  803b3b:	ff 73 1c             	pushl  0x1c(%ebx)
  803b3e:	e8 07 12 00 00       	call   804d4a <pbuf_realloc>
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  803b43:	83 c4 0c             	add    $0xc,%esp
  803b46:	6a 43                	push   $0x43
  803b48:	68 08 24 81 00       	push   $0x812408
  803b4d:	ff 73 08             	pushl  0x8(%ebx)
  803b50:	e8 69 56 00 00       	call   8091be <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  803b55:	89 34 24             	mov    %esi,(%esp)
  803b58:	6a 43                	push   $0x43
  803b5a:	68 04 24 81 00       	push   $0x812404
  803b5f:	ff 73 1c             	pushl  0x1c(%ebx)
  803b62:	ff 73 08             	pushl  0x8(%ebx)
  803b65:	e8 53 54 00 00       	call   808fbd <udp_sendto_if>
    dhcp_delete_request(netif);
  803b6a:	83 c4 20             	add    $0x20,%esp
  803b6d:	89 f0                	mov    %esi,%eax
  803b6f:	e8 21 f3 ff ff       	call   802e95 <dhcp_delete_request>
  803b74:	e9 41 ff ff ff       	jmp    803aba <dhcp_arp_reply+0x5b>

00803b79 <dhcp_renew>:
{
  803b79:	f3 0f 1e fb          	endbr32 
  803b7d:	55                   	push   %ebp
  803b7e:	89 e5                	mov    %esp,%ebp
  803b80:	57                   	push   %edi
  803b81:	56                   	push   %esi
  803b82:	53                   	push   %ebx
  803b83:	83 ec 1c             	sub    $0x1c,%esp
  803b86:	8b 7d 08             	mov    0x8(%ebp),%edi
  struct dhcp *dhcp = netif->dhcp;
  803b89:	8b 5f 20             	mov    0x20(%edi),%ebx
  dhcp_set_state(dhcp, DHCP_RENEWING);
  803b8c:	ba 05 00 00 00       	mov    $0x5,%edx
  803b91:	89 d8                	mov    %ebx,%eax
  803b93:	e8 7d ed ff ff       	call   802915 <dhcp_set_state>
  result = dhcp_create_request(netif);
  803b98:	89 f8                	mov    %edi,%eax
  803b9a:	e8 03 f1 ff ff       	call   802ca2 <dhcp_create_request>
  803b9f:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  803ba1:	84 c0                	test   %al,%al
  803ba3:	74 3e                	je     803be3 <dhcp_renew+0x6a>
  dhcp->tries++;
  803ba5:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  803ba9:	83 c0 01             	add    $0x1,%eax
  803bac:	88 43 01             	mov    %al,0x1(%ebx)
  msecs = dhcp->tries < 10 ? dhcp->tries * 2000 : 20 * 1000;
  803baf:	ba 20 4e 00 00       	mov    $0x4e20,%edx
  803bb4:	3c 09                	cmp    $0x9,%al
  803bb6:	77 08                	ja     803bc0 <dhcp_renew+0x47>
  803bb8:	0f b6 d0             	movzbl %al,%edx
  803bbb:	66 69 d2 d0 07       	imul   $0x7d0,%dx,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  803bc0:	0f b7 d2             	movzwl %dx,%edx
  803bc3:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  803bc9:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  803bce:	89 d0                	mov    %edx,%eax
  803bd0:	f7 e9                	imul   %ecx
  803bd2:	c1 fa 05             	sar    $0x5,%edx
  803bd5:	66 89 53 26          	mov    %dx,0x26(%ebx)
}
  803bd9:	89 f0                	mov    %esi,%eax
  803bdb:	8d 65 f4             	lea    -0xc(%ebp),%esp
  803bde:	5b                   	pop    %ebx
  803bdf:	5e                   	pop    %esi
  803be0:	5f                   	pop    %edi
  803be1:	5d                   	pop    %ebp
  803be2:	c3                   	ret    
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  803be3:	b9 01 00 00 00       	mov    $0x1,%ecx
  803be8:	ba 35 00 00 00       	mov    $0x35,%edx
  803bed:	89 d8                	mov    %ebx,%eax
  803bef:	e8 9c ee ff ff       	call   802a90 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  803bf4:	ba 03 00 00 00       	mov    $0x3,%edx
  803bf9:	89 d8                	mov    %ebx,%eax
  803bfb:	e8 4f ee ff ff       	call   802a4f <dhcp_option_byte>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  803c00:	b9 02 00 00 00       	mov    $0x2,%ecx
  803c05:	ba 39 00 00 00       	mov    $0x39,%edx
  803c0a:	89 d8                	mov    %ebx,%eax
  803c0c:	e8 7f ee ff ff       	call   802a90 <dhcp_option>
    dhcp_option_short(dhcp, 576);
  803c11:	ba 40 02 00 00       	mov    $0x240,%edx
  803c16:	89 d8                	mov    %ebx,%eax
  803c18:	e8 da ee ff ff       	call   802af7 <dhcp_option_short>
    dhcp_option_trailer(dhcp);
  803c1d:	89 d8                	mov    %ebx,%eax
  803c1f:	e8 31 ef ff ff       	call   802b55 <dhcp_option_trailer>
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  803c24:	83 ec 08             	sub    $0x8,%esp
  803c27:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  803c2b:	66 05 f0 00          	add    $0xf0,%ax
  803c2f:	0f b7 c0             	movzwl %ax,%eax
  803c32:	50                   	push   %eax
  803c33:	ff 73 1c             	pushl  0x1c(%ebx)
  803c36:	e8 0f 11 00 00       	call   804d4a <pbuf_realloc>
    udp_connect(dhcp->pcb, &dhcp->server_ip_addr, DHCP_SERVER_PORT);
  803c3b:	8d 43 2c             	lea    0x2c(%ebx),%eax
  803c3e:	83 c4 0c             	add    $0xc,%esp
  803c41:	6a 43                	push   $0x43
  803c43:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  803c46:	50                   	push   %eax
  803c47:	ff 73 08             	pushl  0x8(%ebx)
  803c4a:	e8 6f 55 00 00       	call   8091be <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
  803c4f:	89 3c 24             	mov    %edi,(%esp)
  803c52:	6a 43                	push   $0x43
  803c54:	ff 75 e4             	pushl  -0x1c(%ebp)
  803c57:	ff 73 1c             	pushl  0x1c(%ebx)
  803c5a:	ff 73 08             	pushl  0x8(%ebx)
  803c5d:	e8 5b 53 00 00       	call   808fbd <udp_sendto_if>
    dhcp_delete_request(netif);
  803c62:	83 c4 20             	add    $0x20,%esp
  803c65:	89 f8                	mov    %edi,%eax
  803c67:	e8 29 f2 ff ff       	call   802e95 <dhcp_delete_request>
  803c6c:	e9 34 ff ff ff       	jmp    803ba5 <dhcp_renew+0x2c>

00803c71 <dhcp_coarse_tmr>:
{
  803c71:	f3 0f 1e fb          	endbr32 
  803c75:	55                   	push   %ebp
  803c76:	89 e5                	mov    %esp,%ebp
  803c78:	53                   	push   %ebx
  803c79:	83 ec 04             	sub    $0x4,%esp
  struct netif *netif = netif_list;
  803c7c:	8b 1d 34 b2 b3 00    	mov    0xb3b234,%ebx
  while (netif != NULL) {
  803c82:	eb 1d                	jmp    803ca1 <dhcp_coarse_tmr+0x30>
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
  803c84:	8b 43 20             	mov    0x20(%ebx),%eax
  803c87:	0f b6 00             	movzbl (%eax),%eax
  803c8a:	89 c2                	mov    %eax,%edx
  803c8c:	83 e2 fb             	and    $0xfffffffb,%edx
  803c8f:	80 fa 01             	cmp    $0x1,%dl
  803c92:	74 04                	je     803c98 <dhcp_coarse_tmr+0x27>
  803c94:	3c 0a                	cmp    $0xa,%al
  803c96:	75 07                	jne    803c9f <dhcp_coarse_tmr+0x2e>
    dhcp_rebind(netif);
  803c98:	89 d8                	mov    %ebx,%eax
  803c9a:	e8 90 f2 ff ff       	call   802f2f <dhcp_rebind>
    netif = netif->next;
  803c9f:	8b 1b                	mov    (%ebx),%ebx
  while (netif != NULL) {
  803ca1:	85 db                	test   %ebx,%ebx
  803ca3:	74 4e                	je     803cf3 <dhcp_coarse_tmr+0x82>
    if (netif->dhcp != NULL) {
  803ca5:	8b 43 20             	mov    0x20(%ebx),%eax
  803ca8:	85 c0                	test   %eax,%eax
  803caa:	74 f3                	je     803c9f <dhcp_coarse_tmr+0x2e>
      if (netif->dhcp->t2_timeout-- == 1) {
  803cac:	0f b7 50 2a          	movzwl 0x2a(%eax),%edx
  803cb0:	8d 4a ff             	lea    -0x1(%edx),%ecx
  803cb3:	66 89 48 2a          	mov    %cx,0x2a(%eax)
  803cb7:	66 83 fa 01          	cmp    $0x1,%dx
  803cbb:	74 c7                	je     803c84 <dhcp_coarse_tmr+0x13>
      } else if (netif->dhcp->t1_timeout-- == 1) {
  803cbd:	8b 53 20             	mov    0x20(%ebx),%edx
  803cc0:	0f b7 42 28          	movzwl 0x28(%edx),%eax
  803cc4:	8d 48 ff             	lea    -0x1(%eax),%ecx
  803cc7:	66 89 4a 28          	mov    %cx,0x28(%edx)
  803ccb:	66 83 f8 01          	cmp    $0x1,%ax
  803ccf:	75 ce                	jne    803c9f <dhcp_coarse_tmr+0x2e>
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
  803cd1:	8b 43 20             	mov    0x20(%ebx),%eax
  803cd4:	0f b6 00             	movzbl (%eax),%eax
  803cd7:	89 c2                	mov    %eax,%edx
  803cd9:	83 e2 fb             	and    $0xfffffffb,%edx
  803cdc:	80 fa 01             	cmp    $0x1,%dl
  803cdf:	74 04                	je     803ce5 <dhcp_coarse_tmr+0x74>
  803ce1:	3c 0a                	cmp    $0xa,%al
  803ce3:	75 ba                	jne    803c9f <dhcp_coarse_tmr+0x2e>
    dhcp_renew(netif);
  803ce5:	83 ec 0c             	sub    $0xc,%esp
  803ce8:	53                   	push   %ebx
  803ce9:	e8 8b fe ff ff       	call   803b79 <dhcp_renew>
  803cee:	83 c4 10             	add    $0x10,%esp
  803cf1:	eb ac                	jmp    803c9f <dhcp_coarse_tmr+0x2e>
}
  803cf3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  803cf6:	c9                   	leave  
  803cf7:	c3                   	ret    

00803cf8 <dhcp_release>:
{
  803cf8:	f3 0f 1e fb          	endbr32 
  803cfc:	55                   	push   %ebp
  803cfd:	89 e5                	mov    %esp,%ebp
  803cff:	57                   	push   %edi
  803d00:	56                   	push   %esi
  803d01:	53                   	push   %ebx
  803d02:	83 ec 1c             	sub    $0x1c,%esp
  803d05:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp = netif->dhcp;
  803d08:	8b 5e 20             	mov    0x20(%esi),%ebx
  dhcp_set_state(dhcp, DHCP_OFF);
  803d0b:	ba 0d 00 00 00       	mov    $0xd,%edx
  803d10:	89 d8                	mov    %ebx,%eax
  803d12:	e8 fe eb ff ff       	call   802915 <dhcp_set_state>
  dhcp->server_ip_addr.addr = 0;
  803d17:	c7 43 2c 00 00 00 00 	movl   $0x0,0x2c(%ebx)
  dhcp->offered_ip_addr.addr = dhcp->offered_sn_mask.addr = 0;
  803d1e:	c7 43 34 00 00 00 00 	movl   $0x0,0x34(%ebx)
  803d25:	c7 43 30 00 00 00 00 	movl   $0x0,0x30(%ebx)
  dhcp->offered_gw_addr.addr = dhcp->offered_bc_addr.addr = 0;
  803d2c:	c7 43 3c 00 00 00 00 	movl   $0x0,0x3c(%ebx)
  803d33:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)
  dhcp->offered_t0_lease = dhcp->offered_t1_renew = dhcp->offered_t2_rebind = 0;
  803d3a:	c7 43 54 00 00 00 00 	movl   $0x0,0x54(%ebx)
  803d41:	c7 43 50 00 00 00 00 	movl   $0x0,0x50(%ebx)
  803d48:	c7 43 4c 00 00 00 00 	movl   $0x0,0x4c(%ebx)
  dhcp->dns_count = 0;
  803d4f:	c7 43 40 00 00 00 00 	movl   $0x0,0x40(%ebx)
  result = dhcp_create_request(netif);
  803d56:	89 f0                	mov    %esi,%eax
  803d58:	e8 45 ef ff ff       	call   802ca2 <dhcp_create_request>
  803d5d:	89 c7                	mov    %eax,%edi
  if (result == ERR_OK) {
  803d5f:	84 c0                	test   %al,%al
  803d61:	74 71                	je     803dd4 <dhcp_release+0xdc>
  dhcp->tries++;
  803d63:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  803d67:	83 c0 01             	add    $0x1,%eax
  803d6a:	88 43 01             	mov    %al,0x1(%ebx)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
  803d6d:	ba 10 27 00 00       	mov    $0x2710,%edx
  803d72:	3c 09                	cmp    $0x9,%al
  803d74:	77 08                	ja     803d7e <dhcp_release+0x86>
  803d76:	0f b6 d0             	movzbl %al,%edx
  803d79:	66 69 d2 e8 03       	imul   $0x3e8,%dx,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  803d7e:	0f b7 d2             	movzwl %dx,%edx
  803d81:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  803d87:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  803d8c:	89 d0                	mov    %edx,%eax
  803d8e:	f7 e9                	imul   %ecx
  803d90:	c1 fa 05             	sar    $0x5,%edx
  803d93:	66 89 53 26          	mov    %dx,0x26(%ebx)
  netif_set_down(netif);
  803d97:	83 ec 0c             	sub    $0xc,%esp
  803d9a:	56                   	push   %esi
  803d9b:	e8 81 0b 00 00       	call   804921 <netif_set_down>
  netif_set_ipaddr(netif, IP_ADDR_ANY);
  803da0:	83 c4 08             	add    $0x8,%esp
  803da3:	68 08 24 81 00       	push   $0x812408
  803da8:	56                   	push   %esi
  803da9:	e8 b9 09 00 00       	call   804767 <netif_set_ipaddr>
  netif_set_gw(netif, IP_ADDR_ANY);
  803dae:	83 c4 08             	add    $0x8,%esp
  803db1:	68 08 24 81 00       	push   $0x812408
  803db6:	56                   	push   %esi
  803db7:	e8 e3 0a 00 00       	call   80489f <netif_set_gw>
  netif_set_netmask(netif, IP_ADDR_ANY);
  803dbc:	83 c4 08             	add    $0x8,%esp
  803dbf:	68 08 24 81 00       	push   $0x812408
  803dc4:	56                   	push   %esi
  803dc5:	e8 f2 0a 00 00       	call   8048bc <netif_set_netmask>
}
  803dca:	89 f8                	mov    %edi,%eax
  803dcc:	8d 65 f4             	lea    -0xc(%ebp),%esp
  803dcf:	5b                   	pop    %ebx
  803dd0:	5e                   	pop    %esi
  803dd1:	5f                   	pop    %edi
  803dd2:	5d                   	pop    %ebp
  803dd3:	c3                   	ret    
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  803dd4:	b9 01 00 00 00       	mov    $0x1,%ecx
  803dd9:	ba 35 00 00 00       	mov    $0x35,%edx
  803dde:	89 d8                	mov    %ebx,%eax
  803de0:	e8 ab ec ff ff       	call   802a90 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_RELEASE);
  803de5:	ba 07 00 00 00       	mov    $0x7,%edx
  803dea:	89 d8                	mov    %ebx,%eax
  803dec:	e8 5e ec ff ff       	call   802a4f <dhcp_option_byte>
    dhcp_option_trailer(dhcp);
  803df1:	89 d8                	mov    %ebx,%eax
  803df3:	e8 5d ed ff ff       	call   802b55 <dhcp_option_trailer>
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  803df8:	83 ec 08             	sub    $0x8,%esp
  803dfb:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  803dff:	66 05 f0 00          	add    $0xf0,%ax
  803e03:	0f b7 c0             	movzwl %ax,%eax
  803e06:	50                   	push   %eax
  803e07:	ff 73 1c             	pushl  0x1c(%ebx)
  803e0a:	e8 3b 0f 00 00       	call   804d4a <pbuf_realloc>
    udp_connect(dhcp->pcb, &dhcp->server_ip_addr, DHCP_SERVER_PORT);
  803e0f:	8d 43 2c             	lea    0x2c(%ebx),%eax
  803e12:	83 c4 0c             	add    $0xc,%esp
  803e15:	6a 43                	push   $0x43
  803e17:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  803e1a:	50                   	push   %eax
  803e1b:	ff 73 08             	pushl  0x8(%ebx)
  803e1e:	e8 9b 53 00 00       	call   8091be <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
  803e23:	89 34 24             	mov    %esi,(%esp)
  803e26:	6a 43                	push   $0x43
  803e28:	ff 75 e4             	pushl  -0x1c(%ebp)
  803e2b:	ff 73 1c             	pushl  0x1c(%ebx)
  803e2e:	ff 73 08             	pushl  0x8(%ebx)
  803e31:	e8 87 51 00 00       	call   808fbd <udp_sendto_if>
    dhcp_delete_request(netif);
  803e36:	83 c4 20             	add    $0x20,%esp
  803e39:	89 f0                	mov    %esi,%eax
  803e3b:	e8 55 f0 ff ff       	call   802e95 <dhcp_delete_request>
  803e40:	e9 1e ff ff ff       	jmp    803d63 <dhcp_release+0x6b>

00803e45 <dhcp_fine_tmr>:
{
  803e45:	f3 0f 1e fb          	endbr32 
  803e49:	55                   	push   %ebp
  803e4a:	89 e5                	mov    %esp,%ebp
  803e4c:	53                   	push   %ebx
  803e4d:	83 ec 04             	sub    $0x4,%esp
  struct netif *netif = netif_list;
  803e50:	8b 1d 34 b2 b3 00    	mov    0xb3b234,%ebx
  while (netif != NULL) {
  803e56:	eb 04                	jmp    803e5c <dhcp_fine_tmr+0x17>
      else if (netif->dhcp->request_timeout == 1) {
  803e58:	74 24                	je     803e7e <dhcp_fine_tmr+0x39>
    netif = netif->next;
  803e5a:	8b 1b                	mov    (%ebx),%ebx
  while (netif != NULL) {
  803e5c:	85 db                	test   %ebx,%ebx
  803e5e:	0f 84 c4 00 00 00    	je     803f28 <dhcp_fine_tmr+0xe3>
    if (netif->dhcp != NULL) {
  803e64:	8b 43 20             	mov    0x20(%ebx),%eax
  803e67:	85 c0                	test   %eax,%eax
  803e69:	74 ef                	je     803e5a <dhcp_fine_tmr+0x15>
      if (netif->dhcp->request_timeout > 1) {
  803e6b:	0f b7 50 26          	movzwl 0x26(%eax),%edx
  803e6f:	66 83 fa 01          	cmp    $0x1,%dx
  803e73:	76 e3                	jbe    803e58 <dhcp_fine_tmr+0x13>
        netif->dhcp->request_timeout--;
  803e75:	83 ea 01             	sub    $0x1,%edx
  803e78:	66 89 50 26          	mov    %dx,0x26(%eax)
  803e7c:	eb dc                	jmp    803e5a <dhcp_fine_tmr+0x15>
        netif->dhcp->request_timeout--;
  803e7e:	66 c7 40 26 00 00    	movw   $0x0,0x26(%eax)
  struct dhcp *dhcp = netif->dhcp;
  803e84:	8b 53 20             	mov    0x20(%ebx),%edx
  if ((dhcp->state == DHCP_BACKING_OFF) || (dhcp->state == DHCP_SELECTING)) {
  803e87:	0f b6 02             	movzbl (%edx),%eax
  803e8a:	3c 0c                	cmp    $0xc,%al
  803e8c:	74 23                	je     803eb1 <dhcp_fine_tmr+0x6c>
  803e8e:	3c 06                	cmp    $0x6,%al
  803e90:	74 1f                	je     803eb1 <dhcp_fine_tmr+0x6c>
  } else if (dhcp->state == DHCP_REQUESTING) {
  803e92:	3c 01                	cmp    $0x1,%al
  803e94:	74 24                	je     803eba <dhcp_fine_tmr+0x75>
  } else if (dhcp->state == DHCP_CHECKING) {
  803e96:	3c 08                	cmp    $0x8,%al
  803e98:	74 47                	je     803ee1 <dhcp_fine_tmr+0x9c>
  else if (dhcp->state == DHCP_RENEWING) {
  803e9a:	3c 05                	cmp    $0x5,%al
  803e9c:	74 61                	je     803eff <dhcp_fine_tmr+0xba>
  } else if (dhcp->state == DHCP_REBINDING) {
  803e9e:	3c 04                	cmp    $0x4,%al
  803ea0:	75 b8                	jne    803e5a <dhcp_fine_tmr+0x15>
    if (dhcp->tries <= 8) {
  803ea2:	80 7a 01 08          	cmpb   $0x8,0x1(%edx)
  803ea6:	77 68                	ja     803f10 <dhcp_fine_tmr+0xcb>
      dhcp_rebind(netif);
  803ea8:	89 d8                	mov    %ebx,%eax
  803eaa:	e8 80 f0 ff ff       	call   802f2f <dhcp_rebind>
  803eaf:	eb a9                	jmp    803e5a <dhcp_fine_tmr+0x15>
    dhcp_discover(netif);
  803eb1:	89 d8                	mov    %ebx,%eax
  803eb3:	e8 6a f1 ff ff       	call   803022 <dhcp_discover>
  803eb8:	eb a0                	jmp    803e5a <dhcp_fine_tmr+0x15>
    if (dhcp->tries <= 5) {
  803eba:	80 7a 01 05          	cmpb   $0x5,0x1(%edx)
  803ebe:	77 09                	ja     803ec9 <dhcp_fine_tmr+0x84>
      dhcp_select(netif);
  803ec0:	89 d8                	mov    %ebx,%eax
  803ec2:	e8 9a f2 ff ff       	call   803161 <dhcp_select>
  803ec7:	eb 91                	jmp    803e5a <dhcp_fine_tmr+0x15>
      dhcp_release(netif);
  803ec9:	83 ec 0c             	sub    $0xc,%esp
  803ecc:	53                   	push   %ebx
  803ecd:	e8 26 fe ff ff       	call   803cf8 <dhcp_release>
      dhcp_discover(netif);
  803ed2:	89 d8                	mov    %ebx,%eax
  803ed4:	e8 49 f1 ff ff       	call   803022 <dhcp_discover>
  803ed9:	83 c4 10             	add    $0x10,%esp
  803edc:	e9 79 ff ff ff       	jmp    803e5a <dhcp_fine_tmr+0x15>
    if (dhcp->tries <= 1) {
  803ee1:	80 7a 01 01          	cmpb   $0x1,0x1(%edx)
  803ee5:	76 0c                	jbe    803ef3 <dhcp_fine_tmr+0xae>
      dhcp_bind(netif);
  803ee7:	89 d8                	mov    %ebx,%eax
  803ee9:	e8 23 f4 ff ff       	call   803311 <dhcp_bind>
  803eee:	e9 67 ff ff ff       	jmp    803e5a <dhcp_fine_tmr+0x15>
      dhcp_check(netif);
  803ef3:	89 d8                	mov    %ebx,%eax
  803ef5:	e8 e3 f3 ff ff       	call   8032dd <dhcp_check>
  803efa:	e9 5b ff ff ff       	jmp    803e5a <dhcp_fine_tmr+0x15>
    dhcp_renew(netif);
  803eff:	83 ec 0c             	sub    $0xc,%esp
  803f02:	53                   	push   %ebx
  803f03:	e8 71 fc ff ff       	call   803b79 <dhcp_renew>
  803f08:	83 c4 10             	add    $0x10,%esp
  803f0b:	e9 4a ff ff ff       	jmp    803e5a <dhcp_fine_tmr+0x15>
      dhcp_release(netif);
  803f10:	83 ec 0c             	sub    $0xc,%esp
  803f13:	53                   	push   %ebx
  803f14:	e8 df fd ff ff       	call   803cf8 <dhcp_release>
      dhcp_discover(netif);
  803f19:	89 d8                	mov    %ebx,%eax
  803f1b:	e8 02 f1 ff ff       	call   803022 <dhcp_discover>
  803f20:	83 c4 10             	add    $0x10,%esp
  803f23:	e9 32 ff ff ff       	jmp    803e5a <dhcp_fine_tmr+0x15>
}
  803f28:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  803f2b:	c9                   	leave  
  803f2c:	c3                   	ret    

00803f2d <dhcp_stop>:
{
  803f2d:	f3 0f 1e fb          	endbr32 
  803f31:	55                   	push   %ebp
  803f32:	89 e5                	mov    %esp,%ebp
  803f34:	56                   	push   %esi
  803f35:	53                   	push   %ebx
  803f36:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp = netif->dhcp;
  803f39:	8b 5e 20             	mov    0x20(%esi),%ebx
  netif->flags &= ~NETIF_FLAG_DHCP;
  803f3c:	80 66 2e f7          	andb   $0xf7,0x2e(%esi)
  if (dhcp != NULL) {
  803f40:	85 db                	test   %ebx,%ebx
  803f42:	74 4e                	je     803f92 <dhcp_stop+0x65>
    if (dhcp->pcb != NULL) {
  803f44:	8b 43 08             	mov    0x8(%ebx),%eax
  803f47:	85 c0                	test   %eax,%eax
  803f49:	74 13                	je     803f5e <dhcp_stop+0x31>
      udp_remove(dhcp->pcb);
  803f4b:	83 ec 0c             	sub    $0xc,%esp
  803f4e:	50                   	push   %eax
  803f4f:	e8 16 53 00 00       	call   80926a <udp_remove>
      dhcp->pcb = NULL;
  803f54:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  803f5b:	83 c4 10             	add    $0x10,%esp
    if (dhcp->p != NULL) {
  803f5e:	8b 43 0c             	mov    0xc(%ebx),%eax
  803f61:	85 c0                	test   %eax,%eax
  803f63:	74 13                	je     803f78 <dhcp_stop+0x4b>
      pbuf_free(dhcp->p);
  803f65:	83 ec 0c             	sub    $0xc,%esp
  803f68:	50                   	push   %eax
  803f69:	e8 b3 0a 00 00       	call   804a21 <pbuf_free>
      dhcp->p = NULL;
  803f6e:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
  803f75:	83 c4 10             	add    $0x10,%esp
    dhcp_free_reply(dhcp);
  803f78:	89 d8                	mov    %ebx,%eax
  803f7a:	e8 4f f5 ff ff       	call   8034ce <dhcp_free_reply>
    mem_free((void *)dhcp);
  803f7f:	83 ec 0c             	sub    $0xc,%esp
  803f82:	53                   	push   %ebx
  803f83:	e8 64 01 00 00       	call   8040ec <mem_free>
    netif->dhcp = NULL;
  803f88:	c7 46 20 00 00 00 00 	movl   $0x0,0x20(%esi)
  803f8f:	83 c4 10             	add    $0x10,%esp
}
  803f92:	8d 65 f8             	lea    -0x8(%ebp),%esp
  803f95:	5b                   	pop    %ebx
  803f96:	5e                   	pop    %esi
  803f97:	5d                   	pop    %ebp
  803f98:	c3                   	ret    

00803f99 <dhcp_start>:
{
  803f99:	f3 0f 1e fb          	endbr32 
  803f9d:	55                   	push   %ebp
  803f9e:	89 e5                	mov    %esp,%ebp
  803fa0:	56                   	push   %esi
  803fa1:	53                   	push   %ebx
  803fa2:	8b 5d 08             	mov    0x8(%ebp),%ebx
  LWIP_ERROR("netif != NULL", (netif != NULL), return ERR_ARG;);
  803fa5:	85 db                	test   %ebx,%ebx
  803fa7:	74 73                	je     80401c <dhcp_start+0x83>
  dhcp = netif->dhcp;
  803fa9:	8b 73 20             	mov    0x20(%ebx),%esi
  netif->flags &= ~NETIF_FLAG_DHCP;
  803fac:	80 63 2e f7          	andb   $0xf7,0x2e(%ebx)
  if (dhcp == NULL) {
  803fb0:	85 f6                	test   %esi,%esi
  803fb2:	74 7f                	je     804033 <dhcp_start+0x9a>
  memset(dhcp, 0, sizeof(struct dhcp));
  803fb4:	83 ec 04             	sub    $0x4,%esp
  803fb7:	6a 58                	push   $0x58
  803fb9:	6a 00                	push   $0x0
  803fbb:	56                   	push   %esi
  803fbc:	e8 e1 b1 00 00       	call   80f1a2 <memset>
  dhcp->pcb = udp_new();
  803fc1:	e8 ec 52 00 00       	call   8092b2 <udp_new>
  803fc6:	89 46 08             	mov    %eax,0x8(%esi)
  if (dhcp->pcb == NULL) {
  803fc9:	83 c4 10             	add    $0x10,%esp
  803fcc:	85 c0                	test   %eax,%eax
  803fce:	74 7e                	je     80404e <dhcp_start+0xb5>
  udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
  803fd0:	83 ec 04             	sub    $0x4,%esp
  803fd3:	6a 44                	push   $0x44
  803fd5:	68 08 24 81 00       	push   $0x812408
  803fda:	50                   	push   %eax
  803fdb:	e8 1e 4f 00 00       	call   808efe <udp_bind>
  udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  803fe0:	83 c4 0c             	add    $0xc,%esp
  803fe3:	6a 43                	push   $0x43
  803fe5:	68 08 24 81 00       	push   $0x812408
  803fea:	ff 76 08             	pushl  0x8(%esi)
  803fed:	e8 cc 51 00 00       	call   8091be <udp_connect>
  udp_recv(dhcp->pcb, dhcp_recv, netif);
  803ff2:	83 c4 0c             	add    $0xc,%esp
  803ff5:	53                   	push   %ebx
  803ff6:	68 16 35 80 00       	push   $0x803516
  803ffb:	ff 76 08             	pushl  0x8(%esi)
  803ffe:	e8 4f 52 00 00       	call   809252 <udp_recv>
  result = dhcp_discover(netif);
  804003:	89 d8                	mov    %ebx,%eax
  804005:	e8 18 f0 ff ff       	call   803022 <dhcp_discover>
  if (result != ERR_OK) {
  80400a:	83 c4 10             	add    $0x10,%esp
  80400d:	84 c0                	test   %al,%al
  80400f:	75 57                	jne    804068 <dhcp_start+0xcf>
  netif->flags |= NETIF_FLAG_DHCP;
  804011:	80 4b 2e 08          	orb    $0x8,0x2e(%ebx)
}
  804015:	8d 65 f8             	lea    -0x8(%ebp),%esp
  804018:	5b                   	pop    %ebx
  804019:	5e                   	pop    %esi
  80401a:	5d                   	pop    %ebp
  80401b:	c3                   	ret    
  LWIP_ERROR("netif != NULL", (netif != NULL), return ERR_ARG;);
  80401c:	83 ec 04             	sub    $0x4,%esp
  80401f:	68 82 1b 81 00       	push   $0x811b82
  804024:	68 38 02 00 00       	push   $0x238
  804029:	68 62 1b 81 00       	push   $0x811b62
  80402e:	e8 14 a9 00 00       	call   80e947 <_panic>
    dhcp = mem_malloc(sizeof(struct dhcp));
  804033:	83 ec 0c             	sub    $0xc,%esp
  804036:	6a 58                	push   $0x58
  804038:	e8 a6 03 00 00       	call   8043e3 <mem_malloc>
  80403d:	89 c6                	mov    %eax,%esi
    if (dhcp == NULL) {
  80403f:	83 c4 10             	add    $0x10,%esp
  804042:	85 c0                	test   %eax,%eax
  804044:	74 35                	je     80407b <dhcp_start+0xe2>
    netif->dhcp = dhcp;
  804046:	89 43 20             	mov    %eax,0x20(%ebx)
  804049:	e9 66 ff ff ff       	jmp    803fb4 <dhcp_start+0x1b>
    mem_free((void *)dhcp);
  80404e:	83 ec 0c             	sub    $0xc,%esp
  804051:	56                   	push   %esi
  804052:	e8 95 00 00 00       	call   8040ec <mem_free>
    netif->dhcp = dhcp = NULL;
  804057:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
    return ERR_MEM;
  80405e:	83 c4 10             	add    $0x10,%esp
  804061:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  804066:	eb ad                	jmp    804015 <dhcp_start+0x7c>
    dhcp_stop(netif);
  804068:	83 ec 0c             	sub    $0xc,%esp
  80406b:	53                   	push   %ebx
  80406c:	e8 bc fe ff ff       	call   803f2d <dhcp_stop>
    return ERR_MEM;
  804071:	83 c4 10             	add    $0x10,%esp
  804074:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  804079:	eb 9a                	jmp    804015 <dhcp_start+0x7c>
      return ERR_MEM;
  80407b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  804080:	eb 93                	jmp    804015 <dhcp_start+0x7c>

00804082 <mem_init>:
/**
 * Zero the heap and initialize start, end and lowest-free
 */
void
mem_init(void)
{
  804082:	f3 0f 1e fb          	endbr32 
  804086:	55                   	push   %ebp
  804087:	89 e5                	mov    %esp,%ebp
  804089:	83 ec 14             	sub    $0x14,%esp

  LWIP_ASSERT("Sanity check alignment",
    (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT-1)) == 0);

  /* align the heap */
  ram = LWIP_MEM_ALIGN(ram_heap);
  80408c:	b8 23 53 81 00       	mov    $0x815323,%eax
  804091:	83 e0 fc             	and    $0xfffffffc,%eax
  804094:	a3 0c 53 81 00       	mov    %eax,0x81530c
  /* initialize the start of the heap */
  mem = (struct mem *)ram;
  mem->next = MEM_SIZE_ALIGNED;
  804099:	c7 00 00 00 22 00    	movl   $0x220000,(%eax)
  mem->prev = 0;
  80409f:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  mem->used = 0;
  8040a6:	c6 40 08 00          	movb   $0x0,0x8(%eax)
  /* initialize the end of the heap */
  ram_end = (struct mem *)&ram[MEM_SIZE_ALIGNED];
  8040aa:	8d 90 00 00 22 00    	lea    0x220000(%eax),%edx
  8040b0:	89 15 08 53 81 00    	mov    %edx,0x815308
  ram_end->used = 1;
  8040b6:	c6 80 08 00 22 00 01 	movb   $0x1,0x220008(%eax)
  ram_end->next = MEM_SIZE_ALIGNED;
  8040bd:	c7 80 00 00 22 00 00 	movl   $0x220000,0x220000(%eax)
  8040c4:	00 22 00 
  ram_end->prev = MEM_SIZE_ALIGNED;
  8040c7:	c7 80 04 00 22 00 00 	movl   $0x220000,0x220004(%eax)
  8040ce:	00 22 00 

  mem_sem = sys_sem_new(1);
  8040d1:	6a 01                	push   $0x1
  8040d3:	e8 ce 5f 00 00       	call   80a0a6 <sys_sem_new>
  8040d8:	a3 00 53 81 00       	mov    %eax,0x815300

  /* initialize the lowest-free pointer to the start of the heap */
  lfree = (struct mem *)ram;
  8040dd:	a1 0c 53 81 00       	mov    0x81530c,%eax
  8040e2:	a3 04 53 81 00       	mov    %eax,0x815304

  MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);
}
  8040e7:	83 c4 10             	add    $0x10,%esp
  8040ea:	c9                   	leave  
  8040eb:	c3                   	ret    

008040ec <mem_free>:
 * @param rmem is the data portion of a struct mem as returned by a previous
 *             call to mem_malloc()
 */
void
mem_free(void *rmem)
{
  8040ec:	f3 0f 1e fb          	endbr32 
  8040f0:	55                   	push   %ebp
  8040f1:	89 e5                	mov    %esp,%ebp
  8040f3:	56                   	push   %esi
  8040f4:	53                   	push   %ebx
  8040f5:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct mem *mem;
  LWIP_MEM_FREE_DECL_PROTECT();

  if (rmem == NULL) {
  8040f8:	85 db                	test   %ebx,%ebx
  8040fa:	0f 84 e1 00 00 00    	je     8041e1 <mem_free+0xf5>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | 2, ("mem_free(p == NULL) was called.\n"));
    return;
  }
  LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);
  804100:	f6 c3 03             	test   $0x3,%bl
  804103:	0f 85 df 00 00 00    	jne    8041e8 <mem_free+0xfc>

  LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  804109:	39 1d 0c 53 81 00    	cmp    %ebx,0x81530c
  80410f:	0f 87 ea 00 00 00    	ja     8041ff <mem_free+0x113>
  804115:	39 1d 08 53 81 00    	cmp    %ebx,0x815308
  80411b:	0f 86 de 00 00 00    	jbe    8041ff <mem_free+0x113>
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return;
  }
  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  804121:	83 ec 08             	sub    $0x8,%esp
  804124:	6a 00                	push   $0x0
  804126:	ff 35 00 53 81 00    	pushl  0x815300
  80412c:	e8 b6 62 00 00       	call   80a3e7 <sys_arch_sem_wait>
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  804131:	8d 43 f4             	lea    -0xc(%ebx),%eax
  /* ... which has to be in a used state ... */
  LWIP_ASSERT("mem_free: mem->used", mem->used);
  804134:	83 c4 10             	add    $0x10,%esp
  804137:	80 7b fc 00          	cmpb   $0x0,-0x4(%ebx)
  80413b:	0f 84 d5 00 00 00    	je     804216 <mem_free+0x12a>
  /* ... and is now unused. */
  mem->used = 0;
  804141:	c6 43 fc 00          	movb   $0x0,-0x4(%ebx)

  if (mem < lfree) {
  804145:	39 05 04 53 81 00    	cmp    %eax,0x815304
  80414b:	76 05                	jbe    804152 <mem_free+0x66>
    /* the newly freed struct is now the lowest */
    lfree = mem;
  80414d:	a3 04 53 81 00       	mov    %eax,0x815304
  LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
  804152:	8b 0d 0c 53 81 00    	mov    0x81530c,%ecx
  804158:	39 c8                	cmp    %ecx,%eax
  80415a:	0f 82 cd 00 00 00    	jb     80422d <mem_free+0x141>
  LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
  804160:	8b 35 08 53 81 00    	mov    0x815308,%esi
  804166:	39 f0                	cmp    %esi,%eax
  804168:	0f 83 d6 00 00 00    	jae    804244 <mem_free+0x158>
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);
  80416e:	8b 53 f4             	mov    -0xc(%ebx),%edx
  804171:	81 fa 00 00 22 00    	cmp    $0x220000,%edx
  804177:	0f 87 de 00 00 00    	ja     80425b <mem_free+0x16f>
  nmem = (struct mem *)&ram[mem->next];
  80417d:	01 ca                	add    %ecx,%edx
  if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
  80417f:	39 d0                	cmp    %edx,%eax
  804181:	74 25                	je     8041a8 <mem_free+0xbc>
  804183:	80 7a 08 00          	cmpb   $0x0,0x8(%edx)
  804187:	75 1f                	jne    8041a8 <mem_free+0xbc>
  804189:	39 d6                	cmp    %edx,%esi
  80418b:	74 1b                	je     8041a8 <mem_free+0xbc>
    if (lfree == nmem) {
  80418d:	3b 15 04 53 81 00    	cmp    0x815304,%edx
  804193:	0f 84 d9 00 00 00    	je     804272 <mem_free+0x186>
    mem->next = nmem->next;
  804199:	8b 32                	mov    (%edx),%esi
  80419b:	89 73 f4             	mov    %esi,-0xc(%ebx)
    ((struct mem *)&ram[nmem->next])->prev = (u8_t *)mem - ram;
  80419e:	8b 12                	mov    (%edx),%edx
  8041a0:	89 c6                	mov    %eax,%esi
  8041a2:	29 ce                	sub    %ecx,%esi
  8041a4:	89 74 11 04          	mov    %esi,0x4(%ecx,%edx,1)
  pmem = (struct mem *)&ram[mem->prev];
  8041a8:	8b 73 f8             	mov    -0x8(%ebx),%esi
  8041ab:	8d 14 31             	lea    (%ecx,%esi,1),%edx
  if (pmem != mem && pmem->used == 0) {
  8041ae:	39 d0                	cmp    %edx,%eax
  8041b0:	74 1e                	je     8041d0 <mem_free+0xe4>
  8041b2:	80 7a 08 00          	cmpb   $0x0,0x8(%edx)
  8041b6:	75 18                	jne    8041d0 <mem_free+0xe4>
    if (lfree == mem) {
  8041b8:	3b 05 04 53 81 00    	cmp    0x815304,%eax
  8041be:	0f 84 b8 00 00 00    	je     80427c <mem_free+0x190>
    pmem->next = mem->next;
  8041c4:	8b 43 f4             	mov    -0xc(%ebx),%eax
  8041c7:	89 02                	mov    %eax,(%edx)
    ((struct mem *)&ram[mem->next])->prev = (u8_t *)pmem - ram;
  8041c9:	8b 43 f4             	mov    -0xc(%ebx),%eax
  8041cc:	89 74 01 04          	mov    %esi,0x4(%ecx,%eax,1)
  /* finally, see if prev or next are free also */
  plug_holes(mem);
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  8041d0:	83 ec 0c             	sub    $0xc,%esp
  8041d3:	ff 35 00 53 81 00    	pushl  0x815300
  8041d9:	e8 95 61 00 00       	call   80a373 <sys_sem_signal>
  8041de:	83 c4 10             	add    $0x10,%esp
}
  8041e1:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8041e4:	5b                   	pop    %ebx
  8041e5:	5e                   	pop    %esi
  8041e6:	5d                   	pop    %ebp
  8041e7:	c3                   	ret    
  LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);
  8041e8:	83 ec 04             	sub    $0x4,%esp
  8041eb:	68 d4 1b 81 00       	push   $0x811bd4
  8041f0:	68 30 01 00 00       	push   $0x130
  8041f5:	68 cb 1c 81 00       	push   $0x811ccb
  8041fa:	e8 48 a7 00 00       	call   80e947 <_panic>
  LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  8041ff:	83 ec 04             	sub    $0x4,%esp
  804202:	68 df 1c 81 00       	push   $0x811cdf
  804207:	68 32 01 00 00       	push   $0x132
  80420c:	68 cb 1c 81 00       	push   $0x811ccb
  804211:	e8 31 a7 00 00       	call   80e947 <_panic>
  LWIP_ASSERT("mem_free: mem->used", mem->used);
  804216:	83 ec 04             	sub    $0x4,%esp
  804219:	68 f6 1c 81 00       	push   $0x811cf6
  80421e:	68 43 01 00 00       	push   $0x143
  804223:	68 cb 1c 81 00       	push   $0x811ccb
  804228:	e8 1a a7 00 00       	call   80e947 <_panic>
  LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
  80422d:	83 ec 04             	sub    $0x4,%esp
  804230:	68 0a 1d 81 00       	push   $0x811d0a
  804235:	68 e3 00 00 00       	push   $0xe3
  80423a:	68 cb 1c 81 00       	push   $0x811ccb
  80423f:	e8 03 a7 00 00       	call   80e947 <_panic>
  LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
  804244:	83 ec 04             	sub    $0x4,%esp
  804247:	68 21 1d 81 00       	push   $0x811d21
  80424c:	68 e4 00 00 00       	push   $0xe4
  804251:	68 cb 1c 81 00       	push   $0x811ccb
  804256:	e8 ec a6 00 00       	call   80e947 <_panic>
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);
  80425b:	83 ec 04             	sub    $0x4,%esp
  80425e:	68 f8 1b 81 00       	push   $0x811bf8
  804263:	68 e8 00 00 00       	push   $0xe8
  804268:	68 cb 1c 81 00       	push   $0x811ccb
  80426d:	e8 d5 a6 00 00       	call   80e947 <_panic>
      lfree = mem;
  804272:	a3 04 53 81 00       	mov    %eax,0x815304
  804277:	e9 1d ff ff ff       	jmp    804199 <mem_free+0xad>
      lfree = pmem;
  80427c:	89 15 04 53 81 00    	mov    %edx,0x815304
  804282:	e9 3d ff ff ff       	jmp    8041c4 <mem_free+0xd8>

00804287 <mem_realloc>:
 *         or NULL if newsize is > old size, in which case rmem is NOT touched
 *         or freed!
 */
void *
mem_realloc(void *rmem, mem_size_t newsize)
{
  804287:	f3 0f 1e fb          	endbr32 
  80428b:	55                   	push   %ebp
  80428c:	89 e5                	mov    %esp,%ebp
  80428e:	57                   	push   %edi
  80428f:	56                   	push   %esi
  804290:	53                   	push   %ebx
  804291:	83 ec 1c             	sub    $0x1c,%esp
  804294:	8b 75 08             	mov    0x8(%ebp),%esi
  /* use the FREE_PROTECT here: it protects with sem OR SYS_ARCH_PROTECT */
  LWIP_MEM_FREE_DECL_PROTECT();

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  newsize = LWIP_MEM_ALIGN_SIZE(newsize);
  804297:	8b 45 0c             	mov    0xc(%ebp),%eax
  80429a:	8d 58 03             	lea    0x3(%eax),%ebx
  80429d:	83 e3 fc             	and    $0xfffffffc,%ebx

  if(newsize < MIN_SIZE_ALIGNED) {
  8042a0:	83 fb 0b             	cmp    $0xb,%ebx
  8042a3:	76 12                	jbe    8042b7 <mem_realloc+0x30>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
  }

  if (newsize > MEM_SIZE_ALIGNED) {
  8042a5:	81 fb 00 00 22 00    	cmp    $0x220000,%ebx
  8042ab:	76 0f                	jbe    8042bc <mem_realloc+0x35>
    return NULL;
  8042ad:	be 00 00 00 00       	mov    $0x0,%esi
  8042b2:	e9 a1 00 00 00       	jmp    804358 <mem_realloc+0xd1>
    newsize = MIN_SIZE_ALIGNED;
  8042b7:	bb 0c 00 00 00       	mov    $0xc,%ebx
  }

  LWIP_ASSERT("mem_realloc: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  8042bc:	a1 0c 53 81 00       	mov    0x81530c,%eax
  8042c1:	39 f0                	cmp    %esi,%eax
  8042c3:	0f 87 99 00 00 00    	ja     804362 <mem_realloc+0xdb>
  8042c9:	39 35 08 53 81 00    	cmp    %esi,0x815308
  8042cf:	0f 86 8d 00 00 00    	jbe    804362 <mem_realloc+0xdb>
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return rmem;
  }
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  8042d5:	8d 56 f4             	lea    -0xc(%esi),%edx
  /* ... and its offset pointer */
  ptr = (u8_t *)mem - ram;
  8042d8:	29 c2                	sub    %eax,%edx
  8042da:	89 55 e4             	mov    %edx,-0x1c(%ebp)

  size = mem->next - ptr - SIZEOF_STRUCT_MEM;
  8042dd:	8b 4e f4             	mov    -0xc(%esi),%ecx
  8042e0:	8d 79 f4             	lea    -0xc(%ecx),%edi
  8042e3:	29 d7                	sub    %edx,%edi
  LWIP_ASSERT("mem_realloc can only shrink memory", newsize <= size);
  8042e5:	39 df                	cmp    %ebx,%edi
  8042e7:	0f 82 8c 00 00 00    	jb     804379 <mem_realloc+0xf2>
  if (newsize > size) {
    /* not supported */
    return NULL;
  }
  if (newsize == size) {
  8042ed:	74 69                	je     804358 <mem_realloc+0xd1>
    /* No change in size, simply return */
    return rmem;
  }

  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  8042ef:	83 ec 08             	sub    $0x8,%esp
  8042f2:	6a 00                	push   $0x0
  8042f4:	ff 35 00 53 81 00    	pushl  0x815300
  8042fa:	e8 e8 60 00 00       	call   80a3e7 <sys_arch_sem_wait>

  MEM_STATS_DEC_USED(used, (size - newsize));

  mem2 = (struct mem *)&ram[mem->next];
  8042ff:	a1 0c 53 81 00       	mov    0x81530c,%eax
  804304:	89 c2                	mov    %eax,%edx
  804306:	03 56 f4             	add    -0xc(%esi),%edx
  if(mem2->used == 0) {
  804309:	83 c4 10             	add    $0x10,%esp
  80430c:	80 7a 08 00          	cmpb   $0x0,0x8(%edx)
  804310:	0f 85 85 00 00 00    	jne    80439b <mem_realloc+0x114>
    /* The next struct is unused, we can simply move it at little */
    mem_size_t next;
    /* remember the old next pointer */
    next = mem2->next;
  804316:	8b 0a                	mov    (%edx),%ecx
    /* create new struct mem which is moved directly after the shrinked mem */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
  804318:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  80431b:	8d 5c 3b 0c          	lea    0xc(%ebx,%edi,1),%ebx
    if (lfree == mem2) {
  80431f:	39 15 04 53 81 00    	cmp    %edx,0x815304
  804325:	74 69                	je     804390 <mem_realloc+0x109>
      lfree = (struct mem *)&ram[ptr2];
    }
    mem2 = (struct mem *)&ram[ptr2];
  804327:	8d 14 18             	lea    (%eax,%ebx,1),%edx
    mem2->used = 0;
  80432a:	c6 42 08 00          	movb   $0x0,0x8(%edx)
    /* restore the next pointer */
    mem2->next = next;
  80432e:	89 0a                	mov    %ecx,(%edx)
    /* link it back to mem */
    mem2->prev = ptr;
  804330:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  804333:	89 4a 04             	mov    %ecx,0x4(%edx)
    /* link mem to it */
    mem->next = ptr2;
  804336:	89 5e f4             	mov    %ebx,-0xc(%esi)
    /* last thing to restore linked list: as we have moved mem2,
     * let 'mem2->next->prev' point to mem2 again. but only if mem2->next is not
     * the end of the heap */
    if (mem2->next != MEM_SIZE_ALIGNED) {
  804339:	8b 12                	mov    (%edx),%edx
  80433b:	81 fa 00 00 22 00    	cmp    $0x220000,%edx
  804341:	74 04                	je     804347 <mem_realloc+0xc0>
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
  804343:	89 5c 10 04          	mov    %ebx,0x4(%eax,%edx,1)
    -> the remaining space stays unused since it is too small
  } */
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  804347:	83 ec 0c             	sub    $0xc,%esp
  80434a:	ff 35 00 53 81 00    	pushl  0x815300
  804350:	e8 1e 60 00 00       	call   80a373 <sys_sem_signal>
  return rmem;
  804355:	83 c4 10             	add    $0x10,%esp
}
  804358:	89 f0                	mov    %esi,%eax
  80435a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80435d:	5b                   	pop    %ebx
  80435e:	5e                   	pop    %esi
  80435f:	5f                   	pop    %edi
  804360:	5d                   	pop    %ebp
  804361:	c3                   	ret    
  LWIP_ASSERT("mem_realloc: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  804362:	83 ec 04             	sub    $0x4,%esp
  804365:	68 3b 1d 81 00       	push   $0x811d3b
  80436a:	68 78 01 00 00       	push   $0x178
  80436f:	68 cb 1c 81 00       	push   $0x811ccb
  804374:	e8 ce a5 00 00       	call   80e947 <_panic>
  LWIP_ASSERT("mem_realloc can only shrink memory", newsize <= size);
  804379:	83 ec 04             	sub    $0x4,%esp
  80437c:	68 24 1c 81 00       	push   $0x811c24
  804381:	68 8a 01 00 00       	push   $0x18a
  804386:	68 cb 1c 81 00       	push   $0x811ccb
  80438b:	e8 b7 a5 00 00       	call   80e947 <_panic>
      lfree = (struct mem *)&ram[ptr2];
  804390:	8d 14 18             	lea    (%eax,%ebx,1),%edx
  804393:	89 15 04 53 81 00    	mov    %edx,0x815304
  804399:	eb 8c                	jmp    804327 <mem_realloc+0xa0>
  } else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
  80439b:	8d 53 18             	lea    0x18(%ebx),%edx
  80439e:	39 fa                	cmp    %edi,%edx
  8043a0:	77 a5                	ja     804347 <mem_realloc+0xc0>
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
  8043a2:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  8043a5:	8d 4c 0b 0c          	lea    0xc(%ebx,%ecx,1),%ecx
    mem2 = (struct mem *)&ram[ptr2];
  8043a9:	8d 14 08             	lea    (%eax,%ecx,1),%edx
    if (mem2 < lfree) {
  8043ac:	39 15 04 53 81 00    	cmp    %edx,0x815304
  8043b2:	76 06                	jbe    8043ba <mem_realloc+0x133>
      lfree = mem2;
  8043b4:	89 15 04 53 81 00    	mov    %edx,0x815304
    mem2->used = 0;
  8043ba:	c6 42 08 00          	movb   $0x0,0x8(%edx)
    mem2->next = mem->next;
  8043be:	8b 5e f4             	mov    -0xc(%esi),%ebx
  8043c1:	89 1a                	mov    %ebx,(%edx)
    mem2->prev = ptr;
  8043c3:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  8043c6:	89 7a 04             	mov    %edi,0x4(%edx)
    mem->next = ptr2;
  8043c9:	89 4e f4             	mov    %ecx,-0xc(%esi)
    if (mem2->next != MEM_SIZE_ALIGNED) {
  8043cc:	8b 12                	mov    (%edx),%edx
  8043ce:	81 fa 00 00 22 00    	cmp    $0x220000,%edx
  8043d4:	0f 84 6d ff ff ff    	je     804347 <mem_realloc+0xc0>
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
  8043da:	89 4c 10 04          	mov    %ecx,0x4(%eax,%edx,1)
  8043de:	e9 64 ff ff ff       	jmp    804347 <mem_realloc+0xc0>

008043e3 <mem_malloc>:
 *
 * Note that the returned value will always be aligned (as defined by MEM_ALIGNMENT).
 */
void *
mem_malloc(mem_size_t size)
{
  8043e3:	f3 0f 1e fb          	endbr32 
  8043e7:	55                   	push   %ebp
  8043e8:	89 e5                	mov    %esp,%ebp
  8043ea:	57                   	push   %edi
  8043eb:	56                   	push   %esi
  8043ec:	53                   	push   %ebx
  8043ed:	83 ec 1c             	sub    $0x1c,%esp
  8043f0:	8b 45 08             	mov    0x8(%ebp),%eax
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  u8_t local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_ALLOC_DECL_PROTECT();

  if (size == 0) {
  8043f3:	85 c0                	test   %eax,%eax
  8043f5:	0f 84 a1 01 00 00    	je     80459c <mem_malloc+0x1b9>
    return NULL;
  }

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  size = LWIP_MEM_ALIGN_SIZE(size);
  8043fb:	83 c0 03             	add    $0x3,%eax
  8043fe:	83 e0 fc             	and    $0xfffffffc,%eax
  804401:	89 c7                	mov    %eax,%edi

  if(size < MIN_SIZE_ALIGNED) {
  804403:	83 f8 0b             	cmp    $0xb,%eax
  804406:	76 3a                	jbe    804442 <mem_malloc+0x5f>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
  }

  if (size > MEM_SIZE_ALIGNED) {
  804408:	3d 00 00 22 00       	cmp    $0x220000,%eax
  80440d:	0f 87 90 01 00 00    	ja     8045a3 <mem_malloc+0x1c0>
    return NULL;
  }

  /* protect the heap from concurrent access */
  sys_arch_sem_wait(mem_sem, 0);
  804413:	83 ec 08             	sub    $0x8,%esp
  804416:	6a 00                	push   $0x0
  804418:	ff 35 00 53 81 00    	pushl  0x815300
  80441e:	e8 c4 5f 00 00       	call   80a3e7 <sys_arch_sem_wait>
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
  804423:	a1 04 53 81 00       	mov    0x815304,%eax
  804428:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80442b:	8b 35 0c 53 81 00    	mov    0x81530c,%esi
  804431:	29 f0                	sub    %esi,%eax
  804433:	83 c4 10             	add    $0x10,%esp
  804436:	b9 00 00 22 00       	mov    $0x220000,%ecx
  80443b:	29 f9                	sub    %edi,%ecx
  80443d:	e9 e3 00 00 00       	jmp    804525 <mem_malloc+0x142>
    size = MIN_SIZE_ALIGNED;
  804442:	bf 0c 00 00 00       	mov    $0xc,%edi
  804447:	eb ca                	jmp    804413 <mem_malloc+0x30>
           * take care of this).
           * -> near fit or excact fit: do not split, no mem2 creation
           * also can't move mem->next directly behind mem, since mem->next
           * will always be used at this point!
           */
          mem->used = 1;
  804449:	c6 43 08 01          	movb   $0x1,0x8(%ebx)
          MEM_STATS_INC_USED(used, mem->next - ((u8_t *)mem - ram));
        }

        if (mem == lfree) {
  80444d:	39 5d e4             	cmp    %ebx,-0x1c(%ebp)
  804450:	74 4d                	je     80449f <mem_malloc+0xbc>
            lfree = (struct mem *)&ram[lfree->next];
          }
          LWIP_ASSERT("mem_malloc: !lfree->used", ((lfree == ram_end) || (!lfree->used)));
        }
        LWIP_MEM_ALLOC_UNPROTECT();
        sys_sem_signal(mem_sem);
  804452:	83 ec 0c             	sub    $0xc,%esp
  804455:	ff 35 00 53 81 00    	pushl  0x815300
  80445b:	e8 13 5f 00 00       	call   80a373 <sys_sem_signal>
        LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
  804460:	8d 44 3b 0c          	lea    0xc(%ebx,%edi,1),%eax
  804464:	83 c4 10             	add    $0x10,%esp
  804467:	39 05 08 53 81 00    	cmp    %eax,0x815308
  80446d:	0f 82 82 00 00 00    	jb     8044f5 <mem_malloc+0x112>
         (mem_ptr_t)mem + SIZEOF_STRUCT_MEM + size <= (mem_ptr_t)ram_end);
        LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
  804473:	8d 43 0c             	lea    0xc(%ebx),%eax
  804476:	f6 c3 03             	test   $0x3,%bl
  804479:	0f 85 8d 00 00 00    	jne    80450c <mem_malloc+0x129>
         (unsigned long)((u8_t *)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT == 0);
        LWIP_ASSERT("mem_malloc: sanity check alignment",
  80447f:	f6 c3 03             	test   $0x3,%bl
  804482:	0f 84 0c 01 00 00    	je     804594 <mem_malloc+0x1b1>
  804488:	83 ec 04             	sub    $0x4,%esp
  80448b:	68 a8 1c 81 00       	push   $0x811ca8
  804490:	68 4e 02 00 00       	push   $0x24e
  804495:	68 cb 1c 81 00       	push   $0x811ccb
  80449a:	e8 a8 a4 00 00       	call   80e947 <_panic>
          while (lfree->used && lfree != ram_end) {
  80449f:	8b 15 08 53 81 00    	mov    0x815308,%edx
  8044a5:	b8 00 00 00 00       	mov    $0x0,%eax
            lfree = (struct mem *)&ram[lfree->next];
  8044aa:	b9 01 00 00 00       	mov    $0x1,%ecx
  8044af:	89 7d e0             	mov    %edi,-0x20(%ebp)
  8044b2:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  8044b5:	eb 08                	jmp    8044bf <mem_malloc+0xdc>
  8044b7:	89 f0                	mov    %esi,%eax
  8044b9:	03 07                	add    (%edi),%eax
  8044bb:	89 c7                	mov    %eax,%edi
  8044bd:	89 c8                	mov    %ecx,%eax
          while (lfree->used && lfree != ram_end) {
  8044bf:	80 7f 08 00          	cmpb   $0x0,0x8(%edi)
  8044c3:	74 18                	je     8044dd <mem_malloc+0xfa>
  8044c5:	39 fa                	cmp    %edi,%edx
  8044c7:	75 ee                	jne    8044b7 <mem_malloc+0xd4>
  8044c9:	89 fe                	mov    %edi,%esi
  8044cb:	8b 7d e0             	mov    -0x20(%ebp),%edi
  8044ce:	84 c0                	test   %al,%al
  8044d0:	74 80                	je     804452 <mem_malloc+0x6f>
  8044d2:	89 35 04 53 81 00    	mov    %esi,0x815304
  8044d8:	e9 75 ff ff ff       	jmp    804452 <mem_malloc+0x6f>
  8044dd:	89 fe                	mov    %edi,%esi
  8044df:	8b 7d e0             	mov    -0x20(%ebp),%edi
  8044e2:	84 c0                	test   %al,%al
  8044e4:	0f 84 68 ff ff ff    	je     804452 <mem_malloc+0x6f>
  8044ea:	89 35 04 53 81 00    	mov    %esi,0x815304
  8044f0:	e9 5d ff ff ff       	jmp    804452 <mem_malloc+0x6f>
        LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
  8044f5:	83 ec 04             	sub    $0x4,%esp
  8044f8:	68 48 1c 81 00       	push   $0x811c48
  8044fd:	68 4a 02 00 00       	push   $0x24a
  804502:	68 cb 1c 81 00       	push   $0x811ccb
  804507:	e8 3b a4 00 00       	call   80e947 <_panic>
        LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
  80450c:	83 ec 04             	sub    $0x4,%esp
  80450f:	68 78 1c 81 00       	push   $0x811c78
  804514:	68 4c 02 00 00       	push   $0x24c
  804519:	68 cb 1c 81 00       	push   $0x811ccb
  80451e:	e8 24 a4 00 00       	call   80e947 <_panic>
         ptr = ((struct mem *)&ram[ptr])->next) {
  804523:	8b 03                	mov    (%ebx),%eax
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
  804525:	39 c1                	cmp    %eax,%ecx
  804527:	76 55                	jbe    80457e <mem_malloc+0x19b>
      mem = (struct mem *)&ram[ptr];
  804529:	8d 1c 06             	lea    (%esi,%eax,1),%ebx
      if ((!mem->used) &&
  80452c:	80 7b 08 00          	cmpb   $0x0,0x8(%ebx)
  804530:	75 f1                	jne    804523 <mem_malloc+0x140>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
  804532:	ba f4 ff ff ff       	mov    $0xfffffff4,%edx
  804537:	29 c2                	sub    %eax,%edx
  804539:	03 13                	add    (%ebx),%edx
      if ((!mem->used) &&
  80453b:	39 fa                	cmp    %edi,%edx
  80453d:	72 e4                	jb     804523 <mem_malloc+0x140>
        if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
  80453f:	8d 4f 18             	lea    0x18(%edi),%ecx
  804542:	39 ca                	cmp    %ecx,%edx
  804544:	0f 82 ff fe ff ff    	jb     804449 <mem_malloc+0x66>
          ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
  80454a:	8d 4c 38 0c          	lea    0xc(%eax,%edi,1),%ecx
          mem2 = (struct mem *)&ram[ptr2];
  80454e:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  804551:	8d 14 0e             	lea    (%esi,%ecx,1),%edx
          mem2->used = 0;
  804554:	c6 42 08 00          	movb   $0x0,0x8(%edx)
          mem2->next = mem->next;
  804558:	8b 0b                	mov    (%ebx),%ecx
  80455a:	89 0a                	mov    %ecx,(%edx)
          mem2->prev = ptr;
  80455c:	89 42 04             	mov    %eax,0x4(%edx)
          mem->next = ptr2;
  80455f:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  804562:	89 0b                	mov    %ecx,(%ebx)
          mem->used = 1;
  804564:	c6 43 08 01          	movb   $0x1,0x8(%ebx)
          if (mem2->next != MEM_SIZE_ALIGNED) {
  804568:	8b 02                	mov    (%edx),%eax
  80456a:	3d 00 00 22 00       	cmp    $0x220000,%eax
  80456f:	0f 84 d8 fe ff ff    	je     80444d <mem_malloc+0x6a>
            ((struct mem *)&ram[mem2->next])->prev = ptr2;
  804575:	89 4c 06 04          	mov    %ecx,0x4(%esi,%eax,1)
  804579:	e9 cf fe ff ff       	jmp    80444d <mem_malloc+0x6a>
  } while(local_mem_free_count != 0);
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_DEBUGF(MEM_DEBUG | 2, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  MEM_STATS_INC(err);
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_sem_signal(mem_sem);
  80457e:	83 ec 0c             	sub    $0xc,%esp
  804581:	ff 35 00 53 81 00    	pushl  0x815300
  804587:	e8 e7 5d 00 00       	call   80a373 <sys_sem_signal>
  return NULL;
  80458c:	83 c4 10             	add    $0x10,%esp
  80458f:	b8 00 00 00 00       	mov    $0x0,%eax
}
  804594:	8d 65 f4             	lea    -0xc(%ebp),%esp
  804597:	5b                   	pop    %ebx
  804598:	5e                   	pop    %esi
  804599:	5f                   	pop    %edi
  80459a:	5d                   	pop    %ebp
  80459b:	c3                   	ret    
    return NULL;
  80459c:	b8 00 00 00 00       	mov    $0x0,%eax
  8045a1:	eb f1                	jmp    804594 <mem_malloc+0x1b1>
    return NULL;
  8045a3:	b8 00 00 00 00       	mov    $0x0,%eax
  8045a8:	eb ea                	jmp    804594 <mem_malloc+0x1b1>

008045aa <mem_calloc>:
 * @param count number of objects to allocate
 * @param size size of the objects to allocate
 * @return pointer to allocated memory / NULL pointer if there is an error
 */
void *mem_calloc(mem_size_t count, mem_size_t size)
{
  8045aa:	f3 0f 1e fb          	endbr32 
  8045ae:	55                   	push   %ebp
  8045af:	89 e5                	mov    %esp,%ebp
  8045b1:	56                   	push   %esi
  8045b2:	53                   	push   %ebx
  void *p;

  /* allocate 'count' objects of size 'size' */
  p = mem_malloc(count * size);
  8045b3:	8b 75 0c             	mov    0xc(%ebp),%esi
  8045b6:	0f af 75 08          	imul   0x8(%ebp),%esi
  8045ba:	83 ec 0c             	sub    $0xc,%esp
  8045bd:	56                   	push   %esi
  8045be:	e8 20 fe ff ff       	call   8043e3 <mem_malloc>
  8045c3:	89 c3                	mov    %eax,%ebx
  if (p) {
  8045c5:	83 c4 10             	add    $0x10,%esp
  8045c8:	85 c0                	test   %eax,%eax
  8045ca:	74 0f                	je     8045db <mem_calloc+0x31>
    /* zero the memory */
    memset(p, 0, count * size);
  8045cc:	83 ec 04             	sub    $0x4,%esp
  8045cf:	56                   	push   %esi
  8045d0:	6a 00                	push   $0x0
  8045d2:	50                   	push   %eax
  8045d3:	e8 ca ab 00 00       	call   80f1a2 <memset>
  8045d8:	83 c4 10             	add    $0x10,%esp
  }
  return p;
}
  8045db:	89 d8                	mov    %ebx,%eax
  8045dd:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8045e0:	5b                   	pop    %ebx
  8045e1:	5e                   	pop    %esi
  8045e2:	5d                   	pop    %ebp
  8045e3:	c3                   	ret    

008045e4 <memp_init>:
 * 
 * Carves out memp_memory into linked lists for each pool-type.
 */
void
memp_init(void)
{
  8045e4:	f3 0f 1e fb          	endbr32 
  8045e8:	55                   	push   %ebp
  8045e9:	89 e5                	mov    %esp,%ebp
  8045eb:	56                   	push   %esi
  8045ec:	53                   	push   %ebx
    MEMP_STATS_AVAIL(max, i, 0);
    MEMP_STATS_AVAIL(err, i, 0);
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
  }

  memp = LWIP_MEM_ALIGN(memp_memory);
  8045ed:	b8 43 53 a3 00       	mov    $0xa35343,%eax
  8045f2:	83 e0 fc             	and    $0xfffffffc,%eax
  8045f5:	ba 00 00 00 00       	mov    $0x0,%edx
  8045fa:	eb 2a                	jmp    804626 <memp_init+0x42>
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
    memp_tab[i] = NULL;
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
      memp->next = memp_tab[i];
  8045fc:	8b 1c 95 c0 43 b3 00 	mov    0xb343c0(,%edx,4),%ebx
  804603:	89 18                	mov    %ebx,(%eax)
      memp_tab[i] = memp;
  804605:	89 04 95 c0 43 b3 00 	mov    %eax,0xb343c0(,%edx,4)
      memp = (struct memp *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]);
  80460c:	0f b7 9c 12 e8 1d 81 	movzwl 0x811de8(%edx,%edx,1),%ebx
  804613:	00 
  804614:	01 d8                	add    %ebx,%eax
    for (j = 0; j < memp_num[i]; ++j) {
  804616:	83 c1 01             	add    $0x1,%ecx
  804619:	66 39 ce             	cmp    %cx,%si
  80461c:	75 de                	jne    8045fc <memp_init+0x18>
  80461e:	83 c2 01             	add    $0x1,%edx
  for (i = 0; i < MEMP_MAX; ++i) {
  804621:	83 fa 0e             	cmp    $0xe,%edx
  804624:	74 1a                	je     804640 <memp_init+0x5c>
    memp_tab[i] = NULL;
  804626:	c7 04 95 c0 43 b3 00 	movl   $0x0,0xb343c0(,%edx,4)
  80462d:	00 00 00 00 
    for (j = 0; j < memp_num[i]; ++j) {
  804631:	0f b7 b4 12 cc 1d 81 	movzwl 0x811dcc(%edx,%edx,1),%esi
  804638:	00 
  804639:	b9 00 00 00 00       	mov    $0x0,%ecx
  80463e:	eb d9                	jmp    804619 <memp_init+0x35>
#if MEMP_OVERFLOW_CHECK
  memp_overflow_init();
  /* check everything a first time to see if it worked */
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK */
}
  804640:	5b                   	pop    %ebx
  804641:	5e                   	pop    %esi
  804642:	5d                   	pop    %ebp
  804643:	c3                   	ret    

00804644 <memp_malloc>:
#if !MEMP_OVERFLOW_CHECK
memp_malloc(memp_t type)
#else
memp_malloc_fn(memp_t type, const char* file, const int line)
#endif
{
  804644:	f3 0f 1e fb          	endbr32 
  804648:	55                   	push   %ebp
  804649:	89 e5                	mov    %esp,%ebp
  80464b:	83 ec 08             	sub    $0x8,%esp
  80464e:	8b 55 08             	mov    0x8(%ebp),%edx
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);
 
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
  804651:	83 fa 0d             	cmp    $0xd,%edx
  804654:	77 1a                	ja     804670 <memp_malloc+0x2c>
  SYS_ARCH_PROTECT(old_level);
#if MEMP_OVERFLOW_CHECK >= 2
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK >= 2 */

  memp = memp_tab[type];
  804656:	8b 04 95 c0 43 b3 00 	mov    0xb343c0(,%edx,4),%eax
  
  if (memp != NULL) {    
  80465d:	85 c0                	test   %eax,%eax
  80465f:	74 0d                	je     80466e <memp_malloc+0x2a>
    memp_tab[type] = memp->next;    
  804661:	8b 08                	mov    (%eax),%ecx
  804663:	89 0c 95 c0 43 b3 00 	mov    %ecx,0xb343c0(,%edx,4)
    memp->next = NULL;
    memp->file = file;
    memp->line = line;
#endif /* MEMP_OVERFLOW_CHECK */
    MEMP_STATS_INC_USED(used, type);
    LWIP_ASSERT("memp_malloc: memp properly aligned",
  80466a:	a8 03                	test   $0x3,%al
  80466c:	75 19                	jne    804687 <memp_malloc+0x43>
  }

  SYS_ARCH_UNPROTECT(old_level);

  return memp;
}
  80466e:	c9                   	leave  
  80466f:	c3                   	ret    
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
  804670:	83 ec 04             	sub    $0x4,%esp
  804673:	68 55 1d 81 00       	push   $0x811d55
  804678:	68 2d 01 00 00       	push   $0x12d
  80467d:	68 72 1d 81 00       	push   $0x811d72
  804682:	e8 c0 a2 00 00       	call   80e947 <_panic>
    LWIP_ASSERT("memp_malloc: memp properly aligned",
  804687:	83 ec 04             	sub    $0x4,%esp
  80468a:	68 88 1d 81 00       	push   $0x811d88
  80468f:	68 3e 01 00 00       	push   $0x13e
  804694:	68 72 1d 81 00       	push   $0x811d72
  804699:	e8 a9 a2 00 00       	call   80e947 <_panic>

0080469e <memp_free>:
 * @param type the pool where to put mem
 * @param mem the memp element to free
 */
void
memp_free(memp_t type, void *mem)
{
  80469e:	f3 0f 1e fb          	endbr32 
  8046a2:	55                   	push   %ebp
  8046a3:	89 e5                	mov    %esp,%ebp
  8046a5:	83 ec 08             	sub    $0x8,%esp
  8046a8:	8b 55 08             	mov    0x8(%ebp),%edx
  8046ab:	8b 45 0c             	mov    0xc(%ebp),%eax
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);

  if (mem == NULL) {
  8046ae:	85 c0                	test   %eax,%eax
  8046b0:	74 14                	je     8046c6 <memp_free+0x28>
    return;
  }
  LWIP_ASSERT("memp_free: mem properly aligned",
  8046b2:	a8 03                	test   $0x3,%al
  8046b4:	75 12                	jne    8046c8 <memp_free+0x2a>
#endif /* MEMP_OVERFLOW_CHECK >= 2 */
#endif /* MEMP_OVERFLOW_CHECK */

  MEMP_STATS_DEC(used, type); 
  
  memp->next = memp_tab[type]; 
  8046b6:	8b 0c 95 c0 43 b3 00 	mov    0xb343c0(,%edx,4),%ecx
  8046bd:	89 08                	mov    %ecx,(%eax)
  memp_tab[type] = memp;
  8046bf:	89 04 95 c0 43 b3 00 	mov    %eax,0xb343c0(,%edx,4)
#if MEMP_SANITY_CHECK
  LWIP_ASSERT("memp sanity", memp_sanity());
#endif /* MEMP_SANITY_CHECK */

  SYS_ARCH_UNPROTECT(old_level);
}
  8046c6:	c9                   	leave  
  8046c7:	c3                   	ret    
  LWIP_ASSERT("memp_free: mem properly aligned",
  8046c8:	83 ec 04             	sub    $0x4,%esp
  8046cb:	68 ac 1d 81 00       	push   $0x811dac
  8046d0:	68 5a 01 00 00       	push   $0x15a
  8046d5:	68 72 1d 81 00       	push   $0x811d72
  8046da:	e8 68 a2 00 00       	call   80e947 <_panic>

008046df <netif_remove>:
 * Remove a network interface from the list of lwIP netifs.
 *
 * @param netif the network interface to remove
 */
void netif_remove(struct netif * netif)
{
  8046df:	f3 0f 1e fb          	endbr32 
  8046e3:	55                   	push   %ebp
  8046e4:	89 e5                	mov    %esp,%ebp
  8046e6:	8b 4d 08             	mov    0x8(%ebp),%ecx
  if ( netif == NULL ) return;
  8046e9:	85 c9                	test   %ecx,%ecx
  8046eb:	74 2c                	je     804719 <netif_remove+0x3a>
#endif /* LWIP_IGMP */

  snmp_delete_ipaddridx_tree(netif);

  /*  is it the first netif? */
  if (netif_list == netif) {
  8046ed:	a1 34 b2 b3 00       	mov    0xb3b234,%eax
  8046f2:	39 c8                	cmp    %ecx,%eax
  8046f4:	74 0e                	je     804704 <netif_remove+0x25>
    snmp_dec_iflist();
  }
  else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
  8046f6:	85 c0                	test   %eax,%eax
  8046f8:	74 1f                	je     804719 <netif_remove+0x3a>
      if (tmpNetif->next == netif) {
  8046fa:	8b 10                	mov    (%eax),%edx
  8046fc:	39 ca                	cmp    %ecx,%edx
  8046fe:	74 0d                	je     80470d <netif_remove+0x2e>
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
  804700:	89 d0                	mov    %edx,%eax
  804702:	eb f2                	jmp    8046f6 <netif_remove+0x17>
    netif_list = netif->next;
  804704:	8b 01                	mov    (%ecx),%eax
  804706:	a3 34 b2 b3 00       	mov    %eax,0xb3b234
  80470b:	eb 04                	jmp    804711 <netif_remove+0x32>
        tmpNetif->next = netif->next;
  80470d:	8b 11                	mov    (%ecx),%edx
  80470f:	89 10                	mov    %edx,(%eax)
    }
    if (tmpNetif == NULL)
      return; /*  we didn't find any netif today */
  }
  /* this netif is default? */
  if (netif_default == netif)
  804711:	39 0d 38 b2 b3 00    	cmp    %ecx,0xb3b238
  804717:	74 02                	je     80471b <netif_remove+0x3c>
    /* reset default netif */
    netif_set_default(NULL);
  LWIP_DEBUGF( NETIF_DEBUG, ("netif_remove: removed netif\n") );
}
  804719:	5d                   	pop    %ebp
  80471a:	c3                   	ret    
  else
  {
    /* install default route */
    snmp_insert_iprteidx_tree(1, netif);
  }
  netif_default = netif;
  80471b:	c7 05 38 b2 b3 00 00 	movl   $0x0,0xb3b238
  804722:	00 00 00 
  LWIP_DEBUGF(NETIF_DEBUG, ("netif: setting default interface %c%c\n",
           netif ? netif->name[0] : '\'', netif ? netif->name[1] : '\''));
}
  804725:	eb f2                	jmp    804719 <netif_remove+0x3a>

00804727 <netif_find>:
{
  804727:	f3 0f 1e fb          	endbr32 
  80472b:	55                   	push   %ebp
  80472c:	89 e5                	mov    %esp,%ebp
  80472e:	53                   	push   %ebx
  80472f:	8b 4d 08             	mov    0x8(%ebp),%ecx
  if (name == NULL) {
  804732:	85 c9                	test   %ecx,%ecx
  804734:	74 2d                	je     804763 <netif_find+0x3c>
  num = name[2] - '0';
  804736:	0f b6 41 02          	movzbl 0x2(%ecx),%eax
  80473a:	8d 50 d0             	lea    -0x30(%eax),%edx
  for(netif = netif_list; netif != NULL; netif = netif->next) {
  80473d:	a1 34 b2 b3 00       	mov    0xb3b234,%eax
  804742:	eb 02                	jmp    804746 <netif_find+0x1f>
  804744:	8b 00                	mov    (%eax),%eax
  804746:	85 c0                	test   %eax,%eax
  804748:	74 16                	je     804760 <netif_find+0x39>
    if (num == netif->num &&
  80474a:	38 50 31             	cmp    %dl,0x31(%eax)
  80474d:	75 f5                	jne    804744 <netif_find+0x1d>
  80474f:	0f b6 58 2f          	movzbl 0x2f(%eax),%ebx
  804753:	38 19                	cmp    %bl,(%ecx)
  804755:	75 ed                	jne    804744 <netif_find+0x1d>
       name[0] == netif->name[0] &&
  804757:	0f b6 58 30          	movzbl 0x30(%eax),%ebx
  80475b:	38 59 01             	cmp    %bl,0x1(%ecx)
  80475e:	75 e4                	jne    804744 <netif_find+0x1d>
}
  804760:	5b                   	pop    %ebx
  804761:	5d                   	pop    %ebp
  804762:	c3                   	ret    
    return NULL;
  804763:	89 c8                	mov    %ecx,%eax
  804765:	eb f9                	jmp    804760 <netif_find+0x39>

00804767 <netif_set_ipaddr>:
{
  804767:	f3 0f 1e fb          	endbr32 
  80476b:	55                   	push   %ebp
  80476c:	89 e5                	mov    %esp,%ebp
  80476e:	57                   	push   %edi
  80476f:	56                   	push   %esi
  804770:	53                   	push   %ebx
  804771:	83 ec 0c             	sub    $0xc,%esp
  804774:	8b 5d 08             	mov    0x8(%ebp),%ebx
  804777:	8b 75 0c             	mov    0xc(%ebp),%esi
  if ((ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0)
  80477a:	8b 43 04             	mov    0x4(%ebx),%eax
  80477d:	39 06                	cmp    %eax,(%esi)
  80477f:	74 47                	je     8047c8 <netif_set_ipaddr+0x61>
    pcb = tcp_active_pcbs;
  804781:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
    while (pcb != NULL) {
  804786:	eb 11                	jmp    804799 <netif_set_ipaddr+0x32>
        struct tcp_pcb *next = pcb->next;
  804788:	8b 78 0c             	mov    0xc(%eax),%edi
        tcp_abort(pcb);
  80478b:	83 ec 0c             	sub    $0xc,%esp
  80478e:	50                   	push   %eax
  80478f:	e8 45 16 00 00       	call   805dd9 <tcp_abort>
  804794:	83 c4 10             	add    $0x10,%esp
        pcb = next;
  804797:	89 f8                	mov    %edi,%eax
    while (pcb != NULL) {
  804799:	85 c0                	test   %eax,%eax
  80479b:	74 0c                	je     8047a9 <netif_set_ipaddr+0x42>
      if (ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
  80479d:	8b 4b 04             	mov    0x4(%ebx),%ecx
  8047a0:	39 08                	cmp    %ecx,(%eax)
  8047a2:	74 e4                	je     804788 <netif_set_ipaddr+0x21>
        pcb = pcb->next;
  8047a4:	8b 40 0c             	mov    0xc(%eax),%eax
  8047a7:	eb f0                	jmp    804799 <netif_set_ipaddr+0x32>
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  8047a9:	a1 44 b2 b3 00       	mov    0xb3b244,%eax
  8047ae:	eb 03                	jmp    8047b3 <netif_set_ipaddr+0x4c>
  8047b0:	8b 40 0c             	mov    0xc(%eax),%eax
  8047b3:	85 c0                	test   %eax,%eax
  8047b5:	74 11                	je     8047c8 <netif_set_ipaddr+0x61>
      if ((!(ip_addr_isany(&(lpcb->local_ip)))) &&
  8047b7:	8b 10                	mov    (%eax),%edx
  8047b9:	85 d2                	test   %edx,%edx
  8047bb:	74 f3                	je     8047b0 <netif_set_ipaddr+0x49>
  8047bd:	3b 53 04             	cmp    0x4(%ebx),%edx
  8047c0:	75 ee                	jne    8047b0 <netif_set_ipaddr+0x49>
        ip_addr_set(&(lpcb->local_ip), ipaddr);
  8047c2:	8b 16                	mov    (%esi),%edx
  8047c4:	89 10                	mov    %edx,(%eax)
  8047c6:	eb e8                	jmp    8047b0 <netif_set_ipaddr+0x49>
  ip_addr_set(&(netif->ip_addr), ipaddr);
  8047c8:	8b 06                	mov    (%esi),%eax
  8047ca:	89 43 04             	mov    %eax,0x4(%ebx)
}
  8047cd:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8047d0:	5b                   	pop    %ebx
  8047d1:	5e                   	pop    %esi
  8047d2:	5f                   	pop    %edi
  8047d3:	5d                   	pop    %ebp
  8047d4:	c3                   	ret    

008047d5 <netif_set_addr>:
{
  8047d5:	f3 0f 1e fb          	endbr32 
  8047d9:	55                   	push   %ebp
  8047da:	89 e5                	mov    %esp,%ebp
  8047dc:	57                   	push   %edi
  8047dd:	56                   	push   %esi
  8047de:	53                   	push   %ebx
  8047df:	83 ec 14             	sub    $0x14,%esp
  8047e2:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8047e5:	8b 7d 10             	mov    0x10(%ebp),%edi
  8047e8:	8b 75 14             	mov    0x14(%ebp),%esi
  netif_set_ipaddr(netif, ipaddr);
  8047eb:	ff 75 0c             	pushl  0xc(%ebp)
  8047ee:	53                   	push   %ebx
  8047ef:	e8 73 ff ff ff       	call   804767 <netif_set_ipaddr>
  ip_addr_set(&(netif->netmask), netmask);
  8047f4:	83 c4 10             	add    $0x10,%esp
  8047f7:	b8 00 00 00 00       	mov    $0x0,%eax
  8047fc:	85 ff                	test   %edi,%edi
  8047fe:	74 02                	je     804802 <netif_set_addr+0x2d>
  804800:	8b 07                	mov    (%edi),%eax
  804802:	89 43 08             	mov    %eax,0x8(%ebx)
  ip_addr_set(&(netif->gw), gw);
  804805:	b8 00 00 00 00       	mov    $0x0,%eax
  80480a:	85 f6                	test   %esi,%esi
  80480c:	74 02                	je     804810 <netif_set_addr+0x3b>
  80480e:	8b 06                	mov    (%esi),%eax
  804810:	89 43 0c             	mov    %eax,0xc(%ebx)
}
  804813:	8d 65 f4             	lea    -0xc(%ebp),%esp
  804816:	5b                   	pop    %ebx
  804817:	5e                   	pop    %esi
  804818:	5f                   	pop    %edi
  804819:	5d                   	pop    %ebp
  80481a:	c3                   	ret    

0080481b <netif_add>:
{
  80481b:	f3 0f 1e fb          	endbr32 
  80481f:	55                   	push   %ebp
  804820:	89 e5                	mov    %esp,%ebp
  804822:	53                   	push   %ebx
  804823:	83 ec 04             	sub    $0x4,%esp
  804826:	8b 5d 08             	mov    0x8(%ebp),%ebx
  netif->ip_addr.addr = 0;
  804829:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  netif->netmask.addr = 0;
  804830:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  netif->gw.addr = 0;
  804837:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
  netif->flags = 0;
  80483e:	c6 43 2e 00          	movb   $0x0,0x2e(%ebx)
  netif->dhcp = NULL;
  804842:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
  netif->state = state;
  804849:	8b 45 18             	mov    0x18(%ebp),%eax
  80484c:	89 43 1c             	mov    %eax,0x1c(%ebx)
  netif->num = netifnum++;
  80484f:	0f b6 05 f8 43 b3 00 	movzbl 0xb343f8,%eax
  804856:	8d 50 01             	lea    0x1(%eax),%edx
  804859:	88 15 f8 43 b3 00    	mov    %dl,0xb343f8
  80485f:	88 43 31             	mov    %al,0x31(%ebx)
  netif->input = input;
  804862:	8b 45 20             	mov    0x20(%ebp),%eax
  804865:	89 43 10             	mov    %eax,0x10(%ebx)
  netif_set_addr(netif, ipaddr, netmask, gw);
  804868:	ff 75 14             	pushl  0x14(%ebp)
  80486b:	ff 75 10             	pushl  0x10(%ebp)
  80486e:	ff 75 0c             	pushl  0xc(%ebp)
  804871:	53                   	push   %ebx
  804872:	e8 5e ff ff ff       	call   8047d5 <netif_set_addr>
  if (init(netif) != ERR_OK) {
  804877:	89 1c 24             	mov    %ebx,(%esp)
  80487a:	ff 55 1c             	call   *0x1c(%ebp)
  80487d:	83 c4 10             	add    $0x10,%esp
  804880:	84 c0                	test   %al,%al
  804882:	75 14                	jne    804898 <netif_add+0x7d>
  netif->next = netif_list;
  804884:	a1 34 b2 b3 00       	mov    0xb3b234,%eax
  804889:	89 03                	mov    %eax,(%ebx)
  netif_list = netif;
  80488b:	89 1d 34 b2 b3 00    	mov    %ebx,0xb3b234
  return netif;
  804891:	89 d8                	mov    %ebx,%eax
}
  804893:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  804896:	c9                   	leave  
  804897:	c3                   	ret    
    return NULL;
  804898:	b8 00 00 00 00       	mov    $0x0,%eax
  80489d:	eb f4                	jmp    804893 <netif_add+0x78>

0080489f <netif_set_gw>:
{
  80489f:	f3 0f 1e fb          	endbr32 
  8048a3:	55                   	push   %ebp
  8048a4:	89 e5                	mov    %esp,%ebp
  8048a6:	8b 55 0c             	mov    0xc(%ebp),%edx
  ip_addr_set(&(netif->gw), gw);
  8048a9:	b8 00 00 00 00       	mov    $0x0,%eax
  8048ae:	85 d2                	test   %edx,%edx
  8048b0:	74 02                	je     8048b4 <netif_set_gw+0x15>
  8048b2:	8b 02                	mov    (%edx),%eax
  8048b4:	8b 55 08             	mov    0x8(%ebp),%edx
  8048b7:	89 42 0c             	mov    %eax,0xc(%edx)
}
  8048ba:	5d                   	pop    %ebp
  8048bb:	c3                   	ret    

008048bc <netif_set_netmask>:
{
  8048bc:	f3 0f 1e fb          	endbr32 
  8048c0:	55                   	push   %ebp
  8048c1:	89 e5                	mov    %esp,%ebp
  8048c3:	8b 55 0c             	mov    0xc(%ebp),%edx
  ip_addr_set(&(netif->netmask), netmask);
  8048c6:	b8 00 00 00 00       	mov    $0x0,%eax
  8048cb:	85 d2                	test   %edx,%edx
  8048cd:	74 02                	je     8048d1 <netif_set_netmask+0x15>
  8048cf:	8b 02                	mov    (%edx),%eax
  8048d1:	8b 55 08             	mov    0x8(%ebp),%edx
  8048d4:	89 42 08             	mov    %eax,0x8(%edx)
}
  8048d7:	5d                   	pop    %ebp
  8048d8:	c3                   	ret    

008048d9 <netif_set_default>:
{
  8048d9:	f3 0f 1e fb          	endbr32 
  8048dd:	55                   	push   %ebp
  8048de:	89 e5                	mov    %esp,%ebp
  netif_default = netif;
  8048e0:	8b 45 08             	mov    0x8(%ebp),%eax
  8048e3:	a3 38 b2 b3 00       	mov    %eax,0xb3b238
}
  8048e8:	5d                   	pop    %ebp
  8048e9:	c3                   	ret    

008048ea <netif_set_up>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_up(struct netif *netif)
{
  8048ea:	f3 0f 1e fb          	endbr32 
  8048ee:	55                   	push   %ebp
  8048ef:	89 e5                	mov    %esp,%ebp
  8048f1:	83 ec 08             	sub    $0x8,%esp
  8048f4:	8b 55 08             	mov    0x8(%ebp),%edx
  if ( !(netif->flags & NETIF_FLAG_UP )) {
  8048f7:	0f b6 42 2e          	movzbl 0x2e(%edx),%eax
  8048fb:	a8 01                	test   $0x1,%al
  8048fd:	75 0c                	jne    80490b <netif_set_up+0x21>
    netif->flags |= NETIF_FLAG_UP;
  8048ff:	89 c1                	mov    %eax,%ecx
  804901:	83 c9 01             	or     $0x1,%ecx
  804904:	88 4a 2e             	mov    %cl,0x2e(%edx)
    /** For Ethernet network interfaces, we would like to send a
     *  "gratuitous ARP"; this is an ARP packet sent by a node in order
     *  to spontaneously cause other nodes to update an entry in their
     *  ARP cache. From RFC 3220 "IP Mobility Support for IPv4" section 4.6.
     */ 
    if (netif->flags & NETIF_FLAG_ETHARP) {
  804907:	a8 20                	test   $0x20,%al
  804909:	75 02                	jne    80490d <netif_set_up+0x23>
      etharp_query(netif, &(netif->ip_addr), NULL);
    }
#endif /* LWIP_ARP */
    
  }
}
  80490b:	c9                   	leave  
  80490c:	c3                   	ret    
      etharp_query(netif, &(netif->ip_addr), NULL);
  80490d:	83 ec 04             	sub    $0x4,%esp
  804910:	6a 00                	push   $0x0
  804912:	8d 42 04             	lea    0x4(%edx),%eax
  804915:	50                   	push   %eax
  804916:	52                   	push   %edx
  804917:	e8 a3 52 00 00       	call   809bbf <etharp_query>
  80491c:	83 c4 10             	add    $0x10,%esp
}
  80491f:	eb ea                	jmp    80490b <netif_set_up+0x21>

00804921 <netif_set_down>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_down(struct netif *netif)
{
  804921:	f3 0f 1e fb          	endbr32 
  804925:	55                   	push   %ebp
  804926:	89 e5                	mov    %esp,%ebp
  804928:	8b 55 08             	mov    0x8(%ebp),%edx
  if ( netif->flags & NETIF_FLAG_UP )
  80492b:	0f b6 42 2e          	movzbl 0x2e(%edx),%eax
  80492f:	a8 01                	test   $0x1,%al
  804931:	74 06                	je     804939 <netif_set_down+0x18>
    {
      netif->flags &= ~NETIF_FLAG_UP;
  804933:	83 e0 fe             	and    $0xfffffffe,%eax
  804936:	88 42 2e             	mov    %al,0x2e(%edx)
#endif
      
      NETIF_LINK_CALLBACK(netif);
      NETIF_STATUS_CALLBACK(netif);
    }
}
  804939:	5d                   	pop    %ebp
  80493a:	c3                   	ret    

0080493b <netif_is_up>:

/**
 * Ask if an interface is up
 */ 
u8_t netif_is_up(struct netif *netif)
{
  80493b:	f3 0f 1e fb          	endbr32 
  80493f:	55                   	push   %ebp
  804940:	89 e5                	mov    %esp,%ebp
  return (netif->flags & NETIF_FLAG_UP)?1:0;
  804942:	8b 45 08             	mov    0x8(%ebp),%eax
  804945:	0f b6 40 2e          	movzbl 0x2e(%eax),%eax
  804949:	83 e0 01             	and    $0x1,%eax
}
  80494c:	5d                   	pop    %ebp
  80494d:	c3                   	ret    

0080494e <pbuf_header>:
 * @return non-zero on failure, zero on success.
 *
 */
u8_t
pbuf_header(struct pbuf *p, s16_t header_size_increment)
{
  80494e:	f3 0f 1e fb          	endbr32 
  804952:	55                   	push   %ebp
  804953:	89 e5                	mov    %esp,%ebp
  804955:	56                   	push   %esi
  804956:	53                   	push   %ebx
  804957:	8b 45 08             	mov    0x8(%ebp),%eax
  80495a:	8b 55 0c             	mov    0xc(%ebp),%edx
  u16_t type;
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
  80495d:	85 c0                	test   %eax,%eax
  80495f:	74 42                	je     8049a3 <pbuf_header+0x55>
  if ((header_size_increment == 0) || (p == NULL))
  804961:	66 85 d2             	test   %dx,%dx
  804964:	0f 84 b0 00 00 00    	je     804a1a <pbuf_header+0xcc>
  if (header_size_increment < 0){
    increment_magnitude = -header_size_increment;
    /* Check that we aren't going to move off the end of the pbuf */
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
  } else {
    increment_magnitude = header_size_increment;
  80496a:	89 d6                	mov    %edx,%esi
  if (header_size_increment < 0){
  80496c:	78 4c                	js     8049ba <pbuf_header+0x6c>
    LWIP_ASSERT("p->payload - increment_magnitude >= p + SIZEOF_STRUCT_PBUF",
                (u8_t *)p->payload - increment_magnitude >= (u8_t *)p + SIZEOF_STRUCT_PBUF);
#endif
  }

  type = p->type;
  80496e:	0f b6 48 0c          	movzbl 0xc(%eax),%ecx
  /* remember current payload pointer */
  payload = p->payload;
  804972:	8b 58 04             	mov    0x4(%eax),%ebx

  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
  804975:	66 85 c9             	test   %cx,%cx
  804978:	74 5f                	je     8049d9 <pbuf_header+0x8b>
  80497a:	66 83 f9 03          	cmp    $0x3,%cx
  80497e:	74 59                	je     8049d9 <pbuf_header+0x8b>
      p->payload = payload;
      /* bail out unsuccesfully */
      return 1;
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
  804980:	83 e9 01             	sub    $0x1,%ecx
  804983:	66 83 f9 01          	cmp    $0x1,%cx
  804987:	77 7a                	ja     804a03 <pbuf_header+0xb5>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
    } else {
      /* cannot expand payload to front (yet!)
       * bail out unsuccesfully */
      return 1;
  804989:	b9 01 00 00 00       	mov    $0x1,%ecx
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
  80498e:	66 85 d2             	test   %dx,%dx
  804991:	79 67                	jns    8049fa <pbuf_header+0xac>
  804993:	66 39 70 0a          	cmp    %si,0xa(%eax)
  804997:	72 61                	jb     8049fa <pbuf_header+0xac>
      p->payload = (u8_t *)p->payload - header_size_increment;
  804999:	0f bf ca             	movswl %dx,%ecx
  80499c:	29 cb                	sub    %ecx,%ebx
  80499e:	89 58 04             	mov    %ebx,0x4(%eax)
  8049a1:	eb 4a                	jmp    8049ed <pbuf_header+0x9f>
  LWIP_ASSERT("p != NULL", p != NULL);
  8049a3:	83 ec 04             	sub    $0x4,%esp
  8049a6:	68 c8 1e 81 00       	push   $0x811ec8
  8049ab:	68 64 01 00 00       	push   $0x164
  8049b0:	68 04 1e 81 00       	push   $0x811e04
  8049b5:	e8 8d 9f 00 00       	call   80e947 <_panic>
    increment_magnitude = -header_size_increment;
  8049ba:	f7 de                	neg    %esi
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
  8049bc:	66 39 70 0a          	cmp    %si,0xa(%eax)
  8049c0:	73 ac                	jae    80496e <pbuf_header+0x20>
  8049c2:	83 ec 04             	sub    $0x4,%esp
  8049c5:	68 19 1e 81 00       	push   $0x811e19
  8049ca:	68 6b 01 00 00       	push   $0x16b
  8049cf:	68 04 1e 81 00       	push   $0x811e04
  8049d4:	e8 6e 9f 00 00       	call   80e947 <_panic>
    p->payload = (u8_t *)p->payload - header_size_increment;
  8049d9:	0f bf ca             	movswl %dx,%ecx
  8049dc:	29 cb                	sub    %ecx,%ebx
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
  8049de:	8d 70 10             	lea    0x10(%eax),%esi
      return 1;
  8049e1:	b9 01 00 00 00       	mov    $0x1,%ecx
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
  8049e6:	39 f3                	cmp    %esi,%ebx
  8049e8:	72 10                	jb     8049fa <pbuf_header+0xac>
    p->payload = (u8_t *)p->payload - header_size_increment;
  8049ea:	89 58 04             	mov    %ebx,0x4(%eax)
    /* Unknown type */
    LWIP_ASSERT("bad pbuf type", 0);
    return 1;
  }
  /* modify pbuf length fields */
  p->len += header_size_increment;
  8049ed:	66 01 50 0a          	add    %dx,0xa(%eax)
  p->tot_len += header_size_increment;
  8049f1:	66 01 50 08          	add    %dx,0x8(%eax)

  LWIP_DEBUGF(PBUF_DEBUG, ("pbuf_header: old %p new %p (%"S16_F")\n",
    (void *)payload, (void *)p->payload, header_size_increment));

  return 0;
  8049f5:	b9 00 00 00 00       	mov    $0x0,%ecx
}
  8049fa:	89 c8                	mov    %ecx,%eax
  8049fc:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8049ff:	5b                   	pop    %ebx
  804a00:	5e                   	pop    %esi
  804a01:	5d                   	pop    %ebp
  804a02:	c3                   	ret    
    LWIP_ASSERT("bad pbuf type", 0);
  804a03:	83 ec 04             	sub    $0x4,%esp
  804a06:	68 37 1e 81 00       	push   $0x811e37
  804a0b:	68 9a 01 00 00       	push   $0x19a
  804a10:	68 04 1e 81 00       	push   $0x811e04
  804a15:	e8 2d 9f 00 00       	call   80e947 <_panic>
    return 0;
  804a1a:	b9 00 00 00 00       	mov    $0x0,%ecx
  804a1f:	eb d9                	jmp    8049fa <pbuf_header+0xac>

00804a21 <pbuf_free>:
 * 1->1->1 becomes .......
 *
 */
u8_t
pbuf_free(struct pbuf *p)
{
  804a21:	f3 0f 1e fb          	endbr32 
  804a25:	55                   	push   %ebp
  804a26:	89 e5                	mov    %esp,%ebp
  804a28:	56                   	push   %esi
  804a29:	53                   	push   %ebx
  804a2a:	8b 45 08             	mov    0x8(%ebp),%eax
  u16_t type;
  struct pbuf *q;
  u8_t count;

  if (p == NULL) {
  804a2d:	85 c0                	test   %eax,%eax
  804a2f:	74 0d                	je     804a3e <pbuf_free+0x1d>
  }
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_free(%p)\n", (void *)p));

  PERF_START;

  LWIP_ASSERT("pbuf_free: sane type",
  804a31:	80 78 0c 03          	cmpb   $0x3,0xc(%eax)
  804a35:	77 1e                	ja     804a55 <pbuf_free+0x34>
    p->type == PBUF_RAM || p->type == PBUF_ROM ||
    p->type == PBUF_REF || p->type == PBUF_POOL);

  count = 0;
  804a37:	bb 00 00 00 00       	mov    $0x0,%ebx
  804a3c:	eb 6c                	jmp    804aaa <pbuf_free+0x89>
    LWIP_ASSERT("p != NULL", p != NULL);
  804a3e:	83 ec 04             	sub    $0x4,%esp
  804a41:	68 c8 1e 81 00       	push   $0x811ec8
  804a46:	68 d0 01 00 00       	push   $0x1d0
  804a4b:	68 04 1e 81 00       	push   $0x811e04
  804a50:	e8 f2 9e 00 00       	call   80e947 <_panic>
  LWIP_ASSERT("pbuf_free: sane type",
  804a55:	83 ec 04             	sub    $0x4,%esp
  804a58:	68 45 1e 81 00       	push   $0x811e45
  804a5d:	68 d9 01 00 00       	push   $0x1d9
  804a62:	68 04 1e 81 00       	push   $0x811e04
  804a67:	e8 db 9e 00 00       	call   80e947 <_panic>
    /* Since decrementing ref cannot be guaranteed to be a single machine operation
     * we must protect it. We put the new ref into a local variable to prevent
     * further protection. */
    SYS_ARCH_PROTECT(old_level);
    /* all pbufs in a chain are referenced at least once */
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
  804a6c:	83 ec 04             	sub    $0x4,%esp
  804a6f:	68 5a 1e 81 00       	push   $0x811e5a
  804a74:	68 e8 01 00 00       	push   $0x1e8
  804a79:	68 04 1e 81 00       	push   $0x811e04
  804a7e:	e8 c4 9e 00 00       	call   80e947 <_panic>
      q = p->next;
      LWIP_DEBUGF( PBUF_DEBUG | 2, ("pbuf_free: deallocating %p\n", (void *)p));
      type = p->type;
      /* is this a pbuf from the pool? */
      if (type == PBUF_POOL) {
        memp_free(MEMP_PBUF_POOL, p);
  804a83:	83 ec 08             	sub    $0x8,%esp
  804a86:	50                   	push   %eax
  804a87:	6a 0d                	push   $0xd
  804a89:	e8 10 fc ff ff       	call   80469e <memp_free>
  804a8e:	83 c4 10             	add    $0x10,%esp
  804a91:	eb 0e                	jmp    804aa1 <pbuf_free+0x80>
      /* is this a ROM or RAM referencing pbuf? */
      } else if (type == PBUF_ROM || type == PBUF_REF) {
        memp_free(MEMP_PBUF, p);
  804a93:	83 ec 08             	sub    $0x8,%esp
  804a96:	50                   	push   %eax
  804a97:	6a 0c                	push   $0xc
  804a99:	e8 00 fc ff ff       	call   80469e <memp_free>
  804a9e:	83 c4 10             	add    $0x10,%esp
      /* type == PBUF_RAM */
      } else {
        mem_free(p);
      }
      count++;
  804aa1:	83 c3 01             	add    $0x1,%ebx
  while (p != NULL) {
  804aa4:	85 f6                	test   %esi,%esi
  804aa6:	74 3a                	je     804ae2 <pbuf_free+0xc1>
      /* proceed to next pbuf */
      p = q;
  804aa8:	89 f0                	mov    %esi,%eax
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
  804aaa:	0f b7 50 0e          	movzwl 0xe(%eax),%edx
  804aae:	66 85 d2             	test   %dx,%dx
  804ab1:	74 b9                	je     804a6c <pbuf_free+0x4b>
    ref = --(p->ref);
  804ab3:	83 ea 01             	sub    $0x1,%edx
  804ab6:	66 89 50 0e          	mov    %dx,0xe(%eax)
    if (ref == 0) {
  804aba:	66 85 d2             	test   %dx,%dx
  804abd:	75 23                	jne    804ae2 <pbuf_free+0xc1>
      q = p->next;
  804abf:	8b 30                	mov    (%eax),%esi
      type = p->type;
  804ac1:	0f b6 50 0c          	movzbl 0xc(%eax),%edx
      if (type == PBUF_POOL) {
  804ac5:	66 83 fa 03          	cmp    $0x3,%dx
  804ac9:	74 b8                	je     804a83 <pbuf_free+0x62>
      } else if (type == PBUF_ROM || type == PBUF_REF) {
  804acb:	83 ea 01             	sub    $0x1,%edx
  804ace:	66 83 fa 01          	cmp    $0x1,%dx
  804ad2:	76 bf                	jbe    804a93 <pbuf_free+0x72>
        mem_free(p);
  804ad4:	83 ec 0c             	sub    $0xc,%esp
  804ad7:	50                   	push   %eax
  804ad8:	e8 0f f6 ff ff       	call   8040ec <mem_free>
  804add:	83 c4 10             	add    $0x10,%esp
  804ae0:	eb bf                	jmp    804aa1 <pbuf_free+0x80>
    }
  }
  PERF_STOP("pbuf_free");
  /* return number of de-allocated pbufs */
  return count;
}
  804ae2:	89 d8                	mov    %ebx,%eax
  804ae4:	8d 65 f8             	lea    -0x8(%ebp),%esp
  804ae7:	5b                   	pop    %ebx
  804ae8:	5e                   	pop    %esi
  804ae9:	5d                   	pop    %ebp
  804aea:	c3                   	ret    

00804aeb <pbuf_alloc>:
{
  804aeb:	f3 0f 1e fb          	endbr32 
  804aef:	55                   	push   %ebp
  804af0:	89 e5                	mov    %esp,%ebp
  804af2:	57                   	push   %edi
  804af3:	56                   	push   %esi
  804af4:	53                   	push   %ebx
  804af5:	83 ec 1c             	sub    $0x1c,%esp
  804af8:	8b 45 08             	mov    0x8(%ebp),%eax
  804afb:	8b 75 0c             	mov    0xc(%ebp),%esi
  804afe:	8b 5d 10             	mov    0x10(%ebp),%ebx
  switch (layer) {
  804b01:	83 f8 02             	cmp    $0x2,%eax
  804b04:	0f 84 8b 00 00 00    	je     804b95 <pbuf_alloc+0xaa>
  804b0a:	77 14                	ja     804b20 <pbuf_alloc+0x35>
  offset = 0;
  804b0c:	83 f8 01             	cmp    $0x1,%eax
  804b0f:	19 ff                	sbb    %edi,%edi
  804b11:	83 e7 14             	and    $0x14,%edi
    offset += PBUF_IP_HLEN;
  804b14:	83 c7 14             	add    $0x14,%edi
    offset += PBUF_LINK_HLEN;
  804b17:	8d 47 0e             	lea    0xe(%edi),%eax
  804b1a:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    break;
  804b1e:	eb 0b                	jmp    804b2b <pbuf_alloc+0x40>
  switch (layer) {
  804b20:	83 f8 03             	cmp    $0x3,%eax
  804b23:	75 7a                	jne    804b9f <pbuf_alloc+0xb4>
  804b25:	66 c7 45 e4 00 00    	movw   $0x0,-0x1c(%ebp)
  switch (type) {
  804b2b:	83 fb 02             	cmp    $0x2,%ebx
  804b2e:	0f 87 82 00 00 00    	ja     804bb6 <pbuf_alloc+0xcb>
  804b34:	85 db                	test   %ebx,%ebx
  804b36:	0f 85 c3 01 00 00    	jne    804cff <pbuf_alloc+0x214>
    p = (struct pbuf*)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length));
  804b3c:	0f b7 5d e4          	movzwl -0x1c(%ebp),%ebx
  804b40:	83 ec 0c             	sub    $0xc,%esp
  804b43:	8d 43 13             	lea    0x13(%ebx),%eax
  804b46:	83 e0 fc             	and    $0xfffffffc,%eax
  804b49:	89 c2                	mov    %eax,%edx
  804b4b:	0f b7 c6             	movzwl %si,%eax
  804b4e:	83 c0 03             	add    $0x3,%eax
  804b51:	83 e0 fc             	and    $0xfffffffc,%eax
  804b54:	01 d0                	add    %edx,%eax
  804b56:	50                   	push   %eax
  804b57:	e8 87 f8 ff ff       	call   8043e3 <mem_malloc>
  804b5c:	89 c7                	mov    %eax,%edi
    if (p == NULL) {
  804b5e:	83 c4 10             	add    $0x10,%esp
  804b61:	85 c0                	test   %eax,%eax
  804b63:	74 26                	je     804b8b <pbuf_alloc+0xa0>
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
  804b65:	8d 44 18 13          	lea    0x13(%eax,%ebx,1),%eax
  804b69:	83 e0 fc             	and    $0xfffffffc,%eax
  804b6c:	89 47 04             	mov    %eax,0x4(%edi)
    p->len = p->tot_len = length;
  804b6f:	66 89 77 08          	mov    %si,0x8(%edi)
  804b73:	66 89 77 0a          	mov    %si,0xa(%edi)
    p->next = NULL;
  804b77:	c7 07 00 00 00 00    	movl   $0x0,(%edi)
    p->type = type;
  804b7d:	c6 47 0c 00          	movb   $0x0,0xc(%edi)
  p->ref = 1;
  804b81:	66 c7 47 0e 01 00    	movw   $0x1,0xe(%edi)
  p->flags = 0;
  804b87:	c6 47 0d 00          	movb   $0x0,0xd(%edi)
}
  804b8b:	89 f8                	mov    %edi,%eax
  804b8d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  804b90:	5b                   	pop    %ebx
  804b91:	5e                   	pop    %esi
  804b92:	5f                   	pop    %edi
  804b93:	5d                   	pop    %ebp
  804b94:	c3                   	ret    
  switch (layer) {
  804b95:	bf 00 00 00 00       	mov    $0x0,%edi
  804b9a:	e9 78 ff ff ff       	jmp    804b17 <pbuf_alloc+0x2c>
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
  804b9f:	83 ec 04             	sub    $0x4,%esp
  804ba2:	68 70 1e 81 00       	push   $0x811e70
  804ba7:	68 8a 00 00 00       	push   $0x8a
  804bac:	68 04 1e 81 00       	push   $0x811e04
  804bb1:	e8 91 9d 00 00       	call   80e947 <_panic>
  switch (type) {
  804bb6:	83 fb 03             	cmp    $0x3,%ebx
  804bb9:	0f 85 74 01 00 00    	jne    804d33 <pbuf_alloc+0x248>
      p = memp_malloc(MEMP_PBUF_POOL);
  804bbf:	83 ec 0c             	sub    $0xc,%esp
  804bc2:	6a 0d                	push   $0xd
  804bc4:	e8 7b fa ff ff       	call   804644 <memp_malloc>
  804bc9:	89 c7                	mov    %eax,%edi
    if (p == NULL) {
  804bcb:	83 c4 10             	add    $0x10,%esp
  804bce:	85 c0                	test   %eax,%eax
  804bd0:	74 b9                	je     804b8b <pbuf_alloc+0xa0>
    p->type = type;
  804bd2:	c6 40 0c 03          	movb   $0x3,0xc(%eax)
    p->next = NULL;
  804bd6:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
  804bdc:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  804be0:	8d 54 07 13          	lea    0x13(%edi,%eax,1),%edx
  804be4:	83 e2 fc             	and    $0xfffffffc,%edx
  804be7:	89 57 04             	mov    %edx,0x4(%edi)
    p->tot_len = length;
  804bea:	66 89 77 08          	mov    %si,0x8(%edi)
    p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
  804bee:	0f b7 f6             	movzwl %si,%esi
  804bf1:	83 c0 03             	add    $0x3,%eax
  804bf4:	83 e0 fc             	and    $0xfffffffc,%eax
  804bf7:	89 c1                	mov    %eax,%ecx
  804bf9:	b8 d0 07 00 00       	mov    $0x7d0,%eax
  804bfe:	29 c8                	sub    %ecx,%eax
  804c00:	39 f0                	cmp    %esi,%eax
  804c02:	0f 4f c6             	cmovg  %esi,%eax
  804c05:	66 89 47 0a          	mov    %ax,0xa(%edi)
    LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  804c09:	8d 9f e0 07 00 00    	lea    0x7e0(%edi),%ebx
  804c0f:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  804c12:	01 c2                	add    %eax,%edx
  804c14:	39 d3                	cmp    %edx,%ebx
  804c16:	72 76                	jb     804c8e <pbuf_alloc+0x1a3>
    p->ref = 1;
  804c18:	66 c7 47 0e 01 00    	movw   $0x1,0xe(%edi)
    rem_len = length - p->len;
  804c1e:	29 c6                	sub    %eax,%esi
    r = p;
  804c20:	89 fb                	mov    %edi,%ebx
    while (rem_len > 0) {
  804c22:	85 f6                	test   %esi,%esi
  804c24:	0f 8e 57 ff ff ff    	jle    804b81 <pbuf_alloc+0x96>
      q = memp_malloc(MEMP_PBUF_POOL);
  804c2a:	83 ec 0c             	sub    $0xc,%esp
  804c2d:	6a 0d                	push   $0xd
  804c2f:	e8 10 fa ff ff       	call   804644 <memp_malloc>
      if (q == NULL) {
  804c34:	83 c4 10             	add    $0x10,%esp
  804c37:	85 c0                	test   %eax,%eax
  804c39:	74 6a                	je     804ca5 <pbuf_alloc+0x1ba>
      q->type = type;
  804c3b:	c6 40 0c 03          	movb   $0x3,0xc(%eax)
      q->flags = 0;
  804c3f:	c6 40 0d 00          	movb   $0x0,0xd(%eax)
      q->next = NULL;
  804c43:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
      r->next = q;
  804c49:	89 03                	mov    %eax,(%ebx)
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
  804c4b:	81 fe fe ff 00 00    	cmp    $0xfffe,%esi
  804c51:	7f 67                	jg     804cba <pbuf_alloc+0x1cf>
      q->tot_len = (u16_t)rem_len;
  804c53:	66 89 70 08          	mov    %si,0x8(%eax)
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
  804c57:	66 81 fe d0 07       	cmp    $0x7d0,%si
  804c5c:	ba d0 07 00 00       	mov    $0x7d0,%edx
  804c61:	0f 46 d6             	cmovbe %esi,%edx
  804c64:	66 89 50 0a          	mov    %dx,0xa(%eax)
      q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
  804c68:	8d 48 10             	lea    0x10(%eax),%ecx
  804c6b:	89 48 04             	mov    %ecx,0x4(%eax)
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
  804c6e:	f6 c1 03             	test   $0x3,%cl
  804c71:	75 5e                	jne    804cd1 <pbuf_alloc+0x1e6>
      LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  804c73:	0f b7 4f 0a          	movzwl 0xa(%edi),%ecx
  804c77:	03 4f 04             	add    0x4(%edi),%ecx
  804c7a:	39 4d e4             	cmp    %ecx,-0x1c(%ebp)
  804c7d:	72 69                	jb     804ce8 <pbuf_alloc+0x1fd>
      q->ref = 1;
  804c7f:	66 c7 40 0e 01 00    	movw   $0x1,0xe(%eax)
      rem_len -= q->len;
  804c85:	0f b7 d2             	movzwl %dx,%edx
  804c88:	29 d6                	sub    %edx,%esi
      r = q;
  804c8a:	89 c3                	mov    %eax,%ebx
  804c8c:	eb 94                	jmp    804c22 <pbuf_alloc+0x137>
    LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  804c8e:	83 ec 04             	sub    $0x4,%esp
  804c91:	68 88 1f 81 00       	push   $0x811f88
  804c96:	68 a1 00 00 00       	push   $0xa1
  804c9b:	68 04 1e 81 00       	push   $0x811e04
  804ca0:	e8 a2 9c 00 00       	call   80e947 <_panic>
  804ca5:	89 c3                	mov    %eax,%ebx
        pbuf_free(p);
  804ca7:	83 ec 0c             	sub    $0xc,%esp
  804caa:	57                   	push   %edi
  804cab:	e8 71 fd ff ff       	call   804a21 <pbuf_free>
        return NULL;
  804cb0:	83 c4 10             	add    $0x10,%esp
  804cb3:	89 df                	mov    %ebx,%edi
  804cb5:	e9 d1 fe ff ff       	jmp    804b8b <pbuf_alloc+0xa0>
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
  804cba:	83 ec 04             	sub    $0x4,%esp
  804cbd:	68 8b 1e 81 00       	push   $0x811e8b
  804cc2:	68 bc 00 00 00       	push   $0xbc
  804cc7:	68 04 1e 81 00       	push   $0x811e04
  804ccc:	e8 76 9c 00 00       	call   80e947 <_panic>
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
  804cd1:	83 ec 04             	sub    $0x4,%esp
  804cd4:	68 bc 1f 81 00       	push   $0x811fbc
  804cd9:	68 c1 00 00 00       	push   $0xc1
  804cde:	68 04 1e 81 00       	push   $0x811e04
  804ce3:	e8 5f 9c 00 00       	call   80e947 <_panic>
      LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  804ce8:	83 ec 04             	sub    $0x4,%esp
  804ceb:	68 88 1f 81 00       	push   $0x811f88
  804cf0:	68 c3 00 00 00       	push   $0xc3
  804cf5:	68 04 1e 81 00       	push   $0x811e04
  804cfa:	e8 48 9c 00 00       	call   80e947 <_panic>
    p = memp_malloc(MEMP_PBUF);
  804cff:	83 ec 0c             	sub    $0xc,%esp
  804d02:	6a 0c                	push   $0xc
  804d04:	e8 3b f9 ff ff       	call   804644 <memp_malloc>
  804d09:	89 c7                	mov    %eax,%edi
    if (p == NULL) {
  804d0b:	83 c4 10             	add    $0x10,%esp
  804d0e:	85 c0                	test   %eax,%eax
  804d10:	0f 84 75 fe ff ff    	je     804b8b <pbuf_alloc+0xa0>
    p->payload = NULL;
  804d16:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    p->len = p->tot_len = length;
  804d1d:	66 89 70 08          	mov    %si,0x8(%eax)
  804d21:	66 89 70 0a          	mov    %si,0xa(%eax)
    p->next = NULL;
  804d25:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    p->type = type;
  804d2b:	88 58 0c             	mov    %bl,0xc(%eax)
    break;
  804d2e:	e9 4e fe ff ff       	jmp    804b81 <pbuf_alloc+0x96>
    LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
  804d33:	83 ec 04             	sub    $0x4,%esp
  804d36:	68 9f 1e 81 00       	push   $0x811e9f
  804d3b:	68 f1 00 00 00       	push   $0xf1
  804d40:	68 04 1e 81 00       	push   $0x811e04
  804d45:	e8 fd 9b 00 00       	call   80e947 <_panic>

00804d4a <pbuf_realloc>:
{
  804d4a:	f3 0f 1e fb          	endbr32 
  804d4e:	55                   	push   %ebp
  804d4f:	89 e5                	mov    %esp,%ebp
  804d51:	57                   	push   %edi
  804d52:	56                   	push   %esi
  804d53:	53                   	push   %ebx
  804d54:	83 ec 0c             	sub    $0xc,%esp
  804d57:	8b 5d 08             	mov    0x8(%ebp),%ebx
  804d5a:	8b 75 0c             	mov    0xc(%ebp),%esi
  LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
  804d5d:	85 db                	test   %ebx,%ebx
  804d5f:	74 53                	je     804db4 <pbuf_realloc+0x6a>
  804d61:	89 f2                	mov    %esi,%edx
  LWIP_ASSERT("pbuf_realloc: sane p->type", p->type == PBUF_POOL ||
  804d63:	80 7b 0c 03          	cmpb   $0x3,0xc(%ebx)
  804d67:	77 62                	ja     804dcb <pbuf_realloc+0x81>
  if (new_len >= p->tot_len) {
  804d69:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  804d6d:	66 39 f0             	cmp    %si,%ax
  804d70:	0f 86 ae 00 00 00    	jbe    804e24 <pbuf_realloc+0xda>
  grow = new_len - p->tot_len;
  804d76:	0f b7 ce             	movzwl %si,%ecx
  804d79:	0f b7 f8             	movzwl %ax,%edi
  804d7c:	29 f9                	sub    %edi,%ecx
    q->tot_len += (u16_t)grow;
  804d7e:	29 c2                	sub    %eax,%edx
  while (rem_len > q->len) {
  804d80:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  804d84:	66 39 f0             	cmp    %si,%ax
  804d87:	73 70                	jae    804df9 <pbuf_realloc+0xaf>
    rem_len -= q->len;
  804d89:	29 c6                	sub    %eax,%esi
    LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
  804d8b:	81 f9 fe ff 00 00    	cmp    $0xfffe,%ecx
  804d91:	7f 4f                	jg     804de2 <pbuf_realloc+0x98>
    q->tot_len += (u16_t)grow;
  804d93:	66 01 53 08          	add    %dx,0x8(%ebx)
    q = q->next;
  804d97:	8b 1b                	mov    (%ebx),%ebx
    LWIP_ASSERT("pbuf_realloc: q != NULL", q != NULL);
  804d99:	85 db                	test   %ebx,%ebx
  804d9b:	75 e3                	jne    804d80 <pbuf_realloc+0x36>
  804d9d:	83 ec 04             	sub    $0x4,%esp
  804da0:	68 fe 1e 81 00       	push   $0x811efe
  804da5:	68 2f 01 00 00       	push   $0x12f
  804daa:	68 04 1e 81 00       	push   $0x811e04
  804daf:	e8 93 9b 00 00       	call   80e947 <_panic>
  LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
  804db4:	83 ec 04             	sub    $0x4,%esp
  804db7:	68 ba 1e 81 00       	push   $0x811eba
  804dbc:	68 13 01 00 00       	push   $0x113
  804dc1:	68 04 1e 81 00       	push   $0x811e04
  804dc6:	e8 7c 9b 00 00       	call   80e947 <_panic>
  LWIP_ASSERT("pbuf_realloc: sane p->type", p->type == PBUF_POOL ||
  804dcb:	83 ec 04             	sub    $0x4,%esp
  804dce:	68 d2 1e 81 00       	push   $0x811ed2
  804dd3:	68 14 01 00 00       	push   $0x114
  804dd8:	68 04 1e 81 00       	push   $0x811e04
  804ddd:	e8 65 9b 00 00       	call   80e947 <_panic>
    LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
  804de2:	83 ec 04             	sub    $0x4,%esp
  804de5:	68 ed 1e 81 00       	push   $0x811eed
  804dea:	68 2b 01 00 00       	push   $0x12b
  804def:	68 04 1e 81 00       	push   $0x811e04
  804df4:	e8 4e 9b 00 00       	call   80e947 <_panic>
  if ((q->type == PBUF_RAM) && (rem_len != q->len)) {
  804df9:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
  804dfd:	75 05                	jne    804e04 <pbuf_realloc+0xba>
  804dff:	66 39 f0             	cmp    %si,%ax
  804e02:	75 28                	jne    804e2c <pbuf_realloc+0xe2>
  q->len = rem_len;
  804e04:	66 89 73 0a          	mov    %si,0xa(%ebx)
  q->tot_len = q->len;
  804e08:	66 89 73 08          	mov    %si,0x8(%ebx)
  if (q->next != NULL) {
  804e0c:	8b 03                	mov    (%ebx),%eax
  804e0e:	85 c0                	test   %eax,%eax
  804e10:	74 0c                	je     804e1e <pbuf_realloc+0xd4>
    pbuf_free(q->next);
  804e12:	83 ec 0c             	sub    $0xc,%esp
  804e15:	50                   	push   %eax
  804e16:	e8 06 fc ff ff       	call   804a21 <pbuf_free>
  804e1b:	83 c4 10             	add    $0x10,%esp
  q->next = NULL;
  804e1e:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
}
  804e24:	8d 65 f4             	lea    -0xc(%ebp),%esp
  804e27:	5b                   	pop    %ebx
  804e28:	5e                   	pop    %esi
  804e29:	5f                   	pop    %edi
  804e2a:	5d                   	pop    %ebp
  804e2b:	c3                   	ret    
    q = mem_realloc(q, (u8_t *)q->payload - (u8_t *)q + rem_len);
  804e2c:	8b 43 04             	mov    0x4(%ebx),%eax
  804e2f:	29 d8                	sub    %ebx,%eax
  804e31:	0f b7 d6             	movzwl %si,%edx
  804e34:	01 d0                	add    %edx,%eax
  804e36:	83 ec 08             	sub    $0x8,%esp
  804e39:	50                   	push   %eax
  804e3a:	53                   	push   %ebx
  804e3b:	e8 47 f4 ff ff       	call   804287 <mem_realloc>
  804e40:	89 c3                	mov    %eax,%ebx
    LWIP_ASSERT("mem_realloc give q == NULL", q != NULL);
  804e42:	83 c4 10             	add    $0x10,%esp
  804e45:	85 c0                	test   %eax,%eax
  804e47:	75 bb                	jne    804e04 <pbuf_realloc+0xba>
  804e49:	83 ec 04             	sub    $0x4,%esp
  804e4c:	68 16 1f 81 00       	push   $0x811f16
  804e51:	68 39 01 00 00       	push   $0x139
  804e56:	68 04 1e 81 00       	push   $0x811e04
  804e5b:	e8 e7 9a 00 00       	call   80e947 <_panic>

00804e60 <pbuf_clen>:
 * @return the number of pbufs in a chain
 */

u8_t
pbuf_clen(struct pbuf *p)
{
  804e60:	f3 0f 1e fb          	endbr32 
  804e64:	55                   	push   %ebp
  804e65:	89 e5                	mov    %esp,%ebp
  804e67:	8b 45 08             	mov    0x8(%ebp),%eax
  u8_t len;

  len = 0;
  804e6a:	ba 00 00 00 00       	mov    $0x0,%edx
  while (p != NULL) {
  804e6f:	85 c0                	test   %eax,%eax
  804e71:	74 07                	je     804e7a <pbuf_clen+0x1a>
    ++len;
  804e73:	83 c2 01             	add    $0x1,%edx
    p = p->next;
  804e76:	8b 00                	mov    (%eax),%eax
  804e78:	eb f5                	jmp    804e6f <pbuf_clen+0xf>
  }
  return len;
}
  804e7a:	89 d0                	mov    %edx,%eax
  804e7c:	5d                   	pop    %ebp
  804e7d:	c3                   	ret    

00804e7e <pbuf_ref>:
 * @param p pbuf to increase reference counter of
 *
 */
void
pbuf_ref(struct pbuf *p)
{
  804e7e:	f3 0f 1e fb          	endbr32 
  804e82:	55                   	push   %ebp
  804e83:	89 e5                	mov    %esp,%ebp
  804e85:	8b 45 08             	mov    0x8(%ebp),%eax
  SYS_ARCH_DECL_PROTECT(old_level);
  /* pbuf given? */
  if (p != NULL) {
  804e88:	85 c0                	test   %eax,%eax
  804e8a:	74 05                	je     804e91 <pbuf_ref+0x13>
    SYS_ARCH_PROTECT(old_level);
    ++(p->ref);
  804e8c:	66 83 40 0e 01       	addw   $0x1,0xe(%eax)
    SYS_ARCH_UNPROTECT(old_level);
  }
}
  804e91:	5d                   	pop    %ebp
  804e92:	c3                   	ret    

00804e93 <pbuf_cat>:
 * @see pbuf_chain()
 */

void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
  804e93:	f3 0f 1e fb          	endbr32 
  804e97:	55                   	push   %ebp
  804e98:	89 e5                	mov    %esp,%ebp
  804e9a:	53                   	push   %ebx
  804e9b:	83 ec 04             	sub    $0x4,%esp
  804e9e:	8b 45 08             	mov    0x8(%ebp),%eax
  804ea1:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  struct pbuf *p;

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
  804ea4:	85 c0                	test   %eax,%eax
  804ea6:	74 04                	je     804eac <pbuf_cat+0x19>
  804ea8:	85 db                	test   %ebx,%ebx
  804eaa:	75 21                	jne    804ecd <pbuf_cat+0x3a>
  804eac:	83 ec 04             	sub    $0x4,%esp
  804eaf:	68 ec 1f 81 00       	push   $0x811fec
  804eb4:	68 41 02 00 00       	push   $0x241
  804eb9:	68 04 1e 81 00       	push   $0x811e04
  804ebe:	e8 84 9a 00 00       	call   80e947 <_panic>
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
  804ec3:	0f b7 4b 08          	movzwl 0x8(%ebx),%ecx
  804ec7:	66 01 48 08          	add    %cx,0x8(%eax)
  for (p = h; p->next != NULL; p = p->next) {
  804ecb:	89 d0                	mov    %edx,%eax
  804ecd:	8b 10                	mov    (%eax),%edx
  804ecf:	85 d2                	test   %edx,%edx
  804ed1:	75 f0                	jne    804ec3 <pbuf_cat+0x30>
  }
  /* { p is last pbuf of first h chain, p->next == NULL } */
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
  804ed3:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  804ed7:	66 3b 50 0a          	cmp    0xa(%eax),%dx
  804edb:	75 0f                	jne    804eec <pbuf_cat+0x59>
  LWIP_ASSERT("p->next == NULL", p->next == NULL);
  /* add total length of second chain to last pbuf total of first chain */
  p->tot_len += t->tot_len;
  804edd:	66 03 53 08          	add    0x8(%ebx),%dx
  804ee1:	66 89 50 08          	mov    %dx,0x8(%eax)
  /* chain last pbuf of head (p) with first of tail (t) */
  p->next = t;
  804ee5:	89 18                	mov    %ebx,(%eax)
  /* p->next now references t, but the caller will drop its reference to t,
   * so netto there is no change to the reference count of t.
   */
}
  804ee7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  804eea:	c9                   	leave  
  804eeb:	c3                   	ret    
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
  804eec:	83 ec 04             	sub    $0x4,%esp
  804eef:	68 24 20 81 00       	push   $0x812024
  804ef4:	68 4a 02 00 00       	push   $0x24a
  804ef9:	68 04 1e 81 00       	push   $0x811e04
  804efe:	e8 44 9a 00 00       	call   80e947 <_panic>

00804f03 <pbuf_chain>:
 * The ->ref field of the first pbuf of the tail chain is adjusted.
 *
 */
void
pbuf_chain(struct pbuf *h, struct pbuf *t)
{
  804f03:	f3 0f 1e fb          	endbr32 
  804f07:	55                   	push   %ebp
  804f08:	89 e5                	mov    %esp,%ebp
  804f0a:	53                   	push   %ebx
  804f0b:	83 ec 0c             	sub    $0xc,%esp
  804f0e:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  pbuf_cat(h, t);
  804f11:	53                   	push   %ebx
  804f12:	ff 75 08             	pushl  0x8(%ebp)
  804f15:	e8 79 ff ff ff       	call   804e93 <pbuf_cat>
  /* t is now referenced by h */
  pbuf_ref(t);
  804f1a:	89 1c 24             	mov    %ebx,(%esp)
  804f1d:	e8 5c ff ff ff       	call   804e7e <pbuf_ref>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_FRESH | 2, ("pbuf_chain: %p references %p\n", (void *)h, (void *)t));
}
  804f22:	83 c4 10             	add    $0x10,%esp
  804f25:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  804f28:	c9                   	leave  
  804f29:	c3                   	ret    

00804f2a <pbuf_dechain>:
 * @return remainder of the pbuf chain, or NULL if it was de-allocated.
 * @note May not be called on a packet queue.
 */
struct pbuf *
pbuf_dechain(struct pbuf *p)
{
  804f2a:	f3 0f 1e fb          	endbr32 
  804f2e:	55                   	push   %ebp
  804f2f:	89 e5                	mov    %esp,%ebp
  804f31:	57                   	push   %edi
  804f32:	56                   	push   %esi
  804f33:	53                   	push   %ebx
  804f34:	83 ec 1c             	sub    $0x1c,%esp
  804f37:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct pbuf *q;
  u8_t tail_gone = 1;
  /* tail */
  q = p->next;
  804f3a:	8b 33                	mov    (%ebx),%esi
  /* pbuf has successor in chain? */
  if (q != NULL) {
  804f3c:	85 f6                	test   %esi,%esi
  804f3e:	74 71                	je     804fb1 <pbuf_dechain+0x87>
    /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
    LWIP_ASSERT("p->tot_len == p->len + q->tot_len", q->tot_len == p->tot_len - p->len);
  804f40:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  804f44:	0f b7 4b 0a          	movzwl 0xa(%ebx),%ecx
  804f48:	0f b7 7e 08          	movzwl 0x8(%esi),%edi
  804f4c:	89 7d e4             	mov    %edi,-0x1c(%ebp)
  804f4f:	0f b7 d0             	movzwl %ax,%edx
  804f52:	0f b7 f9             	movzwl %cx,%edi
  804f55:	29 fa                	sub    %edi,%edx
  804f57:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
  804f5a:	75 3e                	jne    804f9a <pbuf_dechain+0x70>
    /* enforce invariant if assertion is disabled */
    q->tot_len = p->tot_len - p->len;
  804f5c:	29 c8                	sub    %ecx,%eax
  804f5e:	66 89 46 08          	mov    %ax,0x8(%esi)
    /* decouple pbuf from remainder */
    p->next = NULL;
  804f62:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
    /* total length of pbuf p is its own length only */
    p->tot_len = p->len;
  804f68:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  804f6c:	66 89 43 08          	mov    %ax,0x8(%ebx)
    /* q is no longer referenced by p, free it */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_STATE, ("pbuf_dechain: unreferencing %p\n", (void *)q));
    tail_gone = pbuf_free(q);
  804f70:	83 ec 0c             	sub    $0xc,%esp
  804f73:	56                   	push   %esi
  804f74:	e8 a8 fa ff ff       	call   804a21 <pbuf_free>
                  ("pbuf_dechain: deallocated %p (as it is no longer referenced)\n", (void *)q));
    }
    /* return remaining tail or NULL if deallocated */
  }
  /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
  LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
  804f79:	83 c4 10             	add    $0x10,%esp
  804f7c:	0f b7 4b 0a          	movzwl 0xa(%ebx),%ecx
  804f80:	66 39 4b 08          	cmp    %cx,0x8(%ebx)
  804f84:	75 35                	jne    804fbb <pbuf_dechain+0x91>
  return ((tail_gone > 0) ? NULL : q);
  804f86:	84 c0                	test   %al,%al
  804f88:	b8 00 00 00 00       	mov    $0x0,%eax
  804f8d:	0f 45 f0             	cmovne %eax,%esi
}
  804f90:	89 f0                	mov    %esi,%eax
  804f92:	8d 65 f4             	lea    -0xc(%ebp),%esp
  804f95:	5b                   	pop    %ebx
  804f96:	5e                   	pop    %esi
  804f97:	5f                   	pop    %edi
  804f98:	5d                   	pop    %ebp
  804f99:	c3                   	ret    
    LWIP_ASSERT("p->tot_len == p->len + q->tot_len", q->tot_len == p->tot_len - p->len);
  804f9a:	83 ec 04             	sub    $0x4,%esp
  804f9d:	68 54 20 81 00       	push   $0x812054
  804fa2:	68 80 02 00 00       	push   $0x280
  804fa7:	68 04 1e 81 00       	push   $0x811e04
  804fac:	e8 96 99 00 00       	call   80e947 <_panic>
  LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
  804fb1:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  804fb5:	66 39 43 08          	cmp    %ax,0x8(%ebx)
  804fb9:	74 d5                	je     804f90 <pbuf_dechain+0x66>
  804fbb:	83 ec 04             	sub    $0x4,%esp
  804fbe:	68 31 1f 81 00       	push   $0x811f31
  804fc3:	68 91 02 00 00       	push   $0x291
  804fc8:	68 04 1e 81 00       	push   $0x811e04
  804fcd:	e8 75 99 00 00       	call   80e947 <_panic>

00804fd2 <pbuf_copy>:
 *         ERR_ARG if one of the pbufs is NULL or p_to is not big
 *                 enough to hold p_from
 */
err_t
pbuf_copy(struct pbuf *p_to, struct pbuf *p_from)
{
  804fd2:	f3 0f 1e fb          	endbr32 
  804fd6:	55                   	push   %ebp
  804fd7:	89 e5                	mov    %esp,%ebp
  804fd9:	57                   	push   %edi
  804fda:	56                   	push   %esi
  804fdb:	53                   	push   %ebx
  804fdc:	83 ec 1c             	sub    $0x1c,%esp
  804fdf:	8b 7d 08             	mov    0x8(%ebp),%edi
  804fe2:	8b 5d 0c             	mov    0xc(%ebp),%ebx

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_copy(%p, %p)\n",
    (void*)p_to, (void*)p_from));

  /* is the target big enough to hold the source? */
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
  804fe5:	85 ff                	test   %edi,%edi
  804fe7:	74 22                	je     80500b <pbuf_copy+0x39>
  804fe9:	85 db                	test   %ebx,%ebx
  804feb:	74 1e                	je     80500b <pbuf_copy+0x39>
  804fed:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  804ff1:	66 39 47 08          	cmp    %ax,0x8(%edi)
  804ff5:	72 14                	jb     80500b <pbuf_copy+0x39>
  u16_t offset_to=0, offset_from=0, len;
  804ff7:	66 c7 45 e6 00 00    	movw   $0x0,-0x1a(%ebp)
  804ffd:	66 c7 45 e4 00 00    	movw   $0x0,-0x1c(%ebp)
  805003:	89 7d 08             	mov    %edi,0x8(%ebp)
  805006:	e9 92 00 00 00       	jmp    80509d <pbuf_copy+0xcb>
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
  80500b:	83 ec 04             	sub    $0x4,%esp
  80500e:	68 78 20 81 00       	push   $0x812078
  805013:	68 b0 02 00 00       	push   $0x2b0
  805018:	68 04 1e 81 00       	push   $0x811e04
  80501d:	e8 25 99 00 00       	call   80e947 <_panic>
      len = p_to->len - offset_to;
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
    offset_to += len;
    offset_from += len;
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
  805022:	83 ec 04             	sub    $0x4,%esp
  805025:	68 46 1f 81 00       	push   $0x811f46
  80502a:	68 c2 02 00 00       	push   $0x2c2
  80502f:	68 04 1e 81 00       	push   $0x811e04
  805034:	e8 0e 99 00 00       	call   80e947 <_panic>
    if (offset_to == p_to->len) {
      /* on to next p_to (if any) */
      offset_to = 0;
      p_to = p_to->next;
  805039:	8b 45 08             	mov    0x8(%ebp),%eax
  80503c:	8b 00                	mov    (%eax),%eax
  80503e:	89 45 08             	mov    %eax,0x8(%ebp)
      offset_to = 0;
  805041:	66 c7 45 e4 00 00    	movw   $0x0,-0x1c(%ebp)
  805047:	e9 c7 00 00 00       	jmp    805113 <pbuf_copy+0x141>
    }
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
  80504c:	83 ec 04             	sub    $0x4,%esp
  80504f:	68 5d 1f 81 00       	push   $0x811f5d
  805054:	68 c8 02 00 00       	push   $0x2c8
  805059:	68 04 1e 81 00       	push   $0x811e04
  80505e:	e8 e4 98 00 00       	call   80e947 <_panic>
    if (offset_from >= p_from->len) {
      /* on to next p_from (if any) */
      offset_from = 0;
  805063:	66 c7 45 e6 00 00    	movw   $0x0,-0x1a(%ebp)
      p_from = p_from->next;
    }

    if((p_from != NULL) && (p_from->len == p_from->tot_len)) {
  805069:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80506d:	66 39 43 0a          	cmp    %ax,0xa(%ebx)
  805071:	0f 84 cf 00 00 00    	je     805146 <pbuf_copy+0x174>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
                 (p_from->next == NULL), return ERR_VAL;);
    }
    if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
  805077:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  80507b:	0f 84 05 01 00 00    	je     805186 <pbuf_copy+0x1b4>
  805081:	8b 45 08             	mov    0x8(%ebp),%eax
  805084:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  805088:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80508b:	66 39 41 0a          	cmp    %ax,0xa(%ecx)
  80508f:	0f 84 d1 00 00 00    	je     805166 <pbuf_copy+0x194>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
                  (p_to->next == NULL), return ERR_VAL;);
    }
  } while (p_from);
  805095:	85 db                	test   %ebx,%ebx
  805097:	0f 84 00 01 00 00    	je     80519d <pbuf_copy+0x1cb>
    if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
  80509d:	8b 45 08             	mov    0x8(%ebp),%eax
  8050a0:	0f b7 70 0a          	movzwl 0xa(%eax),%esi
  8050a4:	0f b7 ce             	movzwl %si,%ecx
  8050a7:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  8050ab:	29 c1                	sub    %eax,%ecx
  8050ad:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  8050b1:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  8050b5:	29 c2                	sub    %eax,%edx
      len = p_from->len - offset_from;
  8050b7:	0f b7 7b 0a          	movzwl 0xa(%ebx),%edi
  8050bb:	66 2b 7d e6          	sub    -0x1a(%ebp),%di
  8050bf:	89 f8                	mov    %edi,%eax
  8050c1:	0f b7 7d e4          	movzwl -0x1c(%ebp),%edi
  8050c5:	29 fe                	sub    %edi,%esi
  8050c7:	39 d1                	cmp    %edx,%ecx
  8050c9:	0f 4d f0             	cmovge %eax,%esi
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
  8050cc:	83 ec 04             	sub    $0x4,%esp
  8050cf:	0f b7 c6             	movzwl %si,%eax
  8050d2:	50                   	push   %eax
  8050d3:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  8050d7:	03 43 04             	add    0x4(%ebx),%eax
  8050da:	50                   	push   %eax
  8050db:	0f b7 c7             	movzwl %di,%eax
  8050de:	8b 4d 08             	mov    0x8(%ebp),%ecx
  8050e1:	03 41 04             	add    0x4(%ecx),%eax
  8050e4:	50                   	push   %eax
  8050e5:	e8 6a a1 00 00       	call   80f254 <memcpy>
    offset_to += len;
  8050ea:	89 fa                	mov    %edi,%edx
  8050ec:	01 f2                	add    %esi,%edx
  8050ee:	66 89 55 e4          	mov    %dx,-0x1c(%ebp)
    offset_from += len;
  8050f2:	66 01 75 e6          	add    %si,-0x1a(%ebp)
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
  8050f6:	8b 45 08             	mov    0x8(%ebp),%eax
  8050f9:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  8050fd:	83 c4 10             	add    $0x10,%esp
  805100:	66 39 d0             	cmp    %dx,%ax
  805103:	0f 82 19 ff ff ff    	jb     805022 <pbuf_copy+0x50>
    if (offset_to == p_to->len) {
  805109:	66 3b 45 e4          	cmp    -0x1c(%ebp),%ax
  80510d:	0f 84 26 ff ff ff    	je     805039 <pbuf_copy+0x67>
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
  805113:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  805117:	66 3b 45 e6          	cmp    -0x1a(%ebp),%ax
  80511b:	0f 82 2b ff ff ff    	jb     80504c <pbuf_copy+0x7a>
    if (offset_from >= p_from->len) {
  805121:	66 3b 45 e6          	cmp    -0x1a(%ebp),%ax
  805125:	0f 85 3e ff ff ff    	jne    805069 <pbuf_copy+0x97>
      p_from = p_from->next;
  80512b:	8b 1b                	mov    (%ebx),%ebx
    if((p_from != NULL) && (p_from->len == p_from->tot_len)) {
  80512d:	85 db                	test   %ebx,%ebx
  80512f:	0f 85 2e ff ff ff    	jne    805063 <pbuf_copy+0x91>
    if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
  805135:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  805139:	74 62                	je     80519d <pbuf_copy+0x1cb>
      offset_from = 0;
  80513b:	66 c7 45 e6 00 00    	movw   $0x0,-0x1a(%ebp)
  805141:	e9 3b ff ff ff       	jmp    805081 <pbuf_copy+0xaf>
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
  805146:	83 3b 00             	cmpl   $0x0,(%ebx)
  805149:	0f 84 28 ff ff ff    	je     805077 <pbuf_copy+0xa5>
  80514f:	83 ec 04             	sub    $0x4,%esp
  805152:	68 a8 20 81 00       	push   $0x8120a8
  805157:	68 d1 02 00 00       	push   $0x2d1
  80515c:	68 04 1e 81 00       	push   $0x811e04
  805161:	e8 e1 97 00 00       	call   80e947 <_panic>
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
  805166:	83 39 00             	cmpl   $0x0,(%ecx)
  805169:	0f 84 26 ff ff ff    	je     805095 <pbuf_copy+0xc3>
  80516f:	83 ec 04             	sub    $0x4,%esp
  805172:	68 a8 20 81 00       	push   $0x8120a8
  805177:	68 d6 02 00 00       	push   $0x2d6
  80517c:	68 04 1e 81 00       	push   $0x811e04
  805181:	e8 c1 97 00 00       	call   80e947 <_panic>
    LWIP_ASSERT("p_to != NULL", p_to != NULL);
  805186:	83 ec 04             	sub    $0x4,%esp
  805189:	68 78 1f 81 00       	push   $0x811f78
  80518e:	68 b6 02 00 00       	push   $0x2b6
  805193:	68 04 1e 81 00       	push   $0x811e04
  805198:	e8 aa 97 00 00       	call   80e947 <_panic>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 1, ("pbuf_copy: end of chain reached.\n"));
  return ERR_OK;
}
  80519d:	b8 00 00 00 00       	mov    $0x0,%eax
  8051a2:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8051a5:	5b                   	pop    %ebx
  8051a6:	5e                   	pop    %esi
  8051a7:	5f                   	pop    %edi
  8051a8:	5d                   	pop    %ebp
  8051a9:	c3                   	ret    

008051aa <pbuf_copy_partial>:
 * @param len length of data to copy (dataptr must be big enough)
 * @param offset offset into the packet buffer from where to begin copying len bytes
 */
u16_t
pbuf_copy_partial(struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
{
  8051aa:	f3 0f 1e fb          	endbr32 
  8051ae:	55                   	push   %ebp
  8051af:	89 e5                	mov    %esp,%ebp
  8051b1:	57                   	push   %edi
  8051b2:	56                   	push   %esi
  8051b3:	53                   	push   %ebx
  8051b4:	83 ec 1c             	sub    $0x1c,%esp
  8051b7:	8b 75 08             	mov    0x8(%ebp),%esi
  8051ba:	0f b7 7d 10          	movzwl 0x10(%ebp),%edi
  8051be:	0f b7 45 14          	movzwl 0x14(%ebp),%eax
  struct pbuf *p;
  u16_t left;
  u16_t buf_copy_len;
  u16_t copied_total = 0;

  LWIP_ERROR("netbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
  8051c2:	85 f6                	test   %esi,%esi
  8051c4:	74 14                	je     8051da <pbuf_copy_partial+0x30>
  LWIP_ERROR("netbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
  8051c6:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  8051ca:	74 25                	je     8051f1 <pbuf_copy_partial+0x47>
  u16_t copied_total = 0;
  8051cc:	66 c7 45 e4 00 00    	movw   $0x0,-0x1c(%ebp)

  left = 0;
  8051d2:	66 c7 45 e6 00 00    	movw   $0x0,-0x1a(%ebp)
  8051d8:	eb 69                	jmp    805243 <pbuf_copy_partial+0x99>
  LWIP_ERROR("netbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
  8051da:	83 ec 04             	sub    $0x4,%esp
  8051dd:	68 d4 20 81 00       	push   $0x8120d4
  8051e2:	68 ef 02 00 00       	push   $0x2ef
  8051e7:	68 04 1e 81 00       	push   $0x811e04
  8051ec:	e8 56 97 00 00       	call   80e947 <_panic>
  LWIP_ERROR("netbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
  8051f1:	83 ec 04             	sub    $0x4,%esp
  8051f4:	68 f8 20 81 00       	push   $0x8120f8
  8051f9:	68 f0 02 00 00       	push   $0x2f0
  8051fe:	68 04 1e 81 00       	push   $0x811e04
  805203:	e8 3f 97 00 00       	call   80e947 <_panic>
    if ((offset != 0) && (offset >= p->len)) {
      /* don't copy from this buffer -> on to the next */
      offset -= p->len;
    } else {
      /* copy from this buffer. maybe only partially. */
      buf_copy_len = p->len - offset;
  805208:	0f b7 5e 0a          	movzwl 0xa(%esi),%ebx
  80520c:	29 c3                	sub    %eax,%ebx
  80520e:	66 39 df             	cmp    %bx,%di
  805211:	0f 46 df             	cmovbe %edi,%ebx
      if (buf_copy_len > len)
          buf_copy_len = len;
      /* copy the necessary parts of the buffer */
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
  805214:	83 ec 04             	sub    $0x4,%esp
  805217:	0f b7 d3             	movzwl %bx,%edx
  80521a:	52                   	push   %edx
  80521b:	0f b7 c0             	movzwl %ax,%eax
  80521e:	03 46 04             	add    0x4(%esi),%eax
  805221:	50                   	push   %eax
  805222:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  805226:	03 45 0c             	add    0xc(%ebp),%eax
  805229:	50                   	push   %eax
  80522a:	e8 25 a0 00 00       	call   80f254 <memcpy>
      copied_total += buf_copy_len;
  80522f:	66 01 5d e4          	add    %bx,-0x1c(%ebp)
      left += buf_copy_len;
  805233:	66 01 5d e6          	add    %bx,-0x1a(%ebp)
      len -= buf_copy_len;
  805237:	29 df                	sub    %ebx,%edi
  805239:	83 c4 10             	add    $0x10,%esp
      offset = 0;
  80523c:	b8 00 00 00 00       	mov    $0x0,%eax
  for(p = buf; len != 0 && p != NULL; p = p->next) {
  805241:	8b 36                	mov    (%esi),%esi
  805243:	66 85 ff             	test   %di,%di
  805246:	74 16                	je     80525e <pbuf_copy_partial+0xb4>
  805248:	85 f6                	test   %esi,%esi
  80524a:	74 12                	je     80525e <pbuf_copy_partial+0xb4>
    if ((offset != 0) && (offset >= p->len)) {
  80524c:	66 85 c0             	test   %ax,%ax
  80524f:	74 b7                	je     805208 <pbuf_copy_partial+0x5e>
  805251:	0f b7 56 0a          	movzwl 0xa(%esi),%edx
  805255:	66 39 c2             	cmp    %ax,%dx
  805258:	77 ae                	ja     805208 <pbuf_copy_partial+0x5e>
      offset -= p->len;
  80525a:	29 d0                	sub    %edx,%eax
  80525c:	eb e3                	jmp    805241 <pbuf_copy_partial+0x97>
    }
  }
  return copied_total;
}
  80525e:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  805262:	8d 65 f4             	lea    -0xc(%ebp),%esp
  805265:	5b                   	pop    %ebx
  805266:	5e                   	pop    %esi
  805267:	5f                   	pop    %edi
  805268:	5d                   	pop    %ebp
  805269:	c3                   	ret    

0080526a <sswt_handler>:
 *
 * @param arg struct sswt_cb* used to signal a semaphore and end waiting.
 */
static void
sswt_handler(void *arg)
{
  80526a:	f3 0f 1e fb          	endbr32 
  80526e:	55                   	push   %ebp
  80526f:	89 e5                	mov    %esp,%ebp
  805271:	83 ec 14             	sub    $0x14,%esp
  805274:	8b 45 08             	mov    0x8(%ebp),%eax
  struct sswt_cb *sswt_cb = (struct sswt_cb *) arg;

  /* Timeout. Set flag to TRUE and signal semaphore */
  sswt_cb->timeflag = 1;
  805277:	66 c7 00 01 00       	movw   $0x1,(%eax)
  sys_sem_signal(*(sswt_cb->psem));
  80527c:	8b 40 04             	mov    0x4(%eax),%eax
  80527f:	ff 30                	pushl  (%eax)
  805281:	e8 ed 50 00 00       	call   80a373 <sys_sem_signal>
}
  805286:	83 c4 10             	add    $0x10,%esp
  805289:	c9                   	leave  
  80528a:	c3                   	ret    

0080528b <sys_mbox_fetch>:
{
  80528b:	f3 0f 1e fb          	endbr32 
  80528f:	55                   	push   %ebp
  805290:	89 e5                	mov    %esp,%ebp
  805292:	57                   	push   %edi
  805293:	56                   	push   %esi
  805294:	53                   	push   %ebx
  805295:	83 ec 0c             	sub    $0xc,%esp
  805298:	8b 7d 0c             	mov    0xc(%ebp),%edi
  80529b:	eb 44                	jmp    8052e1 <sys_mbox_fetch+0x56>
    time_needed = sys_arch_mbox_fetch(mbox, msg, 0);
  80529d:	83 ec 04             	sub    $0x4,%esp
  8052a0:	6a 00                	push   $0x0
  8052a2:	57                   	push   %edi
  8052a3:	ff 75 08             	pushl  0x8(%ebp)
  8052a6:	e8 4d 53 00 00       	call   80a5f8 <sys_arch_mbox_fetch>
  8052ab:	83 c4 10             	add    $0x10,%esp
}
  8052ae:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8052b1:	5b                   	pop    %ebx
  8052b2:	5e                   	pop    %esi
  8052b3:	5f                   	pop    %edi
  8052b4:	5d                   	pop    %ebp
  8052b5:	c3                   	ret    
      tmptimeout = timeouts->next;
  8052b6:	8b 03                	mov    (%ebx),%eax
      timeouts->next = tmptimeout->next;
  8052b8:	8b 10                	mov    (%eax),%edx
  8052ba:	89 13                	mov    %edx,(%ebx)
      h   = tmptimeout->h;
  8052bc:	8b 58 08             	mov    0x8(%eax),%ebx
      arg = tmptimeout->arg;
  8052bf:	8b 70 0c             	mov    0xc(%eax),%esi
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
  8052c2:	83 ec 08             	sub    $0x8,%esp
  8052c5:	50                   	push   %eax
  8052c6:	6a 0b                	push   $0xb
  8052c8:	e8 d1 f3 ff ff       	call   80469e <memp_free>
      if (h != NULL) {
  8052cd:	83 c4 10             	add    $0x10,%esp
  8052d0:	85 db                	test   %ebx,%ebx
  8052d2:	74 0d                	je     8052e1 <sys_mbox_fetch+0x56>
        h(arg);
  8052d4:	83 ec 0c             	sub    $0xc,%esp
  8052d7:	56                   	push   %esi
  8052d8:	ff d3                	call   *%ebx
  8052da:	83 c4 10             	add    $0x10,%esp
  8052dd:	f3 0f 1e fb          	endbr32 
  timeouts = sys_arch_timeouts();
  8052e1:	e8 b3 54 00 00       	call   80a799 <sys_arch_timeouts>
  8052e6:	89 c3                	mov    %eax,%ebx
  if (!timeouts || !timeouts->next) {
  8052e8:	85 c0                	test   %eax,%eax
  8052ea:	74 b1                	je     80529d <sys_mbox_fetch+0x12>
  8052ec:	8b 00                	mov    (%eax),%eax
  8052ee:	85 c0                	test   %eax,%eax
  8052f0:	74 ab                	je     80529d <sys_mbox_fetch+0x12>
    if (timeouts->next->time > 0) {
  8052f2:	8b 40 04             	mov    0x4(%eax),%eax
  8052f5:	85 c0                	test   %eax,%eax
  8052f7:	74 bd                	je     8052b6 <sys_mbox_fetch+0x2b>
      time_needed = sys_arch_mbox_fetch(mbox, msg, timeouts->next->time);
  8052f9:	83 ec 04             	sub    $0x4,%esp
  8052fc:	50                   	push   %eax
  8052fd:	57                   	push   %edi
  8052fe:	ff 75 08             	pushl  0x8(%ebp)
  805301:	e8 f2 52 00 00       	call   80a5f8 <sys_arch_mbox_fetch>
    if (time_needed == SYS_ARCH_TIMEOUT) {
  805306:	83 c4 10             	add    $0x10,%esp
  805309:	83 f8 ff             	cmp    $0xffffffff,%eax
  80530c:	74 a8                	je     8052b6 <sys_mbox_fetch+0x2b>
      if (time_needed < timeouts->next->time) {
  80530e:	8b 0b                	mov    (%ebx),%ecx
  805310:	8b 59 04             	mov    0x4(%ecx),%ebx
        timeouts->next->time -= time_needed;
  805313:	89 da                	mov    %ebx,%edx
  805315:	29 c2                	sub    %eax,%edx
  805317:	39 c3                	cmp    %eax,%ebx
  805319:	b8 00 00 00 00       	mov    $0x0,%eax
  80531e:	0f 47 c2             	cmova  %edx,%eax
  805321:	89 41 04             	mov    %eax,0x4(%ecx)
  805324:	eb 88                	jmp    8052ae <sys_mbox_fetch+0x23>

00805326 <sys_sem_wait>:
{
  805326:	f3 0f 1e fb          	endbr32 
  80532a:	55                   	push   %ebp
  80532b:	89 e5                	mov    %esp,%ebp
  80532d:	57                   	push   %edi
  80532e:	56                   	push   %esi
  80532f:	53                   	push   %ebx
  805330:	83 ec 0c             	sub    $0xc,%esp
  805333:	8b 75 08             	mov    0x8(%ebp),%esi
  805336:	eb 41                	jmp    805379 <sys_sem_wait+0x53>
    sys_arch_sem_wait(sem, 0);
  805338:	83 ec 08             	sub    $0x8,%esp
  80533b:	6a 00                	push   $0x0
  80533d:	56                   	push   %esi
  80533e:	e8 a4 50 00 00       	call   80a3e7 <sys_arch_sem_wait>
  805343:	83 c4 10             	add    $0x10,%esp
}
  805346:	8d 65 f4             	lea    -0xc(%ebp),%esp
  805349:	5b                   	pop    %ebx
  80534a:	5e                   	pop    %esi
  80534b:	5f                   	pop    %edi
  80534c:	5d                   	pop    %ebp
  80534d:	c3                   	ret    
      tmptimeout = timeouts->next;
  80534e:	8b 03                	mov    (%ebx),%eax
      timeouts->next = tmptimeout->next;
  805350:	8b 10                	mov    (%eax),%edx
  805352:	89 13                	mov    %edx,(%ebx)
      h = tmptimeout->h;
  805354:	8b 58 08             	mov    0x8(%eax),%ebx
      arg = tmptimeout->arg;
  805357:	8b 78 0c             	mov    0xc(%eax),%edi
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
  80535a:	83 ec 08             	sub    $0x8,%esp
  80535d:	50                   	push   %eax
  80535e:	6a 0b                	push   $0xb
  805360:	e8 39 f3 ff ff       	call   80469e <memp_free>
      if (h != NULL) {
  805365:	83 c4 10             	add    $0x10,%esp
  805368:	85 db                	test   %ebx,%ebx
  80536a:	74 0d                	je     805379 <sys_sem_wait+0x53>
        h(arg);
  80536c:	83 ec 0c             	sub    $0xc,%esp
  80536f:	57                   	push   %edi
  805370:	ff d3                	call   *%ebx
  805372:	83 c4 10             	add    $0x10,%esp
  805375:	f3 0f 1e fb          	endbr32 
  timeouts = sys_arch_timeouts();
  805379:	e8 1b 54 00 00       	call   80a799 <sys_arch_timeouts>
  80537e:	89 c3                	mov    %eax,%ebx
  if (!timeouts || !timeouts->next) {
  805380:	85 c0                	test   %eax,%eax
  805382:	74 b4                	je     805338 <sys_sem_wait+0x12>
  805384:	8b 00                	mov    (%eax),%eax
  805386:	85 c0                	test   %eax,%eax
  805388:	74 ae                	je     805338 <sys_sem_wait+0x12>
    if (timeouts->next->time > 0) {
  80538a:	8b 40 04             	mov    0x4(%eax),%eax
  80538d:	85 c0                	test   %eax,%eax
  80538f:	74 bd                	je     80534e <sys_sem_wait+0x28>
      time_needed = sys_arch_sem_wait(sem, timeouts->next->time);
  805391:	83 ec 08             	sub    $0x8,%esp
  805394:	50                   	push   %eax
  805395:	56                   	push   %esi
  805396:	e8 4c 50 00 00       	call   80a3e7 <sys_arch_sem_wait>
    if (time_needed == SYS_ARCH_TIMEOUT) {
  80539b:	83 c4 10             	add    $0x10,%esp
  80539e:	83 f8 ff             	cmp    $0xffffffff,%eax
  8053a1:	74 ab                	je     80534e <sys_sem_wait+0x28>
      if (time_needed < timeouts->next->time) {
  8053a3:	8b 0b                	mov    (%ebx),%ecx
  8053a5:	8b 59 04             	mov    0x4(%ecx),%ebx
        timeouts->next->time -= time_needed;
  8053a8:	89 da                	mov    %ebx,%edx
  8053aa:	29 c2                	sub    %eax,%edx
  8053ac:	39 c3                	cmp    %eax,%ebx
  8053ae:	b8 00 00 00 00       	mov    $0x0,%eax
  8053b3:	0f 47 c2             	cmova  %edx,%eax
  8053b6:	89 41 04             	mov    %eax,0x4(%ecx)
  8053b9:	eb 8b                	jmp    805346 <sys_sem_wait+0x20>

008053bb <sys_timeout>:
{
  8053bb:	f3 0f 1e fb          	endbr32 
  8053bf:	55                   	push   %ebp
  8053c0:	89 e5                	mov    %esp,%ebp
  8053c2:	57                   	push   %edi
  8053c3:	56                   	push   %esi
  8053c4:	53                   	push   %ebx
  8053c5:	83 ec 28             	sub    $0x28,%esp
  8053c8:	8b 75 08             	mov    0x8(%ebp),%esi
  timeout = memp_malloc(MEMP_SYS_TIMEOUT);
  8053cb:	6a 0b                	push   $0xb
  8053cd:	e8 72 f2 ff ff       	call   804644 <memp_malloc>
  if (timeout == NULL) {
  8053d2:	83 c4 10             	add    $0x10,%esp
  8053d5:	85 c0                	test   %eax,%eax
  8053d7:	74 40                	je     805419 <sys_timeout+0x5e>
  8053d9:	89 c3                	mov    %eax,%ebx
  timeout->next = NULL;
  8053db:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  timeout->h = h;
  8053e1:	8b 45 0c             	mov    0xc(%ebp),%eax
  8053e4:	89 43 08             	mov    %eax,0x8(%ebx)
  timeout->arg = arg;
  8053e7:	8b 45 10             	mov    0x10(%ebp),%eax
  8053ea:	89 43 0c             	mov    %eax,0xc(%ebx)
  timeout->time = msecs;
  8053ed:	89 73 04             	mov    %esi,0x4(%ebx)
  timeouts = sys_arch_timeouts();
  8053f0:	e8 a4 53 00 00       	call   80a799 <sys_arch_timeouts>
  if (timeouts == NULL) {
  8053f5:	85 c0                	test   %eax,%eax
  8053f7:	74 37                	je     805430 <sys_timeout+0x75>
  if (timeouts->next == NULL) {
  8053f9:	8b 10                	mov    (%eax),%edx
  8053fb:	85 d2                	test   %edx,%edx
  8053fd:	74 48                	je     805447 <sys_timeout+0x8c>
  if (timeouts->next->time > msecs) {
  8053ff:	8b 4a 04             	mov    0x4(%edx),%ecx
  805402:	39 f1                	cmp    %esi,%ecx
  805404:	76 45                	jbe    80544b <sys_timeout+0x90>
    timeouts->next->time -= msecs;
  805406:	29 f1                	sub    %esi,%ecx
  805408:	89 4a 04             	mov    %ecx,0x4(%edx)
    timeout->next = timeouts->next;
  80540b:	8b 10                	mov    (%eax),%edx
  80540d:	89 13                	mov    %edx,(%ebx)
    timeouts->next = timeout;
  80540f:	89 18                	mov    %ebx,(%eax)
}
  805411:	8d 65 f4             	lea    -0xc(%ebp),%esp
  805414:	5b                   	pop    %ebx
  805415:	5e                   	pop    %esi
  805416:	5f                   	pop    %edi
  805417:	5d                   	pop    %ebp
  805418:	c3                   	ret    
    LWIP_ASSERT("sys_timeout: timeout != NULL", timeout != NULL);
  805419:	83 ec 04             	sub    $0x4,%esp
  80541c:	68 1d 21 81 00       	push   $0x81211d
  805421:	68 c3 00 00 00       	push   $0xc3
  805426:	68 3a 21 81 00       	push   $0x81213a
  80542b:	e8 17 95 00 00       	call   80e947 <_panic>
    LWIP_ASSERT("sys_timeout: timeouts != NULL", timeouts != NULL);
  805430:	83 ec 04             	sub    $0x4,%esp
  805433:	68 4e 21 81 00       	push   $0x81214e
  805438:	68 d1 00 00 00       	push   $0xd1
  80543d:	68 3a 21 81 00       	push   $0x81213a
  805442:	e8 00 95 00 00       	call   80e947 <_panic>
    timeouts->next = timeout;
  805447:	89 18                	mov    %ebx,(%eax)
    return;
  805449:	eb c6                	jmp    805411 <sys_timeout+0x56>
      timeout->time -= t->time;
  80544b:	8b 7b 04             	mov    0x4(%ebx),%edi
  80544e:	8b 72 04             	mov    0x4(%edx),%esi
  805451:	89 f8                	mov    %edi,%eax
  805453:	29 f0                	sub    %esi,%eax
  805455:	89 43 04             	mov    %eax,0x4(%ebx)
  805458:	89 55 e4             	mov    %edx,-0x1c(%ebp)
      if (t->next == NULL || t->next->time > timeout->time) {
  80545b:	8b 12                	mov    (%edx),%edx
  80545d:	85 d2                	test   %edx,%edx
  80545f:	74 0e                	je     80546f <sys_timeout+0xb4>
  805461:	8b 4a 04             	mov    0x4(%edx),%ecx
  805464:	39 c8                	cmp    %ecx,%eax
  805466:	73 e3                	jae    80544b <sys_timeout+0x90>
          t->next->time -= timeout->time;
  805468:	29 f9                	sub    %edi,%ecx
  80546a:	01 ce                	add    %ecx,%esi
  80546c:	89 72 04             	mov    %esi,0x4(%edx)
        timeout->next = t->next;
  80546f:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  805472:	8b 07                	mov    (%edi),%eax
  805474:	89 03                	mov    %eax,(%ebx)
        t->next = timeout;
  805476:	89 1f                	mov    %ebx,(%edi)
        break;
  805478:	eb 97                	jmp    805411 <sys_timeout+0x56>

0080547a <sys_untimeout>:
{
  80547a:	f3 0f 1e fb          	endbr32 
  80547e:	55                   	push   %ebp
  80547f:	89 e5                	mov    %esp,%ebp
  805481:	57                   	push   %edi
  805482:	56                   	push   %esi
  805483:	53                   	push   %ebx
  805484:	83 ec 0c             	sub    $0xc,%esp
  805487:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80548a:	8b 75 0c             	mov    0xc(%ebp),%esi
  timeouts = sys_arch_timeouts();
  80548d:	e8 07 53 00 00       	call   80a799 <sys_arch_timeouts>
  if (timeouts == NULL) {
  805492:	85 c0                	test   %eax,%eax
  805494:	74 0f                	je     8054a5 <sys_untimeout+0x2b>
  805496:	89 c7                	mov    %eax,%edi
  if (timeouts->next == NULL) {
  805498:	8b 10                	mov    (%eax),%edx
  80549a:	85 d2                	test   %edx,%edx
  80549c:	74 5a                	je     8054f8 <sys_untimeout+0x7e>
  for (t = timeouts->next, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
  80549e:	b8 00 00 00 00       	mov    $0x0,%eax
  8054a3:	eb 27                	jmp    8054cc <sys_untimeout+0x52>
    LWIP_ASSERT("sys_untimeout: timeouts != NULL", timeouts != NULL);
  8054a5:	83 ec 04             	sub    $0x4,%esp
  8054a8:	68 6c 21 81 00       	push   $0x81216c
  8054ad:	68 00 01 00 00       	push   $0x100
  8054b2:	68 3a 21 81 00       	push   $0x81213a
  8054b7:	e8 8b 94 00 00       	call   80e947 <_panic>
        timeouts->next = t->next;
  8054bc:	8b 02                	mov    (%edx),%eax
  8054be:	89 07                	mov    %eax,(%edi)
  8054c0:	eb 1c                	jmp    8054de <sys_untimeout+0x64>
  for (t = timeouts->next, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
  8054c2:	8b 0a                	mov    (%edx),%ecx
  8054c4:	89 d0                	mov    %edx,%eax
  8054c6:	85 c9                	test   %ecx,%ecx
  8054c8:	74 2e                	je     8054f8 <sys_untimeout+0x7e>
  8054ca:	89 ca                	mov    %ecx,%edx
    if ((t->h == h) && (t->arg == arg)) {
  8054cc:	39 5a 08             	cmp    %ebx,0x8(%edx)
  8054cf:	75 f1                	jne    8054c2 <sys_untimeout+0x48>
  8054d1:	39 72 0c             	cmp    %esi,0xc(%edx)
  8054d4:	75 ec                	jne    8054c2 <sys_untimeout+0x48>
      if (prev_t == NULL)
  8054d6:	85 c0                	test   %eax,%eax
  8054d8:	74 e2                	je     8054bc <sys_untimeout+0x42>
        prev_t->next = t->next;
  8054da:	8b 0a                	mov    (%edx),%ecx
  8054dc:	89 08                	mov    %ecx,(%eax)
      if (t->next != NULL)
  8054de:	8b 02                	mov    (%edx),%eax
  8054e0:	85 c0                	test   %eax,%eax
  8054e2:	74 06                	je     8054ea <sys_untimeout+0x70>
        t->next->time += t->time;
  8054e4:	8b 4a 04             	mov    0x4(%edx),%ecx
  8054e7:	01 48 04             	add    %ecx,0x4(%eax)
      memp_free(MEMP_SYS_TIMEOUT, t);
  8054ea:	83 ec 08             	sub    $0x8,%esp
  8054ed:	52                   	push   %edx
  8054ee:	6a 0b                	push   $0xb
  8054f0:	e8 a9 f1 ff ff       	call   80469e <memp_free>
      return;
  8054f5:	83 c4 10             	add    $0x10,%esp
}
  8054f8:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8054fb:	5b                   	pop    %ebx
  8054fc:	5e                   	pop    %esi
  8054fd:	5f                   	pop    %edi
  8054fe:	5d                   	pop    %ebp
  8054ff:	c3                   	ret    

00805500 <sys_sem_wait_timeout>:
 * @param timeout timeout in ms (0: wait forever)
 * @return 0 on timeout, 1 otherwise
 */
int
sys_sem_wait_timeout(sys_sem_t sem, u32_t timeout)
{
  805500:	f3 0f 1e fb          	endbr32 
  805504:	55                   	push   %ebp
  805505:	89 e5                	mov    %esp,%ebp
  805507:	83 ec 18             	sub    $0x18,%esp
  80550a:	8b 45 0c             	mov    0xc(%ebp),%eax
  struct sswt_cb sswt_cb;

  sswt_cb.psem = &sem;
  80550d:	8d 4d 08             	lea    0x8(%ebp),%ecx
  805510:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  sswt_cb.timeflag = 0;
  805513:	66 c7 45 f0 00 00    	movw   $0x0,-0x10(%ebp)

  /* If timeout is zero, then just wait forever */
  if (timeout > 0) {
  805519:	85 c0                	test   %eax,%eax
  80551b:	75 1c                	jne    805539 <sys_sem_wait_timeout+0x39>
    /* Create a timer and pass it the address of our flag */
    sys_timeout(timeout, sswt_handler, &sswt_cb);
  }
  sys_sem_wait(sem);
  80551d:	83 ec 0c             	sub    $0xc,%esp
  805520:	ff 75 08             	pushl  0x8(%ebp)
  805523:	e8 fe fd ff ff       	call   805326 <sys_sem_wait>
  /* Was it a timeout? */
  if (sswt_cb.timeflag) {
  805528:	83 c4 10             	add    $0x10,%esp
    /* timeout */
    return 0;
  80552b:	b8 00 00 00 00       	mov    $0x0,%eax
  if (sswt_cb.timeflag) {
  805530:	66 83 7d f0 00       	cmpw   $0x0,-0x10(%ebp)
  805535:	74 19                	je     805550 <sys_sem_wait_timeout+0x50>
  } else {
    /* Not a timeout. Remove timeout entry */
    sys_untimeout(sswt_handler, &sswt_cb);
    return 1;
  }
}
  805537:	c9                   	leave  
  805538:	c3                   	ret    
    sys_timeout(timeout, sswt_handler, &sswt_cb);
  805539:	83 ec 04             	sub    $0x4,%esp
  80553c:	8d 55 f0             	lea    -0x10(%ebp),%edx
  80553f:	52                   	push   %edx
  805540:	68 6a 52 80 00       	push   $0x80526a
  805545:	50                   	push   %eax
  805546:	e8 70 fe ff ff       	call   8053bb <sys_timeout>
  80554b:	83 c4 10             	add    $0x10,%esp
  80554e:	eb cd                	jmp    80551d <sys_sem_wait_timeout+0x1d>
    sys_untimeout(sswt_handler, &sswt_cb);
  805550:	83 ec 08             	sub    $0x8,%esp
  805553:	8d 45 f0             	lea    -0x10(%ebp),%eax
  805556:	50                   	push   %eax
  805557:	68 6a 52 80 00       	push   $0x80526a
  80555c:	e8 19 ff ff ff       	call   80547a <sys_untimeout>
    return 1;
  805561:	83 c4 10             	add    $0x10,%esp
  805564:	b8 01 00 00 00       	mov    $0x1,%eax
  805569:	eb cc                	jmp    805537 <sys_sem_wait_timeout+0x37>

0080556b <sys_msleep>:
 *
 * @param ms number of milliseconds to sleep
 */
void
sys_msleep(u32_t ms)
{
  80556b:	f3 0f 1e fb          	endbr32 
  80556f:	55                   	push   %ebp
  805570:	89 e5                	mov    %esp,%ebp
  805572:	53                   	push   %ebx
  805573:	83 ec 10             	sub    $0x10,%esp
  sys_sem_t delaysem = sys_sem_new(0);
  805576:	6a 00                	push   $0x0
  805578:	e8 29 4b 00 00       	call   80a0a6 <sys_sem_new>
  80557d:	89 c3                	mov    %eax,%ebx

  sys_sem_wait_timeout(delaysem, ms);
  80557f:	83 c4 08             	add    $0x8,%esp
  805582:	ff 75 08             	pushl  0x8(%ebp)
  805585:	50                   	push   %eax
  805586:	e8 75 ff ff ff       	call   805500 <sys_sem_wait_timeout>

  sys_sem_free(delaysem);
  80558b:	89 1c 24             	mov    %ebx,(%esp)
  80558e:	e8 98 4b 00 00       	call   80a12b <sys_sem_free>
}
  805593:	83 c4 10             	add    $0x10,%esp
  805596:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  805599:	c9                   	leave  
  80559a:	c3                   	ret    

0080559b <tcp_accept_null>:
/**
 * Default accept callback if no accept callback is specified by the user.
 */
static err_t
tcp_accept_null(void *arg, struct tcp_pcb *pcb, err_t err)
{
  80559b:	f3 0f 1e fb          	endbr32 
  LWIP_UNUSED_ARG(arg);
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(err);

  return ERR_ABRT;
}
  80559f:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
  8055a4:	c3                   	ret    

008055a5 <tcp_new_port>:
 *
 * @return a new (free) local TCP port number
 */
static u16_t
tcp_new_port(void)
{
  8055a5:	55                   	push   %ebp
  8055a6:	89 e5                	mov    %esp,%ebp
  8055a8:	57                   	push   %edi
  8055a9:	56                   	push   %esi
  8055aa:	53                   	push   %ebx
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
    port = TCP_LOCAL_PORT_RANGE_START;
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  8055ab:	8b 1d 3c b2 b3 00    	mov    0xb3b23c,%ebx
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  8055b1:	8b 35 50 b2 b3 00    	mov    0xb3b250,%esi
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  8055b7:	8b 3d 44 b2 b3 00    	mov    0xb3b244,%edi
  8055bd:	0f b7 15 0c 40 81 00 	movzwl 0x81400c,%edx
    port = TCP_LOCAL_PORT_RANGE_START;
  8055c4:	b9 00 10 00 00       	mov    $0x1000,%ecx
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
  8055c9:	66 83 c2 01          	add    $0x1,%dx
    port = TCP_LOCAL_PORT_RANGE_START;
  8055cd:	0f 48 d1             	cmovs  %ecx,%edx
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  8055d0:	89 d8                	mov    %ebx,%eax
  8055d2:	85 c0                	test   %eax,%eax
  8055d4:	74 0b                	je     8055e1 <tcp_new_port+0x3c>
    if (pcb->local_port == port) {
  8055d6:	66 39 50 1c          	cmp    %dx,0x1c(%eax)
  8055da:	74 ed                	je     8055c9 <tcp_new_port+0x24>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  8055dc:	8b 40 0c             	mov    0xc(%eax),%eax
  8055df:	eb f1                	jmp    8055d2 <tcp_new_port+0x2d>
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  8055e1:	89 f0                	mov    %esi,%eax
  8055e3:	85 c0                	test   %eax,%eax
  8055e5:	74 0b                	je     8055f2 <tcp_new_port+0x4d>
    if (pcb->local_port == port) {
  8055e7:	66 39 50 1c          	cmp    %dx,0x1c(%eax)
  8055eb:	74 dc                	je     8055c9 <tcp_new_port+0x24>
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  8055ed:	8b 40 0c             	mov    0xc(%eax),%eax
  8055f0:	eb f1                	jmp    8055e3 <tcp_new_port+0x3e>
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  8055f2:	89 f8                	mov    %edi,%eax
  8055f4:	85 c0                	test   %eax,%eax
  8055f6:	74 0b                	je     805603 <tcp_new_port+0x5e>
    if (pcb->local_port == port) {
  8055f8:	66 39 50 1c          	cmp    %dx,0x1c(%eax)
  8055fc:	74 cb                	je     8055c9 <tcp_new_port+0x24>
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  8055fe:	8b 40 0c             	mov    0xc(%eax),%eax
  805601:	eb f1                	jmp    8055f4 <tcp_new_port+0x4f>
  805603:	66 89 15 0c 40 81 00 	mov    %dx,0x81400c
      goto again;
    }
  }
  return port;
}
  80560a:	89 d0                	mov    %edx,%eax
  80560c:	5b                   	pop    %ebx
  80560d:	5e                   	pop    %esi
  80560e:	5f                   	pop    %edi
  80560f:	5d                   	pop    %ebp
  805610:	c3                   	ret    

00805611 <tcp_bind>:
{
  805611:	f3 0f 1e fb          	endbr32 
  805615:	55                   	push   %ebp
  805616:	89 e5                	mov    %esp,%ebp
  805618:	57                   	push   %edi
  805619:	56                   	push   %esi
  80561a:	53                   	push   %ebx
  80561b:	83 ec 0c             	sub    $0xc,%esp
  80561e:	8b 75 08             	mov    0x8(%ebp),%esi
  805621:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  805624:	8b 55 10             	mov    0x10(%ebp),%edx
  LWIP_ERROR("tcp_connect: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  805627:	83 7e 10 00          	cmpl   $0x0,0x10(%esi)
  80562b:	75 0f                	jne    80563c <tcp_bind+0x2b>
  80562d:	89 d0                	mov    %edx,%eax
  if (port == 0) {
  80562f:	66 85 d2             	test   %dx,%dx
  805632:	74 1f                	je     805653 <tcp_bind+0x42>
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
  805634:	8b 15 44 b2 b3 00    	mov    0xb3b244,%edx
  80563a:	eb 21                	jmp    80565d <tcp_bind+0x4c>
  LWIP_ERROR("tcp_connect: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  80563c:	83 ec 04             	sub    $0x4,%esp
  80563f:	68 8c 21 81 00       	push   $0x81218c
  805644:	68 05 01 00 00       	push   $0x105
  805649:	68 6e 23 81 00       	push   $0x81236e
  80564e:	e8 f4 92 00 00       	call   80e947 <_panic>
    port = tcp_new_port();
  805653:	e8 4d ff ff ff       	call   8055a5 <tcp_new_port>
  805658:	eb da                	jmp    805634 <tcp_bind+0x23>
      cpcb != NULL; cpcb = cpcb->next) {
  80565a:	8b 52 0c             	mov    0xc(%edx),%edx
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
  80565d:	85 d2                	test   %edx,%edx
  80565f:	74 2c                	je     80568d <tcp_bind+0x7c>
    if (cpcb->local_port == port) {
  805661:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  805665:	75 f3                	jne    80565a <tcp_bind+0x49>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  805667:	8b 0a                	mov    (%edx),%ecx
  805669:	85 db                	test   %ebx,%ebx
  80566b:	0f 84 d4 00 00 00    	je     805745 <tcp_bind+0x134>
  805671:	85 c9                	test   %ecx,%ecx
  805673:	0f 84 cc 00 00 00    	je     805745 <tcp_bind+0x134>
          ip_addr_isany(ipaddr) ||
  805679:	8b 3b                	mov    (%ebx),%edi
  80567b:	39 f9                	cmp    %edi,%ecx
  80567d:	74 04                	je     805683 <tcp_bind+0x72>
  80567f:	85 ff                	test   %edi,%edi
  805681:	75 d7                	jne    80565a <tcp_bind+0x49>
        return ERR_USE;
  805683:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805688:	e9 bd 00 00 00       	jmp    80574a <tcp_bind+0x139>
  for(cpcb = tcp_active_pcbs;
  80568d:	8b 15 3c b2 b3 00    	mov    0xb3b23c,%edx
  805693:	eb 03                	jmp    805698 <tcp_bind+0x87>
      cpcb != NULL; cpcb = cpcb->next) {
  805695:	8b 52 0c             	mov    0xc(%edx),%edx
  for(cpcb = tcp_active_pcbs;
  805698:	85 d2                	test   %edx,%edx
  80569a:	74 2c                	je     8056c8 <tcp_bind+0xb7>
    if (cpcb->local_port == port) {
  80569c:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  8056a0:	75 f3                	jne    805695 <tcp_bind+0x84>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  8056a2:	8b 0a                	mov    (%edx),%ecx
  8056a4:	85 db                	test   %ebx,%ebx
  8056a6:	0f 84 a6 00 00 00    	je     805752 <tcp_bind+0x141>
  8056ac:	85 c9                	test   %ecx,%ecx
  8056ae:	0f 84 9e 00 00 00    	je     805752 <tcp_bind+0x141>
          ip_addr_isany(ipaddr) ||
  8056b4:	8b 3b                	mov    (%ebx),%edi
  8056b6:	39 f9                	cmp    %edi,%ecx
  8056b8:	74 04                	je     8056be <tcp_bind+0xad>
  8056ba:	85 ff                	test   %edi,%edi
  8056bc:	75 d7                	jne    805695 <tcp_bind+0x84>
        return ERR_USE;
  8056be:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  8056c3:	e9 82 00 00 00       	jmp    80574a <tcp_bind+0x139>
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  8056c8:	8b 15 4c b2 b3 00    	mov    0xb3b24c,%edx
  8056ce:	eb 03                	jmp    8056d3 <tcp_bind+0xc2>
  8056d0:	8b 52 0c             	mov    0xc(%edx),%edx
  8056d3:	85 d2                	test   %edx,%edx
  8056d5:	74 21                	je     8056f8 <tcp_bind+0xe7>
    if (cpcb->local_port == port) {
  8056d7:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  8056db:	75 f3                	jne    8056d0 <tcp_bind+0xbf>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  8056dd:	8b 0a                	mov    (%edx),%ecx
  8056df:	85 db                	test   %ebx,%ebx
  8056e1:	74 76                	je     805759 <tcp_bind+0x148>
  8056e3:	85 c9                	test   %ecx,%ecx
  8056e5:	74 72                	je     805759 <tcp_bind+0x148>
          ip_addr_isany(ipaddr) ||
  8056e7:	8b 3b                	mov    (%ebx),%edi
  8056e9:	39 f9                	cmp    %edi,%ecx
  8056eb:	74 04                	je     8056f1 <tcp_bind+0xe0>
  8056ed:	85 ff                	test   %edi,%edi
  8056ef:	75 df                	jne    8056d0 <tcp_bind+0xbf>
        return ERR_USE;
  8056f1:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  8056f6:	eb 52                	jmp    80574a <tcp_bind+0x139>
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  8056f8:	8b 15 50 b2 b3 00    	mov    0xb3b250,%edx
  8056fe:	eb 03                	jmp    805703 <tcp_bind+0xf2>
  805700:	8b 52 0c             	mov    0xc(%edx),%edx
  805703:	85 d2                	test   %edx,%edx
  805705:	74 13                	je     80571a <tcp_bind+0x109>
    if (cpcb->local_port == port) {
  805707:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  80570b:	75 f3                	jne    805700 <tcp_bind+0xef>
      if (ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
  80570d:	8b 3b                	mov    (%ebx),%edi
  80570f:	39 3a                	cmp    %edi,(%edx)
  805711:	75 ed                	jne    805700 <tcp_bind+0xef>
        return ERR_USE;
  805713:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805718:	eb 30                	jmp    80574a <tcp_bind+0x139>
  if (!ip_addr_isany(ipaddr)) {
  80571a:	85 db                	test   %ebx,%ebx
  80571c:	74 09                	je     805727 <tcp_bind+0x116>
  80571e:	83 3b 00             	cmpl   $0x0,(%ebx)
  805721:	74 04                	je     805727 <tcp_bind+0x116>
    pcb->local_ip = *ipaddr;
  805723:	8b 13                	mov    (%ebx),%edx
  805725:	89 16                	mov    %edx,(%esi)
  pcb->local_port = port;
  805727:	66 89 46 1c          	mov    %ax,0x1c(%esi)
  TCP_REG(&tcp_bound_pcbs, pcb);
  80572b:	a1 4c b2 b3 00       	mov    0xb3b24c,%eax
  805730:	89 46 0c             	mov    %eax,0xc(%esi)
  805733:	89 35 4c b2 b3 00    	mov    %esi,0xb3b24c
  805739:	e8 0e cc ff ff       	call   80234c <tcp_timer_needed>
  return ERR_OK;
  80573e:	b8 00 00 00 00       	mov    $0x0,%eax
  805743:	eb 05                	jmp    80574a <tcp_bind+0x139>
        return ERR_USE;
  805745:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
}
  80574a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80574d:	5b                   	pop    %ebx
  80574e:	5e                   	pop    %esi
  80574f:	5f                   	pop    %edi
  805750:	5d                   	pop    %ebp
  805751:	c3                   	ret    
        return ERR_USE;
  805752:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805757:	eb f1                	jmp    80574a <tcp_bind+0x139>
        return ERR_USE;
  805759:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  80575e:	eb ea                	jmp    80574a <tcp_bind+0x139>

00805760 <tcp_listen_with_backlog>:
{
  805760:	f3 0f 1e fb          	endbr32 
  805764:	55                   	push   %ebp
  805765:	89 e5                	mov    %esp,%ebp
  805767:	57                   	push   %edi
  805768:	56                   	push   %esi
  805769:	53                   	push   %ebx
  80576a:	83 ec 0c             	sub    $0xc,%esp
  80576d:	8b 5d 08             	mov    0x8(%ebp),%ebx
  LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);
  805770:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  805774:	75 65                	jne    8057db <tcp_listen_with_backlog+0x7b>
  lpcb = memp_malloc(MEMP_TCP_PCB_LISTEN);
  805776:	83 ec 0c             	sub    $0xc,%esp
  805779:	6a 03                	push   $0x3
  80577b:	e8 c4 ee ff ff       	call   804644 <memp_malloc>
  805780:	89 c6                	mov    %eax,%esi
  if (lpcb == NULL) {
  805782:	83 c4 10             	add    $0x10,%esp
  805785:	85 c0                	test   %eax,%eax
  805787:	0f 84 9c 00 00 00    	je     805829 <tcp_listen_with_backlog+0xc9>
  lpcb->callback_arg = pcb->callback_arg;
  80578d:	8b 43 18             	mov    0x18(%ebx),%eax
  805790:	89 46 18             	mov    %eax,0x18(%esi)
  lpcb->local_port = pcb->local_port;
  805793:	0f b7 43 1c          	movzwl 0x1c(%ebx),%eax
  805797:	66 89 46 1c          	mov    %ax,0x1c(%esi)
  lpcb->state = LISTEN;
  80579b:	c7 46 10 01 00 00 00 	movl   $0x1,0x10(%esi)
  lpcb->so_options |= SOF_ACCEPTCONN;
  8057a2:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  8057a6:	83 c8 02             	or     $0x2,%eax
  8057a9:	66 89 46 08          	mov    %ax,0x8(%esi)
  lpcb->ttl = pcb->ttl;
  8057ad:	0f b6 43 0b          	movzbl 0xb(%ebx),%eax
  8057b1:	88 46 0b             	mov    %al,0xb(%esi)
  lpcb->tos = pcb->tos;
  8057b4:	0f b6 43 0a          	movzbl 0xa(%ebx),%eax
  8057b8:	88 46 0a             	mov    %al,0xa(%esi)
  ip_addr_set(&lpcb->local_ip, &pcb->local_ip);
  8057bb:	8b 03                	mov    (%ebx),%eax
  8057bd:	89 06                	mov    %eax,(%esi)
  TCP_RMV(&tcp_bound_pcbs, pcb);
  8057bf:	8b 15 4c b2 b3 00    	mov    0xb3b24c,%edx
  8057c5:	39 da                	cmp    %ebx,%edx
  8057c7:	74 29                	je     8057f2 <tcp_listen_with_backlog+0x92>
  8057c9:	89 15 48 b2 b3 00    	mov    %edx,0xb3b248
  8057cf:	b9 00 00 00 00       	mov    $0x0,%ecx
  8057d4:	bf 01 00 00 00       	mov    $0x1,%edi
  8057d9:	eb 5c                	jmp    805837 <tcp_listen_with_backlog+0xd7>
  LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);
  8057db:	83 ec 04             	sub    $0x4,%esp
  8057de:	68 b8 21 81 00       	push   $0x8121b8
  8057e3:	68 60 01 00 00       	push   $0x160
  8057e8:	68 6e 23 81 00       	push   $0x81236e
  8057ed:	e8 55 91 00 00       	call   80e947 <_panic>
  TCP_RMV(&tcp_bound_pcbs, pcb);
  8057f2:	8b 43 0c             	mov    0xc(%ebx),%eax
  8057f5:	a3 4c b2 b3 00       	mov    %eax,0xb3b24c
  8057fa:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
  memp_free(MEMP_TCP_PCB, pcb);
  805801:	83 ec 08             	sub    $0x8,%esp
  805804:	53                   	push   %ebx
  805805:	6a 02                	push   $0x2
  805807:	e8 92 ee ff ff       	call   80469e <memp_free>
  lpcb->accept = tcp_accept_null;
  80580c:	c7 46 20 9b 55 80 00 	movl   $0x80559b,0x20(%esi)
  TCP_REG(&tcp_listen_pcbs.listen_pcbs, lpcb);
  805813:	a1 44 b2 b3 00       	mov    0xb3b244,%eax
  805818:	89 46 0c             	mov    %eax,0xc(%esi)
  80581b:	89 35 44 b2 b3 00    	mov    %esi,0xb3b244
  805821:	e8 26 cb ff ff       	call   80234c <tcp_timer_needed>
  return (struct tcp_pcb *)lpcb;
  805826:	83 c4 10             	add    $0x10,%esp
}
  805829:	89 f0                	mov    %esi,%eax
  80582b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80582e:	5b                   	pop    %ebx
  80582f:	5e                   	pop    %esi
  805830:	5f                   	pop    %edi
  805831:	5d                   	pop    %ebp
  805832:	c3                   	ret    
  805833:	89 f9                	mov    %edi,%ecx
  TCP_RMV(&tcp_bound_pcbs, pcb);
  805835:	89 c2                	mov    %eax,%edx
  805837:	85 d2                	test   %edx,%edx
  805839:	74 1d                	je     805858 <tcp_listen_with_backlog+0xf8>
  80583b:	8b 42 0c             	mov    0xc(%edx),%eax
  80583e:	39 d8                	cmp    %ebx,%eax
  805840:	75 f1                	jne    805833 <tcp_listen_with_backlog+0xd3>
  805842:	85 c0                	test   %eax,%eax
  805844:	74 ed                	je     805833 <tcp_listen_with_backlog+0xd3>
  805846:	84 c9                	test   %cl,%cl
  805848:	74 06                	je     805850 <tcp_listen_with_backlog+0xf0>
  80584a:	89 15 48 b2 b3 00    	mov    %edx,0xb3b248
  805850:	8b 43 0c             	mov    0xc(%ebx),%eax
  805853:	89 42 0c             	mov    %eax,0xc(%edx)
  805856:	eb a2                	jmp    8057fa <tcp_listen_with_backlog+0x9a>
  805858:	84 c9                	test   %cl,%cl
  80585a:	74 9e                	je     8057fa <tcp_listen_with_backlog+0x9a>
  80585c:	c7 05 48 b2 b3 00 00 	movl   $0x0,0xb3b248
  805863:	00 00 00 
  805866:	eb 92                	jmp    8057fa <tcp_listen_with_backlog+0x9a>

00805868 <tcp_recved>:
{
  805868:	f3 0f 1e fb          	endbr32 
  80586c:	55                   	push   %ebp
  80586d:	89 e5                	mov    %esp,%ebp
  80586f:	56                   	push   %esi
  805870:	53                   	push   %ebx
  805871:	8b 45 08             	mov    0x8(%ebp),%eax
  805874:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  if ((u32_t)pcb->rcv_wnd + len > TCP_WND) {
  805877:	0f b7 50 28          	movzwl 0x28(%eax),%edx
  80587b:	0f b7 ca             	movzwl %dx,%ecx
  80587e:	0f b7 f3             	movzwl %bx,%esi
  805881:	01 f1                	add    %esi,%ecx
  805883:	81 f9 c0 5d 00 00    	cmp    $0x5dc0,%ecx
  805889:	76 27                	jbe    8058b2 <tcp_recved+0x4a>
    pcb->rcv_wnd = TCP_WND;
  80588b:	66 c7 40 28 c0 5d    	movw   $0x5dc0,0x28(%eax)
    pcb->rcv_ann_wnd = TCP_WND;
  805891:	66 c7 40 2a c0 5d    	movw   $0x5dc0,0x2a(%eax)
  if (!(pcb->flags & TF_ACK_DELAY) &&
  805897:	0f b6 50 20          	movzbl 0x20(%eax),%edx
  80589b:	f6 c2 03             	test   $0x3,%dl
  80589e:	75 3b                	jne    8058db <tcp_recved+0x73>
    tcp_ack(pcb);
  8058a0:	f6 c2 01             	test   $0x1,%dl
  8058a3:	75 1f                	jne    8058c4 <tcp_recved+0x5c>
  8058a5:	83 ca 01             	or     $0x1,%edx
  8058a8:	88 50 20             	mov    %dl,0x20(%eax)
}
  8058ab:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8058ae:	5b                   	pop    %ebx
  8058af:	5e                   	pop    %esi
  8058b0:	5d                   	pop    %ebp
  8058b1:	c3                   	ret    
    pcb->rcv_wnd += len;
  8058b2:	01 da                	add    %ebx,%edx
  8058b4:	66 89 50 28          	mov    %dx,0x28(%eax)
    if (pcb->rcv_wnd >= pcb->mss) {
  8058b8:	66 3b 50 34          	cmp    0x34(%eax),%dx
  8058bc:	72 d9                	jb     805897 <tcp_recved+0x2f>
      pcb->rcv_ann_wnd = pcb->rcv_wnd;
  8058be:	66 89 50 2a          	mov    %dx,0x2a(%eax)
  8058c2:	eb d3                	jmp    805897 <tcp_recved+0x2f>
    tcp_ack(pcb);
  8058c4:	83 e2 fe             	and    $0xfffffffe,%edx
  8058c7:	83 ca 02             	or     $0x2,%edx
  8058ca:	88 50 20             	mov    %dl,0x20(%eax)
  8058cd:	83 ec 0c             	sub    $0xc,%esp
  8058d0:	50                   	push   %eax
  8058d1:	e8 09 2a 00 00       	call   8082df <tcp_output>
  8058d6:	83 c4 10             	add    $0x10,%esp
  8058d9:	eb d0                	jmp    8058ab <tcp_recved+0x43>
  else if (pcb->flags & TF_ACK_DELAY && pcb->rcv_wnd >= TCP_WND/2) {
  8058db:	f6 c2 01             	test   $0x1,%dl
  8058de:	74 cb                	je     8058ab <tcp_recved+0x43>
  8058e0:	66 81 78 28 df 2e    	cmpw   $0x2edf,0x28(%eax)
  8058e6:	76 c3                	jbe    8058ab <tcp_recved+0x43>
    tcp_ack_now(pcb);
  8058e8:	83 ca 02             	or     $0x2,%edx
  8058eb:	88 50 20             	mov    %dl,0x20(%eax)
  8058ee:	83 ec 0c             	sub    $0xc,%esp
  8058f1:	50                   	push   %eax
  8058f2:	e8 e8 29 00 00       	call   8082df <tcp_output>
  8058f7:	83 c4 10             	add    $0x10,%esp
}
  8058fa:	eb af                	jmp    8058ab <tcp_recved+0x43>

008058fc <tcp_fasttmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_fasttmr(void)
{
  8058fc:	f3 0f 1e fb          	endbr32 
  805900:	55                   	push   %ebp
  805901:	89 e5                	mov    %esp,%ebp
  805903:	53                   	push   %ebx
  805904:	83 ec 04             	sub    $0x4,%esp
  struct tcp_pcb *pcb;

  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  805907:	8b 1d 3c b2 b3 00    	mov    0xb3b23c,%ebx
  80590d:	eb 21                	jmp    805930 <tcp_fasttmr+0x34>
    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
      /* Notify again application with data previously received. */
      err_t err;
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_fasttmr: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  80590f:	83 ec 0c             	sub    $0xc,%esp
  805912:	50                   	push   %eax
  805913:	e8 09 f1 ff ff       	call   804a21 <pbuf_free>
  805918:	83 c4 10             	add    $0x10,%esp
      if (err == ERR_OK) {
        pcb->refused_data = NULL;
  80591b:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  805922:	00 00 00 
      }
    }

    /* send delayed ACKs */  
    if (pcb->flags & TF_ACK_DELAY) {
  805925:	0f b6 43 20          	movzbl 0x20(%ebx),%eax
  805929:	a8 01                	test   $0x1,%al
  80592b:	75 2d                	jne    80595a <tcp_fasttmr+0x5e>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80592d:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  805930:	85 db                	test   %ebx,%ebx
  805932:	74 3e                	je     805972 <tcp_fasttmr+0x76>
    if (pcb->refused_data != NULL) {
  805934:	8b 83 80 00 00 00    	mov    0x80(%ebx),%eax
  80593a:	85 c0                	test   %eax,%eax
  80593c:	74 e7                	je     805925 <tcp_fasttmr+0x29>
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  80593e:	8b 93 88 00 00 00    	mov    0x88(%ebx),%edx
  805944:	85 d2                	test   %edx,%edx
  805946:	74 c7                	je     80590f <tcp_fasttmr+0x13>
  805948:	6a 00                	push   $0x0
  80594a:	50                   	push   %eax
  80594b:	53                   	push   %ebx
  80594c:	ff 73 18             	pushl  0x18(%ebx)
  80594f:	ff d2                	call   *%edx
      if (err == ERR_OK) {
  805951:	83 c4 10             	add    $0x10,%esp
  805954:	84 c0                	test   %al,%al
  805956:	74 c3                	je     80591b <tcp_fasttmr+0x1f>
  805958:	eb cb                	jmp    805925 <tcp_fasttmr+0x29>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
      tcp_ack_now(pcb);
  80595a:	83 c8 02             	or     $0x2,%eax
  80595d:	88 43 20             	mov    %al,0x20(%ebx)
  805960:	83 ec 0c             	sub    $0xc,%esp
  805963:	53                   	push   %ebx
  805964:	e8 76 29 00 00       	call   8082df <tcp_output>
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  805969:	80 63 20 fc          	andb   $0xfc,0x20(%ebx)
  80596d:	83 c4 10             	add    $0x10,%esp
  805970:	eb bb                	jmp    80592d <tcp_fasttmr+0x31>
    }
  }
}
  805972:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  805975:	c9                   	leave  
  805976:	c3                   	ret    

00805977 <tcp_seg_free>:
 * @param seg single tcp_seg to free
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_seg_free(struct tcp_seg *seg)
{
  805977:	f3 0f 1e fb          	endbr32 
  80597b:	55                   	push   %ebp
  80597c:	89 e5                	mov    %esp,%ebp
  80597e:	56                   	push   %esi
  80597f:	53                   	push   %ebx
  805980:	8b 75 08             	mov    0x8(%ebp),%esi
  u8_t count = 0;
  805983:	bb 00 00 00 00       	mov    $0x0,%ebx
  
  if (seg != NULL) {
  805988:	85 f6                	test   %esi,%esi
  80598a:	74 23                	je     8059af <tcp_seg_free+0x38>
    if (seg->p != NULL) {
  80598c:	8b 46 04             	mov    0x4(%esi),%eax
  80598f:	85 c0                	test   %eax,%eax
  805991:	74 0e                	je     8059a1 <tcp_seg_free+0x2a>
      count = pbuf_free(seg->p);
  805993:	83 ec 0c             	sub    $0xc,%esp
  805996:	50                   	push   %eax
  805997:	e8 85 f0 ff ff       	call   804a21 <pbuf_free>
  80599c:	89 c3                	mov    %eax,%ebx
  80599e:	83 c4 10             	add    $0x10,%esp
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
  8059a1:	83 ec 08             	sub    $0x8,%esp
  8059a4:	56                   	push   %esi
  8059a5:	6a 04                	push   $0x4
  8059a7:	e8 f2 ec ff ff       	call   80469e <memp_free>
  8059ac:	83 c4 10             	add    $0x10,%esp
  }
  return count;
}
  8059af:	89 d8                	mov    %ebx,%eax
  8059b1:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8059b4:	5b                   	pop    %ebx
  8059b5:	5e                   	pop    %esi
  8059b6:	5d                   	pop    %ebp
  8059b7:	c3                   	ret    

008059b8 <tcp_segs_free>:
{
  8059b8:	f3 0f 1e fb          	endbr32 
  8059bc:	55                   	push   %ebp
  8059bd:	89 e5                	mov    %esp,%ebp
  8059bf:	56                   	push   %esi
  8059c0:	53                   	push   %ebx
  8059c1:	8b 45 08             	mov    0x8(%ebp),%eax
  u8_t count = 0;
  8059c4:	bb 00 00 00 00       	mov    $0x0,%ebx
  while (seg != NULL) {
  8059c9:	85 c0                	test   %eax,%eax
  8059cb:	74 14                	je     8059e1 <tcp_segs_free+0x29>
    next = seg->next;
  8059cd:	8b 30                	mov    (%eax),%esi
    count += tcp_seg_free(seg);
  8059cf:	83 ec 0c             	sub    $0xc,%esp
  8059d2:	50                   	push   %eax
  8059d3:	e8 9f ff ff ff       	call   805977 <tcp_seg_free>
  8059d8:	01 c3                	add    %eax,%ebx
  8059da:	83 c4 10             	add    $0x10,%esp
    seg = next;
  8059dd:	89 f0                	mov    %esi,%eax
  8059df:	eb e8                	jmp    8059c9 <tcp_segs_free+0x11>
}
  8059e1:	89 d8                	mov    %ebx,%eax
  8059e3:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8059e6:	5b                   	pop    %ebx
  8059e7:	5e                   	pop    %esi
  8059e8:	5d                   	pop    %ebp
  8059e9:	c3                   	ret    

008059ea <tcp_setprio>:
 * @param pcb the tcp_pcb to manipulate
 * @param prio new priority
 */
void
tcp_setprio(struct tcp_pcb *pcb, u8_t prio)
{
  8059ea:	f3 0f 1e fb          	endbr32 
  8059ee:	55                   	push   %ebp
  8059ef:	89 e5                	mov    %esp,%ebp
  pcb->prio = prio;
  8059f1:	8b 45 08             	mov    0x8(%ebp),%eax
  8059f4:	8b 55 0c             	mov    0xc(%ebp),%edx
  8059f7:	88 50 14             	mov    %dl,0x14(%eax)
}
  8059fa:	5d                   	pop    %ebp
  8059fb:	c3                   	ret    

008059fc <tcp_seg_copy>:
 * @param seg the old tcp_seg
 * @return a copy of seg
 */ 
struct tcp_seg *
tcp_seg_copy(struct tcp_seg *seg)
{
  8059fc:	f3 0f 1e fb          	endbr32 
  805a00:	55                   	push   %ebp
  805a01:	89 e5                	mov    %esp,%ebp
  805a03:	53                   	push   %ebx
  805a04:	83 ec 10             	sub    $0x10,%esp
  struct tcp_seg *cseg;

  cseg = memp_malloc(MEMP_TCP_SEG);
  805a07:	6a 04                	push   $0x4
  805a09:	e8 36 ec ff ff       	call   804644 <memp_malloc>
  805a0e:	89 c3                	mov    %eax,%ebx
  if (cseg == NULL) {
  805a10:	83 c4 10             	add    $0x10,%esp
  805a13:	85 c0                	test   %eax,%eax
  805a15:	74 1c                	je     805a33 <tcp_seg_copy+0x37>
    return NULL;
  }
  SMEMCPY((u8_t *)cseg, (const u8_t *)seg, sizeof(struct tcp_seg)); 
  805a17:	83 ec 04             	sub    $0x4,%esp
  805a1a:	6a 14                	push   $0x14
  805a1c:	ff 75 08             	pushl  0x8(%ebp)
  805a1f:	50                   	push   %eax
  805a20:	e8 2f 98 00 00       	call   80f254 <memcpy>
  pbuf_ref(cseg->p);
  805a25:	83 c4 04             	add    $0x4,%esp
  805a28:	ff 73 04             	pushl  0x4(%ebx)
  805a2b:	e8 4e f4 ff ff       	call   804e7e <pbuf_ref>
  return cseg;
  805a30:	83 c4 10             	add    $0x10,%esp
}
  805a33:	89 d8                	mov    %ebx,%eax
  805a35:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  805a38:	c9                   	leave  
  805a39:	c3                   	ret    

00805a3a <tcp_arg>:
 * @param pcb tcp_pcb to set the callback argument
 * @param arg void pointer argument to pass to callback functions
 */ 
void
tcp_arg(struct tcp_pcb *pcb, void *arg)
{  
  805a3a:	f3 0f 1e fb          	endbr32 
  805a3e:	55                   	push   %ebp
  805a3f:	89 e5                	mov    %esp,%ebp
  pcb->callback_arg = arg;
  805a41:	8b 45 08             	mov    0x8(%ebp),%eax
  805a44:	8b 55 0c             	mov    0xc(%ebp),%edx
  805a47:	89 50 18             	mov    %edx,0x18(%eax)
}
  805a4a:	5d                   	pop    %ebp
  805a4b:	c3                   	ret    

00805a4c <tcp_recv>:
 * @param recv callback function to call for this pcb when data is received
 */ 
void
tcp_recv(struct tcp_pcb *pcb,
   err_t (* recv)(void *arg, struct tcp_pcb *tpcb, struct pbuf *p, err_t err))
{
  805a4c:	f3 0f 1e fb          	endbr32 
  805a50:	55                   	push   %ebp
  805a51:	89 e5                	mov    %esp,%ebp
  pcb->recv = recv;
  805a53:	8b 45 08             	mov    0x8(%ebp),%eax
  805a56:	8b 55 0c             	mov    0xc(%ebp),%edx
  805a59:	89 90 88 00 00 00    	mov    %edx,0x88(%eax)
}
  805a5f:	5d                   	pop    %ebp
  805a60:	c3                   	ret    

00805a61 <tcp_sent>:
 * @param sent callback function to call for this pcb when data is successfully sent
 */ 
void
tcp_sent(struct tcp_pcb *pcb,
   err_t (* sent)(void *arg, struct tcp_pcb *tpcb, u16_t len))
{
  805a61:	f3 0f 1e fb          	endbr32 
  805a65:	55                   	push   %ebp
  805a66:	89 e5                	mov    %esp,%ebp
  pcb->sent = sent;
  805a68:	8b 45 08             	mov    0x8(%ebp),%eax
  805a6b:	8b 55 0c             	mov    0xc(%ebp),%edx
  805a6e:	89 90 84 00 00 00    	mov    %edx,0x84(%eax)
}
  805a74:	5d                   	pop    %ebp
  805a75:	c3                   	ret    

00805a76 <tcp_err>:
 *        has occured on the connection
 */ 
void
tcp_err(struct tcp_pcb *pcb,
   void (* errf)(void *arg, err_t err))
{
  805a76:	f3 0f 1e fb          	endbr32 
  805a7a:	55                   	push   %ebp
  805a7b:	89 e5                	mov    %esp,%ebp
  pcb->errf = errf;
  805a7d:	8b 45 08             	mov    0x8(%ebp),%eax
  805a80:	8b 55 0c             	mov    0xc(%ebp),%edx
  805a83:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
}
  805a89:	5d                   	pop    %ebp
  805a8a:	c3                   	ret    

00805a8b <tcp_accept>:
 *        connection has been connected to another host
 */ 
void
tcp_accept(struct tcp_pcb *pcb,
     err_t (* accept)(void *arg, struct tcp_pcb *newpcb, err_t err))
{
  805a8b:	f3 0f 1e fb          	endbr32 
  805a8f:	55                   	push   %ebp
  805a90:	89 e5                	mov    %esp,%ebp
  ((struct tcp_pcb_listen *)pcb)->accept = accept;
  805a92:	8b 45 08             	mov    0x8(%ebp),%eax
  805a95:	8b 55 0c             	mov    0xc(%ebp),%edx
  805a98:	89 50 20             	mov    %edx,0x20(%eax)
}
  805a9b:	5d                   	pop    %ebp
  805a9c:	c3                   	ret    

00805a9d <tcp_poll>:
 *
 */ 
void
tcp_poll(struct tcp_pcb *pcb,
   err_t (* poll)(void *arg, struct tcp_pcb *tpcb), u8_t interval)
{
  805a9d:	f3 0f 1e fb          	endbr32 
  805aa1:	55                   	push   %ebp
  805aa2:	89 e5                	mov    %esp,%ebp
  805aa4:	8b 45 08             	mov    0x8(%ebp),%eax
#if LWIP_CALLBACK_API
  pcb->poll = poll;
  805aa7:	8b 55 0c             	mov    0xc(%ebp),%edx
  805aaa:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
#endif /* LWIP_CALLBACK_API */  
  pcb->pollinterval = interval;
  805ab0:	8b 55 10             	mov    0x10(%ebp),%edx
  805ab3:	88 50 31             	mov    %dl,0x31(%eax)
}
  805ab6:	5d                   	pop    %ebp
  805ab7:	c3                   	ret    

00805ab8 <tcp_pcb_purge>:
 *
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  805ab8:	f3 0f 1e fb          	endbr32 
  805abc:	55                   	push   %ebp
  805abd:	89 e5                	mov    %esp,%ebp
  805abf:	53                   	push   %ebx
  805ac0:	83 ec 04             	sub    $0x4,%esp
  805ac3:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (pcb->state != CLOSED &&
  805ac6:	8b 43 10             	mov    0x10(%ebx),%eax
     pcb->state != TIME_WAIT &&
  805ac9:	83 f8 0a             	cmp    $0xa,%eax
  805acc:	74 05                	je     805ad3 <tcp_pcb_purge+0x1b>
  805ace:	83 f8 01             	cmp    $0x1,%eax
  805ad1:	77 05                	ja     805ad8 <tcp_pcb_purge+0x20>
#endif /* TCP_QUEUE_OOSEQ */
    tcp_segs_free(pcb->unsent);
    tcp_segs_free(pcb->unacked);
    pcb->unacked = pcb->unsent = NULL;
  }
}
  805ad3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  805ad6:	c9                   	leave  
  805ad7:	c3                   	ret    
    if (pcb->refused_data != NULL) {
  805ad8:	8b 83 80 00 00 00    	mov    0x80(%ebx),%eax
  805ade:	85 c0                	test   %eax,%eax
  805ae0:	74 16                	je     805af8 <tcp_pcb_purge+0x40>
      pbuf_free(pcb->refused_data);
  805ae2:	83 ec 0c             	sub    $0xc,%esp
  805ae5:	50                   	push   %eax
  805ae6:	e8 36 ef ff ff       	call   804a21 <pbuf_free>
      pcb->refused_data = NULL;
  805aeb:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  805af2:	00 00 00 
  805af5:	83 c4 10             	add    $0x10,%esp
    pcb->rtime = -1;
  805af8:	66 c7 43 32 ff ff    	movw   $0xffff,0x32(%ebx)
    tcp_segs_free(pcb->ooseq);
  805afe:	83 ec 0c             	sub    $0xc,%esp
  805b01:	ff 73 7c             	pushl  0x7c(%ebx)
  805b04:	e8 af fe ff ff       	call   8059b8 <tcp_segs_free>
    pcb->ooseq = NULL;
  805b09:	c7 43 7c 00 00 00 00 	movl   $0x0,0x7c(%ebx)
    tcp_segs_free(pcb->unsent);
  805b10:	83 c4 04             	add    $0x4,%esp
  805b13:	ff 73 74             	pushl  0x74(%ebx)
  805b16:	e8 9d fe ff ff       	call   8059b8 <tcp_segs_free>
    tcp_segs_free(pcb->unacked);
  805b1b:	83 c4 04             	add    $0x4,%esp
  805b1e:	ff 73 78             	pushl  0x78(%ebx)
  805b21:	e8 92 fe ff ff       	call   8059b8 <tcp_segs_free>
    pcb->unacked = pcb->unsent = NULL;
  805b26:	c7 43 74 00 00 00 00 	movl   $0x0,0x74(%ebx)
  805b2d:	c7 43 78 00 00 00 00 	movl   $0x0,0x78(%ebx)
  805b34:	83 c4 10             	add    $0x10,%esp
}
  805b37:	eb 9a                	jmp    805ad3 <tcp_pcb_purge+0x1b>

00805b39 <tcp_pcb_remove>:
 * @param pcblist PCB list to purge.
 * @param pcb tcp_pcb to purge. The pcb itself is also deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
  805b39:	f3 0f 1e fb          	endbr32 
  805b3d:	55                   	push   %ebp
  805b3e:	89 e5                	mov    %esp,%ebp
  805b40:	56                   	push   %esi
  805b41:	53                   	push   %ebx
  805b42:	8b 45 08             	mov    0x8(%ebp),%eax
  805b45:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  TCP_RMV(pcblist, pcb);
  805b48:	8b 10                	mov    (%eax),%edx
  805b4a:	39 da                	cmp    %ebx,%edx
  805b4c:	74 12                	je     805b60 <tcp_pcb_remove+0x27>
  805b4e:	89 15 48 b2 b3 00    	mov    %edx,0xb3b248
  805b54:	b9 00 00 00 00       	mov    $0x0,%ecx
  805b59:	be 01 00 00 00       	mov    $0x1,%esi
  805b5e:	eb 59                	jmp    805bb9 <tcp_pcb_remove+0x80>
  805b60:	8b 53 0c             	mov    0xc(%ebx),%edx
  805b63:	89 10                	mov    %edx,(%eax)
  805b65:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)

  tcp_pcb_purge(pcb);
  805b6c:	83 ec 0c             	sub    $0xc,%esp
  805b6f:	53                   	push   %ebx
  805b70:	e8 43 ff ff ff       	call   805ab8 <tcp_pcb_purge>
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
  805b75:	8b 43 10             	mov    0x10(%ebx),%eax
  805b78:	83 c4 10             	add    $0x10,%esp
  805b7b:	83 f8 0a             	cmp    $0xa,%eax
  805b7e:	74 7f                	je     805bff <tcp_pcb_remove+0xc6>
  805b80:	83 f8 01             	cmp    $0x1,%eax
  805b83:	74 7a                	je     805bff <tcp_pcb_remove+0xc6>
     pcb->state != LISTEN &&
     pcb->flags & TF_ACK_DELAY) {
  805b85:	0f b6 43 20          	movzbl 0x20(%ebx),%eax
     pcb->state != LISTEN &&
  805b89:	a8 01                	test   $0x1,%al
  805b8b:	75 60                	jne    805bed <tcp_pcb_remove+0xb4>
    pcb->flags |= TF_ACK_NOW;
    tcp_output(pcb);
  }

  if (pcb->state != LISTEN) {
    LWIP_ASSERT("unsent segments leaking", pcb->unsent == NULL);
  805b8d:	83 7b 74 00          	cmpl   $0x0,0x74(%ebx)
  805b91:	75 74                	jne    805c07 <tcp_pcb_remove+0xce>
    LWIP_ASSERT("unacked segments leaking", pcb->unacked == NULL);
  805b93:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  805b97:	0f 85 81 00 00 00    	jne    805c1e <tcp_pcb_remove+0xe5>
#if TCP_QUEUE_OOSEQ
    LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
  805b9d:	83 7b 7c 00          	cmpl   $0x0,0x7c(%ebx)
  805ba1:	0f 85 8e 00 00 00    	jne    805c35 <tcp_pcb_remove+0xfc>
#endif /* TCP_QUEUE_OOSEQ */
  }

  pcb->state = CLOSED;
  805ba7:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)

  LWIP_ASSERT("tcp_pcb_remove: tcp_pcbs_sane()", tcp_pcbs_sane());
}
  805bae:	8d 65 f8             	lea    -0x8(%ebp),%esp
  805bb1:	5b                   	pop    %ebx
  805bb2:	5e                   	pop    %esi
  805bb3:	5d                   	pop    %ebp
  805bb4:	c3                   	ret    
  805bb5:	89 f1                	mov    %esi,%ecx
  TCP_RMV(pcblist, pcb);
  805bb7:	89 c2                	mov    %eax,%edx
  805bb9:	85 d2                	test   %edx,%edx
  805bbb:	74 1d                	je     805bda <tcp_pcb_remove+0xa1>
  805bbd:	8b 42 0c             	mov    0xc(%edx),%eax
  805bc0:	39 d8                	cmp    %ebx,%eax
  805bc2:	75 f1                	jne    805bb5 <tcp_pcb_remove+0x7c>
  805bc4:	85 c0                	test   %eax,%eax
  805bc6:	74 ed                	je     805bb5 <tcp_pcb_remove+0x7c>
  805bc8:	84 c9                	test   %cl,%cl
  805bca:	74 06                	je     805bd2 <tcp_pcb_remove+0x99>
  805bcc:	89 15 48 b2 b3 00    	mov    %edx,0xb3b248
  805bd2:	8b 43 0c             	mov    0xc(%ebx),%eax
  805bd5:	89 42 0c             	mov    %eax,0xc(%edx)
  805bd8:	eb 8b                	jmp    805b65 <tcp_pcb_remove+0x2c>
  805bda:	84 c9                	test   %cl,%cl
  805bdc:	74 87                	je     805b65 <tcp_pcb_remove+0x2c>
  805bde:	c7 05 48 b2 b3 00 00 	movl   $0x0,0xb3b248
  805be5:	00 00 00 
  805be8:	e9 78 ff ff ff       	jmp    805b65 <tcp_pcb_remove+0x2c>
    pcb->flags |= TF_ACK_NOW;
  805bed:	83 c8 02             	or     $0x2,%eax
  805bf0:	88 43 20             	mov    %al,0x20(%ebx)
    tcp_output(pcb);
  805bf3:	83 ec 0c             	sub    $0xc,%esp
  805bf6:	53                   	push   %ebx
  805bf7:	e8 e3 26 00 00       	call   8082df <tcp_output>
  805bfc:	83 c4 10             	add    $0x10,%esp
  if (pcb->state != LISTEN) {
  805bff:	83 7b 10 01          	cmpl   $0x1,0x10(%ebx)
  805c03:	74 a2                	je     805ba7 <tcp_pcb_remove+0x6e>
  805c05:	eb 86                	jmp    805b8d <tcp_pcb_remove+0x54>
    LWIP_ASSERT("unsent segments leaking", pcb->unsent == NULL);
  805c07:	83 ec 04             	sub    $0x4,%esp
  805c0a:	68 82 23 81 00       	push   $0x812382
  805c0f:	68 b4 04 00 00       	push   $0x4b4
  805c14:	68 6e 23 81 00       	push   $0x81236e
  805c19:	e8 29 8d 00 00       	call   80e947 <_panic>
    LWIP_ASSERT("unacked segments leaking", pcb->unacked == NULL);
  805c1e:	83 ec 04             	sub    $0x4,%esp
  805c21:	68 9a 23 81 00       	push   $0x81239a
  805c26:	68 b5 04 00 00       	push   $0x4b5
  805c2b:	68 6e 23 81 00       	push   $0x81236e
  805c30:	e8 12 8d 00 00       	call   80e947 <_panic>
    LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
  805c35:	83 ec 04             	sub    $0x4,%esp
  805c38:	68 b3 23 81 00       	push   $0x8123b3
  805c3d:	68 b7 04 00 00       	push   $0x4b7
  805c42:	68 6e 23 81 00       	push   $0x81236e
  805c47:	e8 fb 8c 00 00       	call   80e947 <_panic>

00805c4c <tcp_close>:
{
  805c4c:	f3 0f 1e fb          	endbr32 
  805c50:	55                   	push   %ebp
  805c51:	89 e5                	mov    %esp,%ebp
  805c53:	56                   	push   %esi
  805c54:	53                   	push   %ebx
  805c55:	8b 5d 08             	mov    0x8(%ebp),%ebx
  805c58:	83 7b 10 07          	cmpl   $0x7,0x10(%ebx)
  805c5c:	0f 87 30 01 00 00    	ja     805d92 <tcp_close+0x146>
  805c62:	8b 43 10             	mov    0x10(%ebx),%eax
  805c65:	3e ff 24 85 cc 23 81 	notrack jmp *0x8123cc(,%eax,4)
  805c6c:	00 
    TCP_RMV(&tcp_bound_pcbs, pcb);
  805c6d:	8b 15 4c b2 b3 00    	mov    0xb3b24c,%edx
  805c73:	39 da                	cmp    %ebx,%edx
  805c75:	74 12                	je     805c89 <tcp_close+0x3d>
  805c77:	89 15 48 b2 b3 00    	mov    %edx,0xb3b248
  805c7d:	b9 00 00 00 00       	mov    $0x0,%ecx
  805c82:	be 01 00 00 00       	mov    $0x1,%esi
  805c87:	eb 2b                	jmp    805cb4 <tcp_close+0x68>
  805c89:	8b 43 0c             	mov    0xc(%ebx),%eax
  805c8c:	a3 4c b2 b3 00       	mov    %eax,0xb3b24c
  805c91:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
    memp_free(MEMP_TCP_PCB, pcb);
  805c98:	83 ec 08             	sub    $0x8,%esp
  805c9b:	53                   	push   %ebx
  805c9c:	6a 02                	push   $0x2
  805c9e:	e8 fb e9 ff ff       	call   80469e <memp_free>
    break;
  805ca3:	83 c4 10             	add    $0x10,%esp
    err = ERR_OK;
  805ca6:	b8 00 00 00 00       	mov    $0x0,%eax
    break;
  805cab:	e9 a5 00 00 00       	jmp    805d55 <tcp_close+0x109>
  805cb0:	89 f1                	mov    %esi,%ecx
    TCP_RMV(&tcp_bound_pcbs, pcb);
  805cb2:	89 c2                	mov    %eax,%edx
  805cb4:	85 d2                	test   %edx,%edx
  805cb6:	74 1d                	je     805cd5 <tcp_close+0x89>
  805cb8:	8b 42 0c             	mov    0xc(%edx),%eax
  805cbb:	39 d8                	cmp    %ebx,%eax
  805cbd:	75 f1                	jne    805cb0 <tcp_close+0x64>
  805cbf:	85 c0                	test   %eax,%eax
  805cc1:	74 ed                	je     805cb0 <tcp_close+0x64>
  805cc3:	84 c9                	test   %cl,%cl
  805cc5:	74 06                	je     805ccd <tcp_close+0x81>
  805cc7:	89 15 48 b2 b3 00    	mov    %edx,0xb3b248
  805ccd:	8b 43 0c             	mov    0xc(%ebx),%eax
  805cd0:	89 42 0c             	mov    %eax,0xc(%edx)
  805cd3:	eb bc                	jmp    805c91 <tcp_close+0x45>
  805cd5:	84 c9                	test   %cl,%cl
  805cd7:	74 b8                	je     805c91 <tcp_close+0x45>
  805cd9:	c7 05 48 b2 b3 00 00 	movl   $0x0,0xb3b248
  805ce0:	00 00 00 
  805ce3:	eb ac                	jmp    805c91 <tcp_close+0x45>
    tcp_pcb_remove((struct tcp_pcb **)&tcp_listen_pcbs.pcbs, pcb);
  805ce5:	83 ec 08             	sub    $0x8,%esp
  805ce8:	53                   	push   %ebx
  805ce9:	68 44 b2 b3 00       	push   $0xb3b244
  805cee:	e8 46 fe ff ff       	call   805b39 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
  805cf3:	83 c4 08             	add    $0x8,%esp
  805cf6:	53                   	push   %ebx
  805cf7:	6a 03                	push   $0x3
  805cf9:	e8 a0 e9 ff ff       	call   80469e <memp_free>
    break;
  805cfe:	83 c4 10             	add    $0x10,%esp
    err = ERR_OK;
  805d01:	b8 00 00 00 00       	mov    $0x0,%eax
    break;
  805d06:	eb 4d                	jmp    805d55 <tcp_close+0x109>
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
  805d08:	83 ec 08             	sub    $0x8,%esp
  805d0b:	53                   	push   %ebx
  805d0c:	68 3c b2 b3 00       	push   $0xb3b23c
  805d11:	e8 23 fe ff ff       	call   805b39 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
  805d16:	83 c4 08             	add    $0x8,%esp
  805d19:	53                   	push   %ebx
  805d1a:	6a 02                	push   $0x2
  805d1c:	e8 7d e9 ff ff       	call   80469e <memp_free>
    break;
  805d21:	83 c4 10             	add    $0x10,%esp
    err = ERR_OK;
  805d24:	b8 00 00 00 00       	mov    $0x0,%eax
    break;
  805d29:	eb 2a                	jmp    805d55 <tcp_close+0x109>
    err = tcp_send_ctrl(pcb, TCP_FIN);
  805d2b:	83 ec 08             	sub    $0x8,%esp
  805d2e:	6a 01                	push   $0x1
  805d30:	53                   	push   %ebx
  805d31:	e8 2b 25 00 00       	call   808261 <tcp_send_ctrl>
    if (err == ERR_OK) {
  805d36:	83 c4 10             	add    $0x10,%esp
  805d39:	84 c0                	test   %al,%al
  805d3b:	75 18                	jne    805d55 <tcp_close+0x109>
      pcb->state = FIN_WAIT_1;
  805d3d:	c7 43 10 05 00 00 00 	movl   $0x5,0x10(%ebx)
    tcp_output(pcb);
  805d44:	83 ec 0c             	sub    $0xc,%esp
  805d47:	53                   	push   %ebx
  805d48:	e8 92 25 00 00       	call   8082df <tcp_output>
  805d4d:	83 c4 10             	add    $0x10,%esp
  805d50:	b8 00 00 00 00       	mov    $0x0,%eax
}
  805d55:	8d 65 f8             	lea    -0x8(%ebp),%esp
  805d58:	5b                   	pop    %ebx
  805d59:	5e                   	pop    %esi
  805d5a:	5d                   	pop    %ebp
  805d5b:	c3                   	ret    
    err = tcp_send_ctrl(pcb, TCP_FIN);
  805d5c:	83 ec 08             	sub    $0x8,%esp
  805d5f:	6a 01                	push   $0x1
  805d61:	53                   	push   %ebx
  805d62:	e8 fa 24 00 00       	call   808261 <tcp_send_ctrl>
    if (err == ERR_OK) {
  805d67:	83 c4 10             	add    $0x10,%esp
  805d6a:	84 c0                	test   %al,%al
  805d6c:	75 e7                	jne    805d55 <tcp_close+0x109>
      pcb->state = FIN_WAIT_1;
  805d6e:	c7 43 10 05 00 00 00 	movl   $0x5,0x10(%ebx)
  805d75:	eb cd                	jmp    805d44 <tcp_close+0xf8>
    err = tcp_send_ctrl(pcb, TCP_FIN);
  805d77:	83 ec 08             	sub    $0x8,%esp
  805d7a:	6a 01                	push   $0x1
  805d7c:	53                   	push   %ebx
  805d7d:	e8 df 24 00 00       	call   808261 <tcp_send_ctrl>
    if (err == ERR_OK) {
  805d82:	83 c4 10             	add    $0x10,%esp
  805d85:	84 c0                	test   %al,%al
  805d87:	75 cc                	jne    805d55 <tcp_close+0x109>
      pcb->state = LAST_ACK;
  805d89:	c7 43 10 09 00 00 00 	movl   $0x9,0x10(%ebx)
  805d90:	eb b2                	jmp    805d44 <tcp_close+0xf8>
  switch (pcb->state) {
  805d92:	b8 00 00 00 00       	mov    $0x0,%eax
  return err;
  805d97:	eb bc                	jmp    805d55 <tcp_close+0x109>

00805d99 <tcp_recv_null>:
{
  805d99:	f3 0f 1e fb          	endbr32 
  805d9d:	55                   	push   %ebp
  805d9e:	89 e5                	mov    %esp,%ebp
  805da0:	83 ec 08             	sub    $0x8,%esp
  805da3:	8b 45 10             	mov    0x10(%ebp),%eax
  805da6:	8b 55 14             	mov    0x14(%ebp),%edx
  if (p != NULL) {
  805da9:	85 c0                	test   %eax,%eax
  805dab:	74 13                	je     805dc0 <tcp_recv_null+0x27>
    pbuf_free(p);
  805dad:	83 ec 0c             	sub    $0xc,%esp
  805db0:	50                   	push   %eax
  805db1:	e8 6b ec ff ff       	call   804a21 <pbuf_free>
  805db6:	83 c4 10             	add    $0x10,%esp
  return ERR_OK;
  805db9:	b8 00 00 00 00       	mov    $0x0,%eax
}
  805dbe:	c9                   	leave  
  805dbf:	c3                   	ret    
  return ERR_OK;
  805dc0:	b8 00 00 00 00       	mov    $0x0,%eax
  } else if (err == ERR_OK) {
  805dc5:	84 d2                	test   %dl,%dl
  805dc7:	75 f5                	jne    805dbe <tcp_recv_null+0x25>
    return tcp_close(pcb);
  805dc9:	83 ec 0c             	sub    $0xc,%esp
  805dcc:	ff 75 0c             	pushl  0xc(%ebp)
  805dcf:	e8 78 fe ff ff       	call   805c4c <tcp_close>
  805dd4:	83 c4 10             	add    $0x10,%esp
  805dd7:	eb e5                	jmp    805dbe <tcp_recv_null+0x25>

00805dd9 <tcp_abort>:
{
  805dd9:	f3 0f 1e fb          	endbr32 
  805ddd:	55                   	push   %ebp
  805dde:	89 e5                	mov    %esp,%ebp
  805de0:	57                   	push   %edi
  805de1:	56                   	push   %esi
  805de2:	53                   	push   %ebx
  805de3:	83 ec 2c             	sub    $0x2c,%esp
  805de6:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (pcb->state == TIME_WAIT) {
  805de9:	83 7b 10 0a          	cmpl   $0xa,0x10(%ebx)
  805ded:	0f 84 c2 00 00 00    	je     805eb5 <tcp_abort+0xdc>
    seqno = pcb->snd_nxt;
  805df3:	8b 43 54             	mov    0x54(%ebx),%eax
  805df6:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    ackno = pcb->rcv_nxt;
  805df9:	8b 7b 24             	mov    0x24(%ebx),%edi
    ip_addr_set(&local_ip, &(pcb->local_ip));
  805dfc:	8b 03                	mov    (%ebx),%eax
  805dfe:	89 45 e0             	mov    %eax,-0x20(%ebp)
    ip_addr_set(&remote_ip, &(pcb->remote_ip));
  805e01:	8b 43 04             	mov    0x4(%ebx),%eax
  805e04:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    local_port = pcb->local_port;
  805e07:	0f b7 43 1c          	movzwl 0x1c(%ebx),%eax
  805e0b:	66 89 45 d2          	mov    %ax,-0x2e(%ebp)
    remote_port = pcb->remote_port;
  805e0f:	0f b7 43 1e          	movzwl 0x1e(%ebx),%eax
  805e13:	66 89 45 d0          	mov    %ax,-0x30(%ebp)
    errf = pcb->errf;
  805e17:	8b b3 98 00 00 00    	mov    0x98(%ebx),%esi
    errf_arg = pcb->callback_arg;
  805e1d:	8b 43 18             	mov    0x18(%ebx),%eax
  805e20:	89 45 cc             	mov    %eax,-0x34(%ebp)
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
  805e23:	83 ec 08             	sub    $0x8,%esp
  805e26:	53                   	push   %ebx
  805e27:	68 3c b2 b3 00       	push   $0xb3b23c
  805e2c:	e8 08 fd ff ff       	call   805b39 <tcp_pcb_remove>
    if (pcb->unacked != NULL) {
  805e31:	8b 43 78             	mov    0x78(%ebx),%eax
  805e34:	83 c4 10             	add    $0x10,%esp
  805e37:	85 c0                	test   %eax,%eax
  805e39:	74 0c                	je     805e47 <tcp_abort+0x6e>
      tcp_segs_free(pcb->unacked);
  805e3b:	83 ec 0c             	sub    $0xc,%esp
  805e3e:	50                   	push   %eax
  805e3f:	e8 74 fb ff ff       	call   8059b8 <tcp_segs_free>
  805e44:	83 c4 10             	add    $0x10,%esp
    if (pcb->unsent != NULL) {
  805e47:	8b 43 74             	mov    0x74(%ebx),%eax
  805e4a:	85 c0                	test   %eax,%eax
  805e4c:	74 0c                	je     805e5a <tcp_abort+0x81>
      tcp_segs_free(pcb->unsent);
  805e4e:	83 ec 0c             	sub    $0xc,%esp
  805e51:	50                   	push   %eax
  805e52:	e8 61 fb ff ff       	call   8059b8 <tcp_segs_free>
  805e57:	83 c4 10             	add    $0x10,%esp
    if (pcb->ooseq != NULL) {
  805e5a:	8b 43 7c             	mov    0x7c(%ebx),%eax
  805e5d:	85 c0                	test   %eax,%eax
  805e5f:	74 0c                	je     805e6d <tcp_abort+0x94>
      tcp_segs_free(pcb->ooseq);
  805e61:	83 ec 0c             	sub    $0xc,%esp
  805e64:	50                   	push   %eax
  805e65:	e8 4e fb ff ff       	call   8059b8 <tcp_segs_free>
  805e6a:	83 c4 10             	add    $0x10,%esp
    memp_free(MEMP_TCP_PCB, pcb);
  805e6d:	83 ec 08             	sub    $0x8,%esp
  805e70:	53                   	push   %ebx
  805e71:	6a 02                	push   $0x2
  805e73:	e8 26 e8 ff ff       	call   80469e <memp_free>
    TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
  805e78:	83 c4 10             	add    $0x10,%esp
  805e7b:	85 f6                	test   %esi,%esi
  805e7d:	74 0d                	je     805e8c <tcp_abort+0xb3>
  805e7f:	83 ec 08             	sub    $0x8,%esp
  805e82:	6a fb                	push   $0xfffffffb
  805e84:	ff 75 cc             	pushl  -0x34(%ebp)
  805e87:	ff d6                	call   *%esi
  805e89:	83 c4 10             	add    $0x10,%esp
    tcp_rst(seqno, ackno, &local_ip, &remote_ip, local_port, remote_port);
  805e8c:	83 ec 08             	sub    $0x8,%esp
  805e8f:	0f b7 45 d0          	movzwl -0x30(%ebp),%eax
  805e93:	50                   	push   %eax
  805e94:	0f b7 45 d2          	movzwl -0x2e(%ebp),%eax
  805e98:	50                   	push   %eax
  805e99:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  805e9c:	50                   	push   %eax
  805e9d:	8d 45 e0             	lea    -0x20(%ebp),%eax
  805ea0:	50                   	push   %eax
  805ea1:	57                   	push   %edi
  805ea2:	ff 75 d4             	pushl  -0x2c(%ebp)
  805ea5:	e8 db 28 00 00       	call   808785 <tcp_rst>
  805eaa:	83 c4 20             	add    $0x20,%esp
}
  805ead:	8d 65 f4             	lea    -0xc(%ebp),%esp
  805eb0:	5b                   	pop    %ebx
  805eb1:	5e                   	pop    %esi
  805eb2:	5f                   	pop    %edi
  805eb3:	5d                   	pop    %ebp
  805eb4:	c3                   	ret    
    tcp_pcb_remove(&tcp_tw_pcbs, pcb);
  805eb5:	83 ec 08             	sub    $0x8,%esp
  805eb8:	53                   	push   %ebx
  805eb9:	68 50 b2 b3 00       	push   $0xb3b250
  805ebe:	e8 76 fc ff ff       	call   805b39 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
  805ec3:	83 c4 08             	add    $0x8,%esp
  805ec6:	53                   	push   %ebx
  805ec7:	6a 02                	push   $0x2
  805ec9:	e8 d0 e7 ff ff       	call   80469e <memp_free>
  805ece:	83 c4 10             	add    $0x10,%esp
  805ed1:	eb da                	jmp    805ead <tcp_abort+0xd4>

00805ed3 <tcp_slowtmr>:
{
  805ed3:	f3 0f 1e fb          	endbr32 
  805ed7:	55                   	push   %ebp
  805ed8:	89 e5                	mov    %esp,%ebp
  805eda:	57                   	push   %edi
  805edb:	56                   	push   %esi
  805edc:	53                   	push   %ebx
  805edd:	83 ec 1c             	sub    $0x1c,%esp
  ++tcp_ticks;
  805ee0:	83 05 40 b2 b3 00 01 	addl   $0x1,0xb3b240
  pcb = tcp_active_pcbs;
  805ee7:	8b 1d 3c b2 b3 00    	mov    0xb3b23c,%ebx
  err = ERR_OK;
  805eed:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
  prev = NULL;
  805ef1:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  805ef8:	e9 8f 02 00 00       	jmp    80618c <tcp_slowtmr+0x2b9>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
  805efd:	83 ec 04             	sub    $0x4,%esp
  805f00:	68 dc 21 81 00       	push   $0x8121dc
  805f05:	68 36 02 00 00       	push   $0x236
  805f0a:	68 6e 23 81 00       	push   $0x81236e
  805f0f:	e8 33 8a 00 00       	call   80e947 <_panic>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
  805f14:	83 ec 04             	sub    $0x4,%esp
  805f17:	68 08 22 81 00       	push   $0x812208
  805f1c:	68 37 02 00 00       	push   $0x237
  805f21:	68 6e 23 81 00       	push   $0x81236e
  805f26:	e8 1c 8a 00 00       	call   80e947 <_panic>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
  805f2b:	83 ec 04             	sub    $0x4,%esp
  805f2e:	68 34 22 81 00       	push   $0x812234
  805f33:	68 38 02 00 00       	push   $0x238
  805f38:	68 6e 23 81 00       	push   $0x81236e
  805f3d:	e8 05 8a 00 00       	call   80e947 <_panic>
    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
  805f42:	0f b6 53 46          	movzbl 0x46(%ebx),%edx
  805f46:	80 fa 06             	cmp    $0x6,%dl
  805f49:	0f 84 35 01 00 00    	je     806084 <tcp_slowtmr+0x1b1>
    else if (pcb->nrtx == TCP_MAXRTX) {
  805f4f:	80 fa 0c             	cmp    $0xc,%dl
  805f52:	0f 85 74 02 00 00    	jne    8061cc <tcp_slowtmr+0x2f9>
  805f58:	be 01 00 00 00       	mov    $0x1,%esi
  805f5d:	e9 27 01 00 00       	jmp    806089 <tcp_slowtmr+0x1b6>
        if(pcb->rtime >= 0)
  805f62:	0f b7 4b 32          	movzwl 0x32(%ebx),%ecx
  805f66:	66 85 c9             	test   %cx,%cx
  805f69:	78 07                	js     805f72 <tcp_slowtmr+0x9f>
          ++pcb->rtime;
  805f6b:	83 c1 01             	add    $0x1,%ecx
  805f6e:	66 89 4b 32          	mov    %cx,0x32(%ebx)
        if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
  805f72:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  805f76:	74 6c                	je     805fe4 <tcp_slowtmr+0x111>
  805f78:	0f b7 7b 44          	movzwl 0x44(%ebx),%edi
  805f7c:	66 39 7b 32          	cmp    %di,0x32(%ebx)
  805f80:	7c 62                	jl     805fe4 <tcp_slowtmr+0x111>
          if (pcb->state != SYN_SENT) {
  805f82:	83 f8 02             	cmp    $0x2,%eax
  805f85:	74 1f                	je     805fa6 <tcp_slowtmr+0xd3>
            pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[pcb->nrtx];
  805f87:	0f b7 43 40          	movzwl 0x40(%ebx),%eax
  805f8b:	66 c1 f8 03          	sar    $0x3,%ax
  805f8f:	98                   	cwtl   
  805f90:	0f bf 4b 42          	movswl 0x42(%ebx),%ecx
  805f94:	01 c8                	add    %ecx,%eax
  805f96:	0f b6 d2             	movzbl %dl,%edx
  805f99:	0f b6 8a f4 23 81 00 	movzbl 0x8123f4(%edx),%ecx
  805fa0:	d3 e0                	shl    %cl,%eax
  805fa2:	66 89 43 44          	mov    %ax,0x44(%ebx)
          pcb->rtime = 0;
  805fa6:	66 c7 43 32 00 00    	movw   $0x0,0x32(%ebx)
          eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
  805fac:	0f b7 43 4e          	movzwl 0x4e(%ebx),%eax
  805fb0:	66 39 43 5c          	cmp    %ax,0x5c(%ebx)
  805fb4:	66 0f 46 43 5c       	cmovbe 0x5c(%ebx),%ax
          pcb->ssthresh = eff_wnd >> 1;
  805fb9:	66 d1 e8             	shr    %ax
          if (pcb->ssthresh < pcb->mss) {
  805fbc:	0f b7 53 34          	movzwl 0x34(%ebx),%edx
            pcb->ssthresh = pcb->mss * 2;
  805fc0:	8d 0c 12             	lea    (%edx,%edx,1),%ecx
  805fc3:	66 39 d0             	cmp    %dx,%ax
  805fc6:	0f 42 c1             	cmovb  %ecx,%eax
  805fc9:	66 89 43 50          	mov    %ax,0x50(%ebx)
          pcb->cwnd = pcb->mss;
  805fcd:	66 89 53 4e          	mov    %dx,0x4e(%ebx)
          tcp_rexmit_rto(pcb);
  805fd1:	83 ec 0c             	sub    $0xc,%esp
  805fd4:	53                   	push   %ebx
  805fd5:	e8 d8 28 00 00       	call   8088b2 <tcp_rexmit_rto>
  805fda:	83 c4 10             	add    $0x10,%esp
  805fdd:	eb 05                	jmp    805fe4 <tcp_slowtmr+0x111>
    pcb_remove = 0;
  805fdf:	be 00 00 00 00       	mov    $0x0,%esi
    if (pcb->state == FIN_WAIT_2) {
  805fe4:	8b 43 10             	mov    0x10(%ebx),%eax
  805fe7:	83 f8 06             	cmp    $0x6,%eax
  805fea:	74 6d                	je     806059 <tcp_slowtmr+0x186>
    if((pcb->so_options & SOF_KEEPALIVE) && 
  805fec:	f6 43 08 08          	testb  $0x8,0x8(%ebx)
  805ff0:	0f 84 93 00 00 00    	je     806089 <tcp_slowtmr+0x1b6>
  805ff6:	83 f8 04             	cmp    $0x4,%eax
  805ff9:	74 09                	je     806004 <tcp_slowtmr+0x131>
  805ffb:	83 f8 07             	cmp    $0x7,%eax
  805ffe:	0f 85 85 00 00 00    	jne    806089 <tcp_slowtmr+0x1b6>
      if((u32_t)(tcp_ticks - pcb->tmr) > 
  806004:	8b 0d 40 b2 b3 00    	mov    0xb3b240,%ecx
  80600a:	2b 4b 2c             	sub    0x2c(%ebx),%ecx
         (pcb->keep_idle + TCP_MAXIDLE) / TCP_SLOW_INTERVAL)
  80600d:	8b bb 9c 00 00 00    	mov    0x9c(%ebx),%edi
  806013:	8d 97 b8 4c 0a 00    	lea    0xa4cb8(%edi),%edx
  806019:	b8 d3 4d 62 10       	mov    $0x10624dd3,%eax
  80601e:	f7 e2                	mul    %edx
  806020:	c1 ea 05             	shr    $0x5,%edx
      if((u32_t)(tcp_ticks - pcb->tmr) > 
  806023:	39 d1                	cmp    %edx,%ecx
  806025:	77 4f                	ja     806076 <tcp_slowtmr+0x1a3>
              (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEPINTVL_DEFAULT) 
  806027:	0f b6 93 a5 00 00 00 	movzbl 0xa5(%ebx),%edx
  80602e:	69 d2 f8 24 01 00    	imul   $0x124f8,%edx,%edx
  806034:	01 fa                	add    %edi,%edx
              / TCP_SLOW_INTERVAL)
  806036:	b8 d3 4d 62 10       	mov    $0x10624dd3,%eax
  80603b:	f7 e2                	mul    %edx
  80603d:	c1 ea 05             	shr    $0x5,%edx
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
  806040:	39 d1                	cmp    %edx,%ecx
  806042:	76 45                	jbe    806089 <tcp_slowtmr+0x1b6>
        tcp_keepalive(pcb);
  806044:	83 ec 0c             	sub    $0xc,%esp
  806047:	53                   	push   %ebx
  806048:	e8 11 29 00 00       	call   80895e <tcp_keepalive>
        pcb->keep_cnt_sent++;
  80604d:	80 83 a5 00 00 00 01 	addb   $0x1,0xa5(%ebx)
  806054:	83 c4 10             	add    $0x10,%esp
  806057:	eb 30                	jmp    806089 <tcp_slowtmr+0x1b6>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
  806059:	a1 40 b2 b3 00       	mov    0xb3b240,%eax
  80605e:	2b 43 2c             	sub    0x2c(%ebx),%eax
        ++pcb_remove;
  806061:	83 f8 29             	cmp    $0x29,%eax
  806064:	89 f0                	mov    %esi,%eax
  806066:	1c ff                	sbb    $0xff,%al
  806068:	89 c6                	mov    %eax,%esi
    if (pcb->ooseq != NULL &&
  80606a:	8b 4b 7c             	mov    0x7c(%ebx),%ecx
  80606d:	85 c9                	test   %ecx,%ecx
  80606f:	75 1f                	jne    806090 <tcp_slowtmr+0x1bd>
  806071:	e9 d0 00 00 00       	jmp    806146 <tcp_slowtmr+0x273>
        tcp_abort(pcb);
  806076:	83 ec 0c             	sub    $0xc,%esp
  806079:	53                   	push   %ebx
  80607a:	e8 5a fd ff ff       	call   805dd9 <tcp_abort>
  80607f:	83 c4 10             	add    $0x10,%esp
  806082:	eb 05                	jmp    806089 <tcp_slowtmr+0x1b6>
  806084:	be 01 00 00 00       	mov    $0x1,%esi
    if (pcb->ooseq != NULL &&
  806089:	8b 4b 7c             	mov    0x7c(%ebx),%ecx
  80608c:	85 c9                	test   %ecx,%ecx
  80608e:	74 16                	je     8060a6 <tcp_slowtmr+0x1d3>
        (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
  806090:	8b 15 40 b2 b3 00    	mov    0xb3b240,%edx
  806096:	2b 53 2c             	sub    0x2c(%ebx),%edx
  806099:	0f bf 43 44          	movswl 0x44(%ebx),%eax
  80609d:	8d 04 40             	lea    (%eax,%eax,2),%eax
  8060a0:	01 c0                	add    %eax,%eax
    if (pcb->ooseq != NULL &&
  8060a2:	39 c2                	cmp    %eax,%edx
  8060a4:	73 7b                	jae    806121 <tcp_slowtmr+0x24e>
    if (pcb->state == SYN_RCVD) {
  8060a6:	8b 43 10             	mov    0x10(%ebx),%eax
  8060a9:	83 f8 03             	cmp    $0x3,%eax
  8060ac:	0f 84 87 00 00 00    	je     806139 <tcp_slowtmr+0x266>
    if (pcb->state == LAST_ACK) {
  8060b2:	83 f8 09             	cmp    $0x9,%eax
  8060b5:	0f 85 8b 00 00 00    	jne    806146 <tcp_slowtmr+0x273>
      if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
  8060bb:	a1 40 b2 b3 00       	mov    0xb3b240,%eax
  8060c0:	2b 43 2c             	sub    0x2c(%ebx),%eax
  8060c3:	3d f0 00 00 00       	cmp    $0xf0,%eax
  8060c8:	76 7c                	jbe    806146 <tcp_slowtmr+0x273>
      tcp_pcb_purge(pcb);      
  8060ca:	83 ec 0c             	sub    $0xc,%esp
  8060cd:	53                   	push   %ebx
  8060ce:	e8 e5 f9 ff ff       	call   805ab8 <tcp_pcb_purge>
      if (prev != NULL) {
  8060d3:	83 c4 10             	add    $0x10,%esp
  8060d6:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
  8060da:	0f 84 66 01 00 00    	je     806246 <tcp_slowtmr+0x373>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
  8060e0:	3b 1d 3c b2 b3 00    	cmp    0xb3b23c,%ebx
  8060e6:	0f 84 43 01 00 00    	je     80622f <tcp_slowtmr+0x35c>
        prev->next = pcb->next;
  8060ec:	8b 43 0c             	mov    0xc(%ebx),%eax
  8060ef:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  8060f2:	89 47 0c             	mov    %eax,0xc(%edi)
      TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_ABRT);
  8060f5:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
  8060fb:	85 c0                	test   %eax,%eax
  8060fd:	74 0d                	je     80610c <tcp_slowtmr+0x239>
  8060ff:	83 ec 08             	sub    $0x8,%esp
  806102:	6a fb                	push   $0xfffffffb
  806104:	ff 73 18             	pushl  0x18(%ebx)
  806107:	ff d0                	call   *%eax
  806109:	83 c4 10             	add    $0x10,%esp
      pcb2 = pcb->next;
  80610c:	8b 73 0c             	mov    0xc(%ebx),%esi
      memp_free(MEMP_TCP_PCB, pcb);
  80610f:	83 ec 08             	sub    $0x8,%esp
  806112:	53                   	push   %ebx
  806113:	6a 02                	push   $0x2
  806115:	e8 84 e5 ff ff       	call   80469e <memp_free>
  80611a:	83 c4 10             	add    $0x10,%esp
      pcb = pcb2;
  80611d:	89 f3                	mov    %esi,%ebx
  80611f:	eb 6b                	jmp    80618c <tcp_slowtmr+0x2b9>
      tcp_segs_free(pcb->ooseq);
  806121:	83 ec 0c             	sub    $0xc,%esp
  806124:	51                   	push   %ecx
  806125:	e8 8e f8 ff ff       	call   8059b8 <tcp_segs_free>
      pcb->ooseq = NULL;
  80612a:	c7 43 7c 00 00 00 00 	movl   $0x0,0x7c(%ebx)
  806131:	83 c4 10             	add    $0x10,%esp
  806134:	e9 6d ff ff ff       	jmp    8060a6 <tcp_slowtmr+0x1d3>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
  806139:	a1 40 b2 b3 00       	mov    0xb3b240,%eax
  80613e:	2b 43 2c             	sub    0x2c(%ebx),%eax
  806141:	83 f8 28             	cmp    $0x28,%eax
  806144:	77 84                	ja     8060ca <tcp_slowtmr+0x1f7>
    if (pcb_remove) {
  806146:	89 f0                	mov    %esi,%eax
  806148:	84 c0                	test   %al,%al
  80614a:	0f 85 7a ff ff ff    	jne    8060ca <tcp_slowtmr+0x1f7>
      ++pcb->polltmr;
  806150:	0f b6 43 30          	movzbl 0x30(%ebx),%eax
  806154:	83 c0 01             	add    $0x1,%eax
  806157:	88 43 30             	mov    %al,0x30(%ebx)
      if (pcb->polltmr >= pcb->pollinterval) {
  80615a:	3a 43 31             	cmp    0x31(%ebx),%al
  80615d:	72 27                	jb     806186 <tcp_slowtmr+0x2b3>
        pcb->polltmr = 0;
  80615f:	c6 43 30 00          	movb   $0x0,0x30(%ebx)
        TCP_EVENT_POLL(pcb, err);
  806163:	8b 83 94 00 00 00    	mov    0x94(%ebx),%eax
  806169:	85 c0                	test   %eax,%eax
  80616b:	74 0f                	je     80617c <tcp_slowtmr+0x2a9>
  80616d:	83 ec 08             	sub    $0x8,%esp
  806170:	53                   	push   %ebx
  806171:	ff 73 18             	pushl  0x18(%ebx)
  806174:	ff d0                	call   *%eax
  806176:	88 45 e3             	mov    %al,-0x1d(%ebp)
  806179:	83 c4 10             	add    $0x10,%esp
        if (err == ERR_OK) {
  80617c:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
  806180:	0f 84 ec 00 00 00    	je     806272 <tcp_slowtmr+0x39f>
      prev = pcb;
  806186:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
      pcb = pcb->next;
  806189:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  while (pcb != NULL) {
  80618c:	85 db                	test   %ebx,%ebx
  80618e:	0f 84 ef 00 00 00    	je     806283 <tcp_slowtmr+0x3b0>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
  806194:	8b 43 10             	mov    0x10(%ebx),%eax
  806197:	85 c0                	test   %eax,%eax
  806199:	0f 84 5e fd ff ff    	je     805efd <tcp_slowtmr+0x2a>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
  80619f:	83 f8 01             	cmp    $0x1,%eax
  8061a2:	0f 84 6c fd ff ff    	je     805f14 <tcp_slowtmr+0x41>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
  8061a8:	83 f8 0a             	cmp    $0xa,%eax
  8061ab:	0f 84 7a fd ff ff    	je     805f2b <tcp_slowtmr+0x58>
    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
  8061b1:	83 f8 02             	cmp    $0x2,%eax
  8061b4:	0f 84 88 fd ff ff    	je     805f42 <tcp_slowtmr+0x6f>
    else if (pcb->nrtx == TCP_MAXRTX) {
  8061ba:	0f b6 53 46          	movzbl 0x46(%ebx),%edx
      ++pcb_remove;
  8061be:	be 01 00 00 00       	mov    $0x1,%esi
    else if (pcb->nrtx == TCP_MAXRTX) {
  8061c3:	80 fa 0c             	cmp    $0xc,%dl
  8061c6:	0f 84 18 fe ff ff    	je     805fe4 <tcp_slowtmr+0x111>
      if (pcb->persist_backoff > 0) {
  8061cc:	0f b6 b3 a4 00 00 00 	movzbl 0xa4(%ebx),%esi
  8061d3:	89 f1                	mov    %esi,%ecx
  8061d5:	84 c9                	test   %cl,%cl
  8061d7:	0f 84 85 fd ff ff    	je     805f62 <tcp_slowtmr+0x8f>
        pcb->persist_cnt++;
  8061dd:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
  8061e3:	83 c0 01             	add    $0x1,%eax
  8061e6:	89 83 a0 00 00 00    	mov    %eax,0xa0(%ebx)
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
  8061ec:	0f b6 d1             	movzbl %cl,%edx
  8061ef:	bf ec 23 81 00       	mov    $0x8123ec,%edi
  8061f4:	0f b6 54 17 ff       	movzbl -0x1(%edi,%edx,1),%edx
  8061f9:	39 d0                	cmp    %edx,%eax
  8061fb:	0f 82 de fd ff ff    	jb     805fdf <tcp_slowtmr+0x10c>
          pcb->persist_cnt = 0;
  806201:	c7 83 a0 00 00 00 00 	movl   $0x0,0xa0(%ebx)
  806208:	00 00 00 
          if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
  80620b:	80 f9 06             	cmp    $0x6,%cl
  80620e:	77 09                	ja     806219 <tcp_slowtmr+0x346>
            pcb->persist_backoff++;
  806210:	8d 46 01             	lea    0x1(%esi),%eax
  806213:	88 83 a4 00 00 00    	mov    %al,0xa4(%ebx)
          tcp_zero_window_probe(pcb);
  806219:	83 ec 0c             	sub    $0xc,%esp
  80621c:	53                   	push   %ebx
  80621d:	e8 66 28 00 00       	call   808a88 <tcp_zero_window_probe>
  806222:	83 c4 10             	add    $0x10,%esp
    pcb_remove = 0;
  806225:	be 00 00 00 00       	mov    $0x0,%esi
  80622a:	e9 b5 fd ff ff       	jmp    805fe4 <tcp_slowtmr+0x111>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
  80622f:	83 ec 04             	sub    $0x4,%esp
  806232:	68 64 22 81 00       	push   $0x812264
  806237:	68 c1 02 00 00       	push   $0x2c1
  80623c:	68 6e 23 81 00       	push   $0x81236e
  806241:	e8 01 87 00 00       	call   80e947 <_panic>
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
  806246:	3b 1d 3c b2 b3 00    	cmp    0xb3b23c,%ebx
  80624c:	75 0d                	jne    80625b <tcp_slowtmr+0x388>
        tcp_active_pcbs = pcb->next;
  80624e:	8b 43 0c             	mov    0xc(%ebx),%eax
  806251:	a3 3c b2 b3 00       	mov    %eax,0xb3b23c
  806256:	e9 9a fe ff ff       	jmp    8060f5 <tcp_slowtmr+0x222>
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
  80625b:	83 ec 04             	sub    $0x4,%esp
  80625e:	68 90 22 81 00       	push   $0x812290
  806263:	68 c5 02 00 00       	push   $0x2c5
  806268:	68 6e 23 81 00       	push   $0x81236e
  80626d:	e8 d5 86 00 00       	call   80e947 <_panic>
          tcp_output(pcb);
  806272:	83 ec 0c             	sub    $0xc,%esp
  806275:	53                   	push   %ebx
  806276:	e8 64 20 00 00       	call   8082df <tcp_output>
  80627b:	83 c4 10             	add    $0x10,%esp
  80627e:	e9 03 ff ff ff       	jmp    806186 <tcp_slowtmr+0x2b3>
  pcb = tcp_tw_pcbs;
  806283:	8b 35 50 b2 b3 00    	mov    0xb3b250,%esi
  while (pcb != NULL) {
  806289:	eb 48                	jmp    8062d3 <tcp_slowtmr+0x400>
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  80628b:	83 ec 04             	sub    $0x4,%esp
  80628e:	68 bc 22 81 00       	push   $0x8122bc
  806293:	68 e5 02 00 00       	push   $0x2e5
  806298:	68 6e 23 81 00       	push   $0x81236e
  80629d:	e8 a5 86 00 00       	call   80e947 <_panic>
      tcp_pcb_purge(pcb);      
  8062a2:	83 ec 0c             	sub    $0xc,%esp
  8062a5:	56                   	push   %esi
  8062a6:	e8 0d f8 ff ff       	call   805ab8 <tcp_pcb_purge>
      if (prev != NULL) {
  8062ab:	83 c4 10             	add    $0x10,%esp
  8062ae:	85 db                	test   %ebx,%ebx
  8062b0:	74 58                	je     80630a <tcp_slowtmr+0x437>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
  8062b2:	3b 35 50 b2 b3 00    	cmp    0xb3b250,%esi
  8062b8:	74 39                	je     8062f3 <tcp_slowtmr+0x420>
        prev->next = pcb->next;
  8062ba:	8b 46 0c             	mov    0xc(%esi),%eax
  8062bd:	89 43 0c             	mov    %eax,0xc(%ebx)
      pcb2 = pcb->next;
  8062c0:	8b 7e 0c             	mov    0xc(%esi),%edi
      memp_free(MEMP_TCP_PCB, pcb);
  8062c3:	83 ec 08             	sub    $0x8,%esp
  8062c6:	56                   	push   %esi
  8062c7:	6a 02                	push   $0x2
  8062c9:	e8 d0 e3 ff ff       	call   80469e <memp_free>
  8062ce:	83 c4 10             	add    $0x10,%esp
      pcb = pcb2;
  8062d1:	89 fe                	mov    %edi,%esi
  while (pcb != NULL) {
  8062d3:	85 f6                	test   %esi,%esi
  8062d5:	74 5c                	je     806333 <tcp_slowtmr+0x460>
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  8062d7:	83 7e 10 0a          	cmpl   $0xa,0x10(%esi)
  8062db:	75 ae                	jne    80628b <tcp_slowtmr+0x3b8>
    if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
  8062dd:	a1 40 b2 b3 00       	mov    0xb3b240,%eax
  8062e2:	2b 46 2c             	sub    0x2c(%esi),%eax
  8062e5:	3d f0 00 00 00       	cmp    $0xf0,%eax
  8062ea:	77 b6                	ja     8062a2 <tcp_slowtmr+0x3cf>
      prev = pcb;
  8062ec:	89 f3                	mov    %esi,%ebx
      pcb = pcb->next;
  8062ee:	8b 76 0c             	mov    0xc(%esi),%esi
  8062f1:	eb e0                	jmp    8062d3 <tcp_slowtmr+0x400>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
  8062f3:	83 ec 04             	sub    $0x4,%esp
  8062f6:	68 ec 22 81 00       	push   $0x8122ec
  8062fb:	68 f4 02 00 00       	push   $0x2f4
  806300:	68 6e 23 81 00       	push   $0x81236e
  806305:	e8 3d 86 00 00       	call   80e947 <_panic>
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
  80630a:	3b 35 50 b2 b3 00    	cmp    0xb3b250,%esi
  806310:	75 0a                	jne    80631c <tcp_slowtmr+0x449>
        tcp_tw_pcbs = pcb->next;
  806312:	8b 46 0c             	mov    0xc(%esi),%eax
  806315:	a3 50 b2 b3 00       	mov    %eax,0xb3b250
  80631a:	eb a4                	jmp    8062c0 <tcp_slowtmr+0x3ed>
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
  80631c:	83 ec 04             	sub    $0x4,%esp
  80631f:	68 14 23 81 00       	push   $0x812314
  806324:	68 f8 02 00 00       	push   $0x2f8
  806329:	68 6e 23 81 00       	push   $0x81236e
  80632e:	e8 14 86 00 00       	call   80e947 <_panic>
}
  806333:	8d 65 f4             	lea    -0xc(%ebp),%esp
  806336:	5b                   	pop    %ebx
  806337:	5e                   	pop    %esi
  806338:	5f                   	pop    %edi
  806339:	5d                   	pop    %ebp
  80633a:	c3                   	ret    

0080633b <tcp_tmr>:
{
  80633b:	f3 0f 1e fb          	endbr32 
  80633f:	55                   	push   %ebp
  806340:	89 e5                	mov    %esp,%ebp
  806342:	83 ec 08             	sub    $0x8,%esp
  tcp_fasttmr();
  806345:	e8 b2 f5 ff ff       	call   8058fc <tcp_fasttmr>
  if (++tcp_timer & 1) {
  80634a:	0f b6 05 f9 43 b3 00 	movzbl 0xb343f9,%eax
  806351:	83 c0 01             	add    $0x1,%eax
  806354:	a2 f9 43 b3 00       	mov    %al,0xb343f9
  806359:	a8 01                	test   $0x1,%al
  80635b:	75 02                	jne    80635f <tcp_tmr+0x24>
}
  80635d:	c9                   	leave  
  80635e:	c3                   	ret    
    tcp_slowtmr();
  80635f:	e8 6f fb ff ff       	call   805ed3 <tcp_slowtmr>
}
  806364:	eb f7                	jmp    80635d <tcp_tmr+0x22>

00806366 <tcp_next_iss>:
 *
 * @return u32_t pseudo random sequence number
 */
u32_t
tcp_next_iss(void)
{
  806366:	f3 0f 1e fb          	endbr32 
  static u32_t iss = 6510;
  
  iss += tcp_ticks;       /* XXX */
  80636a:	a1 40 b2 b3 00       	mov    0xb3b240,%eax
  80636f:	03 05 08 40 81 00    	add    0x814008,%eax
  806375:	a3 08 40 81 00       	mov    %eax,0x814008
  return iss;
}
  80637a:	c3                   	ret    

0080637b <tcp_alloc>:
{
  80637b:	f3 0f 1e fb          	endbr32 
  80637f:	55                   	push   %ebp
  806380:	89 e5                	mov    %esp,%ebp
  806382:	57                   	push   %edi
  806383:	56                   	push   %esi
  806384:	53                   	push   %ebx
  806385:	83 ec 28             	sub    $0x28,%esp
  806388:	0f b6 75 08          	movzbl 0x8(%ebp),%esi
  pcb = memp_malloc(MEMP_TCP_PCB);
  80638c:	6a 02                	push   $0x2
  80638e:	e8 b1 e2 ff ff       	call   804644 <memp_malloc>
  806393:	89 c3                	mov    %eax,%ebx
  if (pcb == NULL) {
  806395:	83 c4 10             	add    $0x10,%esp
  806398:	85 c0                	test   %eax,%eax
  80639a:	0f 84 a0 00 00 00    	je     806440 <tcp_alloc+0xc5>
    memset(pcb, 0, sizeof(struct tcp_pcb));
  8063a0:	83 ec 04             	sub    $0x4,%esp
  8063a3:	68 a8 00 00 00       	push   $0xa8
  8063a8:	6a 00                	push   $0x0
  8063aa:	53                   	push   %ebx
  8063ab:	e8 f2 8d 00 00       	call   80f1a2 <memset>
    pcb->prio = TCP_PRIO_NORMAL;
  8063b0:	c6 43 14 40          	movb   $0x40,0x14(%ebx)
    pcb->snd_buf = TCP_SND_BUF;
  8063b4:	66 c7 43 6e 40 5b    	movw   $0x5b40,0x6e(%ebx)
    pcb->snd_queuelen = 0;
  8063ba:	66 c7 43 70 00 00    	movw   $0x0,0x70(%ebx)
    pcb->rcv_wnd = TCP_WND;
  8063c0:	66 c7 43 28 c0 5d    	movw   $0x5dc0,0x28(%ebx)
    pcb->rcv_ann_wnd = TCP_WND;
  8063c6:	66 c7 43 2a c0 5d    	movw   $0x5dc0,0x2a(%ebx)
    pcb->tos = 0;
  8063cc:	c6 43 0a 00          	movb   $0x0,0xa(%ebx)
    pcb->ttl = TCP_TTL;
  8063d0:	c6 43 0b ff          	movb   $0xff,0xb(%ebx)
    pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
  8063d4:	66 c7 43 34 18 02    	movw   $0x218,0x34(%ebx)
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
  8063da:	66 c7 43 44 06 00    	movw   $0x6,0x44(%ebx)
    pcb->sa = 0;
  8063e0:	66 c7 43 40 00 00    	movw   $0x0,0x40(%ebx)
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
  8063e6:	66 c7 43 42 06 00    	movw   $0x6,0x42(%ebx)
    pcb->rtime = -1;
  8063ec:	66 c7 43 32 ff ff    	movw   $0xffff,0x32(%ebx)
    pcb->cwnd = 1;
  8063f2:	66 c7 43 4e 01 00    	movw   $0x1,0x4e(%ebx)
    iss = tcp_next_iss();
  8063f8:	e8 69 ff ff ff       	call   806366 <tcp_next_iss>
    pcb->snd_wl2 = iss;
  8063fd:	89 43 64             	mov    %eax,0x64(%ebx)
    pcb->snd_nxt = iss;
  806400:	89 43 54             	mov    %eax,0x54(%ebx)
    pcb->snd_max = iss;
  806403:	89 43 58             	mov    %eax,0x58(%ebx)
    pcb->lastack = iss;
  806406:	89 43 48             	mov    %eax,0x48(%ebx)
    pcb->snd_lbb = iss;   
  806409:	89 43 68             	mov    %eax,0x68(%ebx)
    pcb->tmr = tcp_ticks;
  80640c:	a1 40 b2 b3 00       	mov    0xb3b240,%eax
  806411:	89 43 2c             	mov    %eax,0x2c(%ebx)
    pcb->polltmr = 0;
  806414:	c6 43 30 00          	movb   $0x0,0x30(%ebx)
    pcb->recv = tcp_recv_null;
  806418:	c7 83 88 00 00 00 99 	movl   $0x805d99,0x88(%ebx)
  80641f:	5d 80 00 
    pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
  806422:	c7 83 9c 00 00 00 00 	movl   $0x6ddd00,0x9c(%ebx)
  806429:	dd 6d 00 
    pcb->keep_cnt_sent = 0;
  80642c:	c6 83 a5 00 00 00 00 	movb   $0x0,0xa5(%ebx)
  806433:	83 c4 10             	add    $0x10,%esp
}
  806436:	89 d8                	mov    %ebx,%eax
  806438:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80643b:	5b                   	pop    %ebx
  80643c:	5e                   	pop    %esi
  80643d:	5f                   	pop    %edi
  80643e:	5d                   	pop    %ebp
  80643f:	c3                   	ret    
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  806440:	a1 50 b2 b3 00       	mov    0xb3b250,%eax
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  806445:	8b 3d 40 b2 b3 00    	mov    0xb3b240,%edi
  inactivity = 0;
  80644b:	b9 00 00 00 00       	mov    $0x0,%ecx
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  806450:	eb 03                	jmp    806455 <tcp_alloc+0xda>
  806452:	8b 40 0c             	mov    0xc(%eax),%eax
  806455:	85 c0                	test   %eax,%eax
  806457:	74 0f                	je     806468 <tcp_alloc+0xed>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  806459:	89 fa                	mov    %edi,%edx
  80645b:	2b 50 2c             	sub    0x2c(%eax),%edx
  80645e:	39 ca                	cmp    %ecx,%edx
  806460:	72 f0                	jb     806452 <tcp_alloc+0xd7>
      inactivity = tcp_ticks - pcb->tmr;
  806462:	89 d1                	mov    %edx,%ecx
      inactive = pcb;
  806464:	89 c3                	mov    %eax,%ebx
  806466:	eb ea                	jmp    806452 <tcp_alloc+0xd7>
  if (inactive != NULL) {
  806468:	85 db                	test   %ebx,%ebx
  80646a:	74 0c                	je     806478 <tcp_alloc+0xfd>
    tcp_abort(inactive);
  80646c:	83 ec 0c             	sub    $0xc,%esp
  80646f:	53                   	push   %ebx
  806470:	e8 64 f9 ff ff       	call   805dd9 <tcp_abort>
  806475:	83 c4 10             	add    $0x10,%esp
    pcb = memp_malloc(MEMP_TCP_PCB);
  806478:	83 ec 0c             	sub    $0xc,%esp
  80647b:	6a 02                	push   $0x2
  80647d:	e8 c2 e1 ff ff       	call   804644 <memp_malloc>
  806482:	89 c3                	mov    %eax,%ebx
    if (pcb == NULL) {
  806484:	83 c4 10             	add    $0x10,%esp
  806487:	85 c0                	test   %eax,%eax
  806489:	0f 85 11 ff ff ff    	jne    8063a0 <tcp_alloc+0x25>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80648f:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  806494:	8b 3d 40 b2 b3 00    	mov    0xb3b240,%edi
  80649a:	89 7d dc             	mov    %edi,-0x24(%ebp)
  mprio = TCP_PRIO_MAX;
  80649d:	ba 7f 00 00 00       	mov    $0x7f,%edx
  inactivity = 0;
  8064a2:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  8064a9:	89 df                	mov    %ebx,%edi
  8064ab:	89 f1                	mov    %esi,%ecx
  8064ad:	88 4d e7             	mov    %cl,-0x19(%ebp)
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  8064b0:	eb 03                	jmp    8064b5 <tcp_alloc+0x13a>
  8064b2:	8b 40 0c             	mov    0xc(%eax),%eax
  8064b5:	85 c0                	test   %eax,%eax
  8064b7:	74 29                	je     8064e2 <tcp_alloc+0x167>
    if (pcb->prio <= prio &&
  8064b9:	0f b6 48 14          	movzbl 0x14(%eax),%ecx
  8064bd:	0f b6 5d e7          	movzbl -0x19(%ebp),%ebx
  8064c1:	38 d3                	cmp    %dl,%bl
  8064c3:	89 d6                	mov    %edx,%esi
  8064c5:	0f 46 f3             	cmovbe %ebx,%esi
  8064c8:	89 f3                	mov    %esi,%ebx
  8064ca:	38 cb                	cmp    %cl,%bl
  8064cc:	72 e4                	jb     8064b2 <tcp_alloc+0x137>
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  8064ce:	8b 75 dc             	mov    -0x24(%ebp),%esi
  8064d1:	2b 70 2c             	sub    0x2c(%eax),%esi
       pcb->prio <= mprio &&
  8064d4:	3b 75 e0             	cmp    -0x20(%ebp),%esi
  8064d7:	72 d9                	jb     8064b2 <tcp_alloc+0x137>
      mprio = pcb->prio;
  8064d9:	89 ca                	mov    %ecx,%edx
      inactivity = tcp_ticks - pcb->tmr;
  8064db:	89 75 e0             	mov    %esi,-0x20(%ebp)
      inactive = pcb;
  8064de:	89 c7                	mov    %eax,%edi
  8064e0:	eb d0                	jmp    8064b2 <tcp_alloc+0x137>
  if (inactive != NULL) {
  8064e2:	85 ff                	test   %edi,%edi
  8064e4:	74 0c                	je     8064f2 <tcp_alloc+0x177>
    tcp_abort(inactive);
  8064e6:	83 ec 0c             	sub    $0xc,%esp
  8064e9:	57                   	push   %edi
  8064ea:	e8 ea f8 ff ff       	call   805dd9 <tcp_abort>
  8064ef:	83 c4 10             	add    $0x10,%esp
      pcb = memp_malloc(MEMP_TCP_PCB);
  8064f2:	83 ec 0c             	sub    $0xc,%esp
  8064f5:	6a 02                	push   $0x2
  8064f7:	e8 48 e1 ff ff       	call   804644 <memp_malloc>
  8064fc:	89 c3                	mov    %eax,%ebx
  if (pcb != NULL) {
  8064fe:	83 c4 10             	add    $0x10,%esp
  806501:	85 c0                	test   %eax,%eax
  806503:	0f 84 2d ff ff ff    	je     806436 <tcp_alloc+0xbb>
  806509:	e9 92 fe ff ff       	jmp    8063a0 <tcp_alloc+0x25>

0080650e <tcp_new>:
{
  80650e:	f3 0f 1e fb          	endbr32 
  806512:	55                   	push   %ebp
  806513:	89 e5                	mov    %esp,%ebp
  806515:	83 ec 14             	sub    $0x14,%esp
  return tcp_alloc(TCP_PRIO_NORMAL);
  806518:	6a 40                	push   $0x40
  80651a:	e8 5c fe ff ff       	call   80637b <tcp_alloc>
}
  80651f:	c9                   	leave  
  806520:	c3                   	ret    

00806521 <tcp_eff_send_mss>:
 * by using ip_route to determin the netif used to send to the address and
 * calculating the minimum of TCP_MSS and that netif's mtu (if set).
 */
u16_t
tcp_eff_send_mss(u16_t sendmss, struct ip_addr *addr)
{
  806521:	f3 0f 1e fb          	endbr32 
  806525:	55                   	push   %ebp
  806526:	89 e5                	mov    %esp,%ebp
  806528:	56                   	push   %esi
  806529:	53                   	push   %ebx
  80652a:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80652d:	89 de                	mov    %ebx,%esi
  u16_t mss_s;
  struct netif *outif;

  outif = ip_route(addr);
  80652f:	83 ec 0c             	sub    $0xc,%esp
  806532:	ff 75 0c             	pushl  0xc(%ebp)
  806535:	e8 ea 01 00 00       	call   806724 <ip_route>
  if ((outif != NULL) && (outif->mtu != 0)) {
  80653a:	83 c4 10             	add    $0x10,%esp
  80653d:	85 c0                	test   %eax,%eax
  80653f:	74 12                	je     806553 <tcp_eff_send_mss+0x32>
  806541:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
  806545:	66 85 c0             	test   %ax,%ax
  806548:	74 09                	je     806553 <tcp_eff_send_mss+0x32>
    mss_s = outif->mtu - IP_HLEN - TCP_HLEN;
  80654a:	8d 70 d8             	lea    -0x28(%eax),%esi
    /* RFC 1122, chap 4.2.2.6:
     * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
     * but we only send options with SYN and that is never filled with data! */
    sendmss = LWIP_MIN(sendmss, mss_s);
  80654d:	66 39 f3             	cmp    %si,%bx
  806550:	0f 46 f3             	cmovbe %ebx,%esi
  }
  return sendmss;
}
  806553:	89 f0                	mov    %esi,%eax
  806555:	8d 65 f8             	lea    -0x8(%ebp),%esp
  806558:	5b                   	pop    %ebx
  806559:	5e                   	pop    %esi
  80655a:	5d                   	pop    %ebp
  80655b:	c3                   	ret    

0080655c <tcp_connect>:
{
  80655c:	f3 0f 1e fb          	endbr32 
  806560:	55                   	push   %ebp
  806561:	89 e5                	mov    %esp,%ebp
  806563:	56                   	push   %esi
  806564:	53                   	push   %ebx
  806565:	83 ec 10             	sub    $0x10,%esp
  806568:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80656b:	8b 75 0c             	mov    0xc(%ebp),%esi
  80656e:	8b 45 10             	mov    0x10(%ebp),%eax
  LWIP_ERROR("tcp_connect: can only connected from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  806571:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  806575:	0f 85 9c 00 00 00    	jne    806617 <tcp_connect+0xbb>
  if (ipaddr != NULL) {
  80657b:	85 f6                	test   %esi,%esi
  80657d:	0f 84 53 01 00 00    	je     8066d6 <tcp_connect+0x17a>
    pcb->remote_ip = *ipaddr;
  806583:	8b 16                	mov    (%esi),%edx
  806585:	89 53 04             	mov    %edx,0x4(%ebx)
  pcb->remote_port = port;
  806588:	66 89 43 1e          	mov    %ax,0x1e(%ebx)
  if (pcb->local_port == 0) {
  80658c:	66 83 7b 1c 00       	cmpw   $0x0,0x1c(%ebx)
  806591:	0f 84 97 00 00 00    	je     80662e <tcp_connect+0xd2>
  iss = tcp_next_iss();
  806597:	e8 ca fd ff ff       	call   806366 <tcp_next_iss>
  pcb->rcv_nxt = 0;
  80659c:	c7 43 24 00 00 00 00 	movl   $0x0,0x24(%ebx)
  pcb->snd_nxt = iss;
  8065a3:	89 43 54             	mov    %eax,0x54(%ebx)
  pcb->lastack = iss - 1;
  8065a6:	83 e8 01             	sub    $0x1,%eax
  8065a9:	89 43 48             	mov    %eax,0x48(%ebx)
  pcb->snd_lbb = iss - 1;
  8065ac:	89 43 68             	mov    %eax,0x68(%ebx)
  pcb->rcv_wnd = TCP_WND;
  8065af:	66 c7 43 28 c0 5d    	movw   $0x5dc0,0x28(%ebx)
  pcb->rcv_ann_wnd = TCP_WND;
  8065b5:	66 c7 43 2a c0 5d    	movw   $0x5dc0,0x2a(%ebx)
  pcb->snd_wnd = TCP_WND;
  8065bb:	66 c7 43 5c c0 5d    	movw   $0x5dc0,0x5c(%ebx)
  pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
  8065c1:	66 c7 43 34 18 02    	movw   $0x218,0x34(%ebx)
  pcb->mss = tcp_eff_send_mss(pcb->mss, ipaddr);
  8065c7:	83 ec 08             	sub    $0x8,%esp
  8065ca:	56                   	push   %esi
  8065cb:	68 18 02 00 00       	push   $0x218
  8065d0:	e8 4c ff ff ff       	call   806521 <tcp_eff_send_mss>
  8065d5:	66 89 43 34          	mov    %ax,0x34(%ebx)
  pcb->cwnd = 1;
  8065d9:	66 c7 43 4e 01 00    	movw   $0x1,0x4e(%ebx)
  pcb->ssthresh = pcb->mss * 10;
  8065df:	8d 04 80             	lea    (%eax,%eax,4),%eax
  8065e2:	01 c0                	add    %eax,%eax
  8065e4:	66 89 43 50          	mov    %ax,0x50(%ebx)
  pcb->state = SYN_SENT;
  8065e8:	c7 43 10 02 00 00 00 	movl   $0x2,0x10(%ebx)
  pcb->connected = connected;
  8065ef:	8b 45 14             	mov    0x14(%ebp),%eax
  8065f2:	89 83 8c 00 00 00    	mov    %eax,0x8c(%ebx)
  TCP_RMV(&tcp_bound_pcbs, pcb);
  8065f8:	8b 15 4c b2 b3 00    	mov    0xb3b24c,%edx
  8065fe:	83 c4 10             	add    $0x10,%esp
  806601:	39 da                	cmp    %ebx,%edx
  806603:	74 37                	je     80663c <tcp_connect+0xe0>
  806605:	89 15 48 b2 b3 00    	mov    %edx,0xb3b248
  80660b:	b9 00 00 00 00       	mov    $0x0,%ecx
  806610:	be 01 00 00 00       	mov    $0x1,%esi
  806615:	eb 7d                	jmp    806694 <tcp_connect+0x138>
  LWIP_ERROR("tcp_connect: can only connected from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  806617:	83 ec 04             	sub    $0x4,%esp
  80661a:	68 3c 23 81 00       	push   $0x81233c
  80661f:	68 ec 01 00 00       	push   $0x1ec
  806624:	68 6e 23 81 00       	push   $0x81236e
  806629:	e8 19 83 00 00       	call   80e947 <_panic>
    pcb->local_port = tcp_new_port();
  80662e:	e8 72 ef ff ff       	call   8055a5 <tcp_new_port>
  806633:	66 89 43 1c          	mov    %ax,0x1c(%ebx)
  806637:	e9 5b ff ff ff       	jmp    806597 <tcp_connect+0x3b>
  TCP_RMV(&tcp_bound_pcbs, pcb);
  80663c:	8b 43 0c             	mov    0xc(%ebx),%eax
  80663f:	a3 4c b2 b3 00       	mov    %eax,0xb3b24c
  TCP_REG(&tcp_active_pcbs, pcb);
  806644:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
  806649:	89 43 0c             	mov    %eax,0xc(%ebx)
  80664c:	89 1d 3c b2 b3 00    	mov    %ebx,0xb3b23c
  806652:	e8 f5 bc ff ff       	call   80234c <tcp_timer_needed>
  optdata = TCP_BUILD_MSS_OPTION();
  806657:	83 ec 0c             	sub    $0xc,%esp
  80665a:	68 b4 05 04 02       	push   $0x20405b4
  80665f:	e8 17 13 00 00       	call   80797b <htonl>
  806664:	89 45 f4             	mov    %eax,-0xc(%ebp)
  ret = tcp_enqueue(pcb, NULL, 0, TCP_SYN, 0, (u8_t *)&optdata, 4);
  806667:	83 c4 0c             	add    $0xc,%esp
  80666a:	6a 04                	push   $0x4
  80666c:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80666f:	50                   	push   %eax
  806670:	6a 00                	push   $0x0
  806672:	6a 02                	push   $0x2
  806674:	6a 00                	push   $0x0
  806676:	6a 00                	push   $0x0
  806678:	53                   	push   %ebx
  806679:	e8 41 15 00 00       	call   807bbf <tcp_enqueue>
  80667e:	89 c6                	mov    %eax,%esi
  if (ret == ERR_OK) { 
  806680:	83 c4 20             	add    $0x20,%esp
  806683:	84 c0                	test   %al,%al
  806685:	74 41                	je     8066c8 <tcp_connect+0x16c>
} 
  806687:	89 f0                	mov    %esi,%eax
  806689:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80668c:	5b                   	pop    %ebx
  80668d:	5e                   	pop    %esi
  80668e:	5d                   	pop    %ebp
  80668f:	c3                   	ret    
  806690:	89 f1                	mov    %esi,%ecx
  TCP_RMV(&tcp_bound_pcbs, pcb);
  806692:	89 c2                	mov    %eax,%edx
  806694:	85 d2                	test   %edx,%edx
  806696:	74 1d                	je     8066b5 <tcp_connect+0x159>
  806698:	8b 42 0c             	mov    0xc(%edx),%eax
  80669b:	39 d8                	cmp    %ebx,%eax
  80669d:	75 f1                	jne    806690 <tcp_connect+0x134>
  80669f:	85 c0                	test   %eax,%eax
  8066a1:	74 ed                	je     806690 <tcp_connect+0x134>
  8066a3:	84 c9                	test   %cl,%cl
  8066a5:	74 06                	je     8066ad <tcp_connect+0x151>
  8066a7:	89 15 48 b2 b3 00    	mov    %edx,0xb3b248
  8066ad:	8b 43 0c             	mov    0xc(%ebx),%eax
  8066b0:	89 42 0c             	mov    %eax,0xc(%edx)
  8066b3:	eb 8f                	jmp    806644 <tcp_connect+0xe8>
  8066b5:	84 c9                	test   %cl,%cl
  8066b7:	74 8b                	je     806644 <tcp_connect+0xe8>
  8066b9:	c7 05 48 b2 b3 00 00 	movl   $0x0,0xb3b248
  8066c0:	00 00 00 
  8066c3:	e9 7c ff ff ff       	jmp    806644 <tcp_connect+0xe8>
    tcp_output(pcb);
  8066c8:	83 ec 0c             	sub    $0xc,%esp
  8066cb:	53                   	push   %ebx
  8066cc:	e8 0e 1c 00 00       	call   8082df <tcp_output>
  8066d1:	83 c4 10             	add    $0x10,%esp
  8066d4:	eb b1                	jmp    806687 <tcp_connect+0x12b>
    return ERR_VAL;
  8066d6:	be f7 ff ff ff       	mov    $0xfffffff7,%esi
  8066db:	eb aa                	jmp    806687 <tcp_connect+0x12b>

008066dd <ip_addr_isbroadcast>:
 * @param addr address to be checked
 * @param netif the network interface against which the address is checked
 * @return returns non-zero if the address is a broadcast address
 */
u8_t ip_addr_isbroadcast(struct ip_addr *addr, struct netif *netif)
{
  8066dd:	f3 0f 1e fb          	endbr32 
  8066e1:	55                   	push   %ebp
  8066e2:	89 e5                	mov    %esp,%ebp
  8066e4:	53                   	push   %ebx
  8066e5:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  u32_t addr2test;

  addr2test = addr->addr;
  8066e8:	8b 45 08             	mov    0x8(%ebp),%eax
  8066eb:	8b 10                	mov    (%eax),%edx
  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr2test == IP_ADDR_ANY_VALUE) ||
  8066ed:	8d 5a ff             	lea    -0x1(%edx),%ebx
      (addr2test == IP_ADDR_ANY_VALUE))
    return 1;
  8066f0:	b8 01 00 00 00       	mov    $0x1,%eax
  if ((~addr2test == IP_ADDR_ANY_VALUE) ||
  8066f5:	83 fb fd             	cmp    $0xfffffffd,%ebx
  8066f8:	77 27                	ja     806721 <ip_addr_isbroadcast+0x44>
  /* no broadcast support on this network interface? */
  else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0)
  8066fa:	0f b6 41 2e          	movzbl 0x2e(%ecx),%eax
  8066fe:	83 e0 02             	and    $0x2,%eax
  806701:	74 1e                	je     806721 <ip_addr_isbroadcast+0x44>
    /* the given address cannot be a broadcast address
     * nor can we check against any broadcast addresses */
    return 0;
  /* address matches network interface address exactly? => no broadcast */
  else if (addr2test == netif->ip_addr.addr)
  806703:	8b 59 04             	mov    0x4(%ecx),%ebx
    return 0;
  806706:	b8 00 00 00 00       	mov    $0x0,%eax
  else if (addr2test == netif->ip_addr.addr)
  80670b:	39 d3                	cmp    %edx,%ebx
  80670d:	74 12                	je     806721 <ip_addr_isbroadcast+0x44>
  /*  on the same (sub) network... */
  else if (ip_addr_netcmp(addr, &(netif->ip_addr), &(netif->netmask))
  80670f:	8b 49 08             	mov    0x8(%ecx),%ecx
  806712:	31 d3                	xor    %edx,%ebx
  806714:	85 cb                	test   %ecx,%ebx
  806716:	75 09                	jne    806721 <ip_addr_isbroadcast+0x44>
         /* ...and host identifier bits are all ones? =>... */
          && ((addr2test & ~netif->netmask.addr) ==
  806718:	f7 d1                	not    %ecx
  80671a:	21 ca                	and    %ecx,%edx
  80671c:	39 ca                	cmp    %ecx,%edx
  80671e:	0f 94 c0             	sete   %al
           (IP_ADDR_BROADCAST_VALUE & ~netif->netmask.addr)))
    /* => network broadcast address */
    return 1;
  else
    return 0;
}
  806721:	5b                   	pop    %ebx
  806722:	5d                   	pop    %ebp
  806723:	c3                   	ret    

00806724 <ip_route>:
 * @param dest the destination IP address for which to find the route
 * @return the netif on which to send to reach dest
 */
struct netif *
ip_route(struct ip_addr *dest)
{
  806724:	f3 0f 1e fb          	endbr32 
  806728:	55                   	push   %ebp
  806729:	89 e5                	mov    %esp,%ebp
  80672b:	56                   	push   %esi
  80672c:	53                   	push   %ebx
  80672d:	8b 75 08             	mov    0x8(%ebp),%esi
  struct netif *netif;

  /* iterate through netifs */
  for(netif = netif_list; netif != NULL; netif = netif->next) {
  806730:	8b 1d 34 b2 b3 00    	mov    0xb3b234,%ebx
  806736:	eb 02                	jmp    80673a <ip_route+0x16>
  806738:	8b 1b                	mov    (%ebx),%ebx
  80673a:	85 db                	test   %ebx,%ebx
  80673c:	74 1c                	je     80675a <ip_route+0x36>
    /* network mask matches? */
    if (netif_is_up(netif)) {
  80673e:	83 ec 0c             	sub    $0xc,%esp
  806741:	53                   	push   %ebx
  806742:	e8 f4 e1 ff ff       	call   80493b <netif_is_up>
  806747:	83 c4 10             	add    $0x10,%esp
  80674a:	84 c0                	test   %al,%al
  80674c:	74 ea                	je     806738 <ip_route+0x14>
      if (ip_addr_netcmp(dest, &(netif->ip_addr), &(netif->netmask))) {
  80674e:	8b 06                	mov    (%esi),%eax
  806750:	33 43 04             	xor    0x4(%ebx),%eax
  806753:	85 43 08             	test   %eax,0x8(%ebx)
  806756:	75 e0                	jne    806738 <ip_route+0x14>
  806758:	eb 1e                	jmp    806778 <ip_route+0x54>
        /* return netif on which to forward IP packet */
        return netif;
      }
    }
  }
  if ((netif_default == NULL) || (!netif_is_up(netif_default))) {
  80675a:	a1 38 b2 b3 00       	mov    0xb3b238,%eax
  80675f:	85 c0                	test   %eax,%eax
  806761:	74 1e                	je     806781 <ip_route+0x5d>
  806763:	83 ec 0c             	sub    $0xc,%esp
  806766:	50                   	push   %eax
  806767:	e8 cf e1 ff ff       	call   80493b <netif_is_up>
  80676c:	83 c4 10             	add    $0x10,%esp
    IP_STATS_INC(ip.rterr);
    snmp_inc_ipoutnoroutes();
    return NULL;
  }
  /* no matching netif found, use default netif */
  return netif_default;
  80676f:	84 c0                	test   %al,%al
  806771:	0f 45 1d 38 b2 b3 00 	cmovne 0xb3b238,%ebx
}
  806778:	89 d8                	mov    %ebx,%eax
  80677a:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80677d:	5b                   	pop    %ebx
  80677e:	5e                   	pop    %esi
  80677f:	5d                   	pop    %ebp
  806780:	c3                   	ret    
    return NULL;
  806781:	89 c3                	mov    %eax,%ebx
  806783:	eb f3                	jmp    806778 <ip_route+0x54>

00806785 <ip_input>:
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t
ip_input(struct pbuf *p, struct netif *inp)
{
  806785:	f3 0f 1e fb          	endbr32 
  806789:	55                   	push   %ebp
  80678a:	89 e5                	mov    %esp,%ebp
  80678c:	57                   	push   %edi
  80678d:	56                   	push   %esi
  80678e:	53                   	push   %ebx
  80678f:	83 ec 28             	sub    $0x28,%esp

  IP_STATS_INC(ip.recv);
  snmp_inc_ipinreceives();

  /* identify the IP header */
  iphdr = p->payload;
  806792:	8b 45 08             	mov    0x8(%ebp),%eax
  806795:	8b 78 04             	mov    0x4(%eax),%edi
  if (IPH_V(iphdr) != 4) {
  806798:	0f b7 07             	movzwl (%edi),%eax
  80679b:	50                   	push   %eax
  80679c:	e8 c9 11 00 00       	call   80796a <ntohs>
  8067a1:	66 c1 e8 0c          	shr    $0xc,%ax
  8067a5:	83 c4 10             	add    $0x10,%esp
  8067a8:	66 83 f8 04          	cmp    $0x4,%ax
  8067ac:	74 1b                	je     8067c9 <ip_input+0x44>
    LWIP_DEBUGF(IP_DEBUG | 1, ("IP packet dropped due to bad version number %"U16_F"\n", IPH_V(iphdr)));
    ip_debug_print(p);
    pbuf_free(p);
  8067ae:	83 ec 0c             	sub    $0xc,%esp
  8067b1:	ff 75 08             	pushl  0x8(%ebp)
  8067b4:	e8 68 e2 ff ff       	call   804a21 <pbuf_free>
    IP_STATS_INC(ip.err);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
  8067b9:	83 c4 10             	add    $0x10,%esp
      snmp_inc_ipinunknownprotos();
    }
  }

  return ERR_OK;
}
  8067bc:	b8 00 00 00 00       	mov    $0x0,%eax
  8067c1:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8067c4:	5b                   	pop    %ebx
  8067c5:	5e                   	pop    %esi
  8067c6:	5f                   	pop    %edi
  8067c7:	5d                   	pop    %ebp
  8067c8:	c3                   	ret    
  iphdr_hlen = IPH_HL(iphdr);
  8067c9:	83 ec 0c             	sub    $0xc,%esp
  8067cc:	0f b7 07             	movzwl (%edi),%eax
  8067cf:	50                   	push   %eax
  8067d0:	e8 95 11 00 00       	call   80796a <ntohs>
  8067d5:	66 c1 e8 06          	shr    $0x6,%ax
  iphdr_hlen *= 4;
  8067d9:	83 e0 3c             	and    $0x3c,%eax
  8067dc:	89 c6                	mov    %eax,%esi
  8067de:	66 89 45 e2          	mov    %ax,-0x1e(%ebp)
  iphdr_len = ntohs(IPH_LEN(iphdr));
  8067e2:	0f b7 47 02          	movzwl 0x2(%edi),%eax
  8067e6:	89 04 24             	mov    %eax,(%esp)
  8067e9:	e8 7c 11 00 00       	call   80796a <ntohs>
  8067ee:	89 c3                	mov    %eax,%ebx
  if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len)) {
  8067f0:	83 c4 10             	add    $0x10,%esp
  8067f3:	8b 45 08             	mov    0x8(%ebp),%eax
  8067f6:	66 39 70 0a          	cmp    %si,0xa(%eax)
  8067fa:	72 06                	jb     806802 <ip_input+0x7d>
  8067fc:	66 39 58 08          	cmp    %bx,0x8(%eax)
  806800:	73 10                	jae    806812 <ip_input+0x8d>
    pbuf_free(p);
  806802:	83 ec 0c             	sub    $0xc,%esp
  806805:	ff 75 08             	pushl  0x8(%ebp)
  806808:	e8 14 e2 ff ff       	call   804a21 <pbuf_free>
    return ERR_OK;
  80680d:	83 c4 10             	add    $0x10,%esp
  806810:	eb aa                	jmp    8067bc <ip_input+0x37>
  if (inet_chksum(iphdr, iphdr_hlen) != 0) {
  806812:	83 ec 08             	sub    $0x8,%esp
  806815:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  806819:	50                   	push   %eax
  80681a:	57                   	push   %edi
  80681b:	e8 ff 0f 00 00       	call   80781f <inet_chksum>
  806820:	83 c4 10             	add    $0x10,%esp
  806823:	66 85 c0             	test   %ax,%ax
  806826:	75 27                	jne    80684f <ip_input+0xca>
  pbuf_realloc(p, iphdr_len);
  806828:	83 ec 08             	sub    $0x8,%esp
  80682b:	0f b7 db             	movzwl %bx,%ebx
  80682e:	53                   	push   %ebx
  80682f:	ff 75 08             	pushl  0x8(%ebp)
  806832:	e8 13 e5 ff ff       	call   804d4a <pbuf_realloc>
  806837:	83 c4 10             	add    $0x10,%esp
    netif = inp;
  80683a:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    int first = 1;
  80683d:	be 01 00 00 00       	mov    $0x1,%esi
            ip_addr_isbroadcast(&(iphdr->dest), netif)) {
  806842:	8d 47 10             	lea    0x10(%edi),%eax
  806845:	89 45 dc             	mov    %eax,-0x24(%ebp)
  806848:	89 7d e4             	mov    %edi,-0x1c(%ebp)
  80684b:	89 df                	mov    %ebx,%edi
  80684d:	eb 2e                	jmp    80687d <ip_input+0xf8>
    pbuf_free(p);
  80684f:	83 ec 0c             	sub    $0xc,%esp
  806852:	ff 75 08             	pushl  0x8(%ebp)
  806855:	e8 c7 e1 ff ff       	call   804a21 <pbuf_free>
    return ERR_OK;
  80685a:	83 c4 10             	add    $0x10,%esp
  80685d:	e9 5a ff ff ff       	jmp    8067bc <ip_input+0x37>
      if (first) {
  806862:	85 f6                	test   %esi,%esi
  806864:	74 51                	je     8068b7 <ip_input+0x132>
        netif = netif_list;
  806866:	8b 1d 34 b2 b3 00    	mov    0xb3b234,%ebx
      if (netif == inp) {
  80686c:	39 df                	cmp    %ebx,%edi
  80686e:	74 4b                	je     8068bb <ip_input+0x136>
  806870:	be 00 00 00 00       	mov    $0x0,%esi
    } while(netif != NULL);
  806875:	85 db                	test   %ebx,%ebx
  806877:	0f 84 1b 01 00 00    	je     806998 <ip_input+0x213>
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
  80687d:	83 ec 0c             	sub    $0xc,%esp
  806880:	53                   	push   %ebx
  806881:	e8 b5 e0 ff ff       	call   80493b <netif_is_up>
  806886:	83 c4 10             	add    $0x10,%esp
  806889:	84 c0                	test   %al,%al
  80688b:	74 d5                	je     806862 <ip_input+0xdd>
  80688d:	8b 43 04             	mov    0x4(%ebx),%eax
  806890:	85 c0                	test   %eax,%eax
  806892:	74 ce                	je     806862 <ip_input+0xdd>
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
  806894:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  806897:	3b 41 10             	cmp    0x10(%ecx),%eax
  80689a:	74 4a                	je     8068e6 <ip_input+0x161>
            ip_addr_isbroadcast(&(iphdr->dest), netif)) {
  80689c:	83 ec 08             	sub    $0x8,%esp
  80689f:	53                   	push   %ebx
  8068a0:	ff 75 dc             	pushl  -0x24(%ebp)
  8068a3:	e8 35 fe ff ff       	call   8066dd <ip_addr_isbroadcast>
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
  8068a8:	83 c4 10             	add    $0x10,%esp
  8068ab:	84 c0                	test   %al,%al
  8068ad:	74 b3                	je     806862 <ip_input+0xdd>
  8068af:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  8068b2:	e9 fc 00 00 00       	jmp    8069b3 <ip_input+0x22e>
        netif = netif->next;
  8068b7:	8b 1b                	mov    (%ebx),%ebx
  8068b9:	eb b1                	jmp    80686c <ip_input+0xe7>
        netif = netif->next;
  8068bb:	8b 1b                	mov    (%ebx),%ebx
  8068bd:	eb b1                	jmp    806870 <ip_input+0xeb>
      if (ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest) == DHCP_CLIENT_PORT) {
  8068bf:	83 ec 0c             	sub    $0xc,%esp
  8068c2:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  8068c6:	0f b7 44 07 02       	movzwl 0x2(%edi,%eax,1),%eax
  8068cb:	50                   	push   %eax
  8068cc:	e8 99 10 00 00       	call   80796a <ntohs>
  8068d1:	83 c4 10             	add    $0x10,%esp
  8068d4:	66 83 f8 44          	cmp    $0x44,%ax
  8068d8:	0f 85 d5 00 00 00    	jne    8069b3 <ip_input+0x22e>
        netif = inp;
  8068de:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  8068e1:	e9 10 01 00 00       	jmp    8069f6 <ip_input+0x271>
  8068e6:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  8068e9:	e9 c5 00 00 00       	jmp    8069b3 <ip_input+0x22e>
      pbuf_free(p);
  8068ee:	83 ec 0c             	sub    $0xc,%esp
  8068f1:	ff 75 08             	pushl  0x8(%ebp)
  8068f4:	e8 28 e1 ff ff       	call   804a21 <pbuf_free>
      return ERR_OK;
  8068f9:	83 c4 10             	add    $0x10,%esp
  8068fc:	e9 bb fe ff ff       	jmp    8067bc <ip_input+0x37>
    pbuf_free(p);
  806901:	83 ec 0c             	sub    $0xc,%esp
  806904:	ff 75 08             	pushl  0x8(%ebp)
  806907:	e8 15 e1 ff ff       	call   804a21 <pbuf_free>
    return ERR_OK;
  80690c:	83 c4 10             	add    $0x10,%esp
  80690f:	e9 a8 fe ff ff       	jmp    8067bc <ip_input+0x37>
      udp_input(p, inp);
  806914:	83 ec 08             	sub    $0x8,%esp
  806917:	ff 75 0c             	pushl  0xc(%ebp)
  80691a:	ff 75 08             	pushl  0x8(%ebp)
  80691d:	e8 ba 22 00 00       	call   808bdc <udp_input>
      break;
  806922:	83 c4 10             	add    $0x10,%esp
  806925:	e9 92 fe ff ff       	jmp    8067bc <ip_input+0x37>
      tcp_input(p, inp);
  80692a:	83 ec 08             	sub    $0x8,%esp
  80692d:	ff 75 0c             	pushl  0xc(%ebp)
  806930:	ff 75 08             	pushl  0x8(%ebp)
  806933:	e8 ef 6a 00 00       	call   80d427 <tcp_input>
      break;
  806938:	83 c4 10             	add    $0x10,%esp
  80693b:	e9 7c fe ff ff       	jmp    8067bc <ip_input+0x37>
      icmp_input(p, inp);
  806940:	83 ec 08             	sub    $0x8,%esp
  806943:	ff 75 0c             	pushl  0xc(%ebp)
  806946:	ff 75 08             	pushl  0x8(%ebp)
  806949:	e8 a5 7a 00 00       	call   80e3f3 <icmp_input>
      break;
  80694e:	83 c4 10             	add    $0x10,%esp
  806951:	e9 66 fe ff ff       	jmp    8067bc <ip_input+0x37>
          !ip_addr_ismulticast(&(iphdr->dest))) {
  806956:	8b 5f 10             	mov    0x10(%edi),%ebx
  806959:	83 ec 0c             	sub    $0xc,%esp
  80695c:	68 00 00 00 f0       	push   $0xf0000000
  806961:	e8 42 12 00 00       	call   807ba8 <ntohl>
  806966:	21 c3                	and    %eax,%ebx
  806968:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80696f:	e8 34 12 00 00       	call   807ba8 <ntohl>
      if (!ip_addr_isbroadcast(&(iphdr->dest), inp) &&
  806974:	83 c4 10             	add    $0x10,%esp
  806977:	39 c3                	cmp    %eax,%ebx
  806979:	0f 84 19 01 00 00    	je     806a98 <ip_input+0x313>
        p->payload = iphdr;
  80697f:	8b 45 08             	mov    0x8(%ebp),%eax
  806982:	89 78 04             	mov    %edi,0x4(%eax)
        icmp_dest_unreach(p, ICMP_DUR_PROTO);
  806985:	83 ec 08             	sub    $0x8,%esp
  806988:	6a 02                	push   $0x2
  80698a:	50                   	push   %eax
  80698b:	e8 81 7d 00 00       	call   80e711 <icmp_dest_unreach>
  806990:	83 c4 10             	add    $0x10,%esp
  806993:	e9 00 01 00 00       	jmp    806a98 <ip_input+0x313>
  806998:	8b 7d e4             	mov    -0x1c(%ebp),%edi
    if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
  80699b:	83 ec 0c             	sub    $0xc,%esp
  80699e:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  8069a2:	50                   	push   %eax
  8069a3:	e8 c2 0f 00 00       	call   80796a <ntohs>
  8069a8:	83 c4 10             	add    $0x10,%esp
  8069ab:	3c 11                	cmp    $0x11,%al
  8069ad:	0f 84 0c ff ff ff    	je     8068bf <ip_input+0x13a>
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
  8069b3:	83 ec 08             	sub    $0x8,%esp
  8069b6:	ff 75 0c             	pushl  0xc(%ebp)
  8069b9:	8d 47 0c             	lea    0xc(%edi),%eax
  8069bc:	50                   	push   %eax
  8069bd:	e8 1b fd ff ff       	call   8066dd <ip_addr_isbroadcast>
  8069c2:	83 c4 10             	add    $0x10,%esp
  8069c5:	84 c0                	test   %al,%al
  8069c7:	0f 85 21 ff ff ff    	jne    8068ee <ip_input+0x169>
         (ip_addr_ismulticast(&(iphdr->src)))) {
  8069cd:	8b 77 0c             	mov    0xc(%edi),%esi
  8069d0:	83 ec 0c             	sub    $0xc,%esp
  8069d3:	68 00 00 00 f0       	push   $0xf0000000
  8069d8:	e8 cb 11 00 00       	call   807ba8 <ntohl>
  8069dd:	21 c6                	and    %eax,%esi
  8069df:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  8069e6:	e8 bd 11 00 00       	call   807ba8 <ntohl>
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
  8069eb:	83 c4 10             	add    $0x10,%esp
  8069ee:	39 c6                	cmp    %eax,%esi
  8069f0:	0f 84 f8 fe ff ff    	je     8068ee <ip_input+0x169>
  if (netif == NULL) {
  8069f6:	85 db                	test   %ebx,%ebx
  8069f8:	0f 84 03 ff ff ff    	je     806901 <ip_input+0x17c>
  if ((IPH_OFFSET(iphdr) & htons(IP_OFFMASK | IP_MF)) != 0) {
  8069fe:	0f b7 5f 06          	movzwl 0x6(%edi),%ebx
  806a02:	83 ec 0c             	sub    $0xc,%esp
  806a05:	68 ff 3f 00 00       	push   $0x3fff
  806a0a:	e8 4a 0f 00 00       	call   807959 <htons>
  806a0f:	83 c4 10             	add    $0x10,%esp
  806a12:	66 85 c3             	test   %ax,%bx
  806a15:	74 1c                	je     806a33 <ip_input+0x2ae>
    p = ip_reass(p);
  806a17:	83 ec 0c             	sub    $0xc,%esp
  806a1a:	ff 75 08             	pushl  0x8(%ebp)
  806a1d:	e8 8f 04 00 00       	call   806eb1 <ip_reass>
  806a22:	89 45 08             	mov    %eax,0x8(%ebp)
    if (p == NULL) {
  806a25:	83 c4 10             	add    $0x10,%esp
  806a28:	85 c0                	test   %eax,%eax
  806a2a:	0f 84 8c fd ff ff    	je     8067bc <ip_input+0x37>
    iphdr = p->payload;
  806a30:	8b 78 04             	mov    0x4(%eax),%edi
  if (raw_input(p, inp) == 0)
  806a33:	83 ec 08             	sub    $0x8,%esp
  806a36:	ff 75 0c             	pushl  0xc(%ebp)
  806a39:	ff 75 08             	pushl  0x8(%ebp)
  806a3c:	e8 e9 76 00 00       	call   80e12a <raw_input>
  806a41:	83 c4 10             	add    $0x10,%esp
  806a44:	84 c0                	test   %al,%al
  806a46:	0f 85 70 fd ff ff    	jne    8067bc <ip_input+0x37>
    switch (IPH_PROTO(iphdr)) {
  806a4c:	83 ec 0c             	sub    $0xc,%esp
  806a4f:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  806a53:	50                   	push   %eax
  806a54:	e8 11 0f 00 00       	call   80796a <ntohs>
  806a59:	89 c2                	mov    %eax,%edx
  806a5b:	0f b6 c0             	movzbl %al,%eax
  806a5e:	83 c4 10             	add    $0x10,%esp
  806a61:	80 fa 06             	cmp    $0x6,%dl
  806a64:	0f 84 c0 fe ff ff    	je     80692a <ip_input+0x1a5>
  806a6a:	66 83 f8 11          	cmp    $0x11,%ax
  806a6e:	0f 84 a0 fe ff ff    	je     806914 <ip_input+0x18f>
  806a74:	66 83 f8 01          	cmp    $0x1,%ax
  806a78:	0f 84 c2 fe ff ff    	je     806940 <ip_input+0x1bb>
      if (!ip_addr_isbroadcast(&(iphdr->dest), inp) &&
  806a7e:	83 ec 08             	sub    $0x8,%esp
  806a81:	ff 75 0c             	pushl  0xc(%ebp)
  806a84:	8d 47 10             	lea    0x10(%edi),%eax
  806a87:	50                   	push   %eax
  806a88:	e8 50 fc ff ff       	call   8066dd <ip_addr_isbroadcast>
  806a8d:	83 c4 10             	add    $0x10,%esp
  806a90:	84 c0                	test   %al,%al
  806a92:	0f 84 be fe ff ff    	je     806956 <ip_input+0x1d1>
      pbuf_free(p);
  806a98:	83 ec 0c             	sub    $0xc,%esp
  806a9b:	ff 75 08             	pushl  0x8(%ebp)
  806a9e:	e8 7e df ff ff       	call   804a21 <pbuf_free>
  806aa3:	83 c4 10             	add    $0x10,%esp
  806aa6:	e9 11 fd ff ff       	jmp    8067bc <ip_input+0x37>

00806aab <ip_output_if>:
 */
err_t
ip_output_if(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
             u8_t ttl, u8_t tos,
             u8_t proto, struct netif *netif)
{
  806aab:	f3 0f 1e fb          	endbr32 
  806aaf:	55                   	push   %ebp
  806ab0:	89 e5                	mov    %esp,%ebp
  806ab2:	57                   	push   %edi
  806ab3:	56                   	push   %esi
  806ab4:	53                   	push   %ebx
  806ab5:	83 ec 1c             	sub    $0x1c,%esp
  806ab8:	8b 75 08             	mov    0x8(%ebp),%esi
  806abb:	8b 7d 14             	mov    0x14(%ebp),%edi
  806abe:	8b 45 18             	mov    0x18(%ebp),%eax
  806ac1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  806ac4:	8b 45 1c             	mov    0x1c(%ebp),%eax
  806ac7:	89 45 e0             	mov    %eax,-0x20(%ebp)
  static u16_t ip_id = 0;

  snmp_inc_ipoutrequests();

  /* Should the IP header be generated or is it already included in p? */
  if (dest != IP_HDRINCL) {
  806aca:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  806ace:	0f 84 37 01 00 00    	je     806c0b <ip_output_if+0x160>
    /* generate IP header */
    if (pbuf_header(p, IP_HLEN)) {
  806ad4:	83 ec 08             	sub    $0x8,%esp
  806ad7:	6a 14                	push   $0x14
  806ad9:	56                   	push   %esi
  806ada:	e8 6f de ff ff       	call   80494e <pbuf_header>
  806adf:	83 c4 10             	add    $0x10,%esp
  806ae2:	84 c0                	test   %al,%al
  806ae4:	0f 85 40 01 00 00    	jne    806c2a <ip_output_if+0x17f>
      IP_STATS_INC(ip.err);
      snmp_inc_ipoutdiscards();
      return ERR_BUF;
    }

    iphdr = p->payload;
  806aea:	8b 5e 04             	mov    0x4(%esi),%ebx
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
  806aed:	66 83 7e 0a 13       	cmpw   $0x13,0xa(%esi)
  806af2:	0f 86 f7 00 00 00    	jbe    806bef <ip_output_if+0x144>
               (p->len >= sizeof(struct ip_hdr)));

    IPH_TTL_SET(iphdr, ttl);
  806af8:	83 ec 0c             	sub    $0xc,%esp
  806afb:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  806aff:	50                   	push   %eax
  806b00:	e8 65 0e 00 00       	call   80796a <ntohs>
  806b05:	0f b6 c0             	movzbl %al,%eax
  806b08:	c1 e7 08             	shl    $0x8,%edi
  806b0b:	09 c7                	or     %eax,%edi
  806b0d:	0f b7 ff             	movzwl %di,%edi
  806b10:	89 3c 24             	mov    %edi,(%esp)
  806b13:	e8 41 0e 00 00       	call   807959 <htons>
  806b18:	66 89 43 08          	mov    %ax,0x8(%ebx)
    IPH_PROTO_SET(iphdr, proto);
  806b1c:	0f b7 c0             	movzwl %ax,%eax
  806b1f:	89 04 24             	mov    %eax,(%esp)
  806b22:	e8 43 0e 00 00       	call   80796a <ntohs>
  806b27:	89 c2                	mov    %eax,%edx
  806b29:	81 e2 00 ff 00 00    	and    $0xff00,%edx
  806b2f:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
  806b33:	09 d0                	or     %edx,%eax
  806b35:	0f b7 c0             	movzwl %ax,%eax
  806b38:	89 04 24             	mov    %eax,(%esp)
  806b3b:	e8 19 0e 00 00       	call   807959 <htons>
  806b40:	66 89 43 08          	mov    %ax,0x8(%ebx)

    ip_addr_set(&(iphdr->dest), dest);
  806b44:	8b 45 10             	mov    0x10(%ebp),%eax
  806b47:	8b 00                	mov    (%eax),%eax
  806b49:	89 43 10             	mov    %eax,0x10(%ebx)

    IPH_VHLTOS_SET(iphdr, 4, IP_HLEN / 4, tos);
  806b4c:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  806b50:	80 cc 45             	or     $0x45,%ah
  806b53:	89 04 24             	mov    %eax,(%esp)
  806b56:	e8 fe 0d 00 00       	call   807959 <htons>
  806b5b:	66 89 03             	mov    %ax,(%ebx)
    IPH_LEN_SET(iphdr, htons(p->tot_len));
  806b5e:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  806b62:	89 04 24             	mov    %eax,(%esp)
  806b65:	e8 ef 0d 00 00       	call   807959 <htons>
  806b6a:	66 89 43 02          	mov    %ax,0x2(%ebx)
    IPH_OFFSET_SET(iphdr, 0);
  806b6e:	66 c7 43 06 00 00    	movw   $0x0,0x6(%ebx)
    IPH_ID_SET(iphdr, htons(ip_id));
  806b74:	0f b7 05 fa 43 b3 00 	movzwl 0xb343fa,%eax
  806b7b:	89 04 24             	mov    %eax,(%esp)
  806b7e:	e8 d6 0d 00 00       	call   807959 <htons>
  806b83:	66 89 43 04          	mov    %ax,0x4(%ebx)
    ++ip_id;
  806b87:	66 83 05 fa 43 b3 00 	addw   $0x1,0xb343fa
  806b8e:	01 

    if (ip_addr_isany(src)) {
  806b8f:	83 c4 10             	add    $0x10,%esp
  806b92:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  806b96:	74 09                	je     806ba1 <ip_output_if+0xf6>
  806b98:	8b 45 0c             	mov    0xc(%ebp),%eax
  806b9b:	8b 00                	mov    (%eax),%eax
  806b9d:	85 c0                	test   %eax,%eax
  806b9f:	75 65                	jne    806c06 <ip_output_if+0x15b>
      ip_addr_set(&(iphdr->src), &(netif->ip_addr));
  806ba1:	8b 45 20             	mov    0x20(%ebp),%eax
  806ba4:	8b 40 04             	mov    0x4(%eax),%eax
  806ba7:	89 43 0c             	mov    %eax,0xc(%ebx)
    } else {
      ip_addr_set(&(iphdr->src), src);
    }

    IPH_CHKSUM_SET(iphdr, 0);
  806baa:	66 c7 43 0a 00 00    	movw   $0x0,0xa(%ebx)
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  806bb0:	83 ec 08             	sub    $0x8,%esp
  806bb3:	6a 14                	push   $0x14
  806bb5:	53                   	push   %ebx
  806bb6:	e8 64 0c 00 00       	call   80781f <inet_chksum>
  806bbb:	66 89 43 0a          	mov    %ax,0xa(%ebx)
  806bbf:	83 c4 10             	add    $0x10,%esp
    dest = &(iphdr->dest);
  }

#if IP_FRAG
  /* don't fragment if interface has mtu set to 0 [loopif] */
  if (netif->mtu && (p->tot_len > netif->mtu))
  806bc2:	8b 45 20             	mov    0x20(%ebp),%eax
  806bc5:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
  806bc9:	66 85 c0             	test   %ax,%ax
  806bcc:	74 06                	je     806bd4 <ip_output_if+0x129>
  806bce:	66 3b 46 08          	cmp    0x8(%esi),%ax
  806bd2:	72 42                	jb     806c16 <ip_output_if+0x16b>
  } else
#endif /* (LWIP_NETIF_LOOPBACK || LWIP_HAVE_LOOPIF) */
  {
    LWIP_DEBUGF(IP_DEBUG, ("netif->output()"));

    return netif->output(netif, p, dest);
  806bd4:	83 ec 04             	sub    $0x4,%esp
  806bd7:	ff 75 10             	pushl  0x10(%ebp)
  806bda:	56                   	push   %esi
  806bdb:	ff 75 20             	pushl  0x20(%ebp)
  806bde:	8b 45 20             	mov    0x20(%ebp),%eax
  806be1:	ff 50 14             	call   *0x14(%eax)
  806be4:	83 c4 10             	add    $0x10,%esp
  }
}
  806be7:	8d 65 f4             	lea    -0xc(%ebp),%esp
  806bea:	5b                   	pop    %ebx
  806beb:	5e                   	pop    %esi
  806bec:	5f                   	pop    %edi
  806bed:	5d                   	pop    %ebp
  806bee:	c3                   	ret    
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
  806bef:	83 ec 04             	sub    $0x4,%esp
  806bf2:	68 0c 24 81 00       	push   $0x81240c
  806bf7:	68 ed 01 00 00       	push   $0x1ed
  806bfc:	68 39 24 81 00       	push   $0x812439
  806c01:	e8 41 7d 00 00       	call   80e947 <_panic>
      ip_addr_set(&(iphdr->src), src);
  806c06:	89 43 0c             	mov    %eax,0xc(%ebx)
  806c09:	eb 9f                	jmp    806baa <ip_output_if+0xff>
    dest = &(iphdr->dest);
  806c0b:	8b 46 04             	mov    0x4(%esi),%eax
  806c0e:	83 c0 10             	add    $0x10,%eax
  806c11:	89 45 10             	mov    %eax,0x10(%ebp)
  806c14:	eb ac                	jmp    806bc2 <ip_output_if+0x117>
    return ip_frag(p,netif,dest);
  806c16:	83 ec 04             	sub    $0x4,%esp
  806c19:	ff 75 10             	pushl  0x10(%ebp)
  806c1c:	ff 75 20             	pushl  0x20(%ebp)
  806c1f:	56                   	push   %esi
  806c20:	e8 5f 07 00 00       	call   807384 <ip_frag>
  806c25:	83 c4 10             	add    $0x10,%esp
  806c28:	eb bd                	jmp    806be7 <ip_output_if+0x13c>
      return ERR_BUF;
  806c2a:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  806c2f:	eb b6                	jmp    806be7 <ip_output_if+0x13c>

00806c31 <ip_output>:
 *         see ip_output_if() for more return values
 */
err_t
ip_output(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
          u8_t ttl, u8_t tos, u8_t proto)
{
  806c31:	f3 0f 1e fb          	endbr32 
  806c35:	55                   	push   %ebp
  806c36:	89 e5                	mov    %esp,%ebp
  806c38:	57                   	push   %edi
  806c39:	56                   	push   %esi
  806c3a:	53                   	push   %ebx
  806c3b:	83 ec 18             	sub    $0x18,%esp
  806c3e:	8b 5d 14             	mov    0x14(%ebp),%ebx
  806c41:	8b 75 18             	mov    0x18(%ebp),%esi
  806c44:	8b 7d 1c             	mov    0x1c(%ebp),%edi
  struct netif *netif;

  if ((netif = ip_route(dest)) == NULL) {
  806c47:	ff 75 10             	pushl  0x10(%ebp)
  806c4a:	e8 d5 fa ff ff       	call   806724 <ip_route>
  806c4f:	83 c4 10             	add    $0x10,%esp
  806c52:	85 c0                	test   %eax,%eax
  806c54:	74 2d                	je     806c83 <ip_output+0x52>
    return ERR_RTE;
  }

  return ip_output_if(p, src, dest, ttl, tos, proto, netif);
  806c56:	83 ec 04             	sub    $0x4,%esp
  806c59:	50                   	push   %eax
  806c5a:	89 f8                	mov    %edi,%eax
  806c5c:	0f b6 f8             	movzbl %al,%edi
  806c5f:	57                   	push   %edi
  806c60:	89 f0                	mov    %esi,%eax
  806c62:	0f b6 f0             	movzbl %al,%esi
  806c65:	56                   	push   %esi
  806c66:	0f b6 db             	movzbl %bl,%ebx
  806c69:	53                   	push   %ebx
  806c6a:	ff 75 10             	pushl  0x10(%ebp)
  806c6d:	ff 75 0c             	pushl  0xc(%ebp)
  806c70:	ff 75 08             	pushl  0x8(%ebp)
  806c73:	e8 33 fe ff ff       	call   806aab <ip_output_if>
  806c78:	83 c4 20             	add    $0x20,%esp
}
  806c7b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  806c7e:	5b                   	pop    %ebx
  806c7f:	5e                   	pop    %esi
  806c80:	5f                   	pop    %edi
  806c81:	5d                   	pop    %ebp
  806c82:	c3                   	ret    
    return ERR_RTE;
  806c83:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  806c88:	eb f1                	jmp    806c7b <ip_output+0x4a>

00806c8a <ip_reass_dequeue_datagram>:
 * Dequeues a datagram from the datagram queue. Doesn't deallocate the pbufs.
 * @param ipr points to the queue entry to dequeue
 */
static void
ip_reass_dequeue_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
  806c8a:	55                   	push   %ebp
  806c8b:	89 e5                	mov    %esp,%ebp
  806c8d:	83 ec 08             	sub    $0x8,%esp
  
  /* dequeue the reass struct  */
  if (reassdatagrams == ipr) {
  806c90:	39 05 e0 49 b3 00    	cmp    %eax,0xb349e0
  806c96:	74 18                	je     806cb0 <ip_reass_dequeue_datagram+0x26>
    /* it was the first in the list */
    reassdatagrams = ipr->next;
  } else {
    /* it wasn't the first, so it must have a valid 'prev' */
    LWIP_ASSERT("sanity check linked list", prev != NULL);
  806c98:	85 d2                	test   %edx,%edx
  806c9a:	74 1e                	je     806cba <ip_reass_dequeue_datagram+0x30>
    prev->next = ipr->next;
  806c9c:	8b 08                	mov    (%eax),%ecx
  806c9e:	89 0a                	mov    %ecx,(%edx)
  }

  /* now we can free the ip_reass struct */
  memp_free(MEMP_REASSDATA, ipr);
  806ca0:	83 ec 08             	sub    $0x8,%esp
  806ca3:	50                   	push   %eax
  806ca4:	6a 05                	push   $0x5
  806ca6:	e8 f3 d9 ff ff       	call   80469e <memp_free>
}
  806cab:	83 c4 10             	add    $0x10,%esp
  806cae:	c9                   	leave  
  806caf:	c3                   	ret    
    reassdatagrams = ipr->next;
  806cb0:	8b 10                	mov    (%eax),%edx
  806cb2:	89 15 e0 49 b3 00    	mov    %edx,0xb349e0
  806cb8:	eb e6                	jmp    806ca0 <ip_reass_dequeue_datagram+0x16>
    LWIP_ASSERT("sanity check linked list", prev != NULL);
  806cba:	83 ec 04             	sub    $0x4,%esp
  806cbd:	68 51 24 81 00       	push   $0x812451
  806cc2:	68 29 01 00 00       	push   $0x129
  806cc7:	68 6a 24 81 00       	push   $0x81246a
  806ccc:	e8 76 7c 00 00       	call   80e947 <_panic>

00806cd1 <ip_reass_free_complete_datagram>:
{
  806cd1:	55                   	push   %ebp
  806cd2:	89 e5                	mov    %esp,%ebp
  806cd4:	57                   	push   %edi
  806cd5:	56                   	push   %esi
  806cd6:	53                   	push   %ebx
  806cd7:	83 ec 1c             	sub    $0x1c,%esp
  806cda:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  806cdd:	89 55 e0             	mov    %edx,-0x20(%ebp)
  LWIP_ASSERT("prev != ipr", prev != ipr);
  806ce0:	39 c2                	cmp    %eax,%edx
  806ce2:	74 2e                	je     806d12 <ip_reass_free_complete_datagram+0x41>
  if (prev != NULL) {
  806ce4:	8b 45 e0             	mov    -0x20(%ebp),%eax
  806ce7:	85 c0                	test   %eax,%eax
  806ce9:	74 07                	je     806cf2 <ip_reass_free_complete_datagram+0x21>
    LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
  806ceb:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  806cee:	39 08                	cmp    %ecx,(%eax)
  806cf0:	75 37                	jne    806d29 <ip_reass_free_complete_datagram+0x58>
  iprh = (struct ip_reass_helper *)ipr->p->payload;
  806cf2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  806cf5:	8b 58 04             	mov    0x4(%eax),%ebx
  806cf8:	8b 43 04             	mov    0x4(%ebx),%eax
  int pbufs_freed = 0;
  806cfb:	be 00 00 00 00       	mov    $0x0,%esi
  if (iprh->start == 0) {
  806d00:	66 83 78 04 00       	cmpw   $0x0,0x4(%eax)
  806d05:	74 39                	je     806d40 <ip_reass_free_complete_datagram+0x6f>
  p = ipr->p;
  806d07:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  806d0a:	8b 58 04             	mov    0x4(%eax),%ebx
  while (p != NULL) {
  806d0d:	e9 8a 00 00 00       	jmp    806d9c <ip_reass_free_complete_datagram+0xcb>
  LWIP_ASSERT("prev != ipr", prev != ipr);
  806d12:	83 ec 04             	sub    $0x4,%esp
  806d15:	68 87 24 81 00       	push   $0x812487
  806d1a:	68 99 00 00 00       	push   $0x99
  806d1f:	68 6a 24 81 00       	push   $0x81246a
  806d24:	e8 1e 7c 00 00       	call   80e947 <_panic>
    LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
  806d29:	83 ec 04             	sub    $0x4,%esp
  806d2c:	68 93 24 81 00       	push   $0x812493
  806d31:	68 9b 00 00 00       	push   $0x9b
  806d36:	68 6a 24 81 00       	push   $0x81246a
  806d3b:	e8 07 7c 00 00       	call   80e947 <_panic>
    ipr->p = iprh->next_pbuf;
  806d40:	8b 00                	mov    (%eax),%eax
  806d42:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  806d45:	89 42 04             	mov    %eax,0x4(%edx)
    SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
  806d48:	83 ec 04             	sub    $0x4,%esp
  806d4b:	6a 14                	push   $0x14
  806d4d:	8d 42 08             	lea    0x8(%edx),%eax
  806d50:	50                   	push   %eax
  806d51:	ff 73 04             	pushl  0x4(%ebx)
  806d54:	e8 fb 84 00 00       	call   80f254 <memcpy>
    icmp_time_exceeded(p, ICMP_TE_FRAG);
  806d59:	83 c4 08             	add    $0x8,%esp
  806d5c:	6a 01                	push   $0x1
  806d5e:	53                   	push   %ebx
  806d5f:	e8 94 7a 00 00       	call   80e7f8 <icmp_time_exceeded>
    pbufs_freed += pbuf_clen(p);
  806d64:	89 1c 24             	mov    %ebx,(%esp)
  806d67:	e8 f4 e0 ff ff       	call   804e60 <pbuf_clen>
  806d6c:	0f b6 f0             	movzbl %al,%esi
    pbuf_free(p);
  806d6f:	89 1c 24             	mov    %ebx,(%esp)
  806d72:	e8 aa dc ff ff       	call   804a21 <pbuf_free>
  806d77:	83 c4 10             	add    $0x10,%esp
  806d7a:	eb 8b                	jmp    806d07 <ip_reass_free_complete_datagram+0x36>
    iprh = (struct ip_reass_helper *)p->payload;
  806d7c:	8b 43 04             	mov    0x4(%ebx),%eax
    p = iprh->next_pbuf;
  806d7f:	8b 38                	mov    (%eax),%edi
    pbufs_freed += pbuf_clen(pcur);
  806d81:	83 ec 0c             	sub    $0xc,%esp
  806d84:	53                   	push   %ebx
  806d85:	e8 d6 e0 ff ff       	call   804e60 <pbuf_clen>
  806d8a:	0f b6 c0             	movzbl %al,%eax
  806d8d:	01 c6                	add    %eax,%esi
    pbuf_free(pcur);    
  806d8f:	89 1c 24             	mov    %ebx,(%esp)
  806d92:	e8 8a dc ff ff       	call   804a21 <pbuf_free>
  806d97:	83 c4 10             	add    $0x10,%esp
    p = iprh->next_pbuf;
  806d9a:	89 fb                	mov    %edi,%ebx
  while (p != NULL) {
  806d9c:	85 db                	test   %ebx,%ebx
  806d9e:	75 dc                	jne    806d7c <ip_reass_free_complete_datagram+0xab>
  ip_reass_dequeue_datagram(ipr, prev);
  806da0:	8b 55 e0             	mov    -0x20(%ebp),%edx
  806da3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  806da6:	e8 df fe ff ff       	call   806c8a <ip_reass_dequeue_datagram>
  LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= pbufs_freed);
  806dab:	0f b7 05 dc 49 b3 00 	movzwl 0xb349dc,%eax
  806db2:	0f b7 d0             	movzwl %ax,%edx
  806db5:	39 f2                	cmp    %esi,%edx
  806db7:	7c 12                	jl     806dcb <ip_reass_free_complete_datagram+0xfa>
  ip_reass_pbufcount -= pbufs_freed;
  806db9:	29 f0                	sub    %esi,%eax
  806dbb:	66 a3 dc 49 b3 00    	mov    %ax,0xb349dc
}
  806dc1:	89 f0                	mov    %esi,%eax
  806dc3:	8d 65 f4             	lea    -0xc(%ebp),%esp
  806dc6:	5b                   	pop    %ebx
  806dc7:	5e                   	pop    %esi
  806dc8:	5f                   	pop    %edi
  806dc9:	5d                   	pop    %ebp
  806dca:	c3                   	ret    
  LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= pbufs_freed);
  806dcb:	83 ec 04             	sub    $0x4,%esp
  806dce:	68 a5 24 81 00       	push   $0x8124a5
  806dd3:	68 bc 00 00 00       	push   $0xbc
  806dd8:	68 6a 24 81 00       	push   $0x81246a
  806ddd:	e8 65 7b 00 00       	call   80e947 <_panic>

00806de2 <ip_reass_remove_oldest_datagram>:
{
  806de2:	55                   	push   %ebp
  806de3:	89 e5                	mov    %esp,%ebp
  806de5:	57                   	push   %edi
  806de6:	56                   	push   %esi
  806de7:	53                   	push   %ebx
  806de8:	83 ec 1c             	sub    $0x1c,%esp
  806deb:	89 c6                	mov    %eax,%esi
  806ded:	89 55 e0             	mov    %edx,-0x20(%ebp)
  int pbufs_freed = 0, pbufs_freed_current;
  806df0:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  806df7:	eb 5b                	jmp    806e54 <ip_reass_remove_oldest_datagram+0x72>
        other_datagrams++;
  806df9:	83 c3 01             	add    $0x1,%ebx
        if (oldest == NULL) {
  806dfc:	85 c9                	test   %ecx,%ecx
  806dfe:	74 33                	je     806e33 <ip_reass_remove_oldest_datagram+0x51>
          oldest = r;
  806e00:	0f b6 51 1f          	movzbl 0x1f(%ecx),%edx
  806e04:	38 50 1f             	cmp    %dl,0x1f(%eax)
  806e07:	0f 46 c8             	cmovbe %eax,%ecx
      if (r->next != NULL) {
  806e0a:	8b 10                	mov    (%eax),%edx
        prev = r;
  806e0c:	85 d2                	test   %edx,%edx
  806e0e:	0f 45 f8             	cmovne %eax,%edi
  806e11:	89 d0                	mov    %edx,%eax
    while (r != NULL) {
  806e13:	85 c0                	test   %eax,%eax
  806e15:	74 20                	je     806e37 <ip_reass_remove_oldest_datagram+0x55>
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
  806e17:	8b 56 0c             	mov    0xc(%esi),%edx
  806e1a:	39 50 14             	cmp    %edx,0x14(%eax)
  806e1d:	75 da                	jne    806df9 <ip_reass_remove_oldest_datagram+0x17>
  806e1f:	8b 56 10             	mov    0x10(%esi),%edx
  806e22:	39 50 18             	cmp    %edx,0x18(%eax)
  806e25:	75 d2                	jne    806df9 <ip_reass_remove_oldest_datagram+0x17>
  806e27:	0f b7 56 04          	movzwl 0x4(%esi),%edx
  806e2b:	66 39 50 0c          	cmp    %dx,0xc(%eax)
  806e2f:	75 c8                	jne    806df9 <ip_reass_remove_oldest_datagram+0x17>
  806e31:	eb d7                	jmp    806e0a <ip_reass_remove_oldest_datagram+0x28>
          oldest = r;
  806e33:	89 c1                	mov    %eax,%ecx
  806e35:	eb d3                	jmp    806e0a <ip_reass_remove_oldest_datagram+0x28>
    if (oldest != NULL) {
  806e37:	85 c9                	test   %ecx,%ecx
  806e39:	74 0c                	je     806e47 <ip_reass_remove_oldest_datagram+0x65>
      pbufs_freed_current = ip_reass_free_complete_datagram(oldest, prev);
  806e3b:	89 fa                	mov    %edi,%edx
  806e3d:	89 c8                	mov    %ecx,%eax
  806e3f:	e8 8d fe ff ff       	call   806cd1 <ip_reass_free_complete_datagram>
      pbufs_freed += pbufs_freed_current;
  806e44:	01 45 e4             	add    %eax,-0x1c(%ebp)
  } while ((pbufs_freed < pbufs_needed) && (other_datagrams > 1));
  806e47:	8b 7d e0             	mov    -0x20(%ebp),%edi
  806e4a:	39 7d e4             	cmp    %edi,-0x1c(%ebp)
  806e4d:	7d 1b                	jge    806e6a <ip_reass_remove_oldest_datagram+0x88>
  806e4f:	83 fb 01             	cmp    $0x1,%ebx
  806e52:	7e 16                	jle    806e6a <ip_reass_remove_oldest_datagram+0x88>
    r = reassdatagrams;
  806e54:	a1 e0 49 b3 00       	mov    0xb349e0,%eax
    other_datagrams = 0;
  806e59:	bb 00 00 00 00       	mov    $0x0,%ebx
    prev = NULL;
  806e5e:	bf 00 00 00 00       	mov    $0x0,%edi
    oldest = NULL;
  806e63:	b9 00 00 00 00       	mov    $0x0,%ecx
    while (r != NULL) {
  806e68:	eb a9                	jmp    806e13 <ip_reass_remove_oldest_datagram+0x31>
}
  806e6a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  806e6d:	83 c4 1c             	add    $0x1c,%esp
  806e70:	5b                   	pop    %ebx
  806e71:	5e                   	pop    %esi
  806e72:	5f                   	pop    %edi
  806e73:	5d                   	pop    %ebp
  806e74:	c3                   	ret    

00806e75 <ip_reass_tmr>:
{
  806e75:	f3 0f 1e fb          	endbr32 
  806e79:	55                   	push   %ebp
  806e7a:	89 e5                	mov    %esp,%ebp
  806e7c:	56                   	push   %esi
  806e7d:	53                   	push   %ebx
  r = reassdatagrams;
  806e7e:	a1 e0 49 b3 00       	mov    0xb349e0,%eax
  struct ip_reassdata *r, *prev = NULL;
  806e83:	bb 00 00 00 00       	mov    $0x0,%ebx
  while (r != NULL) {
  806e88:	eb 0b                	jmp    806e95 <ip_reass_tmr+0x20>
      r = r->next;
  806e8a:	8b 30                	mov    (%eax),%esi
      ip_reass_free_complete_datagram(tmp, prev);
  806e8c:	89 da                	mov    %ebx,%edx
  806e8e:	e8 3e fe ff ff       	call   806cd1 <ip_reass_free_complete_datagram>
      r = r->next;
  806e93:	89 f0                	mov    %esi,%eax
  while (r != NULL) {
  806e95:	85 c0                	test   %eax,%eax
  806e97:	74 14                	je     806ead <ip_reass_tmr+0x38>
    if (r->timer > 0) {
  806e99:	0f b6 50 1f          	movzbl 0x1f(%eax),%edx
  806e9d:	84 d2                	test   %dl,%dl
  806e9f:	74 e9                	je     806e8a <ip_reass_tmr+0x15>
      r->timer--;
  806ea1:	83 ea 01             	sub    $0x1,%edx
  806ea4:	88 50 1f             	mov    %dl,0x1f(%eax)
      prev = r;
  806ea7:	89 c3                	mov    %eax,%ebx
      r = r->next;
  806ea9:	8b 00                	mov    (%eax),%eax
  806eab:	eb e8                	jmp    806e95 <ip_reass_tmr+0x20>
}
  806ead:	5b                   	pop    %ebx
  806eae:	5e                   	pop    %esi
  806eaf:	5d                   	pop    %ebp
  806eb0:	c3                   	ret    

00806eb1 <ip_reass>:
 * @param p points to a pbuf chain of the fragment
 * @return NULL if reassembly is incomplete, ? otherwise
 */
struct pbuf *
ip_reass(struct pbuf *p)
{
  806eb1:	f3 0f 1e fb          	endbr32 
  806eb5:	55                   	push   %ebp
  806eb6:	89 e5                	mov    %esp,%ebp
  806eb8:	57                   	push   %edi
  806eb9:	56                   	push   %esi
  806eba:	53                   	push   %ebx
  806ebb:	83 ec 38             	sub    $0x38,%esp
  struct ip_reassdata *ipr_prev = NULL;

  IPFRAG_STATS_INC(ip_frag.recv);
  snmp_inc_ipreasmreqds();

  fraghdr = (struct ip_hdr*)p->payload;
  806ebe:	8b 45 08             	mov    0x8(%ebp),%eax
  806ec1:	8b 58 04             	mov    0x4(%eax),%ebx

  if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
  806ec4:	0f b7 03             	movzwl (%ebx),%eax
  806ec7:	50                   	push   %eax
  806ec8:	e8 9d 0a 00 00       	call   80796a <ntohs>
  806ecd:	66 c1 e8 08          	shr    $0x8,%ax
  806ed1:	83 e0 0f             	and    $0xf,%eax
  806ed4:	83 c4 10             	add    $0x10,%esp
  806ed7:	83 f8 05             	cmp    $0x5,%eax
  806eda:	0f 85 de 01 00 00    	jne    8070be <ip_reass+0x20d>
    LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: IP options currently not supported!\n"));
    IPFRAG_STATS_INC(ip_frag.err);
    goto nullreturn;
  }

  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  806ee0:	83 ec 0c             	sub    $0xc,%esp
  806ee3:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  806ee7:	50                   	push   %eax
  806ee8:	e8 7d 0a 00 00       	call   80796a <ntohs>
  806eed:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  806ef1:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  806ef5:	89 04 24             	mov    %eax,(%esp)
  806ef8:	e8 6d 0a 00 00       	call   80796a <ntohs>
  806efd:	66 89 45 de          	mov    %ax,-0x22(%ebp)
  806f01:	0f b7 03             	movzwl (%ebx),%eax
  806f04:	89 04 24             	mov    %eax,(%esp)
  806f07:	e8 5e 0a 00 00       	call   80796a <ntohs>
  806f0c:	66 89 45 d8          	mov    %ax,-0x28(%ebp)

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
  806f10:	83 c4 04             	add    $0x4,%esp
  806f13:	ff 75 08             	pushl  0x8(%ebp)
  806f16:	e8 45 df ff ff       	call   804e60 <pbuf_clen>
  806f1b:	88 45 e4             	mov    %al,-0x1c(%ebp)
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
  806f1e:	0f b6 f0             	movzbl %al,%esi
  806f21:	0f b7 05 dc 49 b3 00 	movzwl 0xb349dc,%eax
  806f28:	01 f0                	add    %esi,%eax
  806f2a:	83 c4 10             	add    $0x10,%esp
  806f2d:	83 f8 0a             	cmp    $0xa,%eax
  806f30:	7f 0d                	jg     806f3f <ip_reass+0x8e>
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  806f32:	8b 3d e0 49 b3 00    	mov    0xb349e0,%edi
  struct ip_reassdata *ipr_prev = NULL;
  806f38:	b8 00 00 00 00       	mov    $0x0,%eax
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  806f3d:	eb 28                	jmp    806f67 <ip_reass+0xb6>
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
  806f3f:	89 f2                	mov    %esi,%edx
  806f41:	89 d8                	mov    %ebx,%eax
  806f43:	e8 9a fe ff ff       	call   806de2 <ip_reass_remove_oldest_datagram>
  806f48:	85 c0                	test   %eax,%eax
  806f4a:	0f 84 6e 01 00 00    	je     8070be <ip_reass+0x20d>
        ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS))
  806f50:	0f b7 05 dc 49 b3 00 	movzwl 0xb349dc,%eax
  806f57:	01 f0                	add    %esi,%eax
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
  806f59:	83 f8 0a             	cmp    $0xa,%eax
  806f5c:	7e d4                	jle    806f32 <ip_reass+0x81>
  806f5e:	e9 5b 01 00 00       	jmp    8070be <ip_reass+0x20d>
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  806f63:	89 f8                	mov    %edi,%eax
  806f65:	8b 3f                	mov    (%edi),%edi
  806f67:	85 ff                	test   %edi,%edi
  806f69:	0f 84 f7 00 00 00    	je     807066 <ip_reass+0x1b5>
    /* Check if the incoming fragment matches the one currently present
       in the reassembly buffer. If so, we proceed with copying the
       fragment into the buffer. */
    if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
  806f6f:	8b 4b 0c             	mov    0xc(%ebx),%ecx
  806f72:	39 4f 14             	cmp    %ecx,0x14(%edi)
  806f75:	75 ec                	jne    806f63 <ip_reass+0xb2>
  806f77:	8b 53 10             	mov    0x10(%ebx),%edx
  806f7a:	39 57 18             	cmp    %edx,0x18(%edi)
  806f7d:	75 e4                	jne    806f63 <ip_reass+0xb2>
  806f7f:	0f b7 53 04          	movzwl 0x4(%ebx),%edx
  806f83:	66 39 57 0c          	cmp    %dx,0xc(%edi)
  806f87:	75 da                	jne    806f63 <ip_reass+0xb2>
  806f89:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
      goto nullreturn;
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
  806f8c:	83 ec 0c             	sub    $0xc,%esp
  806f8f:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  806f93:	50                   	push   %eax
  806f94:	e8 d1 09 00 00       	call   80796a <ntohs>
  806f99:	83 c4 10             	add    $0x10,%esp
  806f9c:	66 a9 ff 1f          	test   $0x1fff,%ax
  806fa0:	0f 84 4d 01 00 00    	je     8070f3 <ip_reass+0x242>
      SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
    }
  }
  /* Track the current number of pbufs current 'in-flight', in order to limit 
  the number of fragments that may be enqueued at any one time */
  ip_reass_pbufcount += clen;
  806fa6:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  806faa:	66 01 05 dc 49 b3 00 	add    %ax,0xb349dc

  /* At this point, we have either created a new entry or pointing 
   * to an existing one */

  /* check for 'no more fragments', and update queue entry*/
  if ((ntohs(IPH_OFFSET(fraghdr)) & IP_MF) == 0) {
  806fb1:	83 ec 0c             	sub    $0xc,%esp
  806fb4:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  806fb8:	50                   	push   %eax
  806fb9:	e8 ac 09 00 00       	call   80796a <ntohs>
  806fbe:	83 c4 10             	add    $0x10,%esp
  806fc1:	f6 c4 20             	test   $0x20,%ah
  806fc4:	75 20                	jne    806fe6 <ip_reass+0x135>
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
  806fc6:	80 4f 1e 01          	orb    $0x1,0x1e(%edi)
    ipr->datagram_len = offset + len;
  806fca:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  806fce:	0f b7 75 de          	movzwl -0x22(%ebp),%esi
  806fd2:	8d 04 c6             	lea    (%esi,%eax,8),%eax
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  806fd5:	0f b7 55 d8          	movzwl -0x28(%ebp),%edx
  806fd9:	66 c1 ea 06          	shr    $0x6,%dx
  806fdd:	83 e2 3c             	and    $0x3c,%edx
    ipr->datagram_len = offset + len;
  806fe0:	29 d0                	sub    %edx,%eax
  806fe2:	66 89 47 1c          	mov    %ax,0x1c(%edi)
  fraghdr = (struct ip_hdr*)new_p->payload; 
  806fe6:	8b 45 08             	mov    0x8(%ebp),%eax
  806fe9:	8b 70 04             	mov    0x4(%eax),%esi
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  806fec:	83 ec 0c             	sub    $0xc,%esp
  806fef:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  806ff3:	50                   	push   %eax
  806ff4:	e8 71 09 00 00       	call   80796a <ntohs>
  806ff9:	89 c3                	mov    %eax,%ebx
  806ffb:	0f b7 06             	movzwl (%esi),%eax
  806ffe:	89 04 24             	mov    %eax,(%esp)
  807001:	e8 64 09 00 00       	call   80796a <ntohs>
  807006:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  80700a:	0f b7 46 06          	movzwl 0x6(%esi),%eax
  80700e:	89 04 24             	mov    %eax,(%esp)
  807011:	e8 54 09 00 00       	call   80796a <ntohs>
  807016:	8d 0c c5 00 00 00 00 	lea    0x0(,%eax,8),%ecx
  iprh = (struct ip_reass_helper*)new_p->payload;
  80701d:	8b 55 08             	mov    0x8(%ebp),%edx
  807020:	8b 72 04             	mov    0x4(%edx),%esi
  807023:	89 75 e0             	mov    %esi,-0x20(%ebp)
  iprh->next_pbuf = NULL;
  807026:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
  iprh->start = offset;
  80702c:	66 89 4e 04          	mov    %cx,0x4(%esi)
  iprh->end = offset + len;
  807030:	01 cb                	add    %ecx,%ebx
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  807032:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  807036:	66 c1 e8 06          	shr    $0x6,%ax
  80703a:	83 e0 3c             	and    $0x3c,%eax
  iprh->end = offset + len;
  80703d:	29 c3                	sub    %eax,%ebx
  80703f:	66 89 5d de          	mov    %bx,-0x22(%ebp)
  807043:	66 89 5e 06          	mov    %bx,0x6(%esi)
  for (q = ipr->p; q != NULL;) {
  807047:	8b 47 04             	mov    0x4(%edi),%eax
  80704a:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80704d:	83 c4 10             	add    $0x10,%esp
  807050:	89 c3                	mov    %eax,%ebx
  int valid = 1;
  807052:	b8 01 00 00 00       	mov    $0x1,%eax
  struct ip_reass_helper *iprh, *iprh_tmp, *iprh_prev=NULL;
  807057:	be 00 00 00 00       	mov    $0x0,%esi
  80705c:	89 7d e4             	mov    %edi,-0x1c(%ebp)
  80705f:	89 c7                	mov    %eax,%edi
  for (q = ipr->p; q != NULL;) {
  807061:	e9 25 01 00 00       	jmp    80718b <ip_reass+0x2da>
  807066:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  ipr = memp_malloc(MEMP_REASSDATA);
  807069:	83 ec 0c             	sub    $0xc,%esp
  80706c:	6a 05                	push   $0x5
  80706e:	e8 d1 d5 ff ff       	call   804644 <memp_malloc>
  807073:	89 c7                	mov    %eax,%edi
  if (ipr == NULL) {
  807075:	83 c4 10             	add    $0x10,%esp
  807078:	85 c0                	test   %eax,%eax
  80707a:	74 35                	je     8070b1 <ip_reass+0x200>
  memset(ipr, 0, sizeof(struct ip_reassdata));
  80707c:	83 ec 04             	sub    $0x4,%esp
  80707f:	6a 20                	push   $0x20
  807081:	6a 00                	push   $0x0
  807083:	57                   	push   %edi
  807084:	e8 19 81 00 00       	call   80f1a2 <memset>
  ipr->timer = IP_REASS_MAXAGE;
  807089:	c6 47 1f 03          	movb   $0x3,0x1f(%edi)
  ipr->next = reassdatagrams;
  80708d:	a1 e0 49 b3 00       	mov    0xb349e0,%eax
  807092:	89 07                	mov    %eax,(%edi)
  reassdatagrams = ipr;
  807094:	89 3d e0 49 b3 00    	mov    %edi,0xb349e0
  SMEMCPY(&(ipr->iphdr), fraghdr, IP_HLEN);
  80709a:	83 c4 0c             	add    $0xc,%esp
  80709d:	6a 14                	push   $0x14
  80709f:	53                   	push   %ebx
  8070a0:	8d 47 08             	lea    0x8(%edi),%eax
  8070a3:	50                   	push   %eax
  8070a4:	e8 ab 81 00 00       	call   80f254 <memcpy>
  8070a9:	83 c4 10             	add    $0x10,%esp
  8070ac:	e9 f5 fe ff ff       	jmp    806fa6 <ip_reass+0xf5>
    if (ip_reass_remove_oldest_datagram(fraghdr, clen) >= clen) {
  8070b1:	89 f2                	mov    %esi,%edx
  8070b3:	89 d8                	mov    %ebx,%eax
  8070b5:	e8 28 fd ff ff       	call   806de2 <ip_reass_remove_oldest_datagram>
  8070ba:	39 c6                	cmp    %eax,%esi
  8070bc:	7e 20                	jle    8070de <ip_reass+0x22d>
  return NULL;

nullreturn:
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: nullreturn\n"));
  IPFRAG_STATS_INC(ip_frag.drop);
  pbuf_free(p);
  8070be:	83 ec 0c             	sub    $0xc,%esp
  8070c1:	ff 75 08             	pushl  0x8(%ebp)
  8070c4:	e8 58 d9 ff ff       	call   804a21 <pbuf_free>
  return NULL;
  8070c9:	83 c4 10             	add    $0x10,%esp
  8070cc:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
}
  8070d3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8070d6:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8070d9:	5b                   	pop    %ebx
  8070da:	5e                   	pop    %esi
  8070db:	5f                   	pop    %edi
  8070dc:	5d                   	pop    %ebp
  8070dd:	c3                   	ret    
      ipr = memp_malloc(MEMP_REASSDATA);
  8070de:	83 ec 0c             	sub    $0xc,%esp
  8070e1:	6a 05                	push   $0x5
  8070e3:	e8 5c d5 ff ff       	call   804644 <memp_malloc>
  8070e8:	89 c7                	mov    %eax,%edi
    if (ipr == NULL)
  8070ea:	83 c4 10             	add    $0x10,%esp
  8070ed:	85 c0                	test   %eax,%eax
  8070ef:	75 8b                	jne    80707c <ip_reass+0x1cb>
  8070f1:	eb cb                	jmp    8070be <ip_reass+0x20d>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
  8070f3:	83 ec 0c             	sub    $0xc,%esp
  8070f6:	0f b7 47 0e          	movzwl 0xe(%edi),%eax
  8070fa:	50                   	push   %eax
  8070fb:	e8 6a 08 00 00       	call   80796a <ntohs>
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
  807100:	83 c4 10             	add    $0x10,%esp
  807103:	66 a9 ff 1f          	test   $0x1fff,%ax
  807107:	0f 84 99 fe ff ff    	je     806fa6 <ip_reass+0xf5>
      SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
  80710d:	83 ec 04             	sub    $0x4,%esp
  807110:	6a 14                	push   $0x14
  807112:	53                   	push   %ebx
  807113:	8d 47 08             	lea    0x8(%edi),%eax
  807116:	50                   	push   %eax
  807117:	e8 38 81 00 00       	call   80f254 <memcpy>
  80711c:	83 c4 10             	add    $0x10,%esp
  80711f:	e9 82 fe ff ff       	jmp    806fa6 <ip_reass+0xf5>
  807124:	89 7d d0             	mov    %edi,-0x30(%ebp)
  807127:	8b 7d e4             	mov    -0x1c(%ebp),%edi
      iprh->next_pbuf = q;
  80712a:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80712d:	89 1a                	mov    %ebx,(%edx)
      if (iprh_prev != NULL) {
  80712f:	85 f6                	test   %esi,%esi
  807131:	74 4c                	je     80717f <ip_reass+0x2ce>
        if ((iprh->start < iprh_prev->end) || (iprh->end > iprh_tmp->start)) {
  807133:	66 3b 4e 06          	cmp    0x6(%esi),%cx
  807137:	0f 82 9f 01 00 00    	jb     8072dc <ip_reass+0x42b>
  80713d:	0f b7 4d de          	movzwl -0x22(%ebp),%ecx
  807141:	66 3b 48 04          	cmp    0x4(%eax),%cx
  807145:	0f 87 91 01 00 00    	ja     8072dc <ip_reass+0x42b>
        iprh_prev->next_pbuf = new_p;
  80714b:	8b 45 08             	mov    0x8(%ebp),%eax
  80714e:	89 06                	mov    %eax,(%esi)
  if ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0) {
  807150:	f6 47 1e 01          	testb  $0x1,0x1e(%edi)
  807154:	0f 84 a5 01 00 00    	je     8072ff <ip_reass+0x44e>
    if (valid) {
  80715a:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
  80715e:	0f 84 9b 01 00 00    	je     8072ff <ip_reass+0x44e>
      if (((struct ip_reass_helper*)ipr->p->payload)->start != 0) {
  807164:	8b 4f 04             	mov    0x4(%edi),%ecx
  807167:	8b 59 04             	mov    0x4(%ecx),%ebx
  80716a:	66 83 7b 04 00       	cmpw   $0x0,0x4(%ebx)
  80716f:	0f 85 8a 01 00 00    	jne    8072ff <ip_reass+0x44e>
        q = iprh->next_pbuf;
  807175:	8b 75 e0             	mov    -0x20(%ebp),%esi
  807178:	8b 16                	mov    (%esi),%edx
        while (q != NULL) {
  80717a:	e9 85 00 00 00       	jmp    807204 <ip_reass+0x353>
        ipr->p = new_p;
  80717f:	8b 45 08             	mov    0x8(%ebp),%eax
  807182:	89 47 04             	mov    %eax,0x4(%edi)
  807185:	eb c9                	jmp    807150 <ip_reass+0x29f>
    q = iprh_tmp->next_pbuf;
  807187:	8b 18                	mov    (%eax),%ebx
    iprh_tmp = (struct ip_reass_helper*)q->payload;
  807189:	89 c6                	mov    %eax,%esi
  for (q = ipr->p; q != NULL;) {
  80718b:	85 db                	test   %ebx,%ebx
  80718d:	0f 84 c3 01 00 00    	je     807356 <ip_reass+0x4a5>
    iprh_tmp = (struct ip_reass_helper*)q->payload;
  807193:	8b 43 04             	mov    0x4(%ebx),%eax
    if (iprh->start < iprh_tmp->start) {
  807196:	0f b7 50 04          	movzwl 0x4(%eax),%edx
  80719a:	66 39 d1             	cmp    %dx,%cx
  80719d:	72 85                	jb     807124 <ip_reass+0x273>
    } else if(iprh->start == iprh_tmp->start) {
  80719f:	0f 84 37 01 00 00    	je     8072dc <ip_reass+0x42b>
    } else if(iprh->start < iprh_tmp->end) {
  8071a5:	66 3b 48 06          	cmp    0x6(%eax),%cx
  8071a9:	0f 82 2d 01 00 00    	jb     8072dc <ip_reass+0x42b>
      if (iprh_prev != NULL) {
  8071af:	85 f6                	test   %esi,%esi
  8071b1:	74 d4                	je     807187 <ip_reass+0x2d6>
          valid = 0;
  8071b3:	66 3b 56 06          	cmp    0x6(%esi),%dx
  8071b7:	ba 00 00 00 00       	mov    $0x0,%edx
  8071bc:	0f 45 fa             	cmovne %edx,%edi
  8071bf:	eb c6                	jmp    807187 <ip_reass+0x2d6>
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
  8071c1:	83 ec 04             	sub    $0x4,%esp
  8071c4:	68 c0 24 81 00       	push   $0x8124c0
  8071c9:	68 83 01 00 00       	push   $0x183
  8071ce:	68 6a 24 81 00       	push   $0x81246a
  8071d3:	e8 6f 77 00 00       	call   80e947 <_panic>
      LWIP_ASSERT("no previous fragment, this must be the first fragment!",
  8071d8:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
  8071dc:	75 0b                	jne    8071e9 <ip_reass+0x338>
      ipr->p = new_p;
  8071de:	8b 45 08             	mov    0x8(%ebp),%eax
  8071e1:	89 47 04             	mov    %eax,0x4(%edi)
  8071e4:	e9 67 ff ff ff       	jmp    807150 <ip_reass+0x29f>
      LWIP_ASSERT("no previous fragment, this must be the first fragment!",
  8071e9:	83 ec 04             	sub    $0x4,%esp
  8071ec:	68 ec 24 81 00       	push   $0x8124ec
  8071f1:	68 8b 01 00 00       	push   $0x18b
  8071f6:	68 6a 24 81 00       	push   $0x81246a
  8071fb:	e8 47 77 00 00       	call   80e947 <_panic>
          q = iprh->next_pbuf;
  807200:	8b 10                	mov    (%eax),%edx
          iprh = (struct ip_reass_helper*)q->payload;
  807202:	89 c6                	mov    %eax,%esi
        while (q != NULL) {
  807204:	85 d2                	test   %edx,%edx
  807206:	74 12                	je     80721a <ip_reass+0x369>
          iprh = (struct ip_reass_helper*)q->payload;
  807208:	8b 42 04             	mov    0x4(%edx),%eax
          if (iprh_prev->end != iprh->start) {
  80720b:	0f b7 50 04          	movzwl 0x4(%eax),%edx
  80720f:	66 39 56 06          	cmp    %dx,0x6(%esi)
  807213:	74 eb                	je     807200 <ip_reass+0x34f>
  807215:	e9 e5 00 00 00       	jmp    8072ff <ip_reass+0x44e>
  80721a:	89 75 e0             	mov    %esi,-0x20(%ebp)
          LWIP_ASSERT("sanity check",
  80721d:	39 f3                	cmp    %esi,%ebx
  80721f:	74 76                	je     807297 <ip_reass+0x3e6>
          LWIP_ASSERT("validate_datagram:next_pbuf!=NULL",
  807221:	8b 45 e0             	mov    -0x20(%ebp),%eax
  807224:	83 38 00             	cmpl   $0x0,(%eax)
  807227:	0f 85 81 00 00 00    	jne    8072ae <ip_reass+0x3fd>
          LWIP_ASSERT("validate_datagram:datagram end!=datagram len",
  80722d:	0f b7 47 1c          	movzwl 0x1c(%edi),%eax
  807231:	8b 75 e0             	mov    -0x20(%ebp),%esi
  807234:	66 39 46 06          	cmp    %ax,0x6(%esi)
  807238:	0f 85 87 00 00 00    	jne    8072c5 <ip_reass+0x414>
    ipr->datagram_len += IP_HLEN;
  80723e:	83 c0 14             	add    $0x14,%eax
  807241:	66 89 47 1c          	mov    %ax,0x1c(%edi)
    r = ((struct ip_reass_helper*)ipr->p->payload)->next_pbuf;
  807245:	8b 71 04             	mov    0x4(%ecx),%esi
  807248:	8b 1e                	mov    (%esi),%ebx
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
  80724a:	83 ec 04             	sub    $0x4,%esp
  80724d:	6a 14                	push   $0x14
  80724f:	8d 47 08             	lea    0x8(%edi),%eax
  807252:	50                   	push   %eax
  807253:	56                   	push   %esi
  807254:	e8 fb 7f 00 00       	call   80f254 <memcpy>
    IPH_LEN_SET(fraghdr, htons(ipr->datagram_len));
  807259:	0f b7 47 1c          	movzwl 0x1c(%edi),%eax
  80725d:	89 04 24             	mov    %eax,(%esp)
  807260:	e8 f4 06 00 00       	call   807959 <htons>
  807265:	66 89 46 02          	mov    %ax,0x2(%esi)
    IPH_OFFSET_SET(fraghdr, 0);
  807269:	66 c7 46 06 00 00    	movw   $0x0,0x6(%esi)
    IPH_CHKSUM_SET(fraghdr, 0);
  80726f:	66 c7 46 0a 00 00    	movw   $0x0,0xa(%esi)
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));
  807275:	83 c4 08             	add    $0x8,%esp
  807278:	6a 14                	push   $0x14
  80727a:	56                   	push   %esi
  80727b:	e8 9f 05 00 00       	call   80781f <inet_chksum>
  807280:	66 89 46 0a          	mov    %ax,0xa(%esi)
    p = ipr->p;
  807284:	8b 47 04             	mov    0x4(%edi),%eax
  807287:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    while(r != NULL) {
  80728a:	83 c4 10             	add    $0x10,%esp
  80728d:	89 7d e0             	mov    %edi,-0x20(%ebp)
  807290:	89 c7                	mov    %eax,%edi
  807292:	e9 91 00 00 00       	jmp    807328 <ip_reass+0x477>
          LWIP_ASSERT("sanity check",
  807297:	83 ec 04             	sub    $0x4,%esp
  80729a:	68 de 24 81 00       	push   $0x8124de
  80729f:	68 ad 01 00 00       	push   $0x1ad
  8072a4:	68 6a 24 81 00       	push   $0x81246a
  8072a9:	e8 99 76 00 00       	call   80e947 <_panic>
          LWIP_ASSERT("validate_datagram:next_pbuf!=NULL",
  8072ae:	83 ec 04             	sub    $0x4,%esp
  8072b1:	68 24 25 81 00       	push   $0x812524
  8072b6:	68 af 01 00 00       	push   $0x1af
  8072bb:	68 6a 24 81 00       	push   $0x81246a
  8072c0:	e8 82 76 00 00       	call   80e947 <_panic>
          LWIP_ASSERT("validate_datagram:datagram end!=datagram len",
  8072c5:	83 ec 04             	sub    $0x4,%esp
  8072c8:	68 48 25 81 00       	push   $0x812548
  8072cd:	68 b1 01 00 00       	push   $0x1b1
  8072d2:	68 6a 24 81 00       	push   $0x81246a
  8072d7:	e8 6b 76 00 00       	call   80e947 <_panic>
  ip_reass_pbufcount -= pbuf_clen(new_p);
  8072dc:	83 ec 0c             	sub    $0xc,%esp
  8072df:	ff 75 08             	pushl  0x8(%ebp)
  8072e2:	e8 79 db ff ff       	call   804e60 <pbuf_clen>
  8072e7:	0f b6 c0             	movzbl %al,%eax
  8072ea:	66 29 05 dc 49 b3 00 	sub    %ax,0xb349dc
  pbuf_free(new_p);
  8072f1:	83 c4 04             	add    $0x4,%esp
  8072f4:	ff 75 08             	pushl  0x8(%ebp)
  8072f7:	e8 25 d7 ff ff       	call   804a21 <pbuf_free>
  return 0;
  8072fc:	83 c4 10             	add    $0x10,%esp
  return NULL;
  8072ff:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  807306:	e9 c8 fd ff ff       	jmp    8070d3 <ip_reass+0x222>
      iprh = (struct ip_reass_helper*)r->payload;
  80730b:	8b 73 04             	mov    0x4(%ebx),%esi
      pbuf_header(r, -IP_HLEN);
  80730e:	83 ec 08             	sub    $0x8,%esp
  807311:	6a ec                	push   $0xffffffec
  807313:	53                   	push   %ebx
  807314:	e8 35 d6 ff ff       	call   80494e <pbuf_header>
      pbuf_cat(p, r);
  807319:	83 c4 08             	add    $0x8,%esp
  80731c:	53                   	push   %ebx
  80731d:	57                   	push   %edi
  80731e:	e8 70 db ff ff       	call   804e93 <pbuf_cat>
      r = iprh->next_pbuf;
  807323:	8b 1e                	mov    (%esi),%ebx
  807325:	83 c4 10             	add    $0x10,%esp
    while(r != NULL) {
  807328:	85 db                	test   %ebx,%ebx
  80732a:	75 df                	jne    80730b <ip_reass+0x45a>
  80732c:	8b 7d e0             	mov    -0x20(%ebp),%edi
    ip_reass_dequeue_datagram(ipr, ipr_prev);
  80732f:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  807332:	89 f8                	mov    %edi,%eax
  807334:	e8 51 f9 ff ff       	call   806c8a <ip_reass_dequeue_datagram>
    ip_reass_pbufcount -= pbuf_clen(p);
  807339:	83 ec 0c             	sub    $0xc,%esp
  80733c:	ff 75 e4             	pushl  -0x1c(%ebp)
  80733f:	e8 1c db ff ff       	call   804e60 <pbuf_clen>
  807344:	0f b6 c0             	movzbl %al,%eax
  807347:	66 29 05 dc 49 b3 00 	sub    %ax,0xb349dc
    return p;
  80734e:	83 c4 10             	add    $0x10,%esp
  807351:	e9 7d fd ff ff       	jmp    8070d3 <ip_reass+0x222>
  807356:	89 7d d0             	mov    %edi,-0x30(%ebp)
  807359:	8b 7d e4             	mov    -0x1c(%ebp),%edi
    if (iprh_prev != NULL) {
  80735c:	85 f6                	test   %esi,%esi
  80735e:	0f 84 74 fe ff ff    	je     8071d8 <ip_reass+0x327>
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
  807364:	0f b7 46 06          	movzwl 0x6(%esi),%eax
  807368:	66 39 c1             	cmp    %ax,%cx
  80736b:	0f 82 50 fe ff ff    	jb     8071c1 <ip_reass+0x310>
      iprh_prev->next_pbuf = new_p;
  807371:	8b 4d 08             	mov    0x8(%ebp),%ecx
  807374:	89 0e                	mov    %ecx,(%esi)
      if (iprh_prev->end != iprh->start) {
  807376:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  807379:	66 3b 41 04          	cmp    0x4(%ecx),%ax
  80737d:	75 80                	jne    8072ff <ip_reass+0x44e>
  80737f:	e9 cc fd ff ff       	jmp    807150 <ip_reass+0x29f>

00807384 <ip_frag>:
 *
 * @return ERR_OK if sent successfully, err_t otherwise
 */
err_t 
ip_frag(struct pbuf *p, struct netif *netif, struct ip_addr *dest)
{
  807384:	f3 0f 1e fb          	endbr32 
  807388:	55                   	push   %ebp
  807389:	89 e5                	mov    %esp,%ebp
  80738b:	57                   	push   %edi
  80738c:	56                   	push   %esi
  80738d:	53                   	push   %ebx
  80738e:	83 ec 30             	sub    $0x30,%esp
  struct ip_hdr *original_iphdr;
#endif
  struct ip_hdr *iphdr;
  u16_t nfb;
  u16_t left, cop;
  u16_t mtu = netif->mtu;
  807391:	8b 45 0c             	mov    0xc(%ebp),%eax
  807394:	0f b7 58 2c          	movzwl 0x2c(%eax),%ebx
#if IP_FRAG_USES_STATIC_BUF
  /* When using a static buffer, we use a PBUF_REF, which we will
   * use to reference the packet (without link header).
   * Layer and length is irrelevant.
   */
  rambuf = pbuf_alloc(PBUF_LINK, 0, PBUF_REF);
  807398:	6a 02                	push   $0x2
  80739a:	6a 00                	push   $0x0
  80739c:	6a 02                	push   $0x2
  80739e:	e8 48 d7 ff ff       	call   804aeb <pbuf_alloc>
  8073a3:	89 45 dc             	mov    %eax,-0x24(%ebp)
  if (rambuf == NULL) {
  8073a6:	83 c4 10             	add    $0x10,%esp
  8073a9:	85 c0                	test   %eax,%eax
  8073ab:	0f 84 c2 00 00 00    	je     807473 <ip_frag+0xef>
    LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc(PBUF_LINK, 0, PBUF_REF) failed\n"));
    return ERR_MEM;
  }
  rambuf->tot_len = rambuf->len = mtu;
  8073b1:	66 89 58 0a          	mov    %bx,0xa(%eax)
  8073b5:	66 89 58 08          	mov    %bx,0x8(%eax)
  rambuf->payload = LWIP_MEM_ALIGN((void *)buf);
  8073b9:	be 03 44 b3 00       	mov    $0xb34403,%esi
  8073be:	83 e6 fc             	and    $0xfffffffc,%esi
  8073c1:	89 70 04             	mov    %esi,0x4(%eax)

  /* Copy the IP header in it */
  iphdr = rambuf->payload;
  SMEMCPY(iphdr, p->payload, IP_HLEN);
  8073c4:	83 ec 04             	sub    $0x4,%esp
  8073c7:	6a 14                	push   $0x14
  8073c9:	8b 45 08             	mov    0x8(%ebp),%eax
  8073cc:	ff 70 04             	pushl  0x4(%eax)
  8073cf:	56                   	push   %esi
  8073d0:	e8 7f 7e 00 00       	call   80f254 <memcpy>
  original_iphdr = p->payload;
  iphdr = original_iphdr;
#endif /* IP_FRAG_USES_STATIC_BUF */

  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
  8073d5:	0f b7 46 06          	movzwl 0x6(%esi),%eax
  8073d9:	89 04 24             	mov    %eax,(%esp)
  8073dc:	e8 89 05 00 00       	call   80796a <ntohs>
  ofo = tmp & IP_OFFMASK;
  8073e1:	89 c7                	mov    %eax,%edi
  8073e3:	66 81 e7 ff 1f       	and    $0x1fff,%di
  8073e8:	66 89 7d e4          	mov    %di,-0x1c(%ebp)
  omf = tmp & IP_MF;
  8073ec:	66 25 00 20          	and    $0x2000,%ax
  8073f0:	66 89 45 e0          	mov    %ax,-0x20(%ebp)

  left = p->tot_len - IP_HLEN;
  8073f4:	8b 45 08             	mov    0x8(%ebp),%eax
  8073f7:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  8073fb:	8d 78 ec             	lea    -0x14(%eax),%edi

  nfb = (mtu - IP_HLEN) / 8;
  8073fe:	0f b7 db             	movzwl %bx,%ebx
  807401:	8d 43 f3             	lea    -0xd(%ebx),%eax
  807404:	83 c4 10             	add    $0x10,%esp
  807407:	89 da                	mov    %ebx,%edx
  807409:	83 ea 14             	sub    $0x14,%edx
  80740c:	0f 49 c2             	cmovns %edx,%eax
  80740f:	c1 f8 03             	sar    $0x3,%eax
  807412:	66 89 45 d2          	mov    %ax,-0x2e(%ebp)
    tmp = omf | (IP_OFFMASK & (ofo));
    if (!last)
      tmp = tmp | IP_MF;

    /* Fill this fragment */
    cop = last ? left : nfb * 8;
  807416:	c1 e0 03             	shl    $0x3,%eax
  807419:	66 89 45 d0          	mov    %ax,-0x30(%ebp)

#if IP_FRAG_USES_STATIC_BUF
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  80741d:	0f b7 c8             	movzwl %ax,%ecx
  807420:	89 4d cc             	mov    %ecx,-0x34(%ebp)
    poff = newpbuflen;
#endif /* IP_FRAG_USES_STATIC_BUF */

    /* Correct header */
    IPH_OFFSET_SET(iphdr, htons(tmp));
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
  807423:	83 c0 14             	add    $0x14,%eax
  807426:	0f b7 c0             	movzwl %ax,%eax
  807429:	89 45 c8             	mov    %eax,-0x38(%ebp)
  u16_t poff = IP_HLEN;
  80742c:	66 c7 45 e6 14 00    	movw   $0x14,-0x1a(%ebp)
    last = (left <= mtu - IP_HLEN);
  807432:	8d 43 ed             	lea    -0x13(%ebx),%eax
  807435:	89 45 d8             	mov    %eax,-0x28(%ebp)
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  807438:	8d 46 14             	lea    0x14(%esi),%eax
  80743b:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  while (left) {
  80743e:	e9 e3 00 00 00       	jmp    807526 <ip_frag+0x1a2>
      IPFRAG_STATS_INC(ip_frag.xmit);
      snmp_inc_ipfragcreates();
      pbuf_free(header);
    } else {
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc() for header failed\n"));
      pbuf_free(rambuf);
  807443:	83 ec 0c             	sub    $0xc,%esp
  807446:	ff 75 dc             	pushl  -0x24(%ebp)
  807449:	e8 d3 d5 ff ff       	call   804a21 <pbuf_free>
      return ERR_MEM;
  80744e:	83 c4 10             	add    $0x10,%esp
  807451:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807456:	eb 13                	jmp    80746b <ip_frag+0xe7>
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
    ofo += nfb;
  }
#if IP_FRAG_USES_STATIC_BUF
  pbuf_free(rambuf);
  807458:	83 ec 0c             	sub    $0xc,%esp
  80745b:	ff 75 dc             	pushl  -0x24(%ebp)
  80745e:	e8 be d5 ff ff       	call   804a21 <pbuf_free>
#endif /* IP_FRAG_USES_STATIC_BUF */
  snmp_inc_ipfragoks();
  return ERR_OK;
  807463:	83 c4 10             	add    $0x10,%esp
  807466:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80746b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80746e:	5b                   	pop    %ebx
  80746f:	5e                   	pop    %esi
  807470:	5f                   	pop    %edi
  807471:	5d                   	pop    %ebp
  807472:	c3                   	ret    
    return ERR_MEM;
  807473:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807478:	eb f1                	jmp    80746b <ip_frag+0xe7>
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  80747a:	0f b7 55 e6          	movzwl -0x1a(%ebp),%edx
  80747e:	52                   	push   %edx
  80747f:	50                   	push   %eax
  807480:	ff 75 d4             	pushl  -0x2c(%ebp)
  807483:	ff 75 08             	pushl  0x8(%ebp)
  807486:	e8 1f dd ff ff       	call   8051aa <pbuf_copy_partial>
  80748b:	66 01 45 e6          	add    %ax,-0x1a(%ebp)
    IPH_OFFSET_SET(iphdr, htons(tmp));
  80748f:	0f b7 db             	movzwl %bx,%ebx
  807492:	89 1c 24             	mov    %ebx,(%esp)
  807495:	e8 bf 04 00 00       	call   807959 <htons>
  80749a:	66 89 46 06          	mov    %ax,0x6(%esi)
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
  80749e:	8d 5f 14             	lea    0x14(%edi),%ebx
  8074a1:	0f b7 db             	movzwl %bx,%ebx
  8074a4:	89 1c 24             	mov    %ebx,(%esp)
  8074a7:	e8 ad 04 00 00       	call   807959 <htons>
  8074ac:	66 89 46 02          	mov    %ax,0x2(%esi)
    IPH_CHKSUM_SET(iphdr, 0);
  8074b0:	66 c7 46 0a 00 00    	movw   $0x0,0xa(%esi)
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  8074b6:	83 c4 08             	add    $0x8,%esp
  8074b9:	6a 14                	push   $0x14
  8074bb:	56                   	push   %esi
  8074bc:	e8 5e 03 00 00       	call   80781f <inet_chksum>
  8074c1:	66 89 46 0a          	mov    %ax,0xa(%esi)
      pbuf_realloc(rambuf, left + IP_HLEN);
  8074c5:	83 c4 08             	add    $0x8,%esp
  8074c8:	53                   	push   %ebx
  8074c9:	ff 75 dc             	pushl  -0x24(%ebp)
  8074cc:	e8 79 d8 ff ff       	call   804d4a <pbuf_realloc>
  8074d1:	83 c4 10             	add    $0x10,%esp
    cop = last ? left : nfb * 8;
  8074d4:	66 89 7d e2          	mov    %di,-0x1e(%ebp)
    header = pbuf_alloc(PBUF_LINK, 0, PBUF_RAM);
  8074d8:	83 ec 04             	sub    $0x4,%esp
  8074db:	6a 00                	push   $0x0
  8074dd:	6a 00                	push   $0x0
  8074df:	6a 02                	push   $0x2
  8074e1:	e8 05 d6 ff ff       	call   804aeb <pbuf_alloc>
  8074e6:	89 c3                	mov    %eax,%ebx
    if (header != NULL) {
  8074e8:	83 c4 10             	add    $0x10,%esp
  8074eb:	85 c0                	test   %eax,%eax
  8074ed:	0f 84 50 ff ff ff    	je     807443 <ip_frag+0xbf>
      pbuf_chain(header, rambuf);
  8074f3:	83 ec 08             	sub    $0x8,%esp
  8074f6:	ff 75 dc             	pushl  -0x24(%ebp)
  8074f9:	50                   	push   %eax
  8074fa:	e8 04 da ff ff       	call   804f03 <pbuf_chain>
      netif->output(netif, header, dest);
  8074ff:	83 c4 0c             	add    $0xc,%esp
  807502:	ff 75 10             	pushl  0x10(%ebp)
  807505:	53                   	push   %ebx
  807506:	ff 75 0c             	pushl  0xc(%ebp)
  807509:	8b 45 0c             	mov    0xc(%ebp),%eax
  80750c:	ff 50 14             	call   *0x14(%eax)
      pbuf_free(header);
  80750f:	89 1c 24             	mov    %ebx,(%esp)
  807512:	e8 0a d5 ff ff       	call   804a21 <pbuf_free>
    left -= cop;
  807517:	66 2b 7d e2          	sub    -0x1e(%ebp),%di
    ofo += nfb;
  80751b:	0f b7 4d d2          	movzwl -0x2e(%ebp),%ecx
  80751f:	66 01 4d e4          	add    %cx,-0x1c(%ebp)
  807523:	83 c4 10             	add    $0x10,%esp
  while (left) {
  807526:	66 85 ff             	test   %di,%di
  807529:	0f 84 29 ff ff ff    	je     807458 <ip_frag+0xd4>
    last = (left <= mtu - IP_HLEN);
  80752f:	0f b7 c7             	movzwl %di,%eax
    tmp = omf | (IP_OFFMASK & (ofo));
  807532:	0f b7 5d e4          	movzwl -0x1c(%ebp),%ebx
  807536:	66 81 e3 ff 1f       	and    $0x1fff,%bx
  80753b:	66 0b 5d e0          	or     -0x20(%ebp),%bx
    if (!last)
  80753f:	39 45 d8             	cmp    %eax,-0x28(%ebp)
  807542:	0f 8f 32 ff ff ff    	jg     80747a <ip_frag+0xf6>
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  807548:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  80754c:	50                   	push   %eax
  80754d:	ff 75 cc             	pushl  -0x34(%ebp)
  807550:	ff 75 d4             	pushl  -0x2c(%ebp)
  807553:	ff 75 08             	pushl  0x8(%ebp)
  807556:	e8 4f dc ff ff       	call   8051aa <pbuf_copy_partial>
  80755b:	66 01 45 e6          	add    %ax,-0x1a(%ebp)
      tmp = tmp | IP_MF;
  80755f:	80 cf 20             	or     $0x20,%bh
    IPH_OFFSET_SET(iphdr, htons(tmp));
  807562:	0f b7 db             	movzwl %bx,%ebx
  807565:	89 1c 24             	mov    %ebx,(%esp)
  807568:	e8 ec 03 00 00       	call   807959 <htons>
  80756d:	66 89 46 06          	mov    %ax,0x6(%esi)
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
  807571:	83 c4 04             	add    $0x4,%esp
  807574:	ff 75 c8             	pushl  -0x38(%ebp)
  807577:	e8 dd 03 00 00       	call   807959 <htons>
  80757c:	66 89 46 02          	mov    %ax,0x2(%esi)
    IPH_CHKSUM_SET(iphdr, 0);
  807580:	66 c7 46 0a 00 00    	movw   $0x0,0xa(%esi)
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  807586:	83 c4 08             	add    $0x8,%esp
  807589:	6a 14                	push   $0x14
  80758b:	56                   	push   %esi
  80758c:	e8 8e 02 00 00       	call   80781f <inet_chksum>
  807591:	66 89 46 0a          	mov    %ax,0xa(%esi)
  807595:	83 c4 10             	add    $0x10,%esp
    cop = last ? left : nfb * 8;
  807598:	0f b7 45 d0          	movzwl -0x30(%ebp),%eax
  80759c:	66 89 45 e2          	mov    %ax,-0x1e(%ebp)
  8075a0:	e9 33 ff ff ff       	jmp    8074d8 <ip_frag+0x154>

008075a5 <lwip_standard_chksum>:
 * @note accumulator size limits summable length to 64k
 * @note host endianess is irrelevant (p3 RFC1071)
 */
static u16_t
lwip_standard_chksum(void *dataptr, u16_t len)
{
  8075a5:	55                   	push   %ebp
  8075a6:	89 e5                	mov    %esp,%ebp
  8075a8:	57                   	push   %edi
  8075a9:	56                   	push   %esi
  8075aa:	53                   	push   %ebx
  8075ab:	83 ec 1c             	sub    $0x1c,%esp
  8075ae:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  8075b1:	89 d7                	mov    %edx,%edi
  8075b3:	66 d1 ef             	shr    %di
  8075b6:	0f b7 d7             	movzwl %di,%edx
  8075b9:	8d 34 50             	lea    (%eax,%edx,2),%esi
  u32_t acc;
  u16_t src;
  u8_t *octetptr;

  acc = 0;
  8075bc:	bb 00 00 00 00       	mov    $0x0,%ebx
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
  while (len > 1) {
  8075c1:	39 f0                	cmp    %esi,%eax
  8075c3:	74 18                	je     8075dd <lwip_standard_chksum+0x38>
    /* declare first octet as most significant
       thus assume network order, ignoring host order */
    src = (*octetptr) << 8;
  8075c5:	0f b6 10             	movzbl (%eax),%edx
  8075c8:	89 d1                	mov    %edx,%ecx
  8075ca:	c1 e1 08             	shl    $0x8,%ecx
    octetptr++;
    /* declare second octet as least significant */
    src |= (*octetptr);
  8075cd:	0f b6 50 01          	movzbl 0x1(%eax),%edx
  8075d1:	09 ca                	or     %ecx,%edx
  8075d3:	83 c0 02             	add    $0x2,%eax
    octetptr++;
    acc += src;
  8075d6:	0f b7 d2             	movzwl %dx,%edx
  8075d9:	01 d3                	add    %edx,%ebx
  8075db:	eb e4                	jmp    8075c1 <lwip_standard_chksum+0x1c>
    len -= 2;
  }
  if (len > 0) {
  8075dd:	01 ff                	add    %edi,%edi
  8075df:	66 3b 7d e4          	cmp    -0x1c(%ebp),%di
  8075e3:	74 0b                	je     8075f0 <lwip_standard_chksum+0x4b>
    /* accumulate remaining octet */
    src = (*octetptr) << 8;
  8075e5:	0f b6 00             	movzbl (%eax),%eax
  8075e8:	c1 e0 08             	shl    $0x8,%eax
    acc += src;
  8075eb:	0f b7 c0             	movzwl %ax,%eax
  8075ee:	01 c3                	add    %eax,%ebx
  }
  /* add deferred carry bits */
  acc = (acc >> 16) + (acc & 0x0000ffffUL);
  8075f0:	89 da                	mov    %ebx,%edx
  8075f2:	c1 ea 10             	shr    $0x10,%edx
  8075f5:	0f b7 db             	movzwl %bx,%ebx
  8075f8:	8d 04 1a             	lea    (%edx,%ebx,1),%eax
  if ((acc & 0xffff0000) != 0) {
    acc = (acc >> 16) + (acc & 0x0000ffffUL);
  8075fb:	0f b7 c8             	movzwl %ax,%ecx
  8075fe:	83 c1 01             	add    $0x1,%ecx
  807601:	89 c3                	mov    %eax,%ebx
  807603:	a9 00 00 ff ff       	test   $0xffff0000,%eax
  807608:	89 c8                	mov    %ecx,%eax
  80760a:	0f 44 c3             	cmove  %ebx,%eax
  }
  /* This maybe a little confusing: reorder sum using htons()
     instead of ntohs() since it has a little less call overhead.
     The caller must invert bits for Internet sum ! */
  return htons((u16_t)acc);
  80760d:	83 ec 0c             	sub    $0xc,%esp
  807610:	0f b7 c0             	movzwl %ax,%eax
  807613:	50                   	push   %eax
  807614:	e8 40 03 00 00       	call   807959 <htons>
}
  807619:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80761c:	5b                   	pop    %ebx
  80761d:	5e                   	pop    %esi
  80761e:	5f                   	pop    %edi
  80761f:	5d                   	pop    %ebp
  807620:	c3                   	ret    

00807621 <inet_chksum_pseudo>:
 */
u16_t
inet_chksum_pseudo(struct pbuf *p,
       struct ip_addr *src, struct ip_addr *dest,
       u8_t proto, u16_t proto_len)
{
  807621:	f3 0f 1e fb          	endbr32 
  807625:	55                   	push   %ebp
  807626:	89 e5                	mov    %esp,%ebp
  807628:	57                   	push   %edi
  807629:	56                   	push   %esi
  80762a:	53                   	push   %ebx
  80762b:	83 ec 1c             	sub    $0x1c,%esp
  80762e:	8b 75 08             	mov    0x8(%ebp),%esi
  807631:	8b 45 14             	mov    0x14(%ebp),%eax
  807634:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  807637:	8b 45 18             	mov    0x18(%ebp),%eax
  80763a:	89 45 e0             	mov    %eax,-0x20(%ebp)
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  80763d:	bf 00 00 00 00       	mov    $0x0,%edi
  acc = 0;
  807642:	bb 00 00 00 00       	mov    $0x0,%ebx
  807647:	89 f8                	mov    %edi,%eax
  807649:	89 df                	mov    %ebx,%edi
  80764b:	89 c3                	mov    %eax,%ebx
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
  80764d:	eb 02                	jmp    807651 <inet_chksum_pseudo+0x30>
  80764f:	8b 36                	mov    (%esi),%esi
  807651:	85 f6                	test   %esi,%esi
  807653:	74 3d                	je     807692 <inet_chksum_pseudo+0x71>
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    acc += LWIP_CHKSUM(q->payload, q->len);
  807655:	0f b7 56 0a          	movzwl 0xa(%esi),%edx
  807659:	8b 46 04             	mov    0x4(%esi),%eax
  80765c:	e8 44 ff ff ff       	call   8075a5 <lwip_standard_chksum>
  807661:	0f b7 c0             	movzwl %ax,%eax
  807664:	01 f8                	add    %edi,%eax
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* just executing this next line is probably faster that the if statement needed
       to check whether we really need to execute it, and does no harm */
    acc = FOLD_U32T(acc);
  807666:	89 c7                	mov    %eax,%edi
  807668:	c1 ef 10             	shr    $0x10,%edi
  80766b:	0f b7 c0             	movzwl %ax,%eax
  80766e:	01 c7                	add    %eax,%edi
    if (q->len % 2 != 0) {
  807670:	f6 46 0a 01          	testb  $0x1,0xa(%esi)
  807674:	74 d9                	je     80764f <inet_chksum_pseudo+0x2e>
      swapped = 1 - swapped;
  807676:	b8 01 00 00 00       	mov    $0x1,%eax
  80767b:	29 d8                	sub    %ebx,%eax
  80767d:	89 c3                	mov    %eax,%ebx
      acc = SWAP_BYTES_IN_WORD(acc);
  80767f:	89 fa                	mov    %edi,%edx
  807681:	c1 e2 08             	shl    $0x8,%edx
  807684:	0f b7 d2             	movzwl %dx,%edx
  807687:	89 f8                	mov    %edi,%eax
  807689:	0f b6 c4             	movzbl %ah,%eax
  80768c:	09 c2                	or     %eax,%edx
  80768e:	89 d7                	mov    %edx,%edi
  807690:	eb bd                	jmp    80764f <inet_chksum_pseudo+0x2e>
  807692:	89 d8                	mov    %ebx,%eax
  807694:	89 fb                	mov    %edi,%ebx
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
  807696:	84 c0                	test   %al,%al
  807698:	74 0d                	je     8076a7 <inet_chksum_pseudo+0x86>
    acc = SWAP_BYTES_IN_WORD(acc);
  80769a:	89 f8                	mov    %edi,%eax
  80769c:	c1 e0 08             	shl    $0x8,%eax
  80769f:	0f b7 c0             	movzwl %ax,%eax
  8076a2:	0f b6 df             	movzbl %bh,%ebx
  8076a5:	09 c3                	or     %eax,%ebx
  }
  acc += (src->addr & 0xffffUL);
  8076a7:	8b 45 0c             	mov    0xc(%ebp),%eax
  8076aa:	8b 00                	mov    (%eax),%eax
  acc += ((src->addr >> 16) & 0xffffUL);
  acc += (dest->addr & 0xffffUL);
  8076ac:	8b 55 10             	mov    0x10(%ebp),%edx
  8076af:	8b 12                	mov    (%edx),%edx
  8076b1:	0f b7 ca             	movzwl %dx,%ecx
  acc += ((dest->addr >> 16) & 0xffffUL);
  8076b4:	c1 ea 10             	shr    $0x10,%edx
  8076b7:	01 ca                	add    %ecx,%edx
  acc += (src->addr & 0xffffUL);
  8076b9:	0f b7 c8             	movzwl %ax,%ecx
  acc += ((dest->addr >> 16) & 0xffffUL);
  8076bc:	01 ca                	add    %ecx,%edx
  acc += ((src->addr >> 16) & 0xffffUL);
  8076be:	c1 e8 10             	shr    $0x10,%eax
  acc += ((dest->addr >> 16) & 0xffffUL);
  8076c1:	01 d0                	add    %edx,%eax
  8076c3:	01 c3                	add    %eax,%ebx
  acc += (u32_t)htons((u16_t)proto);
  8076c5:	83 ec 0c             	sub    $0xc,%esp
  8076c8:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  8076cc:	50                   	push   %eax
  8076cd:	e8 87 02 00 00       	call   807959 <htons>
  8076d2:	0f b7 f0             	movzwl %ax,%esi
  8076d5:	01 de                	add    %ebx,%esi
  acc += (u32_t)htons(proto_len);
  8076d7:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  8076db:	89 04 24             	mov    %eax,(%esp)
  8076de:	e8 76 02 00 00       	call   807959 <htons>
  8076e3:	0f b7 d8             	movzwl %ax,%ebx
  8076e6:	01 f3                	add    %esi,%ebx

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
  8076e8:	89 d8                	mov    %ebx,%eax
  8076ea:	c1 e8 10             	shr    $0x10,%eax
  8076ed:	0f b7 db             	movzwl %bx,%ebx
  8076f0:	01 c3                	add    %eax,%ebx
  acc = FOLD_U32T(acc);
  8076f2:	89 d8                	mov    %ebx,%eax
  8076f4:	c1 e8 10             	shr    $0x10,%eax
  8076f7:	01 d8                	add    %ebx,%eax
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
  8076f9:	f7 d0                	not    %eax
}
  8076fb:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8076fe:	5b                   	pop    %ebx
  8076ff:	5e                   	pop    %esi
  807700:	5f                   	pop    %edi
  807701:	5d                   	pop    %ebp
  807702:	c3                   	ret    

00807703 <inet_chksum_pseudo_partial>:
 */
u16_t
inet_chksum_pseudo_partial(struct pbuf *p,
       struct ip_addr *src, struct ip_addr *dest,
       u8_t proto, u16_t proto_len, u16_t chksum_len)
{
  807703:	f3 0f 1e fb          	endbr32 
  807707:	55                   	push   %ebp
  807708:	89 e5                	mov    %esp,%ebp
  80770a:	57                   	push   %edi
  80770b:	56                   	push   %esi
  80770c:	53                   	push   %ebx
  80770d:	83 ec 1c             	sub    $0x1c,%esp
  807710:	8b 5d 08             	mov    0x8(%ebp),%ebx
  807713:	8b 45 14             	mov    0x14(%ebp),%eax
  807716:	89 45 dc             	mov    %eax,-0x24(%ebp)
  807719:	8b 45 18             	mov    0x18(%ebp),%eax
  80771c:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80771f:	0f b7 75 1c          	movzwl 0x1c(%ebp),%esi
  struct pbuf *q;
  u8_t swapped;
  u16_t chklen;

  acc = 0;
  swapped = 0;
  807723:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
  acc = 0;
  807727:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  /* iterate through all pbuf in chain */
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
  80772e:	eb 19                	jmp    807749 <inet_chksum_pseudo_partial+0x46>
    if (chklen > chksum_len) {
      chklen = chksum_len;
    }
    acc += LWIP_CHKSUM(q->payload, chklen);
    chksum_len -= chklen;
    LWIP_ASSERT("delete me", chksum_len < 0x7fff);
  807730:	83 ec 04             	sub    $0x4,%esp
  807733:	68 75 25 81 00       	push   $0x812575
  807738:	68 60 01 00 00       	push   $0x160
  80773d:	68 80 25 81 00       	push   $0x812580
  807742:	e8 00 72 00 00       	call   80e947 <_panic>
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
  807747:	8b 1b                	mov    (%ebx),%ebx
  807749:	85 db                	test   %ebx,%ebx
  80774b:	74 5c                	je     8077a9 <inet_chksum_pseudo_partial+0xa6>
  80774d:	66 85 f6             	test   %si,%si
  807750:	74 57                	je     8077a9 <inet_chksum_pseudo_partial+0xa6>
    chklen = q->len;
  807752:	0f b7 7b 0a          	movzwl 0xa(%ebx),%edi
  807756:	66 39 fe             	cmp    %di,%si
  807759:	0f 46 fe             	cmovbe %esi,%edi
    acc += LWIP_CHKSUM(q->payload, chklen);
  80775c:	0f b7 d7             	movzwl %di,%edx
  80775f:	8b 43 04             	mov    0x4(%ebx),%eax
  807762:	e8 3e fe ff ff       	call   8075a5 <lwip_standard_chksum>
  807767:	0f b7 c0             	movzwl %ax,%eax
  80776a:	03 45 e4             	add    -0x1c(%ebp),%eax
    chksum_len -= chklen;
  80776d:	29 fe                	sub    %edi,%esi
    LWIP_ASSERT("delete me", chksum_len < 0x7fff);
  80776f:	66 81 fe fe 7f       	cmp    $0x7ffe,%si
  807774:	77 ba                	ja     807730 <inet_chksum_pseudo_partial+0x2d>
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* fold the upper bit down */
    acc = FOLD_U32T(acc);
  807776:	89 c2                	mov    %eax,%edx
  807778:	c1 ea 10             	shr    $0x10,%edx
  80777b:	0f b7 c0             	movzwl %ax,%eax
  80777e:	8d 3c 02             	lea    (%edx,%eax,1),%edi
  807781:	89 7d e4             	mov    %edi,-0x1c(%ebp)
    if (q->len % 2 != 0) {
  807784:	f6 43 0a 01          	testb  $0x1,0xa(%ebx)
  807788:	74 bd                	je     807747 <inet_chksum_pseudo_partial+0x44>
      swapped = 1 - swapped;
  80778a:	b8 01 00 00 00       	mov    $0x1,%eax
  80778f:	2a 45 e3             	sub    -0x1d(%ebp),%al
  807792:	88 45 e3             	mov    %al,-0x1d(%ebp)
      acc = SWAP_BYTES_IN_WORD(acc);
  807795:	89 fa                	mov    %edi,%edx
  807797:	c1 e2 08             	shl    $0x8,%edx
  80779a:	0f b7 d2             	movzwl %dx,%edx
  80779d:	89 f8                	mov    %edi,%eax
  80779f:	0f b6 c4             	movzbl %ah,%eax
  8077a2:	09 c2                	or     %eax,%edx
  8077a4:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  8077a7:	eb 9e                	jmp    807747 <inet_chksum_pseudo_partial+0x44>
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
  8077a9:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
  8077ad:	74 13                	je     8077c2 <inet_chksum_pseudo_partial+0xbf>
    acc = SWAP_BYTES_IN_WORD(acc);
  8077af:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  8077b2:	89 c8                	mov    %ecx,%eax
  8077b4:	c1 e0 08             	shl    $0x8,%eax
  8077b7:	0f b7 c0             	movzwl %ax,%eax
  8077ba:	0f b6 d5             	movzbl %ch,%edx
  8077bd:	09 d0                	or     %edx,%eax
  8077bf:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  }
  acc += (src->addr & 0xffffUL);
  8077c2:	8b 45 0c             	mov    0xc(%ebp),%eax
  8077c5:	8b 18                	mov    (%eax),%ebx
  acc += ((src->addr >> 16) & 0xffffUL);
  acc += (dest->addr & 0xffffUL);
  8077c7:	8b 45 10             	mov    0x10(%ebp),%eax
  8077ca:	8b 00                	mov    (%eax),%eax
  8077cc:	0f b7 d0             	movzwl %ax,%edx
  acc += ((dest->addr >> 16) & 0xffffUL);
  8077cf:	c1 e8 10             	shr    $0x10,%eax
  8077d2:	01 d0                	add    %edx,%eax
  acc += (src->addr & 0xffffUL);
  8077d4:	0f b7 d3             	movzwl %bx,%edx
  acc += ((dest->addr >> 16) & 0xffffUL);
  8077d7:	01 d0                	add    %edx,%eax
  acc += ((src->addr >> 16) & 0xffffUL);
  8077d9:	c1 eb 10             	shr    $0x10,%ebx
  acc += ((dest->addr >> 16) & 0xffffUL);
  8077dc:	01 c3                	add    %eax,%ebx
  8077de:	03 5d e4             	add    -0x1c(%ebp),%ebx
  acc += (u32_t)htons((u16_t)proto);
  8077e1:	83 ec 0c             	sub    $0xc,%esp
  8077e4:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
  8077e8:	50                   	push   %eax
  8077e9:	e8 6b 01 00 00       	call   807959 <htons>
  8077ee:	0f b7 f0             	movzwl %ax,%esi
  8077f1:	01 de                	add    %ebx,%esi
  acc += (u32_t)htons(proto_len);
  8077f3:	0f b7 45 d8          	movzwl -0x28(%ebp),%eax
  8077f7:	89 04 24             	mov    %eax,(%esp)
  8077fa:	e8 5a 01 00 00       	call   807959 <htons>
  8077ff:	0f b7 d8             	movzwl %ax,%ebx
  807802:	01 f3                	add    %esi,%ebx

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
  807804:	89 d8                	mov    %ebx,%eax
  807806:	c1 e8 10             	shr    $0x10,%eax
  807809:	0f b7 db             	movzwl %bx,%ebx
  80780c:	01 c3                	add    %eax,%ebx
  acc = FOLD_U32T(acc);
  80780e:	89 d8                	mov    %ebx,%eax
  807810:	c1 e8 10             	shr    $0x10,%eax
  807813:	01 d8                	add    %ebx,%eax
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
  807815:	f7 d0                	not    %eax
}
  807817:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80781a:	5b                   	pop    %ebx
  80781b:	5e                   	pop    %esi
  80781c:	5f                   	pop    %edi
  80781d:	5d                   	pop    %ebp
  80781e:	c3                   	ret    

0080781f <inet_chksum>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */

u16_t
inet_chksum(void *dataptr, u16_t len)
{
  80781f:	f3 0f 1e fb          	endbr32 
  807823:	55                   	push   %ebp
  807824:	89 e5                	mov    %esp,%ebp
  807826:	83 ec 08             	sub    $0x8,%esp
  return ~LWIP_CHKSUM(dataptr, len);
  807829:	0f b7 55 0c          	movzwl 0xc(%ebp),%edx
  80782d:	8b 45 08             	mov    0x8(%ebp),%eax
  807830:	e8 70 fd ff ff       	call   8075a5 <lwip_standard_chksum>
  807835:	f7 d0                	not    %eax
}
  807837:	c9                   	leave  
  807838:	c3                   	ret    

00807839 <inet_chksum_pbuf>:
 * @param p pbuf chain over that the checksum should be calculated
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
inet_chksum_pbuf(struct pbuf *p)
{
  807839:	f3 0f 1e fb          	endbr32 
  80783d:	55                   	push   %ebp
  80783e:	89 e5                	mov    %esp,%ebp
  807840:	57                   	push   %edi
  807841:	56                   	push   %esi
  807842:	53                   	push   %ebx
  807843:	83 ec 0c             	sub    $0xc,%esp
  807846:	8b 75 08             	mov    0x8(%ebp),%esi
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  807849:	bf 00 00 00 00       	mov    $0x0,%edi
  acc = 0;
  80784e:	bb 00 00 00 00       	mov    $0x0,%ebx
  for(q = p; q != NULL; q = q->next) {
  807853:	eb 02                	jmp    807857 <inet_chksum_pbuf+0x1e>
  807855:	8b 36                	mov    (%esi),%esi
  807857:	85 f6                	test   %esi,%esi
  807859:	74 3b                	je     807896 <inet_chksum_pbuf+0x5d>
    acc += LWIP_CHKSUM(q->payload, q->len);
  80785b:	0f b7 56 0a          	movzwl 0xa(%esi),%edx
  80785f:	8b 46 04             	mov    0x4(%esi),%eax
  807862:	e8 3e fd ff ff       	call   8075a5 <lwip_standard_chksum>
  807867:	0f b7 c0             	movzwl %ax,%eax
  80786a:	01 c3                	add    %eax,%ebx
    acc = FOLD_U32T(acc);
  80786c:	89 d8                	mov    %ebx,%eax
  80786e:	c1 e8 10             	shr    $0x10,%eax
  807871:	0f b7 db             	movzwl %bx,%ebx
  807874:	01 c3                	add    %eax,%ebx
    if (q->len % 2 != 0) {
  807876:	f6 46 0a 01          	testb  $0x1,0xa(%esi)
  80787a:	74 d9                	je     807855 <inet_chksum_pbuf+0x1c>
      swapped = 1 - swapped;
  80787c:	b8 01 00 00 00       	mov    $0x1,%eax
  807881:	89 f9                	mov    %edi,%ecx
  807883:	29 c8                	sub    %ecx,%eax
  807885:	89 c7                	mov    %eax,%edi
      acc = SWAP_BYTES_IN_WORD(acc);
  807887:	89 da                	mov    %ebx,%edx
  807889:	c1 e2 08             	shl    $0x8,%edx
  80788c:	0f b7 d2             	movzwl %dx,%edx
  80788f:	0f b6 df             	movzbl %bh,%ebx
  807892:	09 d3                	or     %edx,%ebx
  807894:	eb bf                	jmp    807855 <inet_chksum_pbuf+0x1c>
    }
  }

  if (swapped) {
  807896:	89 f8                	mov    %edi,%eax
  807898:	84 c0                	test   %al,%al
  80789a:	74 0d                	je     8078a9 <inet_chksum_pbuf+0x70>
    acc = SWAP_BYTES_IN_WORD(acc);
  80789c:	89 da                	mov    %ebx,%edx
  80789e:	c1 e2 08             	shl    $0x8,%edx
  8078a1:	0f b7 d2             	movzwl %dx,%edx
  8078a4:	0f b6 df             	movzbl %bh,%ebx
  8078a7:	09 d3                	or     %edx,%ebx
  }
  return (u16_t)~(acc & 0xffffUL);
  8078a9:	89 d8                	mov    %ebx,%eax
  8078ab:	f7 d0                	not    %eax
}
  8078ad:	83 c4 0c             	add    $0xc,%esp
  8078b0:	5b                   	pop    %ebx
  8078b1:	5e                   	pop    %esi
  8078b2:	5f                   	pop    %edi
  8078b3:	5d                   	pop    %ebp
  8078b4:	c3                   	ret    

008078b5 <inet_ntoa>:
 * @return pointer to a global static (!) buffer that holds the ASCII
 *         represenation of addr
 */
char *
inet_ntoa(struct in_addr addr)
{
  8078b5:	f3 0f 1e fb          	endbr32 
  8078b9:	55                   	push   %ebp
  8078ba:	89 e5                	mov    %esp,%ebp
  8078bc:	57                   	push   %edi
  8078bd:	56                   	push   %esi
  8078be:	53                   	push   %ebx
  8078bf:	83 ec 18             	sub    $0x18,%esp
  static char str[16];
  u32_t s_addr = addr.s_addr;
  8078c2:	8b 45 08             	mov    0x8(%ebp),%eax
  8078c5:	89 45 f0             	mov    %eax,-0x10(%ebp)
  u8_t n;
  u8_t i;

  rp = str;
  ap = (u8_t *)&s_addr;
  for(n = 0; n < 4; n++) {
  8078c8:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
  ap = (u8_t *)&s_addr;
  8078cc:	8d 75 f0             	lea    -0x10(%ebp),%esi
  rp = str;
  8078cf:	bf e4 49 b3 00       	mov    $0xb349e4,%edi
  8078d4:	eb 2e                	jmp    807904 <inet_ntoa+0x4f>
      rem = *ap % (u8_t)10;
      *ap /= (u8_t)10;
      inv[i++] = '0' + rem;
    } while(*ap);
    while(i--)
      *rp++ = inv[i];
  8078d6:	0f b6 c8             	movzbl %al,%ecx
  8078d9:	0f b6 4c 0d ed       	movzbl -0x13(%ebp,%ecx,1),%ecx
  8078de:	88 0a                	mov    %cl,(%edx)
  8078e0:	83 c2 01             	add    $0x1,%edx
    while(i--)
  8078e3:	83 e8 01             	sub    $0x1,%eax
  8078e6:	3c ff                	cmp    $0xff,%al
  8078e8:	75 ec                	jne    8078d6 <inet_ntoa+0x21>
  8078ea:	0f b6 db             	movzbl %bl,%ebx
  8078ed:	01 fb                	add    %edi,%ebx
    *rp++ = '.';
  8078ef:	8d 7b 01             	lea    0x1(%ebx),%edi
  8078f2:	c6 03 2e             	movb   $0x2e,(%ebx)
  8078f5:	83 c6 01             	add    $0x1,%esi
  for(n = 0; n < 4; n++) {
  8078f8:	80 45 df 01          	addb   $0x1,-0x21(%ebp)
  8078fc:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
  807900:	3c 04                	cmp    $0x4,%al
  807902:	74 45                	je     807949 <inet_ntoa+0x94>
  rp = str;
  807904:	bb 00 00 00 00       	mov    $0x0,%ebx
      rem = *ap % (u8_t)10;
  807909:	0f b6 16             	movzbl (%esi),%edx
      *ap /= (u8_t)10;
  80790c:	0f b6 ca             	movzbl %dl,%ecx
  80790f:	8d 04 89             	lea    (%ecx,%ecx,4),%eax
  807912:	8d 04 c1             	lea    (%ecx,%eax,8),%eax
  807915:	8d 04 80             	lea    (%eax,%eax,4),%eax
  807918:	66 c1 e8 0b          	shr    $0xb,%ax
  80791c:	88 06                	mov    %al,(%esi)
  80791e:	89 d9                	mov    %ebx,%ecx
      inv[i++] = '0' + rem;
  807920:	83 c3 01             	add    $0x1,%ebx
  807923:	0f b6 c9             	movzbl %cl,%ecx
  807926:	89 4d e0             	mov    %ecx,-0x20(%ebp)
      rem = *ap % (u8_t)10;
  807929:	8d 04 80             	lea    (%eax,%eax,4),%eax
  80792c:	01 c0                	add    %eax,%eax
  80792e:	89 d1                	mov    %edx,%ecx
  807930:	29 c1                	sub    %eax,%ecx
  807932:	89 c8                	mov    %ecx,%eax
      inv[i++] = '0' + rem;
  807934:	83 c0 30             	add    $0x30,%eax
  807937:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  80793a:	88 44 0d ed          	mov    %al,-0x13(%ebp,%ecx,1)
    } while(*ap);
  80793e:	80 fa 09             	cmp    $0x9,%dl
  807941:	77 c6                	ja     807909 <inet_ntoa+0x54>
  807943:	89 fa                	mov    %edi,%edx
      inv[i++] = '0' + rem;
  807945:	89 d8                	mov    %ebx,%eax
  807947:	eb 9a                	jmp    8078e3 <inet_ntoa+0x2e>
    ap++;
  }
  *--rp = 0;
  807949:	c6 03 00             	movb   $0x0,(%ebx)
  return str;
}
  80794c:	b8 e4 49 b3 00       	mov    $0xb349e4,%eax
  807951:	83 c4 18             	add    $0x18,%esp
  807954:	5b                   	pop    %ebx
  807955:	5e                   	pop    %esi
  807956:	5f                   	pop    %edi
  807957:	5d                   	pop    %ebp
  807958:	c3                   	ret    

00807959 <htons>:
 * @param n u16_t in host byte order
 * @return n in network byte order
 */
u16_t
htons(u16_t n)
{
  807959:	f3 0f 1e fb          	endbr32 
  80795d:	55                   	push   %ebp
  80795e:	89 e5                	mov    %esp,%ebp
  return ((n & 0xff) << 8) | ((n & 0xff00) >> 8);
  807960:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
  807964:	66 c1 c0 08          	rol    $0x8,%ax
}
  807968:	5d                   	pop    %ebp
  807969:	c3                   	ret    

0080796a <ntohs>:
 * @param n u16_t in network byte order
 * @return n in host byte order
 */
u16_t
ntohs(u16_t n)
{
  80796a:	f3 0f 1e fb          	endbr32 
  80796e:	55                   	push   %ebp
  80796f:	89 e5                	mov    %esp,%ebp
  return ((n & 0xff) << 8) | ((n & 0xff00) >> 8);
  807971:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
  807975:	66 c1 c0 08          	rol    $0x8,%ax
  return htons(n);
}
  807979:	5d                   	pop    %ebp
  80797a:	c3                   	ret    

0080797b <htonl>:
 * @param n u32_t in host byte order
 * @return n in network byte order
 */
u32_t
htonl(u32_t n)
{
  80797b:	f3 0f 1e fb          	endbr32 
  80797f:	55                   	push   %ebp
  807980:	89 e5                	mov    %esp,%ebp
  807982:	8b 55 08             	mov    0x8(%ebp),%edx
  return ((n & 0xff) << 24) |
  807985:	89 d0                	mov    %edx,%eax
  807987:	c1 e0 18             	shl    $0x18,%eax
    ((n & 0xff00) << 8) |
    ((n & 0xff0000UL) >> 8) |
    ((n & 0xff000000UL) >> 24);
  80798a:	89 d1                	mov    %edx,%ecx
  80798c:	c1 e9 18             	shr    $0x18,%ecx
    ((n & 0xff0000UL) >> 8) |
  80798f:	09 c8                	or     %ecx,%eax
    ((n & 0xff00) << 8) |
  807991:	89 d1                	mov    %edx,%ecx
  807993:	c1 e1 08             	shl    $0x8,%ecx
  807996:	81 e1 00 00 ff 00    	and    $0xff0000,%ecx
    ((n & 0xff0000UL) >> 8) |
  80799c:	09 c8                	or     %ecx,%eax
  80799e:	c1 ea 08             	shr    $0x8,%edx
  8079a1:	81 e2 00 ff 00 00    	and    $0xff00,%edx
  8079a7:	09 d0                	or     %edx,%eax
}
  8079a9:	5d                   	pop    %ebp
  8079aa:	c3                   	ret    

008079ab <inet_aton>:
{
  8079ab:	f3 0f 1e fb          	endbr32 
  8079af:	55                   	push   %ebp
  8079b0:	89 e5                	mov    %esp,%ebp
  8079b2:	57                   	push   %edi
  8079b3:	56                   	push   %esi
  8079b4:	53                   	push   %ebx
  8079b5:	83 ec 2c             	sub    $0x2c,%esp
  8079b8:	8b 55 08             	mov    0x8(%ebp),%edx
  c = *cp;
  8079bb:	0f be 02             	movsbl (%edx),%eax
  u32_t *pp = parts;
  8079be:	8d 75 d8             	lea    -0x28(%ebp),%esi
  8079c1:	89 75 cc             	mov    %esi,-0x34(%ebp)
  8079c4:	e9 a7 00 00 00       	jmp    807a70 <inet_aton+0xc5>
      c = *++cp;
  8079c9:	0f b6 42 01          	movzbl 0x1(%edx),%eax
      if (c == 'x' || c == 'X') {
  8079cd:	89 c1                	mov    %eax,%ecx
  8079cf:	83 e1 df             	and    $0xffffffdf,%ecx
  8079d2:	80 f9 58             	cmp    $0x58,%cl
  8079d5:	74 10                	je     8079e7 <inet_aton+0x3c>
      c = *++cp;
  8079d7:	83 c2 01             	add    $0x1,%edx
  8079da:	0f be c0             	movsbl %al,%eax
        base = 8;
  8079dd:	be 08 00 00 00       	mov    $0x8,%esi
  8079e2:	e9 a3 00 00 00       	jmp    807a8a <inet_aton+0xdf>
        c = *++cp;
  8079e7:	0f be 42 02          	movsbl 0x2(%edx),%eax
  8079eb:	8d 52 02             	lea    0x2(%edx),%edx
        base = 16;
  8079ee:	be 10 00 00 00       	mov    $0x10,%esi
  8079f3:	e9 92 00 00 00       	jmp    807a8a <inet_aton+0xdf>
      } else if (base == 16 && isxdigit(c)) {
  8079f8:	83 fe 10             	cmp    $0x10,%esi
  8079fb:	75 4d                	jne    807a4a <inet_aton+0x9f>
  8079fd:	8d 4f 9f             	lea    -0x61(%edi),%ecx
  807a00:	88 4d d3             	mov    %cl,-0x2d(%ebp)
  807a03:	89 c1                	mov    %eax,%ecx
  807a05:	83 e1 df             	and    $0xffffffdf,%ecx
  807a08:	83 e9 41             	sub    $0x41,%ecx
  807a0b:	80 f9 05             	cmp    $0x5,%cl
  807a0e:	77 3a                	ja     807a4a <inet_aton+0x9f>
        val = (val << 4) | (int)(c + 10 - (islower(c) ? 'a' : 'A'));
  807a10:	c1 e3 04             	shl    $0x4,%ebx
  807a13:	83 c0 0a             	add    $0xa,%eax
  807a16:	80 7d d3 1a          	cmpb   $0x1a,-0x2d(%ebp)
  807a1a:	19 c9                	sbb    %ecx,%ecx
  807a1c:	83 e1 20             	and    $0x20,%ecx
  807a1f:	83 c1 41             	add    $0x41,%ecx
  807a22:	29 c8                	sub    %ecx,%eax
  807a24:	09 c3                	or     %eax,%ebx
        c = *++cp;
  807a26:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  807a29:	0f be 40 01          	movsbl 0x1(%eax),%eax
  807a2d:	83 c2 01             	add    $0x1,%edx
  807a30:	89 55 d4             	mov    %edx,-0x2c(%ebp)
      if (isdigit(c)) {
  807a33:	89 c7                	mov    %eax,%edi
  807a35:	8d 48 d0             	lea    -0x30(%eax),%ecx
  807a38:	80 f9 09             	cmp    $0x9,%cl
  807a3b:	77 bb                	ja     8079f8 <inet_aton+0x4d>
        val = (val * base) + (int)(c - '0');
  807a3d:	0f af de             	imul   %esi,%ebx
  807a40:	8d 5c 18 d0          	lea    -0x30(%eax,%ebx,1),%ebx
        c = *++cp;
  807a44:	0f be 42 01          	movsbl 0x1(%edx),%eax
  807a48:	eb e3                	jmp    807a2d <inet_aton+0x82>
    if (c == '.') {
  807a4a:	83 f8 2e             	cmp    $0x2e,%eax
  807a4d:	75 42                	jne    807a91 <inet_aton+0xe6>
      if (pp >= parts + 3)
  807a4f:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  807a52:	8b 75 cc             	mov    -0x34(%ebp),%esi
  807a55:	39 c6                	cmp    %eax,%esi
  807a57:	0f 84 16 01 00 00    	je     807b73 <inet_aton+0x1c8>
      *pp++ = val;
  807a5d:	83 c6 04             	add    $0x4,%esi
  807a60:	89 75 cc             	mov    %esi,-0x34(%ebp)
  807a63:	89 5e fc             	mov    %ebx,-0x4(%esi)
      c = *++cp;
  807a66:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  807a69:	8d 50 01             	lea    0x1(%eax),%edx
  807a6c:	0f be 40 01          	movsbl 0x1(%eax),%eax
    if (!isdigit(c))
  807a70:	8d 48 d0             	lea    -0x30(%eax),%ecx
  807a73:	80 f9 09             	cmp    $0x9,%cl
  807a76:	0f 87 f0 00 00 00    	ja     807b6c <inet_aton+0x1c1>
    base = 10;
  807a7c:	be 0a 00 00 00       	mov    $0xa,%esi
    if (c == '0') {
  807a81:	83 f8 30             	cmp    $0x30,%eax
  807a84:	0f 84 3f ff ff ff    	je     8079c9 <inet_aton+0x1e>
    base = 10;
  807a8a:	bb 00 00 00 00       	mov    $0x0,%ebx
  807a8f:	eb 9f                	jmp    807a30 <inet_aton+0x85>
  if (c != '\0' && (!isprint(c) || !isspace(c)))
  807a91:	85 c0                	test   %eax,%eax
  807a93:	74 29                	je     807abe <inet_aton+0x113>
    return (0);
  807a95:	ba 00 00 00 00       	mov    $0x0,%edx
  if (c != '\0' && (!isprint(c) || !isspace(c)))
  807a9a:	89 f9                	mov    %edi,%ecx
  807a9c:	80 f9 1f             	cmp    $0x1f,%cl
  807a9f:	0f 86 d3 00 00 00    	jbe    807b78 <inet_aton+0x1cd>
  807aa5:	84 c0                	test   %al,%al
  807aa7:	0f 88 cb 00 00 00    	js     807b78 <inet_aton+0x1cd>
  807aad:	83 f8 20             	cmp    $0x20,%eax
  807ab0:	74 0c                	je     807abe <inet_aton+0x113>
  807ab2:	83 e8 09             	sub    $0x9,%eax
  807ab5:	83 f8 04             	cmp    $0x4,%eax
  807ab8:	0f 87 ba 00 00 00    	ja     807b78 <inet_aton+0x1cd>
  n = pp - parts + 1;
  807abe:	8d 45 d8             	lea    -0x28(%ebp),%eax
  807ac1:	8b 75 cc             	mov    -0x34(%ebp),%esi
  807ac4:	29 c6                	sub    %eax,%esi
  807ac6:	89 f0                	mov    %esi,%eax
  807ac8:	c1 f8 02             	sar    $0x2,%eax
  807acb:	8d 50 01             	lea    0x1(%eax),%edx
  switch (n) {
  807ace:	83 f8 02             	cmp    $0x2,%eax
  807ad1:	74 7a                	je     807b4d <inet_aton+0x1a2>
  807ad3:	83 fa 03             	cmp    $0x3,%edx
  807ad6:	7f 49                	jg     807b21 <inet_aton+0x176>
  807ad8:	85 d2                	test   %edx,%edx
  807ada:	0f 84 98 00 00 00    	je     807b78 <inet_aton+0x1cd>
  807ae0:	83 fa 02             	cmp    $0x2,%edx
  807ae3:	75 19                	jne    807afe <inet_aton+0x153>
      return (0);
  807ae5:	ba 00 00 00 00       	mov    $0x0,%edx
    if (val > 0xffffffUL)
  807aea:	81 fb ff ff ff 00    	cmp    $0xffffff,%ebx
  807af0:	0f 87 82 00 00 00    	ja     807b78 <inet_aton+0x1cd>
    val |= parts[0] << 24;
  807af6:	8b 45 d8             	mov    -0x28(%ebp),%eax
  807af9:	c1 e0 18             	shl    $0x18,%eax
  807afc:	09 c3                	or     %eax,%ebx
  return (1);
  807afe:	ba 01 00 00 00       	mov    $0x1,%edx
  if (addr)
  807b03:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  807b07:	74 6f                	je     807b78 <inet_aton+0x1cd>
    addr->s_addr = htonl(val);
  807b09:	83 ec 0c             	sub    $0xc,%esp
  807b0c:	53                   	push   %ebx
  807b0d:	e8 69 fe ff ff       	call   80797b <htonl>
  807b12:	83 c4 10             	add    $0x10,%esp
  807b15:	8b 75 0c             	mov    0xc(%ebp),%esi
  807b18:	89 06                	mov    %eax,(%esi)
  return (1);
  807b1a:	ba 01 00 00 00       	mov    $0x1,%edx
  807b1f:	eb 57                	jmp    807b78 <inet_aton+0x1cd>
  switch (n) {
  807b21:	83 fa 04             	cmp    $0x4,%edx
  807b24:	75 d8                	jne    807afe <inet_aton+0x153>
      return (0);
  807b26:	ba 00 00 00 00       	mov    $0x0,%edx
    if (val > 0xff)
  807b2b:	81 fb ff 00 00 00    	cmp    $0xff,%ebx
  807b31:	77 45                	ja     807b78 <inet_aton+0x1cd>
    val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
  807b33:	8b 45 d8             	mov    -0x28(%ebp),%eax
  807b36:	c1 e0 18             	shl    $0x18,%eax
  807b39:	8b 55 dc             	mov    -0x24(%ebp),%edx
  807b3c:	c1 e2 10             	shl    $0x10,%edx
  807b3f:	09 d0                	or     %edx,%eax
  807b41:	8b 55 e0             	mov    -0x20(%ebp),%edx
  807b44:	c1 e2 08             	shl    $0x8,%edx
  807b47:	09 d0                	or     %edx,%eax
  807b49:	09 c3                	or     %eax,%ebx
    break;
  807b4b:	eb b1                	jmp    807afe <inet_aton+0x153>
      return (0);
  807b4d:	ba 00 00 00 00       	mov    $0x0,%edx
    if (val > 0xffff)
  807b52:	81 fb ff ff 00 00    	cmp    $0xffff,%ebx
  807b58:	77 1e                	ja     807b78 <inet_aton+0x1cd>
    val |= (parts[0] << 24) | (parts[1] << 16);
  807b5a:	8b 45 d8             	mov    -0x28(%ebp),%eax
  807b5d:	c1 e0 18             	shl    $0x18,%eax
  807b60:	8b 55 dc             	mov    -0x24(%ebp),%edx
  807b63:	c1 e2 10             	shl    $0x10,%edx
  807b66:	09 d0                	or     %edx,%eax
  807b68:	09 c3                	or     %eax,%ebx
    break;
  807b6a:	eb 92                	jmp    807afe <inet_aton+0x153>
      return (0);
  807b6c:	ba 00 00 00 00       	mov    $0x0,%edx
  807b71:	eb 05                	jmp    807b78 <inet_aton+0x1cd>
        return (0);
  807b73:	ba 00 00 00 00       	mov    $0x0,%edx
}
  807b78:	89 d0                	mov    %edx,%eax
  807b7a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  807b7d:	5b                   	pop    %ebx
  807b7e:	5e                   	pop    %esi
  807b7f:	5f                   	pop    %edi
  807b80:	5d                   	pop    %ebp
  807b81:	c3                   	ret    

00807b82 <inet_addr>:
{
  807b82:	f3 0f 1e fb          	endbr32 
  807b86:	55                   	push   %ebp
  807b87:	89 e5                	mov    %esp,%ebp
  807b89:	83 ec 20             	sub    $0x20,%esp
  if (inet_aton(cp, &val)) {
  807b8c:	8d 45 f4             	lea    -0xc(%ebp),%eax
  807b8f:	50                   	push   %eax
  807b90:	ff 75 08             	pushl  0x8(%ebp)
  807b93:	e8 13 fe ff ff       	call   8079ab <inet_aton>
  807b98:	83 c4 10             	add    $0x10,%esp
    return (val.s_addr);
  807b9b:	85 c0                	test   %eax,%eax
  807b9d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807ba2:	0f 45 45 f4          	cmovne -0xc(%ebp),%eax
}
  807ba6:	c9                   	leave  
  807ba7:	c3                   	ret    

00807ba8 <ntohl>:
 * @param n u32_t in network byte order
 * @return n in host byte order
 */
u32_t
ntohl(u32_t n)
{
  807ba8:	f3 0f 1e fb          	endbr32 
  807bac:	55                   	push   %ebp
  807bad:	89 e5                	mov    %esp,%ebp
  807baf:	83 ec 14             	sub    $0x14,%esp
  return htonl(n);
  807bb2:	ff 75 08             	pushl  0x8(%ebp)
  807bb5:	e8 c1 fd ff ff       	call   80797b <htonl>
  807bba:	83 c4 10             	add    $0x10,%esp
}
  807bbd:	c9                   	leave  
  807bbe:	c3                   	ret    

00807bbf <tcp_enqueue>:
 */
err_t
tcp_enqueue(struct tcp_pcb *pcb, void *arg, u16_t len,
  u8_t flags, u8_t apiflags,
  u8_t *optdata, u8_t optlen)
{
  807bbf:	f3 0f 1e fb          	endbr32 
  807bc3:	55                   	push   %ebp
  807bc4:	89 e5                	mov    %esp,%ebp
  807bc6:	57                   	push   %edi
  807bc7:	56                   	push   %esi
  807bc8:	53                   	push   %ebx
  807bc9:	83 ec 3c             	sub    $0x3c,%esp
  807bcc:	8b 7d 08             	mov    0x8(%ebp),%edi
  807bcf:	8b 75 10             	mov    0x10(%ebp),%esi
  807bd2:	89 75 c4             	mov    %esi,-0x3c(%ebp)
  807bd5:	8b 55 14             	mov    0x14(%ebp),%edx
  807bd8:	89 55 bc             	mov    %edx,-0x44(%ebp)
  807bdb:	8b 5d 18             	mov    0x18(%ebp),%ebx
  807bde:	89 5d b8             	mov    %ebx,-0x48(%ebp)
  807be1:	8b 45 20             	mov    0x20(%ebp),%eax
  807be4:	66 89 75 c2          	mov    %si,-0x3e(%ebp)
  807be8:	88 55 dd             	mov    %dl,-0x23(%ebp)
  807beb:	89 da                	mov    %ebx,%edx
  807bed:	88 45 dc             	mov    %al,-0x24(%ebp)
  void *ptr;
  u16_t queuelen;

  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_enqueue(pcb=%p, arg=%p, len=%"U16_F", flags=%"X16_F", apiflags=%"U16_F")\n",
    (void *)pcb, arg, len, (u16_t)flags, (u16_t)apiflags));
  LWIP_ERROR("tcp_enqueue: len == 0 || optlen == 0 (programmer violates API)",
  807bf0:	66 85 f6             	test   %si,%si
  807bf3:	74 04                	je     807bf9 <tcp_enqueue+0x3a>
  807bf5:	84 c0                	test   %al,%al
  807bf7:	75 54                	jne    807c4d <tcp_enqueue+0x8e>
      ((len == 0) || (optlen == 0)), return ERR_ARG;);
  LWIP_ERROR("tcp_enqueue: arg == NULL || optdata == NULL (programmer violates API)",
  807bf9:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  807bfd:	74 06                	je     807c05 <tcp_enqueue+0x46>
  807bff:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  807c03:	75 5f                	jne    807c64 <tcp_enqueue+0xa5>
      ((arg == NULL) || (optdata == NULL)), return ERR_ARG;);
  /* fail on too much data */
  if (len > pcb->snd_buf) {
  807c05:	0f b7 4d c4          	movzwl -0x3c(%ebp),%ecx
  807c09:	66 39 4f 6e          	cmp    %cx,0x6e(%edi)
  807c0d:	72 6c                	jb     807c7b <tcp_enqueue+0xbc>
  left = len;
  ptr = arg;

  /* seqno will be the sequence number of the first segment enqueued
   * by the call to this function. */
  seqno = pcb->snd_lbb;
  807c0f:	8b 4f 68             	mov    0x68(%edi),%ecx
  807c12:	89 4d d8             	mov    %ecx,-0x28(%ebp)

  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));

  /* If total number of pbufs on the unsent/unacked queues exceeds the
   * configured maximum, return an error */
  queuelen = pcb->snd_queuelen;
  807c15:	0f b7 4f 70          	movzwl 0x70(%edi),%ecx
  807c19:	66 89 4d e0          	mov    %cx,-0x20(%ebp)
  /* check for configured max queuelen and possible overflow */
  if ((queuelen >= TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
  807c1d:	66 83 f9 1f          	cmp    $0x1f,%cx
  807c21:	77 66                	ja     807c89 <tcp_enqueue+0xca>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue: too long queue %"U16_F" (max %"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
    TCP_STATS_INC(tcp.memerr);
    pcb->flags |= TF_NAGLEMEMERR;
    return ERR_MEM;
  }
  if (queuelen != 0) {
  807c23:	66 83 7d e0 00       	cmpw   $0x0,-0x20(%ebp)
  807c28:	74 6d                	je     807c97 <tcp_enqueue+0xd8>
    LWIP_ASSERT("tcp_enqueue: pbufs on queue => at least one queue non-empty",
  807c2a:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  807c2e:	75 7b                	jne    807cab <tcp_enqueue+0xec>
  807c30:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  807c34:	75 75                	jne    807cab <tcp_enqueue+0xec>
  807c36:	83 ec 04             	sub    $0x4,%esp
  807c39:	68 2c 26 81 00       	push   $0x81262c
  807c3e:	68 ad 00 00 00       	push   $0xad
  807c43:	68 46 27 81 00       	push   $0x812746
  807c48:	e8 fa 6c 00 00       	call   80e947 <_panic>
  LWIP_ERROR("tcp_enqueue: len == 0 || optlen == 0 (programmer violates API)",
  807c4d:	83 ec 04             	sub    $0x4,%esp
  807c50:	68 a4 25 81 00       	push   $0x8125a4
  807c55:	68 8f 00 00 00       	push   $0x8f
  807c5a:	68 46 27 81 00       	push   $0x812746
  807c5f:	e8 e3 6c 00 00       	call   80e947 <_panic>
  LWIP_ERROR("tcp_enqueue: arg == NULL || optdata == NULL (programmer violates API)",
  807c64:	83 ec 04             	sub    $0x4,%esp
  807c67:	68 e4 25 81 00       	push   $0x8125e4
  807c6c:	68 91 00 00 00       	push   $0x91
  807c71:	68 46 27 81 00       	push   $0x812746
  807c76:	e8 cc 6c 00 00       	call   80e947 <_panic>
    pcb->flags |= TF_NAGLEMEMERR;
  807c7b:	80 4f 20 80          	orb    $0x80,0x20(%edi)
    return ERR_MEM;
  807c7f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807c84:	e9 64 04 00 00       	jmp    8080ed <tcp_enqueue+0x52e>
    pcb->flags |= TF_NAGLEMEMERR;
  807c89:	80 4f 20 80          	orb    $0x80,0x20(%edi)
    return ERR_MEM;
  807c8d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807c92:	e9 56 04 00 00       	jmp    8080ed <tcp_enqueue+0x52e>
      pcb->unacked != NULL || pcb->unsent != NULL);
  } else {
    LWIP_ASSERT("tcp_enqueue: no pbufs on queue => both queues empty",
  807c97:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  807c9b:	0f 85 c5 02 00 00    	jne    807f66 <tcp_enqueue+0x3a7>
  807ca1:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  807ca5:	0f 85 bb 02 00 00    	jne    807f66 <tcp_enqueue+0x3a7>
    /* Copy the options into the header, if they are present. */
    if (optdata == NULL) {
      TCPH_HDRLEN_SET(seg->tcphdr, 5);
    }
    else {
      TCPH_HDRLEN_SET(seg->tcphdr, (5 + optlen / 4));
  807cab:	c0 e8 02             	shr    $0x2,%al
  807cae:	c1 e0 0c             	shl    $0xc,%eax
  807cb1:	66 05 00 50          	add    $0x5000,%ax
  807cb5:	66 89 45 ca          	mov    %ax,-0x36(%ebp)
  807cb9:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
  807cbd:	66 89 45 de          	mov    %ax,-0x22(%ebp)
  807cc1:	8b 45 0c             	mov    0xc(%ebp),%eax
  807cc4:	89 45 d0             	mov    %eax,-0x30(%ebp)
  807cc7:	bb 00 00 00 00       	mov    $0x0,%ebx
  while (queue == NULL || left > 0) {
  807ccc:	c6 45 e4 01          	movb   $0x1,-0x1c(%ebp)
      TCPH_HDRLEN_SET(seg->tcphdr, (5 + optlen / 4));
  807cd0:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
    else if (apiflags & TCP_WRITE_FLAG_COPY) {
  807cd7:	83 e2 01             	and    $0x1,%edx
  807cda:	88 55 c9             	mov    %dl,-0x37(%ebp)
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
  807cdd:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
  807ce1:	89 45 cc             	mov    %eax,-0x34(%ebp)
    seglen = left > pcb->mss? pcb->mss: left;
  807ce4:	0f b7 45 de          	movzwl -0x22(%ebp),%eax
  807ce8:	66 39 47 34          	cmp    %ax,0x34(%edi)
  807cec:	66 0f 46 47 34       	cmovbe 0x34(%edi),%ax
  807cf1:	66 89 45 e2          	mov    %ax,-0x1e(%ebp)
  807cf5:	89 de                	mov    %ebx,%esi
    seg = memp_malloc(MEMP_TCP_SEG);
  807cf7:	83 ec 0c             	sub    $0xc,%esp
  807cfa:	6a 04                	push   $0x4
  807cfc:	e8 43 c9 ff ff       	call   804644 <memp_malloc>
  807d01:	89 c3                	mov    %eax,%ebx
    if (seg == NULL) {
  807d03:	83 c4 10             	add    $0x10,%esp
  807d06:	85 c0                	test   %eax,%eax
  807d08:	0f 84 a4 03 00 00    	je     8080b2 <tcp_enqueue+0x4f3>
    seg->next = NULL;
  807d0e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    seg->p = NULL;
  807d14:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    if (queue == NULL) {
  807d1b:	80 7d e4 00          	cmpb   $0x0,-0x1c(%ebp)
  807d1f:	0f 85 6f 02 00 00    	jne    807f94 <tcp_enqueue+0x3d5>
      LWIP_ASSERT("useg != NULL", useg != NULL);
  807d25:	85 f6                	test   %esi,%esi
  807d27:	0f 84 50 02 00 00    	je     807f7d <tcp_enqueue+0x3be>
      useg->next = seg;
  807d2d:	89 06                	mov    %eax,(%esi)
    if (optdata != NULL) {
  807d2f:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  807d33:	0f 84 7a 02 00 00    	je     807fb3 <tcp_enqueue+0x3f4>
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
  807d39:	83 ec 04             	sub    $0x4,%esp
  807d3c:	6a 00                	push   $0x0
  807d3e:	ff 75 cc             	pushl  -0x34(%ebp)
  807d41:	6a 00                	push   $0x0
  807d43:	e8 a3 cd ff ff       	call   804aeb <pbuf_alloc>
  807d48:	89 43 04             	mov    %eax,0x4(%ebx)
  807d4b:	83 c4 10             	add    $0x10,%esp
  807d4e:	85 c0                	test   %eax,%eax
  807d50:	0f 84 5c 03 00 00    	je     8080b2 <tcp_enqueue+0x4f3>
      LWIP_ASSERT("check that first pbuf can hold optlen",
  807d56:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
  807d5a:	66 39 50 0a          	cmp    %dx,0xa(%eax)
  807d5e:	0f 82 38 02 00 00    	jb     807f9c <tcp_enqueue+0x3dd>
      queuelen += pbuf_clen(seg->p);
  807d64:	83 ec 0c             	sub    $0xc,%esp
  807d67:	50                   	push   %eax
  807d68:	e8 f3 d0 ff ff       	call   804e60 <pbuf_clen>
  807d6d:	0f b6 c0             	movzbl %al,%eax
  807d70:	66 01 45 e0          	add    %ax,-0x20(%ebp)
      seg->dataptr = seg->p->payload;
  807d74:	8b 43 04             	mov    0x4(%ebx),%eax
  807d77:	8b 40 04             	mov    0x4(%eax),%eax
  807d7a:	89 43 08             	mov    %eax,0x8(%ebx)
  807d7d:	83 c4 10             	add    $0x10,%esp
    if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
  807d80:	66 83 7d e0 20       	cmpw   $0x20,-0x20(%ebp)
  807d85:	0f 87 27 03 00 00    	ja     8080b2 <tcp_enqueue+0x4f3>
    seg->len = seglen;
  807d8b:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  807d8f:	66 89 43 0c          	mov    %ax,0xc(%ebx)
    if (pbuf_header(seg->p, TCP_HLEN)) {
  807d93:	83 ec 08             	sub    $0x8,%esp
  807d96:	6a 14                	push   $0x14
  807d98:	ff 73 04             	pushl  0x4(%ebx)
  807d9b:	e8 ae cb ff ff       	call   80494e <pbuf_header>
  807da0:	83 c4 10             	add    $0x10,%esp
  807da3:	84 c0                	test   %al,%al
  807da5:	0f 85 07 03 00 00    	jne    8080b2 <tcp_enqueue+0x4f3>
    seg->tcphdr = seg->p->payload;
  807dab:	8b 43 04             	mov    0x4(%ebx),%eax
  807dae:	8b 70 04             	mov    0x4(%eax),%esi
  807db1:	89 73 10             	mov    %esi,0x10(%ebx)
    seg->tcphdr->src = htons(pcb->local_port);
  807db4:	83 ec 0c             	sub    $0xc,%esp
  807db7:	0f b7 47 1c          	movzwl 0x1c(%edi),%eax
  807dbb:	50                   	push   %eax
  807dbc:	e8 98 fb ff ff       	call   807959 <htons>
  807dc1:	66 89 06             	mov    %ax,(%esi)
    seg->tcphdr->dest = htons(pcb->remote_port);
  807dc4:	8b 73 10             	mov    0x10(%ebx),%esi
  807dc7:	0f b7 47 1e          	movzwl 0x1e(%edi),%eax
  807dcb:	89 04 24             	mov    %eax,(%esp)
  807dce:	e8 86 fb ff ff       	call   807959 <htons>
  807dd3:	66 89 46 02          	mov    %ax,0x2(%esi)
    seg->tcphdr->seqno = htonl(seqno);
  807dd7:	8b 73 10             	mov    0x10(%ebx),%esi
  807dda:	83 c4 04             	add    $0x4,%esp
  807ddd:	ff 75 d8             	pushl  -0x28(%ebp)
  807de0:	e8 96 fb ff ff       	call   80797b <htonl>
  807de5:	89 46 04             	mov    %eax,0x4(%esi)
    seg->tcphdr->urgp = 0;
  807de8:	8b 43 10             	mov    0x10(%ebx),%eax
  807deb:	66 c7 40 12 00 00    	movw   $0x0,0x12(%eax)
    TCPH_FLAGS_SET(seg->tcphdr, flags);
  807df1:	8b 43 10             	mov    0x10(%ebx),%eax
  807df4:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  807df8:	89 04 24             	mov    %eax,(%esp)
  807dfb:	e8 6a fb ff ff       	call   80796a <ntohs>
  807e00:	8b 73 10             	mov    0x10(%ebx),%esi
  807e03:	83 e0 c0             	and    $0xffffffc0,%eax
  807e06:	0f b6 55 dd          	movzbl -0x23(%ebp),%edx
  807e0a:	09 d0                	or     %edx,%eax
  807e0c:	0f b7 c0             	movzwl %ax,%eax
  807e0f:	89 04 24             	mov    %eax,(%esp)
  807e12:	e8 42 fb ff ff       	call   807959 <htons>
  807e17:	66 89 46 0c          	mov    %ax,0xc(%esi)
    if (optdata == NULL) {
  807e1b:	83 c4 10             	add    $0x10,%esp
  807e1e:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  807e22:	0f 84 cd 02 00 00    	je     8080f5 <tcp_enqueue+0x536>
      TCPH_HDRLEN_SET(seg->tcphdr, (5 + optlen / 4));
  807e28:	83 ec 0c             	sub    $0xc,%esp
  807e2b:	8b 43 10             	mov    0x10(%ebx),%eax
  807e2e:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  807e32:	50                   	push   %eax
  807e33:	e8 32 fb ff ff       	call   80796a <ntohs>
  807e38:	8b 73 10             	mov    0x10(%ebx),%esi
  807e3b:	83 e0 3f             	and    $0x3f,%eax
  807e3e:	66 0b 45 ca          	or     -0x36(%ebp),%ax
  807e42:	0f b7 c0             	movzwl %ax,%eax
  807e45:	89 04 24             	mov    %eax,(%esp)
  807e48:	e8 0c fb ff ff       	call   807959 <htons>
  807e4d:	66 89 46 0c          	mov    %ax,0xc(%esi)
      /* Copy options into data portion of segment.
       Options can thus only be sent in non data carrying
       segments such as SYN|ACK. */
      SMEMCPY(seg->dataptr, optdata, optlen);
  807e51:	83 c4 0c             	add    $0xc,%esp
  807e54:	ff 75 cc             	pushl  -0x34(%ebp)
  807e57:	ff 75 1c             	pushl  0x1c(%ebp)
  807e5a:	ff 73 08             	pushl  0x8(%ebx)
  807e5d:	e8 f2 73 00 00       	call   80f254 <memcpy>
  807e62:	83 c4 10             	add    $0x10,%esp
      ntohl(seg->tcphdr->seqno),
      ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
      (u16_t)flags));

    left -= seglen;
    seqno += seglen;
  807e65:	0f b7 4d e2          	movzwl -0x1e(%ebp),%ecx
  807e69:	0f b7 c1             	movzwl %cx,%eax
  807e6c:	01 45 d8             	add    %eax,-0x28(%ebp)
    ptr = (void *)((u8_t *)ptr + seglen);
  807e6f:	01 45 d0             	add    %eax,-0x30(%ebp)
  while (queue == NULL || left > 0) {
  807e72:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
  807e76:	0f 94 45 e4          	sete   -0x1c(%ebp)
  807e7a:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  807e7e:	66 29 4d de          	sub    %cx,-0x22(%ebp)
  807e82:	0f 85 5c fe ff ff    	jne    807ce4 <tcp_enqueue+0x125>
  807e88:	84 c0                	test   %al,%al
  807e8a:	0f 85 54 fe ff ff    	jne    807ce4 <tcp_enqueue+0x125>
  }

  /* Now that the data to be enqueued has been broken up into TCP
  segments in the queue variable, we add them to the end of the
  pcb->unsent queue. */
  if (pcb->unsent == NULL) {
  807e90:	8b 77 74             	mov    0x74(%edi),%esi
  807e93:	85 f6                	test   %esi,%esi
  807e95:	0f 84 bb 03 00 00    	je     808256 <tcp_enqueue+0x697>
  807e9b:	89 f0                	mov    %esi,%eax
    useg = NULL;
  }
  else {
    for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
  807e9d:	8b 36                	mov    (%esi),%esi
  807e9f:	85 f6                	test   %esi,%esi
  807ea1:	75 f8                	jne    807e9b <tcp_enqueue+0x2dc>
  807ea3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
    TCP_TCPLEN(useg) != 0 &&
  807ea6:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
  807eaa:	66 89 55 de          	mov    %dx,-0x22(%ebp)
  807eae:	83 ec 0c             	sub    $0xc,%esp
  807eb1:	8b 40 10             	mov    0x10(%eax),%eax
  807eb4:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  807eb8:	50                   	push   %eax
  807eb9:	e8 ac fa ff ff       	call   80796a <ntohs>
  807ebe:	83 c4 10             	add    $0x10,%esp
  807ec1:	a8 01                	test   $0x1,%al
  807ec3:	0f 84 59 02 00 00    	je     808122 <tcp_enqueue+0x563>
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
  807ec9:	83 ec 0c             	sub    $0xc,%esp
  807ecc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  807ecf:	8b 40 10             	mov    0x10(%eax),%eax
  807ed2:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  807ed6:	50                   	push   %eax
  807ed7:	e8 8e fa ff ff       	call   80796a <ntohs>
    TCP_TCPLEN(useg) != 0 &&
  807edc:	83 c4 10             	add    $0x10,%esp
  807edf:	a8 03                	test   $0x3,%al
  807ee1:	0f 85 63 02 00 00    	jne    80814a <tcp_enqueue+0x58b>
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
  807ee7:	f6 45 bc 03          	testb  $0x3,-0x44(%ebp)
  807eeb:	0f 85 59 02 00 00    	jne    80814a <tcp_enqueue+0x58b>
    !(flags & (TCP_SYN | TCP_FIN)) &&
    /* fit within max seg size */
    useg->len + queue->len <= pcb->mss) {
  807ef1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  807ef4:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  807ef8:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  807efb:	0f b7 52 0c          	movzwl 0xc(%edx),%edx
  807eff:	01 d0                	add    %edx,%eax
  807f01:	0f b7 57 34          	movzwl 0x34(%edi),%edx
    !(flags & (TCP_SYN | TCP_FIN)) &&
  807f05:	39 d0                	cmp    %edx,%eax
  807f07:	0f 8f 3d 02 00 00    	jg     80814a <tcp_enqueue+0x58b>
    /* Remove TCP header from first segment of our to-be-queued list */
    if(pbuf_header(queue->p, -TCP_HLEN)) {
  807f0d:	83 ec 08             	sub    $0x8,%esp
  807f10:	6a ec                	push   $0xffffffec
  807f12:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  807f15:	ff 70 04             	pushl  0x4(%eax)
  807f18:	e8 31 ca ff ff       	call   80494e <pbuf_header>
  807f1d:	83 c4 10             	add    $0x10,%esp
  807f20:	84 c0                	test   %al,%al
  807f22:	0f 85 c5 02 00 00    	jne    8081ed <tcp_enqueue+0x62e>
      /* Can we cope with this failing?  Just assert for now */
      LWIP_ASSERT("pbuf_header failed\n", 0);
      TCP_STATS_INC(tcp.err);
      goto memerr;
    }
    pbuf_cat(useg->p, queue->p);
  807f28:	83 ec 08             	sub    $0x8,%esp
  807f2b:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  807f2e:	ff 72 04             	pushl  0x4(%edx)
  807f31:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  807f34:	ff 71 04             	pushl  0x4(%ecx)
  807f37:	e8 57 cf ff ff       	call   804e93 <pbuf_cat>
    useg->len += queue->len;
  807f3c:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  807f3f:	0f b7 42 0c          	movzwl 0xc(%edx),%eax
  807f43:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  807f46:	66 01 41 0c          	add    %ax,0xc(%ecx)
    useg->next = queue->next;
  807f4a:	8b 02                	mov    (%edx),%eax
  807f4c:	89 01                	mov    %eax,(%ecx)

    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("tcp_enqueue: chaining segments, new len %"U16_F"\n", useg->len));
    if (seg == queue) {
  807f4e:	83 c4 08             	add    $0x8,%esp
      seg = NULL;
  807f51:	39 da                	cmp    %ebx,%edx
  807f53:	0f 44 de             	cmove  %esi,%ebx
    }
    memp_free(MEMP_TCP_SEG, queue);
  807f56:	52                   	push   %edx
  807f57:	6a 04                	push   $0x4
  807f59:	e8 40 c7 ff ff       	call   80469e <memp_free>
  807f5e:	83 c4 10             	add    $0x10,%esp
  807f61:	e9 00 02 00 00       	jmp    808166 <tcp_enqueue+0x5a7>
    LWIP_ASSERT("tcp_enqueue: no pbufs on queue => both queues empty",
  807f66:	83 ec 04             	sub    $0x4,%esp
  807f69:	68 68 26 81 00       	push   $0x812668
  807f6e:	68 b0 00 00 00       	push   $0xb0
  807f73:	68 46 27 81 00       	push   $0x812746
  807f78:	e8 ca 69 00 00       	call   80e947 <_panic>
      LWIP_ASSERT("useg != NULL", useg != NULL);
  807f7d:	83 ec 04             	sub    $0x4,%esp
  807f80:	68 5e 27 81 00       	push   $0x81275e
  807f85:	68 ce 00 00 00       	push   $0xce
  807f8a:	68 46 27 81 00       	push   $0x812746
  807f8f:	e8 b3 69 00 00       	call   80e947 <_panic>
    seg = memp_malloc(MEMP_TCP_SEG);
  807f94:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  807f97:	e9 93 fd ff ff       	jmp    807d2f <tcp_enqueue+0x170>
      LWIP_ASSERT("check that first pbuf can hold optlen",
  807f9c:	83 ec 04             	sub    $0x4,%esp
  807f9f:	68 9c 26 81 00       	push   $0x81269c
  807fa4:	68 de 00 00 00       	push   $0xde
  807fa9:	68 46 27 81 00       	push   $0x812746
  807fae:	e8 94 69 00 00       	call   80e947 <_panic>
    else if (apiflags & TCP_WRITE_FLAG_COPY) {
  807fb3:	80 7d c9 00          	cmpb   $0x0,-0x37(%ebp)
  807fb7:	74 7f                	je     808038 <tcp_enqueue+0x479>
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_RAM)) == NULL) {
  807fb9:	83 ec 04             	sub    $0x4,%esp
  807fbc:	6a 00                	push   $0x0
  807fbe:	0f b7 75 e2          	movzwl -0x1e(%ebp),%esi
  807fc2:	0f b7 c6             	movzwl %si,%eax
  807fc5:	50                   	push   %eax
  807fc6:	6a 00                	push   $0x0
  807fc8:	e8 1e cb ff ff       	call   804aeb <pbuf_alloc>
  807fcd:	89 43 04             	mov    %eax,0x4(%ebx)
  807fd0:	83 c4 10             	add    $0x10,%esp
  807fd3:	85 c0                	test   %eax,%eax
  807fd5:	0f 84 d7 00 00 00    	je     8080b2 <tcp_enqueue+0x4f3>
      LWIP_ASSERT("check that first pbuf can hold the complete seglen",
  807fdb:	66 39 70 0a          	cmp    %si,0xa(%eax)
  807fdf:	72 40                	jb     808021 <tcp_enqueue+0x462>
      queuelen += pbuf_clen(seg->p);
  807fe1:	83 ec 0c             	sub    $0xc,%esp
  807fe4:	50                   	push   %eax
  807fe5:	e8 76 ce ff ff       	call   804e60 <pbuf_clen>
  807fea:	0f b6 c0             	movzbl %al,%eax
  807fed:	66 01 45 e0          	add    %ax,-0x20(%ebp)
      if (arg != NULL) {
  807ff1:	83 c4 10             	add    $0x10,%esp
  807ff4:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  807ff8:	74 19                	je     808013 <tcp_enqueue+0x454>
        MEMCPY(seg->p->payload, ptr, seglen);
  807ffa:	83 ec 04             	sub    $0x4,%esp
  807ffd:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  808001:	50                   	push   %eax
  808002:	ff 75 d0             	pushl  -0x30(%ebp)
  808005:	8b 43 04             	mov    0x4(%ebx),%eax
  808008:	ff 70 04             	pushl  0x4(%eax)
  80800b:	e8 44 72 00 00       	call   80f254 <memcpy>
  808010:	83 c4 10             	add    $0x10,%esp
      seg->dataptr = seg->p->payload;
  808013:	8b 43 04             	mov    0x4(%ebx),%eax
  808016:	8b 40 04             	mov    0x4(%eax),%eax
  808019:	89 43 08             	mov    %eax,0x8(%ebx)
  80801c:	e9 5f fd ff ff       	jmp    807d80 <tcp_enqueue+0x1c1>
      LWIP_ASSERT("check that first pbuf can hold the complete seglen",
  808021:	83 ec 04             	sub    $0x4,%esp
  808024:	68 c4 26 81 00       	push   $0x8126c4
  808029:	68 e9 00 00 00       	push   $0xe9
  80802e:	68 46 27 81 00       	push   $0x812746
  808033:	e8 0f 69 00 00       	call   80e947 <_panic>
      if ((p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
  808038:	83 ec 04             	sub    $0x4,%esp
  80803b:	6a 01                	push   $0x1
  80803d:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  808041:	50                   	push   %eax
  808042:	6a 00                	push   $0x0
  808044:	e8 a2 ca ff ff       	call   804aeb <pbuf_alloc>
  808049:	89 c6                	mov    %eax,%esi
  80804b:	83 c4 10             	add    $0x10,%esp
  80804e:	85 c0                	test   %eax,%eax
  808050:	74 60                	je     8080b2 <tcp_enqueue+0x4f3>
      ++queuelen;
  808052:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  808056:	83 c0 01             	add    $0x1,%eax
  808059:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
      p->payload = ptr;
  80805d:	8b 45 d0             	mov    -0x30(%ebp),%eax
  808060:	89 46 04             	mov    %eax,0x4(%esi)
      seg->dataptr = ptr;
  808063:	89 43 08             	mov    %eax,0x8(%ebx)
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_RAM)) == NULL) {
  808066:	83 ec 04             	sub    $0x4,%esp
  808069:	6a 00                	push   $0x0
  80806b:	6a 00                	push   $0x0
  80806d:	6a 00                	push   $0x0
  80806f:	e8 77 ca ff ff       	call   804aeb <pbuf_alloc>
  808074:	89 43 04             	mov    %eax,0x4(%ebx)
  808077:	83 c4 10             	add    $0x10,%esp
  80807a:	85 c0                	test   %eax,%eax
  80807c:	74 28                	je     8080a6 <tcp_enqueue+0x4e7>
      queuelen += pbuf_clen(seg->p);
  80807e:	83 ec 0c             	sub    $0xc,%esp
  808081:	50                   	push   %eax
  808082:	e8 d9 cd ff ff       	call   804e60 <pbuf_clen>
  808087:	0f b6 c0             	movzbl %al,%eax
  80808a:	66 03 45 e4          	add    -0x1c(%ebp),%ax
  80808e:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
      pbuf_cat(seg->p/*header*/, p/*data*/);
  808092:	83 c4 08             	add    $0x8,%esp
  808095:	56                   	push   %esi
  808096:	ff 73 04             	pushl  0x4(%ebx)
  808099:	e8 f5 cd ff ff       	call   804e93 <pbuf_cat>
  80809e:	83 c4 10             	add    $0x10,%esp
  8080a1:	e9 da fc ff ff       	jmp    807d80 <tcp_enqueue+0x1c1>
        pbuf_free(p);
  8080a6:	83 ec 0c             	sub    $0xc,%esp
  8080a9:	56                   	push   %esi
  8080aa:	e8 72 c9 ff ff       	call   804a21 <pbuf_free>
        goto memerr;
  8080af:	83 c4 10             	add    $0x10,%esp
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  }

  return ERR_OK;
memerr:
  pcb->flags |= TF_NAGLEMEMERR;
  8080b2:	80 4f 20 80          	orb    $0x80,0x20(%edi)
  TCP_STATS_INC(tcp.memerr);

  if (queue != NULL) {
  8080b6:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  8080b9:	85 c0                	test   %eax,%eax
  8080bb:	74 0c                	je     8080c9 <tcp_enqueue+0x50a>
    tcp_segs_free(queue);
  8080bd:	83 ec 0c             	sub    $0xc,%esp
  8080c0:	50                   	push   %eax
  8080c1:	e8 f2 d8 ff ff       	call   8059b8 <tcp_segs_free>
  8080c6:	83 c4 10             	add    $0x10,%esp
  }
  if (pcb->snd_queuelen != 0) {
  8080c9:	66 83 7f 70 00       	cmpw   $0x0,0x70(%edi)
  8080ce:	0f 84 6e 01 00 00    	je     808242 <tcp_enqueue+0x683>
    LWIP_ASSERT("tcp_enqueue: valid queue length", pcb->unacked != NULL ||
  8080d4:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  8080d8:	0f 85 6e 01 00 00    	jne    80824c <tcp_enqueue+0x68d>
  8080de:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  8080e2:	0f 84 39 01 00 00    	je     808221 <tcp_enqueue+0x662>
      pcb->unsent != NULL);
  }
  LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_enqueue: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
  return ERR_MEM;
  8080e8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  8080ed:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8080f0:	5b                   	pop    %ebx
  8080f1:	5e                   	pop    %esi
  8080f2:	5f                   	pop    %edi
  8080f3:	5d                   	pop    %ebp
  8080f4:	c3                   	ret    
      TCPH_HDRLEN_SET(seg->tcphdr, 5);
  8080f5:	83 ec 0c             	sub    $0xc,%esp
  8080f8:	8b 43 10             	mov    0x10(%ebx),%eax
  8080fb:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8080ff:	50                   	push   %eax
  808100:	e8 65 f8 ff ff       	call   80796a <ntohs>
  808105:	8b 73 10             	mov    0x10(%ebx),%esi
  808108:	83 e0 3f             	and    $0x3f,%eax
  80810b:	80 cc 50             	or     $0x50,%ah
  80810e:	89 04 24             	mov    %eax,(%esp)
  808111:	e8 43 f8 ff ff       	call   807959 <htons>
  808116:	66 89 46 0c          	mov    %ax,0xc(%esi)
  80811a:	83 c4 10             	add    $0x10,%esp
  80811d:	e9 43 fd ff ff       	jmp    807e65 <tcp_enqueue+0x2a6>
    TCP_TCPLEN(useg) != 0 &&
  808122:	83 ec 0c             	sub    $0xc,%esp
  808125:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  808128:	8b 40 10             	mov    0x10(%eax),%eax
  80812b:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80812f:	50                   	push   %eax
  808130:	e8 35 f8 ff ff       	call   80796a <ntohs>
  808135:	66 d1 e8             	shr    %ax
  808138:	83 e0 01             	and    $0x1,%eax
  80813b:	0f b7 55 de          	movzwl -0x22(%ebp),%edx
  if (useg != NULL &&
  80813f:	83 c4 10             	add    $0x10,%esp
  808142:	01 d0                	add    %edx,%eax
  808144:	0f 85 7f fd ff ff    	jne    807ec9 <tcp_enqueue+0x30a>
      useg->next = queue;
  80814a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80814d:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  808150:	89 10                	mov    %edx,(%eax)
    ++len;
  808152:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
  808156:	83 c0 01             	add    $0x1,%eax
  808159:	f6 45 bc 03          	testb  $0x3,-0x44(%ebp)
  80815d:	66 0f 44 45 c2       	cmove  -0x3e(%ebp),%ax
  808162:	66 89 45 c2          	mov    %ax,-0x3e(%ebp)
  if (flags & TCP_FIN) {
  808166:	f6 45 bc 01          	testb  $0x1,-0x44(%ebp)
  80816a:	74 04                	je     808170 <tcp_enqueue+0x5b1>
    pcb->flags |= TF_FIN;
  80816c:	80 4f 20 20          	orb    $0x20,0x20(%edi)
  pcb->snd_lbb += len;
  808170:	0f b7 55 c2          	movzwl -0x3e(%ebp),%edx
  808174:	0f b7 c2             	movzwl %dx,%eax
  808177:	01 47 68             	add    %eax,0x68(%edi)
  pcb->snd_buf -= len;
  80817a:	66 29 57 6e          	sub    %dx,0x6e(%edi)
  pcb->snd_queuelen = queuelen;
  80817e:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  808182:	66 89 47 70          	mov    %ax,0x70(%edi)
  if (pcb->snd_queuelen != 0) {
  808186:	66 85 c0             	test   %ax,%ax
  808189:	74 06                	je     808191 <tcp_enqueue+0x5d2>
    LWIP_ASSERT("tcp_enqueue: valid queue length",
  80818b:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80818f:	74 73                	je     808204 <tcp_enqueue+0x645>
  if (seg != NULL && seglen > 0 && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
  808191:	85 db                	test   %ebx,%ebx
  808193:	0f 84 9f 00 00 00    	je     808238 <tcp_enqueue+0x679>
  808199:	66 83 7d e2 00       	cmpw   $0x0,-0x1e(%ebp)
  80819e:	0f 84 94 00 00 00    	je     808238 <tcp_enqueue+0x679>
  8081a4:	8b 53 10             	mov    0x10(%ebx),%edx
  return ERR_OK;
  8081a7:	b8 00 00 00 00       	mov    $0x0,%eax
  if (seg != NULL && seglen > 0 && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
  8081ac:	85 d2                	test   %edx,%edx
  8081ae:	0f 84 39 ff ff ff    	je     8080ed <tcp_enqueue+0x52e>
  8081b4:	f6 45 b8 02          	testb  $0x2,-0x48(%ebp)
  8081b8:	0f 85 2f ff ff ff    	jne    8080ed <tcp_enqueue+0x52e>
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  8081be:	83 ec 0c             	sub    $0xc,%esp
  8081c1:	0f b7 42 0c          	movzwl 0xc(%edx),%eax
  8081c5:	50                   	push   %eax
  8081c6:	e8 9f f7 ff ff       	call   80796a <ntohs>
  8081cb:	8b 5b 10             	mov    0x10(%ebx),%ebx
  8081ce:	83 c8 08             	or     $0x8,%eax
  8081d1:	0f b7 c0             	movzwl %ax,%eax
  8081d4:	89 04 24             	mov    %eax,(%esp)
  8081d7:	e8 7d f7 ff ff       	call   807959 <htons>
  8081dc:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  8081e0:	83 c4 10             	add    $0x10,%esp
  return ERR_OK;
  8081e3:	b8 00 00 00 00       	mov    $0x0,%eax
  8081e8:	e9 00 ff ff ff       	jmp    8080ed <tcp_enqueue+0x52e>
      LWIP_ASSERT("pbuf_header failed\n", 0);
  8081ed:	83 ec 04             	sub    $0x4,%esp
  8081f0:	68 6b 27 81 00       	push   $0x81276b
  8081f5:	68 52 01 00 00       	push   $0x152
  8081fa:	68 46 27 81 00       	push   $0x812746
  8081ff:	e8 43 67 00 00       	call   80e947 <_panic>
    LWIP_ASSERT("tcp_enqueue: valid queue length",
  808204:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  808208:	75 87                	jne    808191 <tcp_enqueue+0x5d2>
  80820a:	83 ec 04             	sub    $0x4,%esp
  80820d:	68 f8 26 81 00       	push   $0x8126f8
  808212:	68 79 01 00 00       	push   $0x179
  808217:	68 46 27 81 00       	push   $0x812746
  80821c:	e8 26 67 00 00       	call   80e947 <_panic>
    LWIP_ASSERT("tcp_enqueue: valid queue length", pcb->unacked != NULL ||
  808221:	83 ec 04             	sub    $0x4,%esp
  808224:	68 f8 26 81 00       	push   $0x8126f8
  808229:	68 8c 01 00 00       	push   $0x18c
  80822e:	68 46 27 81 00       	push   $0x812746
  808233:	e8 0f 67 00 00       	call   80e947 <_panic>
  return ERR_OK;
  808238:	b8 00 00 00 00       	mov    $0x0,%eax
  80823d:	e9 ab fe ff ff       	jmp    8080ed <tcp_enqueue+0x52e>
  return ERR_MEM;
  808242:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  808247:	e9 a1 fe ff ff       	jmp    8080ed <tcp_enqueue+0x52e>
  80824c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  808251:	e9 97 fe ff ff       	jmp    8080ed <tcp_enqueue+0x52e>
      pcb->unsent = queue;
  808256:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  808259:	89 47 74             	mov    %eax,0x74(%edi)
  80825c:	e9 f1 fe ff ff       	jmp    808152 <tcp_enqueue+0x593>

00808261 <tcp_send_ctrl>:
{
  808261:	f3 0f 1e fb          	endbr32 
  808265:	55                   	push   %ebp
  808266:	89 e5                	mov    %esp,%ebp
  808268:	83 ec 0c             	sub    $0xc,%esp
  return tcp_enqueue(pcb, NULL, 0, flags, TCP_WRITE_FLAG_COPY, NULL, 0);
  80826b:	6a 00                	push   $0x0
  80826d:	6a 00                	push   $0x0
  80826f:	6a 01                	push   $0x1
  808271:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
  808275:	50                   	push   %eax
  808276:	6a 00                	push   $0x0
  808278:	6a 00                	push   $0x0
  80827a:	ff 75 08             	pushl  0x8(%ebp)
  80827d:	e8 3d f9 ff ff       	call   807bbf <tcp_enqueue>
}
  808282:	c9                   	leave  
  808283:	c3                   	ret    

00808284 <tcp_write>:
{
  808284:	f3 0f 1e fb          	endbr32 
  808288:	55                   	push   %ebp
  808289:	89 e5                	mov    %esp,%ebp
  80828b:	56                   	push   %esi
  80828c:	53                   	push   %ebx
  80828d:	8b 4d 08             	mov    0x8(%ebp),%ecx
  808290:	8b 55 10             	mov    0x10(%ebp),%edx
  808293:	8b 75 14             	mov    0x14(%ebp),%esi
  if (pcb->state == ESTABLISHED ||
  808296:	8b 41 10             	mov    0x10(%ecx),%eax
     pcb->state == CLOSE_WAIT ||
  808299:	8d 58 fe             	lea    -0x2(%eax),%ebx
     pcb->state == SYN_SENT ||
  80829c:	83 fb 02             	cmp    $0x2,%ebx
  80829f:	76 05                	jbe    8082a6 <tcp_write+0x22>
  8082a1:	83 f8 07             	cmp    $0x7,%eax
  8082a4:	75 32                	jne    8082d8 <tcp_write+0x54>
    return ERR_OK;
  8082a6:	b8 00 00 00 00       	mov    $0x0,%eax
    if (len > 0) {
  8082ab:	66 85 d2             	test   %dx,%dx
  8082ae:	75 07                	jne    8082b7 <tcp_write+0x33>
}
  8082b0:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8082b3:	5b                   	pop    %ebx
  8082b4:	5e                   	pop    %esi
  8082b5:	5d                   	pop    %ebp
  8082b6:	c3                   	ret    
      return tcp_enqueue(pcb, (void *)data, len, 0, apiflags, NULL, 0);
  8082b7:	83 ec 04             	sub    $0x4,%esp
  8082ba:	6a 00                	push   $0x0
  8082bc:	6a 00                	push   $0x0
  8082be:	89 f0                	mov    %esi,%eax
  8082c0:	0f b6 f0             	movzbl %al,%esi
  8082c3:	56                   	push   %esi
  8082c4:	6a 00                	push   $0x0
  8082c6:	0f b7 d2             	movzwl %dx,%edx
  8082c9:	52                   	push   %edx
  8082ca:	ff 75 0c             	pushl  0xc(%ebp)
  8082cd:	51                   	push   %ecx
  8082ce:	e8 ec f8 ff ff       	call   807bbf <tcp_enqueue>
  8082d3:	83 c4 20             	add    $0x20,%esp
  8082d6:	eb d8                	jmp    8082b0 <tcp_write+0x2c>
    return ERR_CONN;
  8082d8:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
  8082dd:	eb d1                	jmp    8082b0 <tcp_write+0x2c>

008082df <tcp_output>:
 * @return ERR_OK if data has been sent or nothing to send
 *         another err_t on error
 */
err_t
tcp_output(struct tcp_pcb *pcb)
{
  8082df:	f3 0f 1e fb          	endbr32 
  8082e3:	55                   	push   %ebp
  8082e4:	89 e5                	mov    %esp,%ebp
  8082e6:	57                   	push   %edi
  8082e7:	56                   	push   %esi
  8082e8:	53                   	push   %ebx
  8082e9:	83 ec 1c             	sub    $0x1c,%esp
  8082ec:	8b 7d 08             	mov    0x8(%ebp),%edi

  /* First, check if we are invoked by the TCP input processing
     code. If so, we do not output anything. Instead, we rely on the
     input processing code to call us when input processing is done
     with. */
  if (tcp_input_pcb == pcb) {
  8082ef:	39 3d 58 b2 b3 00    	cmp    %edi,0xb3b258
  8082f5:	0f 84 62 04 00 00    	je     80875d <tcp_output+0x47e>
    return ERR_OK;
  }

  wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
  8082fb:	0f b7 47 5c          	movzwl 0x5c(%edi),%eax
  8082ff:	66 39 47 4e          	cmp    %ax,0x4e(%edi)
  808303:	66 0f 46 47 4e       	cmovbe 0x4e(%edi),%ax
  808308:	0f b7 c0             	movzwl %ax,%eax
  80830b:	89 45 d8             	mov    %eax,-0x28(%ebp)

  seg = pcb->unsent;
  80830e:	8b 5f 74             	mov    0x74(%edi),%ebx

  /* useg should point to last segment on unacked queue */
  useg = pcb->unacked;
  808311:	8b 47 78             	mov    0x78(%edi),%eax
  808314:	89 45 dc             	mov    %eax,-0x24(%ebp)
  if (useg != NULL) {
  808317:	85 c0                	test   %eax,%eax
  808319:	74 0b                	je     808326 <tcp_output+0x47>
  80831b:	89 c2                	mov    %eax,%edx
    for (; useg->next != NULL; useg = useg->next);
  80831d:	8b 00                	mov    (%eax),%eax
  80831f:	85 c0                	test   %eax,%eax
  808321:	75 f8                	jne    80831b <tcp_output+0x3c>
  808323:	89 55 dc             	mov    %edx,-0x24(%ebp)
   * because the ->unsent queue is empty or because the window does
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
  808326:	f6 47 20 02          	testb  $0x2,0x20(%edi)
  80832a:	0f 84 eb 03 00 00    	je     80871b <tcp_output+0x43c>
  808330:	85 db                	test   %ebx,%ebx
  808332:	74 25                	je     808359 <tcp_output+0x7a>
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
  808334:	83 ec 0c             	sub    $0xc,%esp
  808337:	8b 43 10             	mov    0x10(%ebx),%eax
  80833a:	ff 70 04             	pushl  0x4(%eax)
  80833d:	e8 66 f8 ff ff       	call   807ba8 <ntohl>
  808342:	89 c2                	mov    %eax,%edx
  808344:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808348:	2b 47 48             	sub    0x48(%edi),%eax
  80834b:	01 d0                	add    %edx,%eax
     (seg == NULL ||
  80834d:	83 c4 10             	add    $0x10,%esp
  808350:	3b 45 d8             	cmp    -0x28(%ebp),%eax
  808353:	0f 86 c2 03 00 00    	jbe    80871b <tcp_output+0x43c>
    p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  808359:	83 ec 04             	sub    $0x4,%esp
  80835c:	6a 00                	push   $0x0
  80835e:	6a 14                	push   $0x14
  808360:	6a 01                	push   $0x1
  808362:	e8 84 c7 ff ff       	call   804aeb <pbuf_alloc>
  808367:	89 c6                	mov    %eax,%esi
    if (p == NULL) {
  808369:	83 c4 10             	add    $0x10,%esp
  80836c:	85 c0                	test   %eax,%eax
  80836e:	0f 84 f0 03 00 00    	je     808764 <tcp_output+0x485>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
      return ERR_BUF;
    }
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: sending ACK for %"U32_F"\n", pcb->rcv_nxt));
    /* remove ACK flags from the PCB, as we send an empty ACK now */
    pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  808374:	80 67 20 fc          	andb   $0xfc,0x20(%edi)

    tcphdr = p->payload;
  808378:	8b 58 04             	mov    0x4(%eax),%ebx
    tcphdr->src = htons(pcb->local_port);
  80837b:	83 ec 0c             	sub    $0xc,%esp
  80837e:	0f b7 47 1c          	movzwl 0x1c(%edi),%eax
  808382:	50                   	push   %eax
  808383:	e8 d1 f5 ff ff       	call   807959 <htons>
  808388:	66 89 03             	mov    %ax,(%ebx)
    tcphdr->dest = htons(pcb->remote_port);
  80838b:	0f b7 47 1e          	movzwl 0x1e(%edi),%eax
  80838f:	89 04 24             	mov    %eax,(%esp)
  808392:	e8 c2 f5 ff ff       	call   807959 <htons>
  808397:	66 89 43 02          	mov    %ax,0x2(%ebx)
    tcphdr->seqno = htonl(pcb->snd_nxt);
  80839b:	83 c4 04             	add    $0x4,%esp
  80839e:	ff 77 54             	pushl  0x54(%edi)
  8083a1:	e8 d5 f5 ff ff       	call   80797b <htonl>
  8083a6:	89 43 04             	mov    %eax,0x4(%ebx)
    tcphdr->ackno = htonl(pcb->rcv_nxt);
  8083a9:	83 c4 04             	add    $0x4,%esp
  8083ac:	ff 77 24             	pushl  0x24(%edi)
  8083af:	e8 c7 f5 ff ff       	call   80797b <htonl>
  8083b4:	89 43 08             	mov    %eax,0x8(%ebx)
    TCPH_FLAGS_SET(tcphdr, TCP_ACK);
  8083b7:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  8083bb:	89 04 24             	mov    %eax,(%esp)
  8083be:	e8 a7 f5 ff ff       	call   80796a <ntohs>
  8083c3:	25 c0 ff 00 00       	and    $0xffc0,%eax
  8083c8:	83 c8 10             	or     $0x10,%eax
  8083cb:	89 04 24             	mov    %eax,(%esp)
  8083ce:	e8 86 f5 ff ff       	call   807959 <htons>
  8083d3:	66 89 43 0c          	mov    %ax,0xc(%ebx)
    tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  8083d7:	0f b7 47 2a          	movzwl 0x2a(%edi),%eax
  8083db:	89 04 24             	mov    %eax,(%esp)
  8083de:	e8 76 f5 ff ff       	call   807959 <htons>
  8083e3:	66 89 43 0e          	mov    %ax,0xe(%ebx)
    tcphdr->urgp = 0;
  8083e7:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
    TCPH_HDRLEN_SET(tcphdr, 5);
  8083ed:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  8083f1:	89 04 24             	mov    %eax,(%esp)
  8083f4:	e8 71 f5 ff ff       	call   80796a <ntohs>
  8083f9:	83 e0 3f             	and    $0x3f,%eax
  8083fc:	80 cc 50             	or     $0x50,%ah
  8083ff:	89 04 24             	mov    %eax,(%esp)
  808402:	e8 52 f5 ff ff       	call   807959 <htons>
  808407:	66 89 43 0c          	mov    %ax,0xc(%ebx)

    tcphdr->chksum = 0;
  80840b:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
    tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip),
  808411:	8d 47 04             	lea    0x4(%edi),%eax
  808414:	89 c1                	mov    %eax,%ecx
  808416:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80841a:	89 04 24             	mov    %eax,(%esp)
  80841d:	6a 06                	push   $0x6
  80841f:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  808422:	51                   	push   %ecx
  808423:	57                   	push   %edi
  808424:	56                   	push   %esi
  808425:	e8 f7 f1 ff ff       	call   807621 <inet_chksum_pseudo>
  80842a:	66 89 43 10          	mov    %ax,0x10(%ebx)
                     pcb->tos, IP_PROTO_TCP, netif);
        netif->addr_hint = NULL;
      }
    }
#else /* LWIP_NETIF_HWADDRHINT*/
    ip_output(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
  80842e:	83 c4 18             	add    $0x18,%esp
  808431:	6a 06                	push   $0x6
  808433:	0f b6 47 0a          	movzbl 0xa(%edi),%eax
  808437:	50                   	push   %eax
  808438:	0f b6 47 0b          	movzbl 0xb(%edi),%eax
  80843c:	50                   	push   %eax
  80843d:	ff 75 e4             	pushl  -0x1c(%ebp)
  808440:	57                   	push   %edi
  808441:	56                   	push   %esi
  808442:	e8 ea e7 ff ff       	call   806c31 <ip_output>
        IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/
    pbuf_free(p);
  808447:	83 c4 14             	add    $0x14,%esp
  80844a:	56                   	push   %esi
  80844b:	e8 d1 c5 ff ff       	call   804a21 <pbuf_free>

    return ERR_OK;
  808450:	83 c4 10             	add    $0x10,%esp
  808453:	b8 00 00 00 00       	mov    $0x0,%eax
  808458:	e9 20 03 00 00       	jmp    80877d <tcp_output+0x49e>
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
    LWIP_ASSERT("RST not expected here!", 
  80845d:	83 ec 04             	sub    $0x4,%esp
  808460:	68 7f 27 81 00       	push   $0x81277f
  808465:	68 04 02 00 00       	push   $0x204
  80846a:	68 46 27 81 00       	push   $0x812746
  80846f:	e8 d3 64 00 00       	call   80e947 <_panic>
#endif /* TCP_CWND_DEBUG */

    pcb->unsent = seg->next;

    if (pcb->state != SYN_SENT) {
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
  808474:	83 ec 0c             	sub    $0xc,%esp
  808477:	8b 43 10             	mov    0x10(%ebx),%eax
  80847a:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80847e:	50                   	push   %eax
  80847f:	e8 e6 f4 ff ff       	call   80796a <ntohs>
  808484:	8b 73 10             	mov    0x10(%ebx),%esi
  808487:	83 c8 10             	or     $0x10,%eax
  80848a:	0f b7 c0             	movzwl %ax,%eax
  80848d:	89 04 24             	mov    %eax,(%esp)
  808490:	e8 c4 f4 ff ff       	call   807959 <htons>
  808495:	66 89 46 0c          	mov    %ax,0xc(%esi)
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  808499:	80 67 20 fc          	andb   $0xfc,0x20(%edi)
  80849d:	83 c4 10             	add    $0x10,%esp
  8084a0:	e9 06 01 00 00       	jmp    8085ab <tcp_output+0x2cc>
    ip_addr_set(&(pcb->local_ip), &(netif->ip_addr));
  }

  /* Set retransmission timer running if it is not currently enabled */
  if(pcb->rtime == -1)
    pcb->rtime = 0;
  8084a5:	66 c7 47 32 00 00    	movw   $0x0,0x32(%edi)
  8084ab:	e9 49 01 00 00       	jmp    8085f9 <tcp_output+0x31a>

  if (pcb->rttest == 0) {
    pcb->rttest = tcp_ticks;
  8084b0:	a1 40 b2 b3 00       	mov    0xb3b240,%eax
  8084b5:	89 47 38             	mov    %eax,0x38(%edi)
    pcb->rtseq = ntohl(seg->tcphdr->seqno);
  8084b8:	83 ec 0c             	sub    $0xc,%esp
  8084bb:	8b 43 10             	mov    0x10(%ebx),%eax
  8084be:	ff 70 04             	pushl  0x4(%eax)
  8084c1:	e8 e2 f6 ff ff       	call   807ba8 <ntohl>
  8084c6:	89 47 3c             	mov    %eax,0x3c(%edi)
  8084c9:	83 c4 10             	add    $0x10,%esp
  8084cc:	e9 32 01 00 00       	jmp    808603 <tcp_output+0x324>
    pcb->snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
  8084d1:	83 ec 0c             	sub    $0xc,%esp
  8084d4:	8b 43 10             	mov    0x10(%ebx),%eax
  8084d7:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8084db:	50                   	push   %eax
  8084dc:	e8 89 f4 ff ff       	call   80796a <ntohs>
  8084e1:	66 d1 e8             	shr    %ax
  8084e4:	83 e0 01             	and    $0x1,%eax
  8084e7:	83 c4 10             	add    $0x10,%esp
  8084ea:	e9 aa 01 00 00       	jmp    808699 <tcp_output+0x3ba>
      pcb->snd_max = pcb->snd_nxt;
  8084ef:	89 77 58             	mov    %esi,0x58(%edi)
  8084f2:	e9 b3 01 00 00       	jmp    8086aa <tcp_output+0x3cb>
    if (TCP_TCPLEN(seg) > 0) {
  8084f7:	83 ec 0c             	sub    $0xc,%esp
  8084fa:	8b 43 10             	mov    0x10(%ebx),%eax
  8084fd:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  808501:	50                   	push   %eax
  808502:	e8 63 f4 ff ff       	call   80796a <ntohs>
  808507:	66 d1 e8             	shr    %ax
  80850a:	83 e0 01             	and    $0x1,%eax
  80850d:	0f b7 f6             	movzwl %si,%esi
  808510:	83 c4 10             	add    $0x10,%esp
  808513:	01 f0                	add    %esi,%eax
  808515:	0f 85 ae 01 00 00    	jne    8086c9 <tcp_output+0x3ea>
      tcp_seg_free(seg);
  80851b:	83 ec 0c             	sub    $0xc,%esp
  80851e:	53                   	push   %ebx
  80851f:	e8 53 d4 ff ff       	call   805977 <tcp_seg_free>
  808524:	83 c4 10             	add    $0x10,%esp
  808527:	eb 06                	jmp    80852f <tcp_output+0x250>
        pcb->unacked = seg;
  808529:	89 5f 78             	mov    %ebx,0x78(%edi)
  80852c:	89 5d dc             	mov    %ebx,-0x24(%ebp)
    seg = pcb->unsent;
  80852f:	8b 5f 74             	mov    0x74(%edi),%ebx
  while (seg != NULL &&
  808532:	85 db                	test   %ebx,%ebx
  808534:	0f 84 3a 02 00 00    	je     808774 <tcp_output+0x495>
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
  80853a:	83 ec 0c             	sub    $0xc,%esp
  80853d:	8b 43 10             	mov    0x10(%ebx),%eax
  808540:	ff 70 04             	pushl  0x4(%eax)
  808543:	e8 60 f6 ff ff       	call   807ba8 <ntohl>
  808548:	89 c2                	mov    %eax,%edx
  80854a:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80854e:	2b 47 48             	sub    0x48(%edi),%eax
  808551:	01 d0                	add    %edx,%eax
  while (seg != NULL &&
  808553:	83 c4 10             	add    $0x10,%esp
  808556:	3b 45 d8             	cmp    -0x28(%ebp),%eax
  808559:	0f 87 0c 02 00 00    	ja     80876b <tcp_output+0x48c>
    LWIP_ASSERT("RST not expected here!", 
  80855f:	83 ec 0c             	sub    $0xc,%esp
  808562:	8b 43 10             	mov    0x10(%ebx),%eax
  808565:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  808569:	50                   	push   %eax
  80856a:	e8 fb f3 ff ff       	call   80796a <ntohs>
  80856f:	83 c4 10             	add    $0x10,%esp
  808572:	a8 04                	test   $0x4,%al
  808574:	0f 85 e3 fe ff ff    	jne    80845d <tcp_output+0x17e>
    if((tcp_do_output_nagle(pcb) == 0) &&
  80857a:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80857e:	74 1c                	je     80859c <tcp_output+0x2bd>
  808580:	0f b6 47 20          	movzbl 0x20(%edi),%eax
  808584:	a8 40                	test   $0x40,%al
  808586:	75 14                	jne    80859c <tcp_output+0x2bd>
  808588:	8b 57 74             	mov    0x74(%edi),%edx
  80858b:	85 d2                	test   %edx,%edx
  80858d:	74 05                	je     808594 <tcp_output+0x2b5>
  80858f:	83 3a 00             	cmpl   $0x0,(%edx)
  808592:	75 08                	jne    80859c <tcp_output+0x2bd>
  808594:	a8 a0                	test   $0xa0,%al
  808596:	0f 84 cf 01 00 00    	je     80876b <tcp_output+0x48c>
    pcb->unsent = seg->next;
  80859c:	8b 03                	mov    (%ebx),%eax
  80859e:	89 47 74             	mov    %eax,0x74(%edi)
    if (pcb->state != SYN_SENT) {
  8085a1:	83 7f 10 02          	cmpl   $0x2,0x10(%edi)
  8085a5:	0f 85 c9 fe ff ff    	jne    808474 <tcp_output+0x195>
  seg->tcphdr->ackno = htonl(pcb->rcv_nxt);
  8085ab:	8b 73 10             	mov    0x10(%ebx),%esi
  8085ae:	83 ec 0c             	sub    $0xc,%esp
  8085b1:	ff 77 24             	pushl  0x24(%edi)
  8085b4:	e8 c2 f3 ff ff       	call   80797b <htonl>
  8085b9:	89 46 08             	mov    %eax,0x8(%esi)
  seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  8085bc:	8b 73 10             	mov    0x10(%ebx),%esi
  8085bf:	0f b7 47 2a          	movzwl 0x2a(%edi),%eax
  8085c3:	89 04 24             	mov    %eax,(%esp)
  8085c6:	e8 8e f3 ff ff       	call   807959 <htons>
  8085cb:	66 89 46 0e          	mov    %ax,0xe(%esi)
  if (ip_addr_isany(&(pcb->local_ip))) {
  8085cf:	83 c4 10             	add    $0x10,%esp
  8085d2:	83 3f 00             	cmpl   $0x0,(%edi)
  8085d5:	75 17                	jne    8085ee <tcp_output+0x30f>
    netif = ip_route(&(pcb->remote_ip));
  8085d7:	83 ec 0c             	sub    $0xc,%esp
  8085da:	ff 75 e4             	pushl  -0x1c(%ebp)
  8085dd:	e8 42 e1 ff ff       	call   806724 <ip_route>
    if (netif == NULL) {
  8085e2:	83 c4 10             	add    $0x10,%esp
  8085e5:	85 c0                	test   %eax,%eax
  8085e7:	74 79                	je     808662 <tcp_output+0x383>
    ip_addr_set(&(pcb->local_ip), &(netif->ip_addr));
  8085e9:	8b 40 04             	mov    0x4(%eax),%eax
  8085ec:	89 07                	mov    %eax,(%edi)
  if(pcb->rtime == -1)
  8085ee:	66 83 7f 32 ff       	cmpw   $0xffff,0x32(%edi)
  8085f3:	0f 84 ac fe ff ff    	je     8084a5 <tcp_output+0x1c6>
  if (pcb->rttest == 0) {
  8085f9:	83 7f 38 00          	cmpl   $0x0,0x38(%edi)
  8085fd:	0f 84 ad fe ff ff    	je     8084b0 <tcp_output+0x1d1>
  }
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output_segment: %"U32_F":%"U32_F"\n",
          htonl(seg->tcphdr->seqno), htonl(seg->tcphdr->seqno) +
          seg->len));

  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
  808603:	8b 53 04             	mov    0x4(%ebx),%edx
  808606:	8b 43 10             	mov    0x10(%ebx),%eax
  808609:	2b 42 04             	sub    0x4(%edx),%eax

  seg->p->len -= len;
  80860c:	66 29 42 0a          	sub    %ax,0xa(%edx)
  seg->p->tot_len -= len;
  808610:	8b 53 04             	mov    0x4(%ebx),%edx
  808613:	66 29 42 08          	sub    %ax,0x8(%edx)

  seg->p->payload = seg->tcphdr;
  808617:	8b 53 04             	mov    0x4(%ebx),%edx
  80861a:	8b 43 10             	mov    0x10(%ebx),%eax
  80861d:	89 42 04             	mov    %eax,0x4(%edx)

  seg->tcphdr->chksum = 0;
  808620:	66 c7 40 10 00 00    	movw   $0x0,0x10(%eax)
#if CHECKSUM_GEN_TCP
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
             &(pcb->local_ip),
             &(pcb->remote_ip),
             IP_PROTO_TCP, seg->p->tot_len);
  808626:	8b 43 04             	mov    0x4(%ebx),%eax
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
  808629:	8b 73 10             	mov    0x10(%ebx),%esi
  80862c:	83 ec 0c             	sub    $0xc,%esp
  80862f:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  808633:	52                   	push   %edx
  808634:	6a 06                	push   $0x6
  808636:	ff 75 e4             	pushl  -0x1c(%ebp)
  808639:	57                   	push   %edi
  80863a:	50                   	push   %eax
  80863b:	e8 e1 ef ff ff       	call   807621 <inet_chksum_pseudo>
  808640:	66 89 46 10          	mov    %ax,0x10(%esi)
                   pcb->tos, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
  808644:	83 c4 18             	add    $0x18,%esp
  808647:	6a 06                	push   $0x6
  808649:	0f b6 47 0a          	movzbl 0xa(%edi),%eax
  80864d:	50                   	push   %eax
  80864e:	0f b6 47 0b          	movzbl 0xb(%edi),%eax
  808652:	50                   	push   %eax
  808653:	ff 75 e4             	pushl  -0x1c(%ebp)
  808656:	57                   	push   %edi
  808657:	ff 73 04             	pushl  0x4(%ebx)
  80865a:	e8 d2 e5 ff ff       	call   806c31 <ip_output>
  80865f:	83 c4 20             	add    $0x20,%esp
    pcb->snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
  808662:	83 ec 0c             	sub    $0xc,%esp
  808665:	8b 43 10             	mov    0x10(%ebx),%eax
  808668:	ff 70 04             	pushl  0x4(%eax)
  80866b:	e8 38 f5 ff ff       	call   807ba8 <ntohl>
  808670:	89 45 e0             	mov    %eax,-0x20(%ebp)
  808673:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  808677:	8b 43 10             	mov    0x10(%ebx),%eax
  80867a:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80867e:	89 04 24             	mov    %eax,(%esp)
  808681:	e8 e4 f2 ff ff       	call   80796a <ntohs>
  808686:	89 c2                	mov    %eax,%edx
  808688:	83 c4 10             	add    $0x10,%esp
  80868b:	b8 01 00 00 00       	mov    $0x1,%eax
  808690:	f6 c2 01             	test   $0x1,%dl
  808693:	0f 84 38 fe ff ff    	je     8084d1 <tcp_output+0x1f2>
  808699:	01 c6                	add    %eax,%esi
  80869b:	03 75 e0             	add    -0x20(%ebp),%esi
  80869e:	89 77 54             	mov    %esi,0x54(%edi)
    if (TCP_SEQ_LT(pcb->snd_max, pcb->snd_nxt)) {
  8086a1:	39 77 58             	cmp    %esi,0x58(%edi)
  8086a4:	0f 88 45 fe ff ff    	js     8084ef <tcp_output+0x210>
    if (TCP_TCPLEN(seg) > 0) {
  8086aa:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  8086ae:	83 ec 0c             	sub    $0xc,%esp
  8086b1:	8b 43 10             	mov    0x10(%ebx),%eax
  8086b4:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8086b8:	50                   	push   %eax
  8086b9:	e8 ac f2 ff ff       	call   80796a <ntohs>
  8086be:	83 c4 10             	add    $0x10,%esp
  8086c1:	a8 01                	test   $0x1,%al
  8086c3:	0f 84 2e fe ff ff    	je     8084f7 <tcp_output+0x218>
      seg->next = NULL;
  8086c9:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
      if (pcb->unacked == NULL) {
  8086cf:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  8086d3:	0f 84 50 fe ff ff    	je     808529 <tcp_output+0x24a>
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))){
  8086d9:	83 ec 0c             	sub    $0xc,%esp
  8086dc:	8b 43 10             	mov    0x10(%ebx),%eax
  8086df:	ff 70 04             	pushl  0x4(%eax)
  8086e2:	e8 c1 f4 ff ff       	call   807ba8 <ntohl>
  8086e7:	89 c6                	mov    %eax,%esi
  8086e9:	83 c4 04             	add    $0x4,%esp
  8086ec:	8b 45 dc             	mov    -0x24(%ebp),%eax
  8086ef:	8b 40 10             	mov    0x10(%eax),%eax
  8086f2:	ff 70 04             	pushl  0x4(%eax)
  8086f5:	e8 ae f4 ff ff       	call   807ba8 <ntohl>
  8086fa:	83 c4 10             	add    $0x10,%esp
  8086fd:	39 c6                	cmp    %eax,%esi
  8086ff:	78 0d                	js     80870e <tcp_output+0x42f>
          useg->next = seg;
  808701:	8b 45 dc             	mov    -0x24(%ebp),%eax
  808704:	89 18                	mov    %ebx,(%eax)
  808706:	89 5d dc             	mov    %ebx,-0x24(%ebp)
  808709:	e9 21 fe ff ff       	jmp    80852f <tcp_output+0x250>
          seg->next = pcb->unacked;
  80870e:	8b 47 78             	mov    0x78(%edi),%eax
  808711:	89 03                	mov    %eax,(%ebx)
          pcb->unacked = seg;
  808713:	89 5f 78             	mov    %ebx,0x78(%edi)
  808716:	e9 14 fe ff ff       	jmp    80852f <tcp_output+0x250>
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
  80871b:	8d 47 04             	lea    0x4(%edi),%eax
  80871e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  808721:	e9 0c fe ff ff       	jmp    808532 <tcp_output+0x253>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > pcb->snd_wnd) {
  808726:	83 ec 0c             	sub    $0xc,%esp
  808729:	8b 43 10             	mov    0x10(%ebx),%eax
  80872c:	ff 70 04             	pushl  0x4(%eax)
  80872f:	e8 74 f4 ff ff       	call   807ba8 <ntohl>
  808734:	89 c2                	mov    %eax,%edx
  808736:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80873a:	2b 47 48             	sub    0x48(%edi),%eax
  80873d:	01 d0                	add    %edx,%eax
  80873f:	0f b7 57 5c          	movzwl 0x5c(%edi),%edx
  if (seg != NULL && pcb->persist_backoff == 0 && 
  808743:	83 c4 10             	add    $0x10,%esp
  808746:	39 d0                	cmp    %edx,%eax
  808748:	76 2a                	jbe    808774 <tcp_output+0x495>
    pcb->persist_cnt = 0;
  80874a:	c7 87 a0 00 00 00 00 	movl   $0x0,0xa0(%edi)
  808751:	00 00 00 
    pcb->persist_backoff = 1;
  808754:	c6 87 a4 00 00 00 01 	movb   $0x1,0xa4(%edi)
  80875b:	eb 17                	jmp    808774 <tcp_output+0x495>
    return ERR_OK;
  80875d:	b8 00 00 00 00       	mov    $0x0,%eax
  808762:	eb 19                	jmp    80877d <tcp_output+0x49e>
      return ERR_BUF;
  808764:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  808769:	eb 12                	jmp    80877d <tcp_output+0x49e>
  if (seg != NULL && pcb->persist_backoff == 0 && 
  80876b:	80 bf a4 00 00 00 00 	cmpb   $0x0,0xa4(%edi)
  808772:	74 b2                	je     808726 <tcp_output+0x447>
  pcb->flags &= ~TF_NAGLEMEMERR;
  808774:	80 67 20 7f          	andb   $0x7f,0x20(%edi)
  return ERR_OK;
  808778:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80877d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  808780:	5b                   	pop    %ebx
  808781:	5e                   	pop    %esi
  808782:	5f                   	pop    %edi
  808783:	5d                   	pop    %ebp
  808784:	c3                   	ret    

00808785 <tcp_rst>:
 */
void
tcp_rst(u32_t seqno, u32_t ackno,
  struct ip_addr *local_ip, struct ip_addr *remote_ip,
  u16_t local_port, u16_t remote_port)
{
  808785:	f3 0f 1e fb          	endbr32 
  808789:	55                   	push   %ebp
  80878a:	89 e5                	mov    %esp,%ebp
  80878c:	57                   	push   %edi
  80878d:	56                   	push   %esi
  80878e:	53                   	push   %ebx
  80878f:	83 ec 20             	sub    $0x20,%esp
  808792:	8b 7d 18             	mov    0x18(%ebp),%edi
  808795:	8b 45 1c             	mov    0x1c(%ebp),%eax
  808798:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  80879b:	6a 00                	push   $0x0
  80879d:	6a 14                	push   $0x14
  80879f:	6a 01                	push   $0x1
  8087a1:	e8 45 c3 ff ff       	call   804aeb <pbuf_alloc>
  if (p == NULL) {
  8087a6:	83 c4 10             	add    $0x10,%esp
  8087a9:	85 c0                	test   %eax,%eax
  8087ab:	0f 84 e2 00 00 00    	je     808893 <tcp_rst+0x10e>
  8087b1:	89 c6                	mov    %eax,%esi
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
      return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  8087b3:	66 83 78 0a 13       	cmpw   $0x13,0xa(%eax)
  8087b8:	0f 86 dd 00 00 00    	jbe    80889b <tcp_rst+0x116>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  8087be:	8b 58 04             	mov    0x4(%eax),%ebx
  tcphdr->src = htons(local_port);
  8087c1:	83 ec 0c             	sub    $0xc,%esp
  8087c4:	0f b7 ff             	movzwl %di,%edi
  8087c7:	57                   	push   %edi
  8087c8:	e8 8c f1 ff ff       	call   807959 <htons>
  8087cd:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = htons(remote_port);
  8087d0:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  8087d4:	89 04 24             	mov    %eax,(%esp)
  8087d7:	e8 7d f1 ff ff       	call   807959 <htons>
  8087dc:	66 89 43 02          	mov    %ax,0x2(%ebx)
  tcphdr->seqno = htonl(seqno);
  8087e0:	83 c4 04             	add    $0x4,%esp
  8087e3:	ff 75 08             	pushl  0x8(%ebp)
  8087e6:	e8 90 f1 ff ff       	call   80797b <htonl>
  8087eb:	89 43 04             	mov    %eax,0x4(%ebx)
  tcphdr->ackno = htonl(ackno);
  8087ee:	83 c4 04             	add    $0x4,%esp
  8087f1:	ff 75 0c             	pushl  0xc(%ebp)
  8087f4:	e8 82 f1 ff ff       	call   80797b <htonl>
  8087f9:	89 43 08             	mov    %eax,0x8(%ebx)
  TCPH_FLAGS_SET(tcphdr, TCP_RST | TCP_ACK);
  8087fc:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808800:	89 04 24             	mov    %eax,(%esp)
  808803:	e8 62 f1 ff ff       	call   80796a <ntohs>
  808808:	25 c0 ff 00 00       	and    $0xffc0,%eax
  80880d:	83 c8 14             	or     $0x14,%eax
  808810:	89 04 24             	mov    %eax,(%esp)
  808813:	e8 41 f1 ff ff       	call   807959 <htons>
  808818:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  tcphdr->wnd = htons(TCP_WND);
  80881c:	c7 04 24 c0 5d 00 00 	movl   $0x5dc0,(%esp)
  808823:	e8 31 f1 ff ff       	call   807959 <htons>
  808828:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  tcphdr->urgp = 0;
  80882c:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
  TCPH_HDRLEN_SET(tcphdr, 5);
  808832:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808836:	89 04 24             	mov    %eax,(%esp)
  808839:	e8 2c f1 ff ff       	call   80796a <ntohs>
  80883e:	83 e0 3f             	and    $0x3f,%eax
  808841:	80 cc 50             	or     $0x50,%ah
  808844:	89 04 24             	mov    %eax,(%esp)
  808847:	e8 0d f1 ff ff       	call   807959 <htons>
  80884c:	66 89 43 0c          	mov    %ax,0xc(%ebx)

  tcphdr->chksum = 0;
  808850:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip,
  808856:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80885a:	89 04 24             	mov    %eax,(%esp)
  80885d:	6a 06                	push   $0x6
  80885f:	ff 75 14             	pushl  0x14(%ebp)
  808862:	ff 75 10             	pushl  0x10(%ebp)
  808865:	56                   	push   %esi
  808866:	e8 b6 ed ff ff       	call   807621 <inet_chksum_pseudo>
  80886b:	66 89 43 10          	mov    %ax,0x10(%ebx)
              IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
  snmp_inc_tcpoutrsts();
   /* Send output with hardcoded TTL since we have no access to the pcb */
  ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
  80886f:	83 c4 18             	add    $0x18,%esp
  808872:	6a 06                	push   $0x6
  808874:	6a 00                	push   $0x0
  808876:	68 ff 00 00 00       	push   $0xff
  80887b:	ff 75 14             	pushl  0x14(%ebp)
  80887e:	ff 75 10             	pushl  0x10(%ebp)
  808881:	56                   	push   %esi
  808882:	e8 aa e3 ff ff       	call   806c31 <ip_output>
  pbuf_free(p);
  808887:	83 c4 14             	add    $0x14,%esp
  80888a:	56                   	push   %esi
  80888b:	e8 91 c1 ff ff       	call   804a21 <pbuf_free>
  808890:	83 c4 10             	add    $0x10,%esp
  LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
}
  808893:	8d 65 f4             	lea    -0xc(%ebp),%esp
  808896:	5b                   	pop    %ebx
  808897:	5e                   	pop    %esi
  808898:	5f                   	pop    %edi
  808899:	5d                   	pop    %ebp
  80889a:	c3                   	ret    
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  80889b:	83 ec 04             	sub    $0x4,%esp
  80889e:	68 18 27 81 00       	push   $0x812718
  8088a3:	68 bd 02 00 00       	push   $0x2bd
  8088a8:	68 46 27 81 00       	push   $0x812746
  8088ad:	e8 95 60 00 00       	call   80e947 <_panic>

008088b2 <tcp_rexmit_rto>:
 *
 * @param pcb the tcp_pcb for which to re-enqueue all unacked segments
 */
void
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
  8088b2:	f3 0f 1e fb          	endbr32 
  8088b6:	55                   	push   %ebp
  8088b7:	89 e5                	mov    %esp,%ebp
  8088b9:	53                   	push   %ebx
  8088ba:	83 ec 04             	sub    $0x4,%esp
  8088bd:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
  8088c0:	8b 43 78             	mov    0x78(%ebx),%eax
  8088c3:	85 c0                	test   %eax,%eax
  8088c5:	74 41                	je     808908 <tcp_rexmit_rto+0x56>
  8088c7:	89 c2                	mov    %eax,%edx
    return;
  }

  /* Move all unacked segments to the head of the unsent queue */
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next);
  8088c9:	8b 00                	mov    (%eax),%eax
  8088cb:	85 c0                	test   %eax,%eax
  8088cd:	75 f8                	jne    8088c7 <tcp_rexmit_rto+0x15>
  /* concatenate unsent queue after unacked queue */
  seg->next = pcb->unsent;
  8088cf:	8b 43 74             	mov    0x74(%ebx),%eax
  8088d2:	89 02                	mov    %eax,(%edx)
  /* unsent queue is the concatenated queue (of unacked, unsent) */
  pcb->unsent = pcb->unacked;
  8088d4:	8b 43 78             	mov    0x78(%ebx),%eax
  8088d7:	89 43 74             	mov    %eax,0x74(%ebx)
  /* unacked queue is now empty */
  pcb->unacked = NULL;
  8088da:	c7 43 78 00 00 00 00 	movl   $0x0,0x78(%ebx)

  pcb->snd_nxt = ntohl(pcb->unsent->tcphdr->seqno);
  8088e1:	83 ec 0c             	sub    $0xc,%esp
  8088e4:	8b 40 10             	mov    0x10(%eax),%eax
  8088e7:	ff 70 04             	pushl  0x4(%eax)
  8088ea:	e8 b9 f2 ff ff       	call   807ba8 <ntohl>
  8088ef:	89 43 54             	mov    %eax,0x54(%ebx)
  /* increment number of retransmissions */
  ++pcb->nrtx;
  8088f2:	80 43 46 01          	addb   $0x1,0x46(%ebx)

  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;
  8088f6:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)

  /* Do the actual retransmission */
  tcp_output(pcb);
  8088fd:	89 1c 24             	mov    %ebx,(%esp)
  808900:	e8 da f9 ff ff       	call   8082df <tcp_output>
  808905:	83 c4 10             	add    $0x10,%esp
}
  808908:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80890b:	c9                   	leave  
  80890c:	c3                   	ret    

0080890d <tcp_rexmit>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void
tcp_rexmit(struct tcp_pcb *pcb)
{
  80890d:	f3 0f 1e fb          	endbr32 
  808911:	55                   	push   %ebp
  808912:	89 e5                	mov    %esp,%ebp
  808914:	53                   	push   %ebx
  808915:	83 ec 04             	sub    $0x4,%esp
  808918:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
  80891b:	8b 43 78             	mov    0x78(%ebx),%eax
  80891e:	85 c0                	test   %eax,%eax
  808920:	74 37                	je     808959 <tcp_rexmit+0x4c>
    return;
  }

  /* Move the first unacked segment to the unsent queue */
  seg = pcb->unacked->next;
  808922:	8b 10                	mov    (%eax),%edx
  pcb->unacked->next = pcb->unsent;
  808924:	8b 4b 74             	mov    0x74(%ebx),%ecx
  808927:	89 08                	mov    %ecx,(%eax)
  pcb->unsent = pcb->unacked;
  808929:	8b 43 78             	mov    0x78(%ebx),%eax
  80892c:	89 43 74             	mov    %eax,0x74(%ebx)
  pcb->unacked = seg;
  80892f:	89 53 78             	mov    %edx,0x78(%ebx)

  pcb->snd_nxt = ntohl(pcb->unsent->tcphdr->seqno);
  808932:	83 ec 0c             	sub    $0xc,%esp
  808935:	8b 40 10             	mov    0x10(%eax),%eax
  808938:	ff 70 04             	pushl  0x4(%eax)
  80893b:	e8 68 f2 ff ff       	call   807ba8 <ntohl>
  808940:	89 43 54             	mov    %eax,0x54(%ebx)

  ++pcb->nrtx;
  808943:	80 43 46 01          	addb   $0x1,0x46(%ebx)

  /* Don't take any rtt measurements after retransmitting. */
  pcb->rttest = 0;
  808947:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)

  /* Do the actual retransmission. */
  snmp_inc_tcpretranssegs();
  tcp_output(pcb);
  80894e:	89 1c 24             	mov    %ebx,(%esp)
  808951:	e8 89 f9 ff ff       	call   8082df <tcp_output>
  808956:	83 c4 10             	add    $0x10,%esp
}
  808959:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80895c:	c9                   	leave  
  80895d:	c3                   	ret    

0080895e <tcp_keepalive>:
 *
 * @param pcb the tcp_pcb for which to send a keepalive packet
 */
void
tcp_keepalive(struct tcp_pcb *pcb)
{
  80895e:	f3 0f 1e fb          	endbr32 
  808962:	55                   	push   %ebp
  808963:	89 e5                	mov    %esp,%ebp
  808965:	57                   	push   %edi
  808966:	56                   	push   %esi
  808967:	53                   	push   %ebx
  808968:	83 ec 20             	sub    $0x20,%esp
  80896b:	8b 7d 08             	mov    0x8(%ebp),%edi
                          ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip)));

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
                          tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));
   
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  80896e:	6a 00                	push   $0x0
  808970:	6a 14                	push   $0x14
  808972:	6a 01                	push   $0x1
  808974:	e8 72 c1 ff ff       	call   804aeb <pbuf_alloc>
   
  if(p == NULL) {
  808979:	83 c4 10             	add    $0x10,%esp
  80897c:	85 c0                	test   %eax,%eax
  80897e:	0f 84 e5 00 00 00    	je     808a69 <tcp_keepalive+0x10b>
  808984:	89 c6                	mov    %eax,%esi
    LWIP_DEBUGF(TCP_DEBUG, 
                ("tcp_keepalive: could not allocate memory for pbuf\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  808986:	66 83 78 0a 13       	cmpw   $0x13,0xa(%eax)
  80898b:	0f 86 e0 00 00 00    	jbe    808a71 <tcp_keepalive+0x113>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  808991:	8b 58 04             	mov    0x4(%eax),%ebx
  tcphdr->src = htons(pcb->local_port);
  808994:	83 ec 0c             	sub    $0xc,%esp
  808997:	0f b7 47 1c          	movzwl 0x1c(%edi),%eax
  80899b:	50                   	push   %eax
  80899c:	e8 b8 ef ff ff       	call   807959 <htons>
  8089a1:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = htons(pcb->remote_port);
  8089a4:	0f b7 47 1e          	movzwl 0x1e(%edi),%eax
  8089a8:	89 04 24             	mov    %eax,(%esp)
  8089ab:	e8 a9 ef ff ff       	call   807959 <htons>
  8089b0:	66 89 43 02          	mov    %ax,0x2(%ebx)
  tcphdr->seqno = htonl(pcb->snd_nxt - 1);
  8089b4:	8b 47 54             	mov    0x54(%edi),%eax
  8089b7:	83 e8 01             	sub    $0x1,%eax
  8089ba:	89 04 24             	mov    %eax,(%esp)
  8089bd:	e8 b9 ef ff ff       	call   80797b <htonl>
  8089c2:	89 43 04             	mov    %eax,0x4(%ebx)
  tcphdr->ackno = htonl(pcb->rcv_nxt);
  8089c5:	83 c4 04             	add    $0x4,%esp
  8089c8:	ff 77 24             	pushl  0x24(%edi)
  8089cb:	e8 ab ef ff ff       	call   80797b <htonl>
  8089d0:	89 43 08             	mov    %eax,0x8(%ebx)
  TCPH_FLAGS_SET(tcphdr, 0);
  8089d3:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  8089d7:	89 04 24             	mov    %eax,(%esp)
  8089da:	e8 8b ef ff ff       	call   80796a <ntohs>
  8089df:	25 c0 ff 00 00       	and    $0xffc0,%eax
  8089e4:	89 04 24             	mov    %eax,(%esp)
  8089e7:	e8 6d ef ff ff       	call   807959 <htons>
  8089ec:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  8089f0:	0f b7 47 2a          	movzwl 0x2a(%edi),%eax
  8089f4:	89 04 24             	mov    %eax,(%esp)
  8089f7:	e8 5d ef ff ff       	call   807959 <htons>
  8089fc:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  tcphdr->urgp = 0;
  808a00:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
  TCPH_HDRLEN_SET(tcphdr, 5);
  808a06:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808a0a:	89 04 24             	mov    %eax,(%esp)
  808a0d:	e8 58 ef ff ff       	call   80796a <ntohs>
  808a12:	83 e0 3f             	and    $0x3f,%eax
  808a15:	80 cc 50             	or     $0x50,%ah
  808a18:	89 04 24             	mov    %eax,(%esp)
  808a1b:	e8 39 ef ff ff       	call   807959 <htons>
  808a20:	66 89 43 0c          	mov    %ax,0xc(%ebx)

  tcphdr->chksum = 0;
  808a24:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
  808a2a:	8d 47 04             	lea    0x4(%edi),%eax
  808a2d:	89 c2                	mov    %eax,%edx
  808a2f:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  808a33:	89 04 24             	mov    %eax,(%esp)
  808a36:	6a 06                	push   $0x6
  808a38:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  808a3b:	52                   	push   %edx
  808a3c:	57                   	push   %edi
  808a3d:	56                   	push   %esi
  808a3e:	e8 de eb ff ff       	call   807621 <inet_chksum_pseudo>
  808a43:	66 89 43 10          	mov    %ax,0x10(%ebx)
                   0, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
  808a47:	83 c4 18             	add    $0x18,%esp
  808a4a:	6a 06                	push   $0x6
  808a4c:	6a 00                	push   $0x0
  808a4e:	0f b6 47 0b          	movzbl 0xb(%edi),%eax
  808a52:	50                   	push   %eax
  808a53:	ff 75 e4             	pushl  -0x1c(%ebp)
  808a56:	57                   	push   %edi
  808a57:	56                   	push   %esi
  808a58:	e8 d4 e1 ff ff       	call   806c31 <ip_output>
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
  808a5d:	83 c4 14             	add    $0x14,%esp
  808a60:	56                   	push   %esi
  808a61:	e8 bb bf ff ff       	call   804a21 <pbuf_free>
  808a66:	83 c4 10             	add    $0x10,%esp

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
  808a69:	8d 65 f4             	lea    -0xc(%ebp),%esp
  808a6c:	5b                   	pop    %ebx
  808a6d:	5e                   	pop    %esi
  808a6e:	5f                   	pop    %edi
  808a6f:	5d                   	pop    %ebp
  808a70:	c3                   	ret    
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  808a71:	83 ec 04             	sub    $0x4,%esp
  808a74:	68 18 27 81 00       	push   $0x812718
  808a79:	68 39 03 00 00       	push   $0x339
  808a7e:	68 46 27 81 00       	push   $0x812746
  808a83:	e8 bf 5e 00 00       	call   80e947 <_panic>

00808a88 <tcp_zero_window_probe>:
 *
 * @param pcb the tcp_pcb for which to send a zero-window probe packet
 */
void
tcp_zero_window_probe(struct tcp_pcb *pcb)
{
  808a88:	f3 0f 1e fb          	endbr32 
  808a8c:	55                   	push   %ebp
  808a8d:	89 e5                	mov    %esp,%ebp
  808a8f:	57                   	push   %edi
  808a90:	56                   	push   %esi
  808a91:	53                   	push   %ebx
  808a92:	83 ec 1c             	sub    $0x1c,%esp
  808a95:	8b 75 08             	mov    0x8(%ebp),%esi
  LWIP_DEBUGF(TCP_DEBUG, 
              ("tcp_zero_window_probe: tcp_ticks %"U32_F
               "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
               tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));

  seg = pcb->unacked;
  808a98:	8b 46 78             	mov    0x78(%esi),%eax
  808a9b:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  if(seg == NULL)
  808a9e:	85 c0                	test   %eax,%eax
  808aa0:	0f 84 10 01 00 00    	je     808bb6 <tcp_zero_window_probe+0x12e>
    seg = pcb->unsent;

  if(seg == NULL)
    return;

  p = pbuf_alloc(PBUF_IP, TCP_HLEN + 1, PBUF_RAM);
  808aa6:	83 ec 04             	sub    $0x4,%esp
  808aa9:	6a 00                	push   $0x0
  808aab:	6a 15                	push   $0x15
  808aad:	6a 01                	push   $0x1
  808aaf:	e8 37 c0 ff ff       	call   804aeb <pbuf_alloc>
  808ab4:	89 c7                	mov    %eax,%edi
   
  if(p == NULL) {
  808ab6:	83 c4 10             	add    $0x10,%esp
  808ab9:	85 c0                	test   %eax,%eax
  808abb:	0f 84 ed 00 00 00    	je     808bae <tcp_zero_window_probe+0x126>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  808ac1:	66 83 78 0a 13       	cmpw   $0x13,0xa(%eax)
  808ac6:	0f 86 f9 00 00 00    	jbe    808bc5 <tcp_zero_window_probe+0x13d>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  808acc:	8b 58 04             	mov    0x4(%eax),%ebx
  tcphdr->src = htons(pcb->local_port);
  808acf:	83 ec 0c             	sub    $0xc,%esp
  808ad2:	0f b7 46 1c          	movzwl 0x1c(%esi),%eax
  808ad6:	50                   	push   %eax
  808ad7:	e8 7d ee ff ff       	call   807959 <htons>
  808adc:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = htons(pcb->remote_port);
  808adf:	0f b7 46 1e          	movzwl 0x1e(%esi),%eax
  808ae3:	89 04 24             	mov    %eax,(%esp)
  808ae6:	e8 6e ee ff ff       	call   807959 <htons>
  808aeb:	66 89 43 02          	mov    %ax,0x2(%ebx)
  tcphdr->seqno = seg->tcphdr->seqno;
  808aef:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  808af2:	8b 40 10             	mov    0x10(%eax),%eax
  808af5:	8b 40 04             	mov    0x4(%eax),%eax
  808af8:	89 43 04             	mov    %eax,0x4(%ebx)
  tcphdr->ackno = htonl(pcb->rcv_nxt);
  808afb:	83 c4 04             	add    $0x4,%esp
  808afe:	ff 76 24             	pushl  0x24(%esi)
  808b01:	e8 75 ee ff ff       	call   80797b <htonl>
  808b06:	89 43 08             	mov    %eax,0x8(%ebx)
  TCPH_FLAGS_SET(tcphdr, 0);
  808b09:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808b0d:	89 04 24             	mov    %eax,(%esp)
  808b10:	e8 55 ee ff ff       	call   80796a <ntohs>
  808b15:	25 c0 ff 00 00       	and    $0xffc0,%eax
  808b1a:	89 04 24             	mov    %eax,(%esp)
  808b1d:	e8 37 ee ff ff       	call   807959 <htons>
  808b22:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  808b26:	0f b7 46 2a          	movzwl 0x2a(%esi),%eax
  808b2a:	89 04 24             	mov    %eax,(%esp)
  808b2d:	e8 27 ee ff ff       	call   807959 <htons>
  808b32:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  tcphdr->urgp = 0;
  808b36:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
  TCPH_HDRLEN_SET(tcphdr, 5);
  808b3c:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808b40:	89 04 24             	mov    %eax,(%esp)
  808b43:	e8 22 ee ff ff       	call   80796a <ntohs>
  808b48:	83 e0 3f             	and    $0x3f,%eax
  808b4b:	80 cc 50             	or     $0x50,%ah
  808b4e:	89 04 24             	mov    %eax,(%esp)
  808b51:	e8 03 ee ff ff       	call   807959 <htons>
  808b56:	66 89 43 0c          	mov    %ax,0xc(%ebx)

  /* Copy in one byte from the head of the unacked queue */
  *((char *)p->payload + sizeof(struct tcp_hdr)) = *(char *)seg->dataptr;
  808b5a:	8b 47 04             	mov    0x4(%edi),%eax
  808b5d:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  808b60:	8b 51 08             	mov    0x8(%ecx),%edx
  808b63:	0f b6 12             	movzbl (%edx),%edx
  808b66:	88 50 14             	mov    %dl,0x14(%eax)

  tcphdr->chksum = 0;
  808b69:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
  808b6f:	8d 46 04             	lea    0x4(%esi),%eax
  808b72:	89 c1                	mov    %eax,%ecx
  808b74:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  808b78:	89 04 24             	mov    %eax,(%esp)
  808b7b:	6a 06                	push   $0x6
  808b7d:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  808b80:	51                   	push   %ecx
  808b81:	56                   	push   %esi
  808b82:	57                   	push   %edi
  808b83:	e8 99 ea ff ff       	call   807621 <inet_chksum_pseudo>
  808b88:	66 89 43 10          	mov    %ax,0x10(%ebx)
                   0, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
  808b8c:	83 c4 18             	add    $0x18,%esp
  808b8f:	6a 06                	push   $0x6
  808b91:	6a 00                	push   $0x0
  808b93:	0f b6 46 0b          	movzbl 0xb(%esi),%eax
  808b97:	50                   	push   %eax
  808b98:	ff 75 e4             	pushl  -0x1c(%ebp)
  808b9b:	56                   	push   %esi
  808b9c:	57                   	push   %edi
  808b9d:	e8 8f e0 ff ff       	call   806c31 <ip_output>
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
  808ba2:	83 c4 14             	add    $0x14,%esp
  808ba5:	57                   	push   %edi
  808ba6:	e8 76 be ff ff       	call   804a21 <pbuf_free>
  808bab:	83 c4 10             	add    $0x10,%esp

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
                          " ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
  808bae:	8d 65 f4             	lea    -0xc(%ebp),%esp
  808bb1:	5b                   	pop    %ebx
  808bb2:	5e                   	pop    %esi
  808bb3:	5f                   	pop    %edi
  808bb4:	5d                   	pop    %ebp
  808bb5:	c3                   	ret    
    seg = pcb->unsent;
  808bb6:	8b 46 74             	mov    0x74(%esi),%eax
  808bb9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if(seg == NULL)
  808bbc:	85 c0                	test   %eax,%eax
  808bbe:	74 ee                	je     808bae <tcp_zero_window_probe+0x126>
  808bc0:	e9 e1 fe ff ff       	jmp    808aa6 <tcp_zero_window_probe+0x1e>
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  808bc5:	83 ec 04             	sub    $0x4,%esp
  808bc8:	68 18 27 81 00       	push   $0x812718
  808bcd:	68 8c 03 00 00       	push   $0x38c
  808bd2:	68 46 27 81 00       	push   $0x812746
  808bd7:	e8 6b 5d 00 00       	call   80e947 <_panic>

00808bdc <udp_input>:
 * @param inp network interface on which the datagram was received.
 *
 */
void
udp_input(struct pbuf *p, struct netif *inp)
{
  808bdc:	f3 0f 1e fb          	endbr32 
  808be0:	55                   	push   %ebp
  808be1:	89 e5                	mov    %esp,%ebp
  808be3:	57                   	push   %edi
  808be4:	56                   	push   %esi
  808be5:	53                   	push   %ebx
  808be6:	83 ec 38             	sub    $0x38,%esp

  PERF_START;

  UDP_STATS_INC(udp.recv);

  iphdr = p->payload;
  808be9:	8b 45 08             	mov    0x8(%ebp),%eax
  808bec:	8b 78 04             	mov    0x4(%eax),%edi

  /* Check minimum length (IP header + UDP header)
   * and move payload pointer to UDP header */
  if (p->tot_len < (IPH_HL(iphdr) * 4 + UDP_HLEN) || pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4))) {
  808bef:	0f b7 58 08          	movzwl 0x8(%eax),%ebx
  808bf3:	0f b7 07             	movzwl (%edi),%eax
  808bf6:	50                   	push   %eax
  808bf7:	e8 6e ed ff ff       	call   80796a <ntohs>
  808bfc:	66 c1 e8 08          	shr    $0x8,%ax
  808c00:	83 e0 0f             	and    $0xf,%eax
  808c03:	8d 04 85 08 00 00 00 	lea    0x8(,%eax,4),%eax
  808c0a:	83 c4 10             	add    $0x10,%esp
  808c0d:	39 c3                	cmp    %eax,%ebx
  808c0f:	7c 29                	jl     808c3a <udp_input+0x5e>
  808c11:	83 ec 0c             	sub    $0xc,%esp
  808c14:	0f b7 07             	movzwl (%edi),%eax
  808c17:	50                   	push   %eax
  808c18:	e8 4d ed ff ff       	call   80796a <ntohs>
  808c1d:	83 c4 08             	add    $0x8,%esp
  808c20:	66 c1 e8 06          	shr    $0x6,%ax
  808c24:	83 e0 3c             	and    $0x3c,%eax
  808c27:	f7 d8                	neg    %eax
  808c29:	98                   	cwtl   
  808c2a:	50                   	push   %eax
  808c2b:	ff 75 08             	pushl  0x8(%ebp)
  808c2e:	e8 1b bd ff ff       	call   80494e <pbuf_header>
  808c33:	83 c4 10             	add    $0x10,%esp
  808c36:	84 c0                	test   %al,%al
  808c38:	74 16                	je     808c50 <udp_input+0x74>
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_input: short UDP datagram (%"U16_F" bytes) discarded\n", p->tot_len));
    UDP_STATS_INC(udp.lenerr);
    UDP_STATS_INC(udp.drop);
    snmp_inc_udpinerrors();
    pbuf_free(p);
  808c3a:	83 ec 0c             	sub    $0xc,%esp
  808c3d:	ff 75 08             	pushl  0x8(%ebp)
  808c40:	e8 dc bd ff ff       	call   804a21 <pbuf_free>
    goto end;
  808c45:	83 c4 10             	add    $0x10,%esp
  } else {
    pbuf_free(p);
  }
end:
  PERF_STOP("udp_input");
}
  808c48:	8d 65 f4             	lea    -0xc(%ebp),%esp
  808c4b:	5b                   	pop    %ebx
  808c4c:	5e                   	pop    %esi
  808c4d:	5f                   	pop    %edi
  808c4e:	5d                   	pop    %ebp
  808c4f:	c3                   	ret    
  udphdr = (struct udp_hdr *)p->payload;
  808c50:	8b 45 08             	mov    0x8(%ebp),%eax
  808c53:	8b 70 04             	mov    0x4(%eax),%esi
  808c56:	89 75 d8             	mov    %esi,-0x28(%ebp)
  src = ntohs(udphdr->src);
  808c59:	83 ec 0c             	sub    $0xc,%esp
  808c5c:	0f b7 06             	movzwl (%esi),%eax
  808c5f:	50                   	push   %eax
  808c60:	e8 05 ed ff ff       	call   80796a <ntohs>
  808c65:	66 89 45 e2          	mov    %ax,-0x1e(%ebp)
  dest = ntohs(udphdr->dest);
  808c69:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  808c6d:	89 04 24             	mov    %eax,(%esp)
  808c70:	e8 f5 ec ff ff       	call   80796a <ntohs>
  808c75:	89 c6                	mov    %eax,%esi
  if (dest == DHCP_CLIENT_PORT) {
  808c77:	83 c4 10             	add    $0x10,%esp
  808c7a:	66 83 f8 44          	cmp    $0x44,%ax
  808c7e:	74 1f                	je     808c9f <udp_input+0xc3>
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  808c80:	8b 1d 54 b2 b3 00    	mov    0xb3b254,%ebx
    uncon_pcb = NULL;
  808c86:	b9 00 00 00 00       	mov    $0x0,%ecx
    prev = NULL;
  808c8b:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
  808c92:	8d 47 10             	lea    0x10(%edi),%eax
  808c95:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  808c98:	89 7d dc             	mov    %edi,-0x24(%ebp)
  808c9b:	89 cf                	mov    %ecx,%edi
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  808c9d:	eb 51                	jmp    808cf0 <udp_input+0x114>
    if (src == DHCP_SERVER_PORT) {
  808c9f:	66 83 7d e2 43       	cmpw   $0x43,-0x1e(%ebp)
  808ca4:	0f 85 c9 01 00 00    	jne    808e73 <udp_input+0x297>
      if ((inp->dhcp != NULL) && (inp->dhcp->pcb != NULL)) {
  808caa:	8b 45 0c             	mov    0xc(%ebp),%eax
  808cad:	8b 40 20             	mov    0x20(%eax),%eax
  808cb0:	85 c0                	test   %eax,%eax
  808cb2:	0f 84 bb 01 00 00    	je     808e73 <udp_input+0x297>
  808cb8:	8b 58 08             	mov    0x8(%eax),%ebx
  808cbb:	85 db                	test   %ebx,%ebx
  808cbd:	0f 84 b0 01 00 00    	je     808e73 <udp_input+0x297>
        if ((ip_addr_isany(&inp->dhcp->pcb->remote_ip) ||
  808cc3:	8b 43 04             	mov    0x4(%ebx),%eax
  808cc6:	85 c0                	test   %eax,%eax
  808cc8:	0f 84 b5 01 00 00    	je     808e83 <udp_input+0x2a7>
  808cce:	3b 47 0c             	cmp    0xc(%edi),%eax
  808cd1:	0f 85 9c 01 00 00    	jne    808e73 <udp_input+0x297>
  808cd7:	e9 a7 01 00 00       	jmp    808e83 <udp_input+0x2a7>
        if ((uncon_pcb == NULL) && 
  808cdc:	85 ff                	test   %edi,%edi
  808cde:	74 43                	je     808d23 <udp_input+0x147>
      if ((local_match != 0) &&
  808ce0:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  808ce4:	66 3b 43 14          	cmp    0x14(%ebx),%ax
  808ce8:	74 42                	je     808d2c <udp_input+0x150>
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  808cea:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  808ced:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  808cf0:	85 db                	test   %ebx,%ebx
  808cf2:	0f 84 6e 01 00 00    	je     808e66 <udp_input+0x28a>
      if ((pcb->local_port == dest) &&
  808cf8:	66 3b 73 12          	cmp    0x12(%ebx),%si
  808cfc:	75 ec                	jne    808cea <udp_input+0x10e>
          (ip_addr_isany(&pcb->local_ip) ||
  808cfe:	8b 03                	mov    (%ebx),%eax
  808d00:	85 c0                	test   %eax,%eax
  808d02:	74 d8                	je     808cdc <udp_input+0x100>
  808d04:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  808d07:	3b 41 10             	cmp    0x10(%ecx),%eax
  808d0a:	74 d0                	je     808cdc <udp_input+0x100>
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
  808d0c:	83 ec 08             	sub    $0x8,%esp
  808d0f:	ff 75 0c             	pushl  0xc(%ebp)
  808d12:	ff 75 d4             	pushl  -0x2c(%ebp)
  808d15:	e8 c3 d9 ff ff       	call   8066dd <ip_addr_isbroadcast>
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) || 
  808d1a:	83 c4 10             	add    $0x10,%esp
  808d1d:	84 c0                	test   %al,%al
  808d1f:	74 c9                	je     808cea <udp_input+0x10e>
  808d21:	eb b9                	jmp    808cdc <udp_input+0x100>
  808d23:	f6 43 10 04          	testb  $0x4,0x10(%ebx)
  808d27:	0f 44 fb             	cmove  %ebx,%edi
  808d2a:	eb b4                	jmp    808ce0 <udp_input+0x104>
          (ip_addr_isany(&pcb->remote_ip) ||
  808d2c:	8b 43 04             	mov    0x4(%ebx),%eax
  808d2f:	85 c0                	test   %eax,%eax
  808d31:	74 08                	je     808d3b <udp_input+0x15f>
  808d33:	8b 55 dc             	mov    -0x24(%ebp),%edx
  808d36:	3b 42 0c             	cmp    0xc(%edx),%eax
  808d39:	75 af                	jne    808cea <udp_input+0x10e>
  808d3b:	8b 7d dc             	mov    -0x24(%ebp),%edi
        if (prev != NULL) {
  808d3e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  808d41:	85 d2                	test   %edx,%edx
  808d43:	0f 84 3a 01 00 00    	je     808e83 <udp_input+0x2a7>
          prev->next = pcb->next;
  808d49:	8b 43 0c             	mov    0xc(%ebx),%eax
  808d4c:	89 42 0c             	mov    %eax,0xc(%edx)
          pcb->next = udp_pcbs;
  808d4f:	a1 54 b2 b3 00       	mov    0xb3b254,%eax
  808d54:	89 43 0c             	mov    %eax,0xc(%ebx)
          udp_pcbs = pcb;
  808d57:	89 1d 54 b2 b3 00    	mov    %ebx,0xb3b254
  808d5d:	e9 21 01 00 00       	jmp    808e83 <udp_input+0x2a7>
  808d62:	89 c3                	mov    %eax,%ebx
  808d64:	e9 1a 01 00 00       	jmp    808e83 <udp_input+0x2a7>
          pbuf_free(p);
  808d69:	83 ec 0c             	sub    $0xc,%esp
  808d6c:	ff 75 08             	pushl  0x8(%ebp)
  808d6f:	e8 ad bc ff ff       	call   804a21 <pbuf_free>
          goto end;
  808d74:	83 c4 10             	add    $0x10,%esp
  808d77:	e9 cc fe ff ff       	jmp    808c48 <udp_input+0x6c>
      LWIP_ASSERT("pbuf_header failed\n", 0);
  808d7c:	83 ec 04             	sub    $0x4,%esp
  808d7f:	68 6b 27 81 00       	push   $0x81276b
  808d84:	68 0a 01 00 00       	push   $0x10a
  808d89:	68 96 27 81 00       	push   $0x812796
  808d8e:	e8 b4 5b 00 00       	call   80e947 <_panic>
        pbuf_free(p);
  808d93:	83 ec 0c             	sub    $0xc,%esp
  808d96:	ff 75 08             	pushl  0x8(%ebp)
  808d99:	e8 83 bc ff ff       	call   804a21 <pbuf_free>
        goto end;
  808d9e:	83 c4 10             	add    $0x10,%esp
  808da1:	e9 a2 fe ff ff       	jmp    808c48 <udp_input+0x6c>
      if (!ip_addr_isbroadcast(&iphdr->dest, inp) &&
  808da6:	83 ec 08             	sub    $0x8,%esp
  808da9:	ff 75 0c             	pushl  0xc(%ebp)
  808dac:	8d 47 10             	lea    0x10(%edi),%eax
  808daf:	50                   	push   %eax
  808db0:	e8 28 d9 ff ff       	call   8066dd <ip_addr_isbroadcast>
  808db5:	83 c4 10             	add    $0x10,%esp
  808db8:	84 c0                	test   %al,%al
  808dba:	75 25                	jne    808de1 <udp_input+0x205>
          !ip_addr_ismulticast(&iphdr->dest)) {
  808dbc:	8b 5f 10             	mov    0x10(%edi),%ebx
  808dbf:	83 ec 0c             	sub    $0xc,%esp
  808dc2:	68 00 00 00 f0       	push   $0xf0000000
  808dc7:	e8 dc ed ff ff       	call   807ba8 <ntohl>
  808dcc:	21 c3                	and    %eax,%ebx
  808dce:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  808dd5:	e8 ce ed ff ff       	call   807ba8 <ntohl>
      if (!ip_addr_isbroadcast(&iphdr->dest, inp) &&
  808dda:	83 c4 10             	add    $0x10,%esp
  808ddd:	39 c3                	cmp    %eax,%ebx
  808ddf:	75 13                	jne    808df4 <udp_input+0x218>
      pbuf_free(p);
  808de1:	83 ec 0c             	sub    $0xc,%esp
  808de4:	ff 75 08             	pushl  0x8(%ebp)
  808de7:	e8 35 bc ff ff       	call   804a21 <pbuf_free>
  808dec:	83 c4 10             	add    $0x10,%esp
  808def:	e9 54 fe ff ff       	jmp    808c48 <udp_input+0x6c>
        pbuf_header(p, (IPH_HL(iphdr) * 4) + UDP_HLEN);
  808df4:	83 ec 0c             	sub    $0xc,%esp
  808df7:	0f b7 07             	movzwl (%edi),%eax
  808dfa:	50                   	push   %eax
  808dfb:	e8 6a eb ff ff       	call   80796a <ntohs>
  808e00:	83 c4 08             	add    $0x8,%esp
  808e03:	66 c1 e8 08          	shr    $0x8,%ax
  808e07:	83 e0 0f             	and    $0xf,%eax
  808e0a:	8d 04 85 08 00 00 00 	lea    0x8(,%eax,4),%eax
  808e11:	98                   	cwtl   
  808e12:	50                   	push   %eax
  808e13:	ff 75 08             	pushl  0x8(%ebp)
  808e16:	e8 33 bb ff ff       	call   80494e <pbuf_header>
        LWIP_ASSERT("p->payload == iphdr", (p->payload == iphdr));
  808e1b:	83 c4 10             	add    $0x10,%esp
  808e1e:	8b 45 08             	mov    0x8(%ebp),%eax
  808e21:	3b 78 04             	cmp    0x4(%eax),%edi
  808e24:	75 12                	jne    808e38 <udp_input+0x25c>
        icmp_dest_unreach(p, ICMP_DUR_PORT);
  808e26:	83 ec 08             	sub    $0x8,%esp
  808e29:	6a 03                	push   $0x3
  808e2b:	ff 75 08             	pushl  0x8(%ebp)
  808e2e:	e8 de 58 00 00       	call   80e711 <icmp_dest_unreach>
  808e33:	83 c4 10             	add    $0x10,%esp
  808e36:	eb a9                	jmp    808de1 <udp_input+0x205>
        LWIP_ASSERT("p->payload == iphdr", (p->payload == iphdr));
  808e38:	83 ec 04             	sub    $0x4,%esp
  808e3b:	68 aa 27 81 00       	push   $0x8127aa
  808e40:	68 25 01 00 00       	push   $0x125
  808e45:	68 96 27 81 00       	push   $0x812796
  808e4a:	e8 f8 5a 00 00       	call   80e947 <_panic>
    pbuf_free(p);
  808e4f:	83 ec 0c             	sub    $0xc,%esp
  808e52:	ff 75 08             	pushl  0x8(%ebp)
  808e55:	e8 c7 bb ff ff       	call   804a21 <pbuf_free>
  808e5a:	83 c4 10             	add    $0x10,%esp
  808e5d:	f3 0f 1e fb          	endbr32 
}
  808e61:	e9 e2 fd ff ff       	jmp    808c48 <udp_input+0x6c>
  808e66:	89 f8                	mov    %edi,%eax
  808e68:	8b 7d dc             	mov    -0x24(%ebp),%edi
  if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &iphdr->dest)) {
  808e6b:	85 c0                	test   %eax,%eax
  808e6d:	0f 85 ef fe ff ff    	jne    808d62 <udp_input+0x186>
  808e73:	8b 45 0c             	mov    0xc(%ebp),%eax
  808e76:	8b 57 10             	mov    0x10(%edi),%edx
  808e79:	bb 00 00 00 00       	mov    $0x0,%ebx
  808e7e:	39 50 04             	cmp    %edx,0x4(%eax)
  808e81:	75 cc                	jne    808e4f <udp_input+0x273>
      if (udphdr->chksum != 0) {
  808e83:	8b 45 d8             	mov    -0x28(%ebp),%eax
  808e86:	66 83 78 06 00       	cmpw   $0x0,0x6(%eax)
  808e8b:	74 29                	je     808eb6 <udp_input+0x2da>
        if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
  808e8d:	83 ec 0c             	sub    $0xc,%esp
  808e90:	8b 45 08             	mov    0x8(%ebp),%eax
  808e93:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  808e97:	50                   	push   %eax
  808e98:	6a 11                	push   $0x11
  808e9a:	8d 47 10             	lea    0x10(%edi),%eax
  808e9d:	50                   	push   %eax
  808e9e:	8d 47 0c             	lea    0xc(%edi),%eax
  808ea1:	50                   	push   %eax
  808ea2:	ff 75 08             	pushl  0x8(%ebp)
  808ea5:	e8 77 e7 ff ff       	call   807621 <inet_chksum_pseudo>
  808eaa:	83 c4 20             	add    $0x20,%esp
  808ead:	66 85 c0             	test   %ax,%ax
  808eb0:	0f 85 b3 fe ff ff    	jne    808d69 <udp_input+0x18d>
    if(pbuf_header(p, -UDP_HLEN)) {
  808eb6:	83 ec 08             	sub    $0x8,%esp
  808eb9:	6a f8                	push   $0xfffffff8
  808ebb:	ff 75 08             	pushl  0x8(%ebp)
  808ebe:	e8 8b ba ff ff       	call   80494e <pbuf_header>
  808ec3:	83 c4 10             	add    $0x10,%esp
  808ec6:	84 c0                	test   %al,%al
  808ec8:	0f 85 ae fe ff ff    	jne    808d7c <udp_input+0x1a0>
    if (pcb != NULL) {
  808ece:	85 db                	test   %ebx,%ebx
  808ed0:	0f 84 d0 fe ff ff    	je     808da6 <udp_input+0x1ca>
      if (pcb->recv != NULL) {
  808ed6:	8b 43 18             	mov    0x18(%ebx),%eax
  808ed9:	85 c0                	test   %eax,%eax
  808edb:	0f 84 b2 fe ff ff    	je     808d93 <udp_input+0x1b7>
        pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src), src);
  808ee1:	83 ec 0c             	sub    $0xc,%esp
  808ee4:	0f b7 55 e2          	movzwl -0x1e(%ebp),%edx
  808ee8:	52                   	push   %edx
  808ee9:	83 c7 0c             	add    $0xc,%edi
  808eec:	57                   	push   %edi
  808eed:	ff 75 08             	pushl  0x8(%ebp)
  808ef0:	53                   	push   %ebx
  808ef1:	ff 73 1c             	pushl  0x1c(%ebx)
  808ef4:	ff d0                	call   *%eax
  808ef6:	83 c4 20             	add    $0x20,%esp
  808ef9:	e9 4a fd ff ff       	jmp    808c48 <udp_input+0x6c>

00808efe <udp_bind>:
 *
 * @see udp_disconnect()
 */
err_t
udp_bind(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  808efe:	f3 0f 1e fb          	endbr32 
  808f02:	55                   	push   %ebp
  808f03:	89 e5                	mov    %esp,%ebp
  808f05:	57                   	push   %edi
  808f06:	56                   	push   %esi
  808f07:	53                   	push   %ebx
  808f08:	83 ec 0c             	sub    $0xc,%esp
  808f0b:	8b 55 08             	mov    0x8(%ebp),%edx
  808f0e:	8b 7d 10             	mov    0x10(%ebp),%edi
  808f11:	89 f9                	mov    %edi,%ecx
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  808f13:	a1 54 b2 b3 00       	mov    0xb3b254,%eax
  rebind = 0;
  808f18:	bb 00 00 00 00       	mov    $0x0,%ebx
    /* is this UDP PCB already on active list? */
    if (pcb == ipcb) {
      /* pcb may occur at most once in active list */
      LWIP_ASSERT("rebind == 0", rebind == 0);
      /* pcb already in list, just rebind */
      rebind = 1;
  808f1d:	be 01 00 00 00       	mov    $0x1,%esi
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  808f22:	eb 1a                	jmp    808f3e <udp_bind+0x40>
      LWIP_ASSERT("rebind == 0", rebind == 0);
  808f24:	83 ec 04             	sub    $0x4,%esp
  808f27:	68 be 27 81 00       	push   $0x8127be
  808f2c:	68 41 02 00 00       	push   $0x241
  808f31:	68 96 27 81 00       	push   $0x812796
  808f36:	e8 0c 5a 00 00       	call   80e947 <_panic>
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  808f3b:	8b 40 0c             	mov    0xc(%eax),%eax
  808f3e:	85 c0                	test   %eax,%eax
  808f40:	74 0c                	je     808f4e <udp_bind+0x50>
    if (pcb == ipcb) {
  808f42:	39 d0                	cmp    %edx,%eax
  808f44:	75 f5                	jne    808f3b <udp_bind+0x3d>
      LWIP_ASSERT("rebind == 0", rebind == 0);
  808f46:	84 db                	test   %bl,%bl
  808f48:	75 da                	jne    808f24 <udp_bind+0x26>
      rebind = 1;
  808f4a:	89 f3                	mov    %esi,%ebx
  808f4c:	eb ed                	jmp    808f3b <udp_bind+0x3d>
        return ERR_USE;
      }
#endif
  }

  ip_addr_set(&pcb->local_ip, ipaddr);
  808f4e:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  808f52:	74 05                	je     808f59 <udp_bind+0x5b>
  808f54:	8b 45 0c             	mov    0xc(%ebp),%eax
  808f57:	8b 00                	mov    (%eax),%eax
  808f59:	89 02                	mov    %eax,(%edx)

  /* no port specified? */
  if (port == 0) {
  808f5b:	66 85 ff             	test   %di,%di
  808f5e:	75 2e                	jne    808f8e <udp_bind+0x90>
#ifndef UDP_LOCAL_PORT_RANGE_START
#define UDP_LOCAL_PORT_RANGE_START 4096
#define UDP_LOCAL_PORT_RANGE_END   0x7fff
#endif
    port = UDP_LOCAL_PORT_RANGE_START;
    ipcb = udp_pcbs;
  808f60:	8b 35 54 b2 b3 00    	mov    0xb3b254,%esi
  808f66:	89 f0                	mov    %esi,%eax
    port = UDP_LOCAL_PORT_RANGE_START;
  808f68:	b9 00 10 00 00       	mov    $0x1000,%ecx
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
  808f6d:	eb 03                	jmp    808f72 <udp_bind+0x74>
        port++;
        /* restart scanning all udp pcbs */
        ipcb = udp_pcbs;
      } else
        /* go on with next udp pcb */
        ipcb = ipcb->next;
  808f6f:	8b 40 0c             	mov    0xc(%eax),%eax
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
  808f72:	85 c0                	test   %eax,%eax
  808f74:	74 14                	je     808f8a <udp_bind+0x8c>
  808f76:	66 81 f9 ff 7f       	cmp    $0x7fff,%cx
  808f7b:	74 0d                	je     808f8a <udp_bind+0x8c>
      if (ipcb->local_port == port) {
  808f7d:	66 39 48 12          	cmp    %cx,0x12(%eax)
  808f81:	75 ec                	jne    808f6f <udp_bind+0x71>
        port++;
  808f83:	83 c1 01             	add    $0x1,%ecx
        ipcb = udp_pcbs;
  808f86:	89 f0                	mov    %esi,%eax
  808f88:	eb e8                	jmp    808f72 <udp_bind+0x74>
    }
    if (ipcb != NULL) {
  808f8a:	85 c0                	test   %eax,%eax
  808f8c:	75 28                	jne    808fb6 <udp_bind+0xb8>
      /* no more ports available in local range */
      LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
      return ERR_USE;
    }
  }
  pcb->local_port = port;
  808f8e:	66 89 4a 12          	mov    %cx,0x12(%edx)
              ("udp_bind: bound to %"U16_F".%"U16_F".%"U16_F".%"U16_F", port %"U16_F"\n",
               (u16_t)(ntohl(pcb->local_ip.addr) >> 24 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) & 0xff), pcb->local_port));
  return ERR_OK;
  808f92:	b8 00 00 00 00       	mov    $0x0,%eax
  if (rebind == 0) {
  808f97:	84 db                	test   %bl,%bl
  808f99:	75 13                	jne    808fae <udp_bind+0xb0>
    pcb->next = udp_pcbs;
  808f9b:	a1 54 b2 b3 00       	mov    0xb3b254,%eax
  808fa0:	89 42 0c             	mov    %eax,0xc(%edx)
    udp_pcbs = pcb;
  808fa3:	89 15 54 b2 b3 00    	mov    %edx,0xb3b254
  return ERR_OK;
  808fa9:	b8 00 00 00 00       	mov    $0x0,%eax
}
  808fae:	8d 65 f4             	lea    -0xc(%ebp),%esp
  808fb1:	5b                   	pop    %ebx
  808fb2:	5e                   	pop    %esi
  808fb3:	5f                   	pop    %edi
  808fb4:	5d                   	pop    %ebp
  808fb5:	c3                   	ret    
      return ERR_USE;
  808fb6:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  808fbb:	eb f1                	jmp    808fae <udp_bind+0xb0>

00808fbd <udp_sendto_if>:
{
  808fbd:	f3 0f 1e fb          	endbr32 
  808fc1:	55                   	push   %ebp
  808fc2:	89 e5                	mov    %esp,%ebp
  808fc4:	57                   	push   %edi
  808fc5:	56                   	push   %esi
  808fc6:	53                   	push   %ebx
  808fc7:	83 ec 1c             	sub    $0x1c,%esp
  808fca:	8b 7d 08             	mov    0x8(%ebp),%edi
  808fcd:	8b 45 14             	mov    0x14(%ebp),%eax
  808fd0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if (pcb->local_port == 0) {
  808fd3:	66 83 7f 12 00       	cmpw   $0x0,0x12(%edi)
  808fd8:	75 19                	jne    808ff3 <udp_sendto_if+0x36>
    err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
  808fda:	83 ec 04             	sub    $0x4,%esp
  808fdd:	6a 00                	push   $0x0
  808fdf:	57                   	push   %edi
  808fe0:	57                   	push   %edi
  808fe1:	e8 18 ff ff ff       	call   808efe <udp_bind>
  808fe6:	89 c6                	mov    %eax,%esi
    if (err != ERR_OK) {
  808fe8:	83 c4 10             	add    $0x10,%esp
  808feb:	84 c0                	test   %al,%al
  808fed:	0f 85 b7 00 00 00    	jne    8090aa <udp_sendto_if+0xed>
  if (pbuf_header(p, UDP_HLEN)) {
  808ff3:	83 ec 08             	sub    $0x8,%esp
  808ff6:	6a 08                	push   $0x8
  808ff8:	ff 75 0c             	pushl  0xc(%ebp)
  808ffb:	e8 4e b9 ff ff       	call   80494e <pbuf_header>
  809000:	83 c4 10             	add    $0x10,%esp
    q = p;
  809003:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  if (pbuf_header(p, UDP_HLEN)) {
  809006:	84 c0                	test   %al,%al
  809008:	0f 85 a6 00 00 00    	jne    8090b4 <udp_sendto_if+0xf7>
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
  80900e:	66 83 7b 0a 07       	cmpw   $0x7,0xa(%ebx)
  809013:	0f 86 ca 00 00 00    	jbe    8090e3 <udp_sendto_if+0x126>
  udphdr = q->payload;
  809019:	8b 73 04             	mov    0x4(%ebx),%esi
  udphdr->src = htons(pcb->local_port);
  80901c:	83 ec 0c             	sub    $0xc,%esp
  80901f:	0f b7 47 12          	movzwl 0x12(%edi),%eax
  809023:	50                   	push   %eax
  809024:	e8 30 e9 ff ff       	call   807959 <htons>
  809029:	66 89 06             	mov    %ax,(%esi)
  udphdr->dest = htons(dst_port);
  80902c:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  809030:	89 04 24             	mov    %eax,(%esp)
  809033:	e8 21 e9 ff ff       	call   807959 <htons>
  809038:	66 89 46 02          	mov    %ax,0x2(%esi)
  udphdr->chksum = 0x0000; 
  80903c:	66 c7 46 06 00 00    	movw   $0x0,0x6(%esi)
  if (ip_addr_isany(&pcb->local_ip)) {
  809042:	8b 07                	mov    (%edi),%eax
  809044:	83 c4 10             	add    $0x10,%esp
  809047:	85 c0                	test   %eax,%eax
  809049:	0f 85 ab 00 00 00    	jne    8090fa <udp_sendto_if+0x13d>
    src_ip = &(netif->ip_addr);
  80904f:	8b 45 18             	mov    0x18(%ebp),%eax
  809052:	83 c0 04             	add    $0x4,%eax
  809055:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    udphdr->len = htons(q->tot_len);
  809058:	83 ec 0c             	sub    $0xc,%esp
  80905b:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80905f:	50                   	push   %eax
  809060:	e8 f4 e8 ff ff       	call   807959 <htons>
  809065:	66 89 46 04          	mov    %ax,0x4(%esi)
    if ((pcb->flags & UDP_FLAGS_NOCHKSUM) == 0) {
  809069:	83 c4 10             	add    $0x10,%esp
  80906c:	f6 47 10 01          	testb  $0x1,0x10(%edi)
  809070:	0f 84 ac 00 00 00    	je     809122 <udp_sendto_if+0x165>
    err = ip_output_if(q, src_ip, dst_ip, pcb->ttl, pcb->tos, IP_PROTO_UDP, netif);    
  809076:	83 ec 04             	sub    $0x4,%esp
  809079:	ff 75 18             	pushl  0x18(%ebp)
  80907c:	6a 11                	push   $0x11
  80907e:	0f b6 47 0a          	movzbl 0xa(%edi),%eax
  809082:	50                   	push   %eax
  809083:	0f b6 47 0b          	movzbl 0xb(%edi),%eax
  809087:	50                   	push   %eax
  809088:	ff 75 10             	pushl  0x10(%ebp)
  80908b:	ff 75 e4             	pushl  -0x1c(%ebp)
  80908e:	53                   	push   %ebx
  80908f:	e8 17 da ff ff       	call   806aab <ip_output_if>
  809094:	89 c6                	mov    %eax,%esi
  if (q != p) {
  809096:	83 c4 20             	add    $0x20,%esp
  809099:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
  80909c:	74 0c                	je     8090aa <udp_sendto_if+0xed>
    pbuf_free(q);
  80909e:	83 ec 0c             	sub    $0xc,%esp
  8090a1:	53                   	push   %ebx
  8090a2:	e8 7a b9 ff ff       	call   804a21 <pbuf_free>
  8090a7:	83 c4 10             	add    $0x10,%esp
}
  8090aa:	89 f0                	mov    %esi,%eax
  8090ac:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8090af:	5b                   	pop    %ebx
  8090b0:	5e                   	pop    %esi
  8090b1:	5f                   	pop    %edi
  8090b2:	5d                   	pop    %ebp
  8090b3:	c3                   	ret    
    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
  8090b4:	83 ec 04             	sub    $0x4,%esp
  8090b7:	6a 00                	push   $0x0
  8090b9:	6a 08                	push   $0x8
  8090bb:	6a 01                	push   $0x1
  8090bd:	e8 29 ba ff ff       	call   804aeb <pbuf_alloc>
  8090c2:	89 c3                	mov    %eax,%ebx
    if (q == NULL) {
  8090c4:	83 c4 10             	add    $0x10,%esp
  8090c7:	85 c0                	test   %eax,%eax
  8090c9:	0f 84 80 00 00 00    	je     80914f <udp_sendto_if+0x192>
    pbuf_chain(q, p);
  8090cf:	83 ec 08             	sub    $0x8,%esp
  8090d2:	ff 75 0c             	pushl  0xc(%ebp)
  8090d5:	50                   	push   %eax
  8090d6:	e8 28 be ff ff       	call   804f03 <pbuf_chain>
  8090db:	83 c4 10             	add    $0x10,%esp
  8090de:	e9 2b ff ff ff       	jmp    80900e <udp_sendto_if+0x51>
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
  8090e3:	83 ec 04             	sub    $0x4,%esp
  8090e6:	68 cc 27 81 00       	push   $0x8127cc
  8090eb:	68 b1 01 00 00       	push   $0x1b1
  8090f0:	68 96 27 81 00       	push   $0x812796
  8090f5:	e8 4d 58 00 00       	call   80e947 <_panic>
    if (!ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
  8090fa:	8b 4d 18             	mov    0x18(%ebp),%ecx
  8090fd:	3b 41 04             	cmp    0x4(%ecx),%eax
  809100:	75 08                	jne    80910a <udp_sendto_if+0x14d>
  if (ip_addr_isany(&pcb->local_ip)) {
  809102:	89 7d e4             	mov    %edi,-0x1c(%ebp)
  809105:	e9 4e ff ff ff       	jmp    809058 <udp_sendto_if+0x9b>
      return ERR_VAL;
  80910a:	be f7 ff ff ff       	mov    $0xfffffff7,%esi
      if (q != p) {
  80910f:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
  809112:	74 96                	je     8090aa <udp_sendto_if+0xed>
        pbuf_free(q);
  809114:	83 ec 0c             	sub    $0xc,%esp
  809117:	53                   	push   %ebx
  809118:	e8 04 b9 ff ff       	call   804a21 <pbuf_free>
  80911d:	83 c4 10             	add    $0x10,%esp
  809120:	eb 88                	jmp    8090aa <udp_sendto_if+0xed>
      udphdr->chksum = inet_chksum_pseudo(q, src_ip, dst_ip, IP_PROTO_UDP, q->tot_len);
  809122:	83 ec 0c             	sub    $0xc,%esp
  809125:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  809129:	50                   	push   %eax
  80912a:	6a 11                	push   $0x11
  80912c:	ff 75 10             	pushl  0x10(%ebp)
  80912f:	ff 75 e4             	pushl  -0x1c(%ebp)
  809132:	53                   	push   %ebx
  809133:	e8 e9 e4 ff ff       	call   807621 <inet_chksum_pseudo>
      if (udphdr->chksum == 0x0000) udphdr->chksum = 0xffff;
  809138:	83 c4 20             	add    $0x20,%esp
      udphdr->chksum = inet_chksum_pseudo(q, src_ip, dst_ip, IP_PROTO_UDP, q->tot_len);
  80913b:	66 85 c0             	test   %ax,%ax
  80913e:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  809143:	0f 44 c2             	cmove  %edx,%eax
  809146:	66 89 46 06          	mov    %ax,0x6(%esi)
  80914a:	e9 27 ff ff ff       	jmp    809076 <udp_sendto_if+0xb9>
      return ERR_MEM;
  80914f:	be ff ff ff ff       	mov    $0xffffffff,%esi
  809154:	e9 51 ff ff ff       	jmp    8090aa <udp_sendto_if+0xed>

00809159 <udp_sendto>:
{
  809159:	f3 0f 1e fb          	endbr32 
  80915d:	55                   	push   %ebp
  80915e:	89 e5                	mov    %esp,%ebp
  809160:	56                   	push   %esi
  809161:	53                   	push   %ebx
  809162:	8b 75 10             	mov    0x10(%ebp),%esi
  809165:	8b 5d 14             	mov    0x14(%ebp),%ebx
  netif = ip_route(dst_ip);
  809168:	83 ec 0c             	sub    $0xc,%esp
  80916b:	56                   	push   %esi
  80916c:	e8 b3 d5 ff ff       	call   806724 <ip_route>
  if (netif == NULL) {
  809171:	83 c4 10             	add    $0x10,%esp
  809174:	85 c0                	test   %eax,%eax
  809176:	74 1e                	je     809196 <udp_sendto+0x3d>
  return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
  809178:	83 ec 0c             	sub    $0xc,%esp
  80917b:	50                   	push   %eax
  80917c:	0f b7 db             	movzwl %bx,%ebx
  80917f:	53                   	push   %ebx
  809180:	56                   	push   %esi
  809181:	ff 75 0c             	pushl  0xc(%ebp)
  809184:	ff 75 08             	pushl  0x8(%ebp)
  809187:	e8 31 fe ff ff       	call   808fbd <udp_sendto_if>
  80918c:	83 c4 20             	add    $0x20,%esp
}
  80918f:	8d 65 f8             	lea    -0x8(%ebp),%esp
  809192:	5b                   	pop    %ebx
  809193:	5e                   	pop    %esi
  809194:	5d                   	pop    %ebp
  809195:	c3                   	ret    
    return ERR_RTE;
  809196:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80919b:	eb f2                	jmp    80918f <udp_sendto+0x36>

0080919d <udp_send>:
{
  80919d:	f3 0f 1e fb          	endbr32 
  8091a1:	55                   	push   %ebp
  8091a2:	89 e5                	mov    %esp,%ebp
  8091a4:	83 ec 08             	sub    $0x8,%esp
  8091a7:	8b 45 08             	mov    0x8(%ebp),%eax
  return udp_sendto(pcb, p, &pcb->remote_ip, pcb->remote_port);
  8091aa:	0f b7 50 14          	movzwl 0x14(%eax),%edx
  8091ae:	52                   	push   %edx
  8091af:	8d 50 04             	lea    0x4(%eax),%edx
  8091b2:	52                   	push   %edx
  8091b3:	ff 75 0c             	pushl  0xc(%ebp)
  8091b6:	50                   	push   %eax
  8091b7:	e8 9d ff ff ff       	call   809159 <udp_sendto>
}
  8091bc:	c9                   	leave  
  8091bd:	c3                   	ret    

008091be <udp_connect>:
 *
 * @see udp_disconnect()
 */
err_t
udp_connect(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  8091be:	f3 0f 1e fb          	endbr32 
  8091c2:	55                   	push   %ebp
  8091c3:	89 e5                	mov    %esp,%ebp
  8091c5:	57                   	push   %edi
  8091c6:	56                   	push   %esi
  8091c7:	53                   	push   %ebx
  8091c8:	83 ec 0c             	sub    $0xc,%esp
  8091cb:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8091ce:	8b 75 0c             	mov    0xc(%ebp),%esi
  8091d1:	8b 7d 10             	mov    0x10(%ebp),%edi
  struct udp_pcb *ipcb;

  if (pcb->local_port == 0) {
  8091d4:	66 83 7b 12 00       	cmpw   $0x0,0x12(%ebx)
  8091d9:	74 2b                	je     809206 <udp_connect+0x48>
    err_t err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
    if (err != ERR_OK)
      return err;
  }

  ip_addr_set(&pcb->remote_ip, ipaddr);
  8091db:	b8 00 00 00 00       	mov    $0x0,%eax
  8091e0:	85 f6                	test   %esi,%esi
  8091e2:	74 02                	je     8091e6 <udp_connect+0x28>
  8091e4:	8b 06                	mov    (%esi),%eax
  8091e6:	89 43 04             	mov    %eax,0x4(%ebx)
  pcb->remote_port = port;
  8091e9:	66 89 7b 14          	mov    %di,0x14(%ebx)
  pcb->flags |= UDP_FLAGS_CONNECTED;
  8091ed:	80 4b 10 04          	orb    $0x4,0x10(%ebx)
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) & 0xff), pcb->remote_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  8091f1:	8b 15 54 b2 b3 00    	mov    0xb3b254,%edx
  8091f7:	89 d0                	mov    %edx,%eax
  8091f9:	85 c0                	test   %eax,%eax
  8091fb:	74 1e                	je     80921b <udp_connect+0x5d>
    if (pcb == ipcb) {
  8091fd:	39 d8                	cmp    %ebx,%eax
  8091ff:	74 2b                	je     80922c <udp_connect+0x6e>
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  809201:	8b 40 0c             	mov    0xc(%eax),%eax
  809204:	eb f3                	jmp    8091f9 <udp_connect+0x3b>
    err_t err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
  809206:	83 ec 04             	sub    $0x4,%esp
  809209:	6a 00                	push   $0x0
  80920b:	53                   	push   %ebx
  80920c:	53                   	push   %ebx
  80920d:	e8 ec fc ff ff       	call   808efe <udp_bind>
    if (err != ERR_OK)
  809212:	83 c4 10             	add    $0x10,%esp
  809215:	84 c0                	test   %al,%al
  809217:	74 c2                	je     8091db <udp_connect+0x1d>
  809219:	eb 09                	jmp    809224 <udp_connect+0x66>
      /* already on the list, just return */
      return ERR_OK;
    }
  }
  /* PCB not yet on the list, add PCB now */
  pcb->next = udp_pcbs;
  80921b:	89 53 0c             	mov    %edx,0xc(%ebx)
  udp_pcbs = pcb;
  80921e:	89 1d 54 b2 b3 00    	mov    %ebx,0xb3b254
  return ERR_OK;
}
  809224:	8d 65 f4             	lea    -0xc(%ebp),%esp
  809227:	5b                   	pop    %ebx
  809228:	5e                   	pop    %esi
  809229:	5f                   	pop    %edi
  80922a:	5d                   	pop    %ebp
  80922b:	c3                   	ret    
      return ERR_OK;
  80922c:	b8 00 00 00 00       	mov    $0x0,%eax
  809231:	eb f1                	jmp    809224 <udp_connect+0x66>

00809233 <udp_disconnect>:
 *
 * @param pcb the udp pcb to disconnect.
 */
void
udp_disconnect(struct udp_pcb *pcb)
{
  809233:	f3 0f 1e fb          	endbr32 
  809237:	55                   	push   %ebp
  809238:	89 e5                	mov    %esp,%ebp
  80923a:	8b 45 08             	mov    0x8(%ebp),%eax
  /* reset remote address association */
  ip_addr_set(&pcb->remote_ip, IP_ADDR_ANY);
  80923d:	8b 15 08 24 81 00    	mov    0x812408,%edx
  809243:	89 50 04             	mov    %edx,0x4(%eax)
  pcb->remote_port = 0;
  809246:	66 c7 40 14 00 00    	movw   $0x0,0x14(%eax)
  /* mark PCB as unconnected */
  pcb->flags &= ~UDP_FLAGS_CONNECTED;
  80924c:	80 60 10 fb          	andb   $0xfb,0x10(%eax)
}
  809250:	5d                   	pop    %ebp
  809251:	c3                   	ret    

00809252 <udp_recv>:
void
udp_recv(struct udp_pcb *pcb,
         void (* recv)(void *arg, struct udp_pcb *upcb, struct pbuf *p,
                       struct ip_addr *addr, u16_t port),
         void *recv_arg)
{
  809252:	f3 0f 1e fb          	endbr32 
  809256:	55                   	push   %ebp
  809257:	89 e5                	mov    %esp,%ebp
  809259:	8b 45 08             	mov    0x8(%ebp),%eax
  /* remember recv() callback and user data */
  pcb->recv = recv;
  80925c:	8b 55 0c             	mov    0xc(%ebp),%edx
  80925f:	89 50 18             	mov    %edx,0x18(%eax)
  pcb->recv_arg = recv_arg;
  809262:	8b 55 10             	mov    0x10(%ebp),%edx
  809265:	89 50 1c             	mov    %edx,0x1c(%eax)
}
  809268:	5d                   	pop    %ebp
  809269:	c3                   	ret    

0080926a <udp_remove>:
 *
 * @see udp_new()
 */
void
udp_remove(struct udp_pcb *pcb)
{
  80926a:	f3 0f 1e fb          	endbr32 
  80926e:	55                   	push   %ebp
  80926f:	89 e5                	mov    %esp,%ebp
  809271:	83 ec 08             	sub    $0x8,%esp
  809274:	8b 4d 08             	mov    0x8(%ebp),%ecx
  struct udp_pcb *pcb2;

  snmp_delete_udpidx_tree(pcb);
  /* pcb to be removed is first in list? */
  if (udp_pcbs == pcb) {
  809277:	a1 54 b2 b3 00       	mov    0xb3b254,%eax
  80927c:	39 c8                	cmp    %ecx,%eax
  80927e:	75 1b                	jne    80929b <udp_remove+0x31>
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
  809280:	8b 41 0c             	mov    0xc(%ecx),%eax
  809283:	a3 54 b2 b3 00       	mov    %eax,0xb3b254
      if (pcb2->next != NULL && pcb2->next == pcb) {
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  memp_free(MEMP_UDP_PCB, pcb);
  809288:	83 ec 08             	sub    $0x8,%esp
  80928b:	51                   	push   %ecx
  80928c:	6a 01                	push   $0x1
  80928e:	e8 0b b4 ff ff       	call   80469e <memp_free>
}
  809293:	83 c4 10             	add    $0x10,%esp
  809296:	c9                   	leave  
  809297:	c3                   	ret    
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  809298:	8b 40 0c             	mov    0xc(%eax),%eax
  80929b:	85 c0                	test   %eax,%eax
  80929d:	74 e9                	je     809288 <udp_remove+0x1e>
      if (pcb2->next != NULL && pcb2->next == pcb) {
  80929f:	8b 50 0c             	mov    0xc(%eax),%edx
  8092a2:	39 ca                	cmp    %ecx,%edx
  8092a4:	75 f2                	jne    809298 <udp_remove+0x2e>
  8092a6:	85 d2                	test   %edx,%edx
  8092a8:	74 ee                	je     809298 <udp_remove+0x2e>
        pcb2->next = pcb->next;
  8092aa:	8b 51 0c             	mov    0xc(%ecx),%edx
  8092ad:	89 50 0c             	mov    %edx,0xc(%eax)
  8092b0:	eb e6                	jmp    809298 <udp_remove+0x2e>

008092b2 <udp_new>:
 *
 * @see udp_remove()
 */
struct udp_pcb *
udp_new(void)
{
  8092b2:	f3 0f 1e fb          	endbr32 
  8092b6:	55                   	push   %ebp
  8092b7:	89 e5                	mov    %esp,%ebp
  8092b9:	53                   	push   %ebx
  8092ba:	83 ec 10             	sub    $0x10,%esp
  struct udp_pcb *pcb;
  pcb = memp_malloc(MEMP_UDP_PCB);
  8092bd:	6a 01                	push   $0x1
  8092bf:	e8 80 b3 ff ff       	call   804644 <memp_malloc>
  8092c4:	89 c3                	mov    %eax,%ebx
  /* could allocate UDP PCB? */
  if (pcb != NULL) {
  8092c6:	83 c4 10             	add    $0x10,%esp
  8092c9:	85 c0                	test   %eax,%eax
  8092cb:	74 14                	je     8092e1 <udp_new+0x2f>
    /* UDP Lite: by initializing to all zeroes, chksum_len is set to 0
     * which means checksum is generated over the whole datagram per default
     * (recommended as default by RFC 3828). */
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct udp_pcb));
  8092cd:	83 ec 04             	sub    $0x4,%esp
  8092d0:	6a 20                	push   $0x20
  8092d2:	6a 00                	push   $0x0
  8092d4:	50                   	push   %eax
  8092d5:	e8 c8 5e 00 00       	call   80f1a2 <memset>
    pcb->ttl = UDP_TTL;
  8092da:	c6 43 0b ff          	movb   $0xff,0xb(%ebx)
  8092de:	83 c4 10             	add    $0x10,%esp
  }
  return pcb;
}
  8092e1:	89 d8                	mov    %ebx,%eax
  8092e3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8092e6:	c9                   	leave  
  8092e7:	c3                   	ret    

008092e8 <free_etharp_q>:
 *
 * @param q a qeueue of etharp_q_entry's to free
 */
static void
free_etharp_q(struct etharp_q_entry *q)
{
  8092e8:	55                   	push   %ebp
  8092e9:	89 e5                	mov    %esp,%ebp
  8092eb:	56                   	push   %esi
  8092ec:	53                   	push   %ebx
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  8092ed:	85 c0                	test   %eax,%eax
  8092ef:	74 35                	je     809326 <free_etharp_q+0x3e>
  8092f1:	89 c3                	mov    %eax,%ebx
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  8092f3:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  8092f7:	74 44                	je     80933d <free_etharp_q+0x55>
  8092f9:	89 de                	mov    %ebx,%esi
  while (q) {
    r = q;
    q = q->next;
  8092fb:	8b 1b                	mov    (%ebx),%ebx
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
  8092fd:	8b 46 04             	mov    0x4(%esi),%eax
  809300:	85 c0                	test   %eax,%eax
  809302:	74 50                	je     809354 <free_etharp_q+0x6c>
    pbuf_free(r->p);
  809304:	83 ec 0c             	sub    $0xc,%esp
  809307:	50                   	push   %eax
  809308:	e8 14 b7 ff ff       	call   804a21 <pbuf_free>
    memp_free(MEMP_ARP_QUEUE, r);
  80930d:	83 c4 08             	add    $0x8,%esp
  809310:	56                   	push   %esi
  809311:	6a 0a                	push   $0xa
  809313:	e8 86 b3 ff ff       	call   80469e <memp_free>
  while (q) {
  809318:	83 c4 10             	add    $0x10,%esp
  80931b:	85 db                	test   %ebx,%ebx
  80931d:	75 da                	jne    8092f9 <free_etharp_q+0x11>
  }
}
  80931f:	8d 65 f8             	lea    -0x8(%ebp),%esp
  809322:	5b                   	pop    %ebx
  809323:	5e                   	pop    %esi
  809324:	5d                   	pop    %ebp
  809325:	c3                   	ret    
  LWIP_ASSERT("q != NULL", q != NULL);
  809326:	83 ec 04             	sub    $0x4,%esp
  809329:	68 0c 1f 81 00       	push   $0x811f0c
  80932e:	68 93 00 00 00       	push   $0x93
  809333:	68 fa 27 81 00       	push   $0x8127fa
  809338:	e8 0a 56 00 00       	call   80e947 <_panic>
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  80933d:	83 ec 04             	sub    $0x4,%esp
  809340:	68 12 28 81 00       	push   $0x812812
  809345:	68 94 00 00 00       	push   $0x94
  80934a:	68 fa 27 81 00       	push   $0x8127fa
  80934f:	e8 f3 55 00 00       	call   80e947 <_panic>
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
  809354:	83 ec 04             	sub    $0x4,%esp
  809357:	68 1f 28 81 00       	push   $0x81281f
  80935c:	68 98 00 00 00       	push   $0x98
  809361:	68 fa 27 81 00       	push   $0x8127fa
  809366:	e8 dc 55 00 00       	call   80e947 <_panic>

0080936b <find_entry>:
#if LWIP_NETIF_HWADDRHINT
find_entry(struct ip_addr *ipaddr, u8_t flags, struct netif *netif)
#else /* LWIP_NETIF_HWADDRHINT */
find_entry(struct ip_addr *ipaddr, u8_t flags)
#endif /* LWIP_NETIF_HWADDRHINT */
{
  80936b:	55                   	push   %ebp
  80936c:	89 e5                	mov    %esp,%ebp
  80936e:	57                   	push   %edi
  80936f:	56                   	push   %esi
  809370:	53                   	push   %ebx
  809371:	83 ec 1c             	sub    $0x1c,%esp
  809374:	89 c3                	mov    %eax,%ebx
  809376:	89 55 e0             	mov    %edx,-0x20(%ebp)
  u8_t age_queue = 0;
#endif

  /* First, test if the last call to this function asked for the
   * same address. If so, we're really fast! */
  if (ipaddr) {
  809379:	85 c0                	test   %eax,%eax
  80937b:	0f 84 86 00 00 00    	je     809407 <find_entry+0x9c>
          return per_pcb_cache;
        }
      }
    }
#else /* #if LWIP_NETIF_HWADDRHINT */
    if (arp_table[etharp_cached_entry].state == ETHARP_STATE_STABLE) {
  809381:	0f b6 05 00 4a b3 00 	movzbl 0xb34a00,%eax
  809388:	0f b6 d0             	movzbl %al,%edx
  80938b:	6b ca 1c             	imul   $0x1c,%edx,%ecx
  80938e:	83 b9 30 4a b3 00 02 	cmpl   $0x2,0xb34a30(%ecx)
  809395:	74 42                	je     8093d9 <find_entry+0x6e>
  809397:	bf 00 00 00 00       	mov    $0x0,%edi
  80939c:	c6 45 df 0a          	movb   $0xa,-0x21(%ebp)
  8093a0:	c6 45 e6 00          	movb   $0x0,-0x1a(%ebp)
  8093a4:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  8093a8:	c6 45 de 0a          	movb   $0xa,-0x22(%ebp)
  8093ac:	c6 45 e5 0a          	movb   $0xa,-0x1b(%ebp)
  8093b0:	b8 00 00 00 00       	mov    $0x0,%eax
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (arp_table[i].state == ETHARP_STATE_EMPTY)) {
  8093b5:	0f b6 d0             	movzbl %al,%edx
  8093b8:	6b d2 1c             	imul   $0x1c,%edx,%edx
  8093bb:	83 ba 30 4a b3 00 00 	cmpl   $0x0,0xb34a30(%edx)
  8093c2:	75 63                	jne    809427 <find_entry+0xbc>
      LWIP_DEBUGF(ETHARP_DEBUG, ("find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
  8093c4:	89 c2                	mov    %eax,%edx
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  8093c6:	83 c0 01             	add    $0x1,%eax
  8093c9:	3c 09                	cmp    $0x9,%al
  8093cb:	0f 87 07 01 00 00    	ja     8094d8 <find_entry+0x16d>
  8093d1:	88 55 e7             	mov    %dl,-0x19(%ebp)
  8093d4:	e9 98 00 00 00       	jmp    809471 <find_entry+0x106>
      if (ip_addr_cmp(ipaddr, &arp_table[etharp_cached_entry].ipaddr)) {
  8093d9:	8b b9 24 4a b3 00    	mov    0xb34a24(%ecx),%edi
  8093df:	39 3b                	cmp    %edi,(%ebx)
  8093e1:	0f 84 3e 01 00 00    	je     809525 <find_entry+0x1ba>
  8093e7:	bf 00 00 00 00       	mov    $0x0,%edi
  8093ec:	c6 45 df 0a          	movb   $0xa,-0x21(%ebp)
  8093f0:	c6 45 e6 00          	movb   $0x0,-0x1a(%ebp)
  8093f4:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  8093f8:	c6 45 de 0a          	movb   $0xa,-0x22(%ebp)
  8093fc:	c6 45 e5 0a          	movb   $0xa,-0x1b(%ebp)
  809400:	b8 00 00 00 00       	mov    $0x0,%eax
  809405:	eb ae                	jmp    8093b5 <find_entry+0x4a>
  809407:	bf 00 00 00 00       	mov    $0x0,%edi
  80940c:	c6 45 df 0a          	movb   $0xa,-0x21(%ebp)
  809410:	c6 45 e6 00          	movb   $0x0,-0x1a(%ebp)
  809414:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  809418:	c6 45 de 0a          	movb   $0xa,-0x22(%ebp)
  80941c:	c6 45 e5 0a          	movb   $0xa,-0x1b(%ebp)
  809420:	b8 00 00 00 00       	mov    $0x0,%eax
  809425:	eb 8e                	jmp    8093b5 <find_entry+0x4a>
  809427:	ba 0a 00 00 00       	mov    $0xa,%edx
  80942c:	88 55 e7             	mov    %dl,-0x19(%ebp)
  80942f:	eb 40                	jmp    809471 <find_entry+0x106>
    }
    /* pending entry? */
    else if (arp_table[i].state == ETHARP_STATE_PENDING) {
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
  809431:	85 db                	test   %ebx,%ebx
  809433:	74 0d                	je     809442 <find_entry+0xd7>
  809435:	6b f1 1c             	imul   $0x1c,%ecx,%esi
  809438:	8b 96 24 4a b3 00    	mov    0xb34a24(%esi),%edx
  80943e:	39 13                	cmp    %edx,(%ebx)
  809440:	74 6d                	je     8094af <find_entry+0x144>
        etharp_cached_entry = i;
#endif /* #if LWIP_NETIF_HWADDRHINT */
        return i;
#if ARP_QUEUEING
      /* pending with queued packets? */
      } else if (arp_table[i].q != NULL) {
  809442:	6b f1 1c             	imul   $0x1c,%ecx,%esi
  809445:	83 be 20 4a b3 00 00 	cmpl   $0x0,0xb34a20(%esi)
  80944c:	74 68                	je     8094b6 <find_entry+0x14b>
        if (arp_table[i].ctime >= age_queue) {
  80944e:	0f b6 8e 34 4a b3 00 	movzbl 0xb34a34(%esi),%ecx
  809455:	89 fa                	mov    %edi,%edx
  809457:	38 d1                	cmp    %dl,%cl
  809459:	72 05                	jb     809460 <find_entry+0xf5>
          old_queue = i;
  80945b:	88 45 df             	mov    %al,-0x21(%ebp)
          age_queue = arp_table[i].ctime;
  80945e:	89 cf                	mov    %ecx,%edi
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  809460:	83 c0 01             	add    $0x1,%eax
  809463:	3c 09                	cmp    $0x9,%al
  809465:	77 6d                	ja     8094d4 <find_entry+0x169>
    if ((empty == ARP_TABLE_SIZE) && (arp_table[i].state == ETHARP_STATE_EMPTY)) {
  809467:	80 7d e7 0a          	cmpb   $0xa,-0x19(%ebp)
  80946b:	0f 84 44 ff ff ff    	je     8093b5 <find_entry+0x4a>
    else if (arp_table[i].state == ETHARP_STATE_PENDING) {
  809471:	0f b6 c8             	movzbl %al,%ecx
  809474:	6b f1 1c             	imul   $0x1c,%ecx,%esi
  809477:	8b b6 30 4a b3 00    	mov    0xb34a30(%esi),%esi
  80947d:	83 fe 01             	cmp    $0x1,%esi
  809480:	74 af                	je     809431 <find_entry+0xc6>
          age_pending = arp_table[i].ctime;
        }
      }        
    }
    /* stable entry? */
    else if (arp_table[i].state == ETHARP_STATE_STABLE) {
  809482:	83 fe 02             	cmp    $0x2,%esi
  809485:	75 d9                	jne    809460 <find_entry+0xf5>
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
  809487:	85 db                	test   %ebx,%ebx
  809489:	74 0d                	je     809498 <find_entry+0x12d>
  80948b:	6b f1 1c             	imul   $0x1c,%ecx,%esi
  80948e:	8b 96 24 4a b3 00    	mov    0xb34a24(%esi),%edx
  809494:	39 13                	cmp    %edx,(%ebx)
  809496:	74 35                	je     8094cd <find_entry+0x162>
#else /* #if LWIP_NETIF_HWADDRHINT */
        etharp_cached_entry = i;
#endif /* #if LWIP_NETIF_HWADDRHINT */
        return i;
      /* remember entry with oldest stable entry in oldest, its age in maxtime */
      } else if (arp_table[i].ctime >= age_stable) {
  809498:	6b c9 1c             	imul   $0x1c,%ecx,%ecx
  80949b:	0f b6 89 34 4a b3 00 	movzbl 0xb34a34(%ecx),%ecx
  8094a2:	3a 4d e6             	cmp    -0x1a(%ebp),%cl
  8094a5:	72 b9                	jb     809460 <find_entry+0xf5>
        old_stable = i;
  8094a7:	88 45 e5             	mov    %al,-0x1b(%ebp)
        age_stable = arp_table[i].ctime;
  8094aa:	88 4d e6             	mov    %cl,-0x1a(%ebp)
  8094ad:	eb b1                	jmp    809460 <find_entry+0xf5>
        etharp_cached_entry = i;
  8094af:	a2 00 4a b3 00       	mov    %al,0xb34a00
        return i;
  8094b4:	eb 6f                	jmp    809525 <find_entry+0x1ba>
        if (arp_table[i].ctime >= age_pending) {
  8094b6:	6b c9 1c             	imul   $0x1c,%ecx,%ecx
  8094b9:	0f b6 89 34 4a b3 00 	movzbl 0xb34a34(%ecx),%ecx
  8094c0:	3a 4d e4             	cmp    -0x1c(%ebp),%cl
  8094c3:	72 9b                	jb     809460 <find_entry+0xf5>
          old_pending = i;
  8094c5:	88 45 de             	mov    %al,-0x22(%ebp)
          age_pending = arp_table[i].ctime;
  8094c8:	88 4d e4             	mov    %cl,-0x1c(%ebp)
  8094cb:	eb 93                	jmp    809460 <find_entry+0xf5>
        etharp_cached_entry = i;
  8094cd:	a2 00 4a b3 00       	mov    %al,0xb34a00
        return i;
  8094d2:	eb 51                	jmp    809525 <find_entry+0x1ba>
  8094d4:	0f b6 55 e7          	movzbl -0x19(%ebp),%edx
    }
  }
  /* { we have no match } => try to create a new entry */
   
  /* no empty entry found and not allowed to recycle? */
  if (((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_TRY_HARD) == 0))
  8094d8:	80 fa 0a             	cmp    $0xa,%dl
  8094db:	74 50                	je     80952d <find_entry+0x1c2>
      /* or don't create new entry, only search? */
      || ((flags & ETHARP_FIND_ONLY) != 0)) {
  8094dd:	f6 45 e0 02          	testb  $0x2,-0x20(%ebp)
  8094e1:	0f 85 e3 00 00 00    	jne    8095ca <find_entry+0x25f>
   * { ETHARP_TRY_HARD is set at this point }
   */ 

  /* 1) empty entry available? */
  if (empty < ARP_TABLE_SIZE) {
    i = empty;
  8094e7:	89 d6                	mov    %edx,%esi
  if (empty < ARP_TABLE_SIZE) {
  8094e9:	80 fa 09             	cmp    $0x9,%dl
  8094ec:	7f 53                	jg     809541 <find_entry+0x1d6>
  } else {
    return (s8_t)ERR_MEM;
  }

  /* { empty or recyclable entry found } */
  LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
  8094ee:	89 f0                	mov    %esi,%eax
  8094f0:	3c 09                	cmp    $0x9,%al
  8094f2:	0f 87 b1 00 00 00    	ja     8095a9 <find_entry+0x23e>

  if (arp_table[i].state != ETHARP_STATE_EMPTY)
  8094f8:	0f b6 c0             	movzbl %al,%eax
  {
    snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
  }
  /* recycle entry (no-op for an already empty entry) */
  arp_table[i].state = ETHARP_STATE_EMPTY;
  8094fb:	6b d0 1c             	imul   $0x1c,%eax,%edx
  8094fe:	c7 82 30 4a b3 00 00 	movl   $0x0,0xb34a30(%edx)
  809505:	00 00 00 

  /* IP address given? */
  if (ipaddr != NULL) {
  809508:	85 db                	test   %ebx,%ebx
  80950a:	74 08                	je     809514 <find_entry+0x1a9>
    /* set IP address */
    ip_addr_set(&arp_table[i].ipaddr, ipaddr);
  80950c:	8b 0b                	mov    (%ebx),%ecx
  80950e:	89 8a 24 4a b3 00    	mov    %ecx,0xb34a24(%edx)
  }
  arp_table[i].ctime = 0;
  809514:	6b c0 1c             	imul   $0x1c,%eax,%eax
  809517:	c6 80 34 4a b3 00 00 	movb   $0x0,0xb34a34(%eax)
#if LWIP_NETIF_HWADDRHINT
  NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
  etharp_cached_entry = i;
  80951e:	89 f0                	mov    %esi,%eax
  809520:	a2 00 4a b3 00       	mov    %al,0xb34a00
#endif /* #if LWIP_NETIF_HWADDRHINT */
  return (err_t)i;
}
  809525:	8d 65 f4             	lea    -0xc(%ebp),%esp
  809528:	5b                   	pop    %ebx
  809529:	5e                   	pop    %esi
  80952a:	5f                   	pop    %edi
  80952b:	5d                   	pop    %ebp
  80952c:	c3                   	ret    
  if (((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_TRY_HARD) == 0))
  80952d:	f6 45 e0 01          	testb  $0x1,-0x20(%ebp)
  809531:	0f 84 89 00 00 00    	je     8095c0 <find_entry+0x255>
      || ((flags & ETHARP_FIND_ONLY) != 0)) {
  809537:	f6 45 e0 02          	testb  $0x2,-0x20(%ebp)
  80953b:	0f 85 9d 00 00 00    	jne    8095de <find_entry+0x273>
  else if (old_stable < ARP_TABLE_SIZE) {
  809541:	0f b6 45 e5          	movzbl -0x1b(%ebp),%eax
  809545:	3c 09                	cmp    $0x9,%al
  809547:	7f 28                	jg     809571 <find_entry+0x206>
    i = old_stable;
  809549:	89 c6                	mov    %eax,%esi
    LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
  80954b:	0f b6 c0             	movzbl %al,%eax
  80954e:	6b c0 1c             	imul   $0x1c,%eax,%eax
  809551:	83 b8 20 4a b3 00 00 	cmpl   $0x0,0xb34a20(%eax)
  809558:	74 94                	je     8094ee <find_entry+0x183>
  80955a:	83 ec 04             	sub    $0x4,%esp
  80955d:	68 2c 28 81 00       	push   $0x81282c
  809562:	68 75 01 00 00       	push   $0x175
  809567:	68 fa 27 81 00       	push   $0x8127fa
  80956c:	e8 d6 53 00 00       	call   80e947 <_panic>
  } else if (old_pending < ARP_TABLE_SIZE) {
  809571:	0f b6 45 de          	movzbl -0x22(%ebp),%eax
    i = old_pending;
  809575:	89 c6                	mov    %eax,%esi
  } else if (old_pending < ARP_TABLE_SIZE) {
  809577:	3c 09                	cmp    $0x9,%al
  809579:	0f 8e 6f ff ff ff    	jle    8094ee <find_entry+0x183>
  } else if (old_queue < ARP_TABLE_SIZE) {
  80957f:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
  809583:	3c 09                	cmp    $0x9,%al
  809585:	7f 4d                	jg     8095d4 <find_entry+0x269>
    i = old_queue;
  809587:	89 c6                	mov    %eax,%esi
    free_etharp_q(arp_table[i].q);
  809589:	0f b6 f8             	movzbl %al,%edi
  80958c:	6b ff 1c             	imul   $0x1c,%edi,%edi
  80958f:	8b 87 20 4a b3 00    	mov    0xb34a20(%edi),%eax
  809595:	e8 4e fd ff ff       	call   8092e8 <free_etharp_q>
    arp_table[i].q = NULL;
  80959a:	c7 87 20 4a b3 00 00 	movl   $0x0,0xb34a20(%edi)
  8095a1:	00 00 00 
  8095a4:	e9 45 ff ff ff       	jmp    8094ee <find_entry+0x183>
  LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
  8095a9:	83 ec 04             	sub    $0x4,%esp
  8095ac:	68 43 28 81 00       	push   $0x812843
  8095b1:	68 8b 01 00 00       	push   $0x18b
  8095b6:	68 fa 27 81 00       	push   $0x8127fa
  8095bb:	e8 87 53 00 00       	call   80e947 <_panic>
    return (s8_t)ERR_MEM;
  8095c0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8095c5:	e9 5b ff ff ff       	jmp    809525 <find_entry+0x1ba>
  8095ca:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8095cf:	e9 51 ff ff ff       	jmp    809525 <find_entry+0x1ba>
    return (s8_t)ERR_MEM;
  8095d4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8095d9:	e9 47 ff ff ff       	jmp    809525 <find_entry+0x1ba>
    return (s8_t)ERR_MEM;
  8095de:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8095e3:	e9 3d ff ff ff       	jmp    809525 <find_entry+0x1ba>

008095e8 <etharp_send_ip>:
 * @params dst the destination MAC address to be copied into the ethernet header
 * @return ERR_OK if the packet was sent, any other err_t on failure
 */
static err_t
etharp_send_ip(struct netif *netif, struct pbuf *p, struct eth_addr *src, struct eth_addr *dst)
{
  8095e8:	55                   	push   %ebp
  8095e9:	89 e5                	mov    %esp,%ebp
  8095eb:	57                   	push   %edi
  8095ec:	56                   	push   %esi
  8095ed:	53                   	push   %ebx
  8095ee:	83 ec 1c             	sub    $0x1c,%esp
  8095f1:	89 d7                	mov    %edx,%edi
  8095f3:	8b 55 08             	mov    0x8(%ebp),%edx
  struct eth_hdr *ethhdr = p->payload;
  8095f6:	8b 5f 04             	mov    0x4(%edi),%ebx
  u8_t k;

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  8095f9:	80 78 24 06          	cmpb   $0x6,0x24(%eax)
  8095fd:	75 45                	jne    809644 <etharp_send_ip+0x5c>
  8095ff:	89 c6                	mov    %eax,%esi
  809601:	b8 05 00 00 00       	mov    $0x5,%eax
  809606:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
  while(k > 0) {
    k--;
    ethhdr->dest.addr[k] = dst->addr[k];
  809609:	0f b6 0c 02          	movzbl (%edx,%eax,1),%ecx
  80960d:	88 0c 03             	mov    %cl,(%ebx,%eax,1)
    ethhdr->src.addr[k]  = src->addr[k];
  809610:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  809613:	0f b6 0c 01          	movzbl (%ecx,%eax,1),%ecx
  809617:	88 4c 03 06          	mov    %cl,0x6(%ebx,%eax,1)
  80961b:	83 e8 01             	sub    $0x1,%eax
  while(k > 0) {
  80961e:	83 f8 ff             	cmp    $0xffffffff,%eax
  809621:	75 e6                	jne    809609 <etharp_send_ip+0x21>
  }
  ethhdr->type = htons(ETHTYPE_IP);
  809623:	83 ec 0c             	sub    $0xc,%esp
  809626:	68 00 08 00 00       	push   $0x800
  80962b:	e8 29 e3 ff ff       	call   807959 <htons>
  809630:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
  /* send the packet */
  return netif->linkoutput(netif, p);
  809634:	83 c4 08             	add    $0x8,%esp
  809637:	57                   	push   %edi
  809638:	56                   	push   %esi
  809639:	ff 56 18             	call   *0x18(%esi)
}
  80963c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80963f:	5b                   	pop    %ebx
  809640:	5e                   	pop    %esi
  809641:	5f                   	pop    %edi
  809642:	5d                   	pop    %ebp
  809643:	c3                   	ret    
  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  809644:	83 ec 04             	sub    $0x4,%esp
  809647:	68 70 28 81 00       	push   $0x812870
  80964c:	68 b2 01 00 00       	push   $0x1b2
  809651:	68 fa 27 81 00       	push   $0x8127fa
  809656:	e8 ec 52 00 00       	call   80e947 <_panic>

0080965b <update_arp_entry>:
 *
 * @see pbuf_free()
 */
static err_t
update_arp_entry(struct netif *netif, struct ip_addr *ipaddr, struct eth_addr *ethaddr, u8_t flags)
{
  80965b:	55                   	push   %ebp
  80965c:	89 e5                	mov    %esp,%ebp
  80965e:	57                   	push   %edi
  80965f:	56                   	push   %esi
  809660:	53                   	push   %ebx
  809661:	83 ec 1c             	sub    $0x1c,%esp
  809664:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  809667:	89 cb                	mov    %ecx,%ebx
  809669:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80966c:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  s8_t i;
  u8_t k;
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 3, ("update_arp_entry()\n"));
  LWIP_ASSERT("netif->hwaddr_len == ETHARP_HWADDR_LEN", netif->hwaddr_len == ETHARP_HWADDR_LEN);
  80966f:	80 78 24 06          	cmpb   $0x6,0x24(%eax)
  809673:	0f 85 ae 00 00 00    	jne    809727 <update_arp_entry+0xcc>
  809679:	89 d6                	mov    %edx,%esi
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
  80967b:	85 d2                	test   %edx,%edx
  80967d:	0f 84 fe 00 00 00    	je     809781 <update_arp_entry+0x126>
  809683:	83 3a 00             	cmpl   $0x0,(%edx)
  809686:	0f 84 fc 00 00 00    	je     809788 <update_arp_entry+0x12d>
      ip_addr_isbroadcast(ipaddr, netif) ||
  80968c:	83 ec 08             	sub    $0x8,%esp
  80968f:	ff 75 e4             	pushl  -0x1c(%ebp)
  809692:	52                   	push   %edx
  809693:	e8 45 d0 ff ff       	call   8066dd <ip_addr_isbroadcast>
  if (ip_addr_isany(ipaddr) ||
  809698:	83 c4 10             	add    $0x10,%esp
  80969b:	84 c0                	test   %al,%al
  80969d:	0f 85 ec 00 00 00    	jne    80978f <update_arp_entry+0x134>
      ip_addr_ismulticast(ipaddr)) {
  8096a3:	8b 3e                	mov    (%esi),%edi
  8096a5:	83 ec 0c             	sub    $0xc,%esp
  8096a8:	68 00 00 00 f0       	push   $0xf0000000
  8096ad:	e8 f6 e4 ff ff       	call   807ba8 <ntohl>
  8096b2:	21 c7                	and    %eax,%edi
  8096b4:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  8096bb:	e8 e8 e4 ff ff       	call   807ba8 <ntohl>
      ip_addr_isbroadcast(ipaddr, netif) ||
  8096c0:	83 c4 10             	add    $0x10,%esp
  8096c3:	39 c7                	cmp    %eax,%edi
  8096c5:	0f 84 cb 00 00 00    	je     809796 <update_arp_entry+0x13b>
  }
  /* find or create ARP entry */
#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, flags, netif);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, flags);
  8096cb:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
  8096cf:	89 f0                	mov    %esi,%eax
  8096d1:	e8 95 fc ff ff       	call   80936b <find_entry>
#endif /* LWIP_NETIF_HWADDRHINT */
  /* bail out if no entry could be found */
  if (i < 0)
  8096d6:	84 c0                	test   %al,%al
  8096d8:	0f 88 9b 00 00 00    	js     809779 <update_arp_entry+0x11e>
    return (err_t)i;
  
  /* mark it stable */
  arp_table[i].state = ETHARP_STATE_STABLE;
  8096de:	0f be c0             	movsbl %al,%eax
  8096e1:	6b f0 1c             	imul   $0x1c,%eax,%esi
  8096e4:	c7 86 30 4a b3 00 02 	movl   $0x2,0xb34a30(%esi)
  8096eb:	00 00 00 
  /* record network interface */
  arp_table[i].netif = netif;
  8096ee:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  8096f1:	89 8e 38 4a b3 00    	mov    %ecx,0xb34a38(%esi)
  8096f7:	ba 00 00 00 00       	mov    $0x0,%edx
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  k = ETHARP_HWADDR_LEN;
  while (k > 0) {
    k--;
    arp_table[i].ethaddr.addr[k] = ethaddr->addr[k];
  8096fc:	0f b6 4c 13 05       	movzbl 0x5(%ebx,%edx,1),%ecx
  809701:	88 8c 16 2d 4a b3 00 	mov    %cl,0xb34a2d(%esi,%edx,1)
  809708:	83 ea 01             	sub    $0x1,%edx
  while (k > 0) {
  80970b:	83 fa fa             	cmp    $0xfffffffa,%edx
  80970e:	75 ec                	jne    8096fc <update_arp_entry+0xa1>
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
  809710:	6b d0 1c             	imul   $0x1c,%eax,%edx
  809713:	c6 82 34 4a b3 00 00 	movb   $0x0,0xb34a34(%edx)
#if ARP_QUEUEING
  /* this is where we will send out queued packets! */
  while (arp_table[i].q != NULL) {
  80971a:	89 d6                	mov    %edx,%esi
    /* get the packet pointer */
    p = q->p;
    /* now queue entry can be freed */
    memp_free(MEMP_ARP_QUEUE, q);
    /* send the queued IP packet */
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
  80971c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80971f:	83 c0 25             	add    $0x25,%eax
  809722:	89 45 e0             	mov    %eax,-0x20(%ebp)
  while (arp_table[i].q != NULL) {
  809725:	eb 48                	jmp    80976f <update_arp_entry+0x114>
  LWIP_ASSERT("netif->hwaddr_len == ETHARP_HWADDR_LEN", netif->hwaddr_len == ETHARP_HWADDR_LEN);
  809727:	83 ec 04             	sub    $0x4,%esp
  80972a:	68 b4 28 81 00       	push   $0x8128b4
  80972f:	68 d9 01 00 00       	push   $0x1d9
  809734:	68 fa 27 81 00       	push   $0x8127fa
  809739:	e8 09 52 00 00       	call   80e947 <_panic>
    arp_table[i].q = q->next;
  80973e:	8b 10                	mov    (%eax),%edx
  809740:	89 96 20 4a b3 00    	mov    %edx,0xb34a20(%esi)
    p = q->p;
  809746:	8b 78 04             	mov    0x4(%eax),%edi
    memp_free(MEMP_ARP_QUEUE, q);
  809749:	83 ec 08             	sub    $0x8,%esp
  80974c:	50                   	push   %eax
  80974d:	6a 0a                	push   $0xa
  80974f:	e8 4a af ff ff       	call   80469e <memp_free>
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
  809754:	89 1c 24             	mov    %ebx,(%esp)
  809757:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  80975a:	89 fa                	mov    %edi,%edx
  80975c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80975f:	e8 84 fe ff ff       	call   8095e8 <etharp_send_ip>
    /* free the queued IP packet */
    pbuf_free(p);
  809764:	89 3c 24             	mov    %edi,(%esp)
  809767:	e8 b5 b2 ff ff       	call   804a21 <pbuf_free>
  80976c:	83 c4 10             	add    $0x10,%esp
  while (arp_table[i].q != NULL) {
  80976f:	8b 86 20 4a b3 00    	mov    0xb34a20(%esi),%eax
  809775:	85 c0                	test   %eax,%eax
  809777:	75 c5                	jne    80973e <update_arp_entry+0xe3>
  }
#endif
  return ERR_OK;
}
  809779:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80977c:	5b                   	pop    %ebx
  80977d:	5e                   	pop    %esi
  80977e:	5f                   	pop    %edi
  80977f:	5d                   	pop    %ebp
  809780:	c3                   	ret    
    return ERR_ARG;
  809781:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  809786:	eb f1                	jmp    809779 <update_arp_entry+0x11e>
  809788:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  80978d:	eb ea                	jmp    809779 <update_arp_entry+0x11e>
  80978f:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  809794:	eb e3                	jmp    809779 <update_arp_entry+0x11e>
  809796:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  80979b:	eb dc                	jmp    809779 <update_arp_entry+0x11e>

0080979d <etharp_tmr>:
{
  80979d:	f3 0f 1e fb          	endbr32 
  8097a1:	55                   	push   %ebp
  8097a2:	89 e5                	mov    %esp,%ebp
  8097a4:	57                   	push   %edi
  8097a5:	56                   	push   %esi
  8097a6:	53                   	push   %ebx
  8097a7:	83 ec 0c             	sub    $0xc,%esp
  8097aa:	bb 20 4a b3 00       	mov    $0xb34a20,%ebx
  8097af:	bf 38 4b b3 00       	mov    $0xb34b38,%edi
  8097b4:	eb 1f                	jmp    8097d5 <etharp_tmr+0x38>
      if (arp_table[i].q != NULL) {
  8097b6:	8b 06                	mov    (%esi),%eax
  8097b8:	85 c0                	test   %eax,%eax
  8097ba:	74 0b                	je     8097c7 <etharp_tmr+0x2a>
        free_etharp_q(arp_table[i].q);
  8097bc:	e8 27 fb ff ff       	call   8092e8 <free_etharp_q>
        arp_table[i].q = NULL;
  8097c1:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
      arp_table[i].state = ETHARP_STATE_EMPTY;
  8097c7:	c7 46 10 00 00 00 00 	movl   $0x0,0x10(%esi)
  8097ce:	83 c3 1c             	add    $0x1c,%ebx
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  8097d1:	39 fb                	cmp    %edi,%ebx
  8097d3:	74 23                	je     8097f8 <etharp_tmr+0x5b>
  8097d5:	89 de                	mov    %ebx,%esi
    arp_table[i].ctime++;
  8097d7:	0f b6 43 14          	movzbl 0x14(%ebx),%eax
  8097db:	83 c0 01             	add    $0x1,%eax
  8097de:	88 43 14             	mov    %al,0x14(%ebx)
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
  8097e1:	8b 53 10             	mov    0x10(%ebx),%edx
  8097e4:	3c ef                	cmp    $0xef,%al
  8097e6:	76 05                	jbe    8097ed <etharp_tmr+0x50>
  8097e8:	83 fa 02             	cmp    $0x2,%edx
  8097eb:	74 c9                	je     8097b6 <etharp_tmr+0x19>
        ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
  8097ed:	3c 01                	cmp    $0x1,%al
  8097ef:	76 dd                	jbe    8097ce <etharp_tmr+0x31>
  8097f1:	83 fa 01             	cmp    $0x1,%edx
  8097f4:	75 d8                	jne    8097ce <etharp_tmr+0x31>
  8097f6:	eb be                	jmp    8097b6 <etharp_tmr+0x19>
}
  8097f8:	83 c4 0c             	add    $0xc,%esp
  8097fb:	5b                   	pop    %ebx
  8097fc:	5e                   	pop    %esi
  8097fd:	5f                   	pop    %edi
  8097fe:	5d                   	pop    %ebp
  8097ff:	c3                   	ret    

00809800 <etharp_find_addr>:
 * @return table index if found, -1 otherwise
 */
s8_t
etharp_find_addr(struct netif *netif, struct ip_addr *ipaddr,
         struct eth_addr **eth_ret, struct ip_addr **ip_ret)
{
  809800:	f3 0f 1e fb          	endbr32 
  809804:	55                   	push   %ebp
  809805:	89 e5                	mov    %esp,%ebp
  809807:	53                   	push   %ebx
  809808:	83 ec 04             	sub    $0x4,%esp
  LWIP_UNUSED_ARG(netif);

#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, ETHARP_FIND_ONLY, NULL);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, ETHARP_FIND_ONLY);
  80980b:	ba 02 00 00 00       	mov    $0x2,%edx
  809810:	8b 45 0c             	mov    0xc(%ebp),%eax
  809813:	e8 53 fb ff ff       	call   80936b <find_entry>
#endif /* LWIP_NETIF_HWADDRHINT */
  if((i >= 0) && arp_table[i].state == ETHARP_STATE_STABLE) {
  809818:	84 c0                	test   %al,%al
  80981a:	78 31                	js     80984d <etharp_find_addr+0x4d>
  80981c:	0f be d0             	movsbl %al,%edx
  80981f:	6b d2 1c             	imul   $0x1c,%edx,%edx
  809822:	83 ba 30 4a b3 00 02 	cmpl   $0x2,0xb34a30(%edx)
  809829:	75 29                	jne    809854 <etharp_find_addr+0x54>
  80982b:	0f be d0             	movsbl %al,%edx
  80982e:	6b d2 1c             	imul   $0x1c,%edx,%edx
      *eth_ret = &arp_table[i].ethaddr;
  809831:	8d 9a 28 4a b3 00    	lea    0xb34a28(%edx),%ebx
  809837:	8b 4d 10             	mov    0x10(%ebp),%ecx
  80983a:	89 19                	mov    %ebx,(%ecx)
      *ip_ret = &arp_table[i].ipaddr;
  80983c:	81 c2 24 4a b3 00    	add    $0xb34a24,%edx
  809842:	8b 4d 14             	mov    0x14(%ebp),%ecx
  809845:	89 11                	mov    %edx,(%ecx)
      return i;
  }
  return -1;
}
  809847:	83 c4 04             	add    $0x4,%esp
  80984a:	5b                   	pop    %ebx
  80984b:	5d                   	pop    %ebp
  80984c:	c3                   	ret    
  return -1;
  80984d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809852:	eb f3                	jmp    809847 <etharp_find_addr+0x47>
  809854:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809859:	eb ec                	jmp    809847 <etharp_find_addr+0x47>

0080985b <etharp_ip_input>:
 *
 * @see pbuf_free()
 */
void
etharp_ip_input(struct netif *netif, struct pbuf *p)
{
  80985b:	f3 0f 1e fb          	endbr32 
  80985f:	55                   	push   %ebp
  809860:	89 e5                	mov    %esp,%ebp
  809862:	83 ec 08             	sub    $0x8,%esp
  809865:	8b 45 08             	mov    0x8(%ebp),%eax
  struct ethip_hdr *hdr;
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  809868:	85 c0                	test   %eax,%eax
  80986a:	74 13                	je     80987f <etharp_ip_input+0x24>
  /* Only insert an entry if the source IP address of the
     incoming IP packet comes from a host on the local network. */
  hdr = p->payload;
  80986c:	8b 55 0c             	mov    0xc(%ebp),%edx
  80986f:	8b 52 04             	mov    0x4(%edx),%edx
  /* source is not on the local network? */
  if (!ip_addr_netcmp(&(hdr->ip.src), &(netif->ip_addr), &(netif->netmask))) {
  809872:	8b 4a 1c             	mov    0x1c(%edx),%ecx
  809875:	33 48 04             	xor    0x4(%eax),%ecx
  809878:	85 48 08             	test   %ecx,0x8(%eax)
  80987b:	74 19                	je     809896 <etharp_ip_input+0x3b>
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_ip_input: updating ETHARP table.\n"));
  /* update ARP table */
  /* @todo We could use ETHARP_TRY_HARD if we think we are going to talk
   * back soon (for example, if the destination IP address is ours. */
  update_arp_entry(netif, &(hdr->ip.src), &(hdr->eth.src), 0);
}
  80987d:	c9                   	leave  
  80987e:	c3                   	ret    
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  80987f:	83 ec 04             	sub    $0x4,%esp
  809882:	68 82 1b 81 00       	push   $0x811b82
  809887:	68 48 02 00 00       	push   $0x248
  80988c:	68 fa 27 81 00       	push   $0x8127fa
  809891:	e8 b1 50 00 00       	call   80e947 <_panic>
  update_arp_entry(netif, &(hdr->ip.src), &(hdr->eth.src), 0);
  809896:	8d 4a 06             	lea    0x6(%edx),%ecx
  809899:	83 c2 1c             	add    $0x1c,%edx
  80989c:	83 ec 0c             	sub    $0xc,%esp
  80989f:	6a 00                	push   $0x0
  8098a1:	e8 b5 fd ff ff       	call   80965b <update_arp_entry>
  8098a6:	83 c4 10             	add    $0x10,%esp
  8098a9:	eb d2                	jmp    80987d <etharp_ip_input+0x22>

008098ab <etharp_arp_input>:
 *
 * @see pbuf_free()
 */
void
etharp_arp_input(struct netif *netif, struct eth_addr *ethaddr, struct pbuf *p)
{
  8098ab:	f3 0f 1e fb          	endbr32 
  8098af:	55                   	push   %ebp
  8098b0:	89 e5                	mov    %esp,%ebp
  8098b2:	57                   	push   %edi
  8098b3:	56                   	push   %esi
  8098b4:	53                   	push   %ebx
  8098b5:	83 ec 1c             	sub    $0x1c,%esp
  8098b8:	8b 5d 10             	mov    0x10(%ebp),%ebx
  u8_t for_us;
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  8098bb:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  8098bf:	74 4d                	je     80990e <etharp_arp_input+0x63>
  
  /* drop short ARP packets: we have to check for p->len instead of p->tot_len here
     since a struct etharp_hdr is pointed to p->payload, so it musn't be chained! */
  if (p->len < sizeof(struct etharp_hdr)) {
  8098c1:	66 83 7b 0a 29       	cmpw   $0x29,0xa(%ebx)
  8098c6:	76 5d                	jbe    809925 <etharp_arp_input+0x7a>
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
    return;
  }

  hdr = p->payload;
  8098c8:	8b 73 04             	mov    0x4(%ebx),%esi

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
  8098cb:	0f b7 7e 0e          	movzwl 0xe(%esi),%edi
  8098cf:	83 ec 0c             	sub    $0xc,%esp
  8098d2:	6a 01                	push   $0x1
  8098d4:	e8 80 e0 ff ff       	call   807959 <htons>
  8098d9:	83 c4 10             	add    $0x10,%esp
  8098dc:	66 39 c7             	cmp    %ax,%di
  8098df:	75 19                	jne    8098fa <etharp_arp_input+0x4f>
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
  8098e1:	0f b7 7e 12          	movzwl 0x12(%esi),%edi
  8098e5:	83 ec 0c             	sub    $0xc,%esp
  8098e8:	68 04 06 00 00       	push   $0x604
  8098ed:	e8 67 e0 ff ff       	call   807959 <htons>
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
  8098f2:	83 c4 10             	add    $0x10,%esp
  8098f5:	66 39 c7             	cmp    %ax,%di
  8098f8:	74 39                	je     809933 <etharp_arp_input+0x88>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 1,
      ("etharp_arp_input: packet dropped, wrong hw type, hwlen, proto, protolen or ethernet type (%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F")\n",
      hdr->hwtype, ARPH_HWLEN(hdr), hdr->proto, ARPH_PROTOLEN(hdr), hdr->ethhdr.type));
    ETHARP_STATS_INC(etharp.proterr);
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
  8098fa:	83 ec 0c             	sub    $0xc,%esp
  8098fd:	53                   	push   %ebx
  8098fe:	e8 1e b1 ff ff       	call   804a21 <pbuf_free>
    return;
  809903:	83 c4 10             	add    $0x10,%esp
    ETHARP_STATS_INC(etharp.err);
    break;
  }
  /* free ARP packet */
  pbuf_free(p);
}
  809906:	8d 65 f4             	lea    -0xc(%ebp),%esp
  809909:	5b                   	pop    %ebx
  80990a:	5e                   	pop    %esi
  80990b:	5f                   	pop    %edi
  80990c:	5d                   	pop    %ebp
  80990d:	c3                   	ret    
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  80990e:	83 ec 04             	sub    $0x4,%esp
  809911:	68 82 1b 81 00       	push   $0x811b82
  809916:	68 75 02 00 00       	push   $0x275
  80991b:	68 fa 27 81 00       	push   $0x8127fa
  809920:	e8 22 50 00 00       	call   80e947 <_panic>
    pbuf_free(p);
  809925:	83 ec 0c             	sub    $0xc,%esp
  809928:	53                   	push   %ebx
  809929:	e8 f3 b0 ff ff       	call   804a21 <pbuf_free>
    return;
  80992e:	83 c4 10             	add    $0x10,%esp
  809931:	eb d3                	jmp    809906 <etharp_arp_input+0x5b>
      (hdr->proto != htons(ETHTYPE_IP)) ||
  809933:	0f b7 7e 10          	movzwl 0x10(%esi),%edi
  809937:	83 ec 0c             	sub    $0xc,%esp
  80993a:	68 00 08 00 00       	push   $0x800
  80993f:	e8 15 e0 ff ff       	call   807959 <htons>
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
  809944:	83 c4 10             	add    $0x10,%esp
  809947:	66 39 c7             	cmp    %ax,%di
  80994a:	75 ae                	jne    8098fa <etharp_arp_input+0x4f>
      (hdr->ethhdr.type != htons(ETHTYPE_ARP)))  {
  80994c:	0f b7 7e 0c          	movzwl 0xc(%esi),%edi
  809950:	83 ec 0c             	sub    $0xc,%esp
  809953:	68 06 08 00 00       	push   $0x806
  809958:	e8 fc df ff ff       	call   807959 <htons>
      (hdr->proto != htons(ETHTYPE_IP)) ||
  80995d:	83 c4 10             	add    $0x10,%esp
  809960:	66 39 c7             	cmp    %ax,%di
  809963:	75 95                	jne    8098fa <etharp_arp_input+0x4f>
  SMEMCPY(&sipaddr, &hdr->sipaddr, sizeof(sipaddr));
  809965:	83 ec 04             	sub    $0x4,%esp
  809968:	6a 04                	push   $0x4
  80996a:	8d 46 1c             	lea    0x1c(%esi),%eax
  80996d:	50                   	push   %eax
  80996e:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  809971:	50                   	push   %eax
  809972:	e8 dd 58 00 00       	call   80f254 <memcpy>
  SMEMCPY(&dipaddr, &hdr->dipaddr, sizeof(dipaddr));
  809977:	83 c4 0c             	add    $0xc,%esp
  80997a:	6a 04                	push   $0x4
  80997c:	8d 46 26             	lea    0x26(%esi),%eax
  80997f:	50                   	push   %eax
  809980:	8d 45 e0             	lea    -0x20(%ebp),%eax
  809983:	50                   	push   %eax
  809984:	e8 cb 58 00 00       	call   80f254 <memcpy>
  if (netif->ip_addr.addr == 0) {
  809989:	8b 45 08             	mov    0x8(%ebp),%eax
  80998c:	8b 40 04             	mov    0x4(%eax),%eax
  80998f:	83 c4 10             	add    $0x10,%esp
  809992:	85 c0                	test   %eax,%eax
  809994:	74 05                	je     80999b <etharp_arp_input+0xf0>
  if (for_us) {
  809996:	3b 45 e0             	cmp    -0x20(%ebp),%eax
  809999:	74 3f                	je     8099da <etharp_arp_input+0x12f>
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), 0);
  80999b:	8d 4e 16             	lea    0x16(%esi),%ecx
  80999e:	83 ec 0c             	sub    $0xc,%esp
  8099a1:	6a 00                	push   $0x0
  8099a3:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  8099a6:	8b 45 08             	mov    0x8(%ebp),%eax
  8099a9:	e8 ad fc ff ff       	call   80965b <update_arp_entry>
  switch (htons(hdr->opcode)) {
  8099ae:	0f b7 46 14          	movzwl 0x14(%esi),%eax
  8099b2:	89 04 24             	mov    %eax,(%esp)
  8099b5:	e8 9f df ff ff       	call   807959 <htons>
  8099ba:	83 c4 10             	add    $0x10,%esp
  8099bd:	66 83 f8 01          	cmp    $0x1,%ax
  8099c1:	74 06                	je     8099c9 <etharp_arp_input+0x11e>
  8099c3:	66 83 f8 02          	cmp    $0x2,%ax
  8099c7:	74 3f                	je     809a08 <etharp_arp_input+0x15d>
  pbuf_free(p);
  8099c9:	83 ec 0c             	sub    $0xc,%esp
  8099cc:	53                   	push   %ebx
  8099cd:	e8 4f b0 ff ff       	call   804a21 <pbuf_free>
  8099d2:	83 c4 10             	add    $0x10,%esp
  8099d5:	e9 2c ff ff ff       	jmp    809906 <etharp_arp_input+0x5b>
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), ETHARP_TRY_HARD);
  8099da:	8d 4e 16             	lea    0x16(%esi),%ecx
  8099dd:	83 ec 0c             	sub    $0xc,%esp
  8099e0:	6a 01                	push   $0x1
  8099e2:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  8099e5:	8b 45 08             	mov    0x8(%ebp),%eax
  8099e8:	e8 6e fc ff ff       	call   80965b <update_arp_entry>
  switch (htons(hdr->opcode)) {
  8099ed:	0f b7 46 14          	movzwl 0x14(%esi),%eax
  8099f1:	89 04 24             	mov    %eax,(%esp)
  8099f4:	e8 60 df ff ff       	call   807959 <htons>
  8099f9:	83 c4 10             	add    $0x10,%esp
  8099fc:	66 83 f8 01          	cmp    $0x1,%ax
  809a00:	74 1a                	je     809a1c <etharp_arp_input+0x171>
  809a02:	66 83 f8 02          	cmp    $0x2,%ax
  809a06:	75 c1                	jne    8099c9 <etharp_arp_input+0x11e>
    dhcp_arp_reply(netif, &sipaddr);
  809a08:	83 ec 08             	sub    $0x8,%esp
  809a0b:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  809a0e:	50                   	push   %eax
  809a0f:	ff 75 08             	pushl  0x8(%ebp)
  809a12:	e8 48 a0 ff ff       	call   803a5f <dhcp_arp_reply>
    break;
  809a17:	83 c4 10             	add    $0x10,%esp
  809a1a:	eb ad                	jmp    8099c9 <etharp_arp_input+0x11e>
      hdr->opcode = htons(ARP_REPLY);
  809a1c:	83 ec 0c             	sub    $0xc,%esp
  809a1f:	6a 02                	push   $0x2
  809a21:	e8 33 df ff ff       	call   807959 <htons>
  809a26:	66 89 46 14          	mov    %ax,0x14(%esi)
      hdr->dipaddr = hdr->sipaddr;
  809a2a:	8b 46 1c             	mov    0x1c(%esi),%eax
  809a2d:	89 46 26             	mov    %eax,0x26(%esi)
      hdr->sipaddr = *(struct ip_addr2 *)&netif->ip_addr;
  809a30:	8b 45 08             	mov    0x8(%ebp),%eax
  809a33:	8b 40 04             	mov    0x4(%eax),%eax
  809a36:	89 46 1c             	mov    %eax,0x1c(%esi)
      LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  809a39:	83 c4 10             	add    $0x10,%esp
  809a3c:	8b 45 08             	mov    0x8(%ebp),%eax
  809a3f:	80 78 24 06          	cmpb   $0x6,0x24(%eax)
  809a43:	75 3e                	jne    809a83 <etharp_arp_input+0x1d8>
  809a45:	8d 46 05             	lea    0x5(%esi),%eax
  809a48:	8b 55 0c             	mov    0xc(%ebp),%edx
  809a4b:	83 c2 05             	add    $0x5,%edx
  809a4e:	89 f7                	mov    %esi,%edi
  809a50:	89 c6                	mov    %eax,%esi
        hdr->dhwaddr.addr[i] = hdr->shwaddr.addr[i];
  809a52:	0f b6 48 16          	movzbl 0x16(%eax),%ecx
  809a56:	88 48 20             	mov    %cl,0x20(%eax)
        hdr->ethhdr.dest.addr[i] = hdr->shwaddr.addr[i];
  809a59:	88 08                	mov    %cl,(%eax)
        hdr->shwaddr.addr[i] = ethaddr->addr[i];
  809a5b:	0f b6 0a             	movzbl (%edx),%ecx
  809a5e:	88 48 16             	mov    %cl,0x16(%eax)
        hdr->ethhdr.src.addr[i] = ethaddr->addr[i];
  809a61:	88 48 06             	mov    %cl,0x6(%eax)
  809a64:	83 e8 01             	sub    $0x1,%eax
  809a67:	83 ea 01             	sub    $0x1,%edx
      while(i > 0) {
  809a6a:	39 fe                	cmp    %edi,%esi
  809a6c:	75 e2                	jne    809a50 <etharp_arp_input+0x1a5>
      netif->linkoutput(netif, p);
  809a6e:	83 ec 08             	sub    $0x8,%esp
  809a71:	53                   	push   %ebx
  809a72:	ff 75 08             	pushl  0x8(%ebp)
  809a75:	8b 45 08             	mov    0x8(%ebp),%eax
  809a78:	ff 50 18             	call   *0x18(%eax)
  809a7b:	83 c4 10             	add    $0x10,%esp
  809a7e:	e9 46 ff ff ff       	jmp    8099c9 <etharp_arp_input+0x11e>
      LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  809a83:	83 ec 04             	sub    $0x4,%esp
  809a86:	68 70 28 81 00       	push   $0x812870
  809a8b:	68 c6 02 00 00       	push   $0x2c6
  809a90:	68 fa 27 81 00       	push   $0x8127fa
  809a95:	e8 ad 4e 00 00       	call   80e947 <_panic>

00809a9a <etharp_request>:
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
err_t
etharp_request(struct netif *netif, struct ip_addr *ipaddr)
{
  809a9a:	f3 0f 1e fb          	endbr32 
  809a9e:	55                   	push   %ebp
  809a9f:	89 e5                	mov    %esp,%ebp
  809aa1:	57                   	push   %edi
  809aa2:	56                   	push   %esi
  809aa3:	53                   	push   %ebx
  809aa4:	83 ec 10             	sub    $0x10,%esp
  809aa7:	8b 7d 08             	mov    0x8(%ebp),%edi
  p = pbuf_alloc(PBUF_LINK, sizeof(struct etharp_hdr), PBUF_RAM);
  809aaa:	6a 00                	push   $0x0
  809aac:	6a 2a                	push   $0x2a
  809aae:	6a 02                	push   $0x2
  809ab0:	e8 36 b0 ff ff       	call   804aeb <pbuf_alloc>
  if (p == NULL) {
  809ab5:	83 c4 10             	add    $0x10,%esp
  809ab8:	85 c0                	test   %eax,%eax
  809aba:	0f 84 f8 00 00 00    	je     809bb8 <etharp_request+0x11e>
  809ac0:	89 c6                	mov    %eax,%esi
  LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
  809ac2:	66 83 78 0a 29       	cmpw   $0x29,0xa(%eax)
  809ac7:	0f 86 bd 00 00 00    	jbe    809b8a <etharp_request+0xf0>
  hdr = p->payload;
  809acd:	8b 58 04             	mov    0x4(%eax),%ebx
  hdr->opcode = htons(opcode);
  809ad0:	83 ec 0c             	sub    $0xc,%esp
  809ad3:	6a 01                	push   $0x1
  809ad5:	e8 7f de ff ff       	call   807959 <htons>
  809ada:	66 89 43 14          	mov    %ax,0x14(%ebx)
  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  809ade:	83 c4 10             	add    $0x10,%esp
  809ae1:	80 7f 24 06          	cmpb   $0x6,0x24(%edi)
  809ae5:	0f 85 b6 00 00 00    	jne    809ba1 <etharp_request+0x107>
  809aeb:	b8 05 00 00 00       	mov    $0x5,%eax
    hdr->shwaddr.addr[k] = hwsrc_addr->addr[k];
  809af0:	0f b6 54 07 25       	movzbl 0x25(%edi,%eax,1),%edx
  809af5:	88 54 03 16          	mov    %dl,0x16(%ebx,%eax,1)
    hdr->dhwaddr.addr[k] = hwdst_addr->addr[k];
  809af9:	0f b6 90 5c 29 81 00 	movzbl 0x81295c(%eax),%edx
  809b00:	88 54 03 20          	mov    %dl,0x20(%ebx,%eax,1)
    hdr->ethhdr.dest.addr[k] = ethdst_addr->addr[k];
  809b04:	0f b6 90 64 29 81 00 	movzbl 0x812964(%eax),%edx
  809b0b:	88 14 03             	mov    %dl,(%ebx,%eax,1)
    hdr->ethhdr.src.addr[k]  = ethsrc_addr->addr[k];
  809b0e:	0f b6 54 07 25       	movzbl 0x25(%edi,%eax,1),%edx
  809b13:	88 54 03 06          	mov    %dl,0x6(%ebx,%eax,1)
  809b17:	83 e8 01             	sub    $0x1,%eax
  while(k > 0) {
  809b1a:	83 f8 ff             	cmp    $0xffffffff,%eax
  809b1d:	75 d1                	jne    809af0 <etharp_request+0x56>
  hdr->sipaddr = *(struct ip_addr2 *)ipsrc_addr;
  809b1f:	8b 47 04             	mov    0x4(%edi),%eax
  809b22:	89 43 1c             	mov    %eax,0x1c(%ebx)
  hdr->dipaddr = *(struct ip_addr2 *)ipdst_addr;
  809b25:	8b 45 0c             	mov    0xc(%ebp),%eax
  809b28:	8b 00                	mov    (%eax),%eax
  809b2a:	89 43 26             	mov    %eax,0x26(%ebx)
  hdr->hwtype = htons(HWTYPE_ETHERNET);
  809b2d:	83 ec 0c             	sub    $0xc,%esp
  809b30:	6a 01                	push   $0x1
  809b32:	e8 22 de ff ff       	call   807959 <htons>
  809b37:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  hdr->proto = htons(ETHTYPE_IP);
  809b3b:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  809b42:	e8 12 de ff ff       	call   807959 <htons>
  809b47:	66 89 43 10          	mov    %ax,0x10(%ebx)
  hdr->_hwlen_protolen = htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr));
  809b4b:	c7 04 24 04 06 00 00 	movl   $0x604,(%esp)
  809b52:	e8 02 de ff ff       	call   807959 <htons>
  809b57:	66 89 43 12          	mov    %ax,0x12(%ebx)
  hdr->ethhdr.type = htons(ETHTYPE_ARP);
  809b5b:	c7 04 24 06 08 00 00 	movl   $0x806,(%esp)
  809b62:	e8 f2 dd ff ff       	call   807959 <htons>
  809b67:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  result = netif->linkoutput(netif, p);
  809b6b:	83 c4 08             	add    $0x8,%esp
  809b6e:	56                   	push   %esi
  809b6f:	57                   	push   %edi
  809b70:	ff 57 18             	call   *0x18(%edi)
  809b73:	89 c3                	mov    %eax,%ebx
  pbuf_free(p);
  809b75:	89 34 24             	mov    %esi,(%esp)
  809b78:	e8 a4 ae ff ff       	call   804a21 <pbuf_free>
  return result;
  809b7d:	83 c4 10             	add    $0x10,%esp
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
                    (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
                    ipaddr, ARP_REQUEST);
}
  809b80:	89 d8                	mov    %ebx,%eax
  809b82:	8d 65 f4             	lea    -0xc(%ebp),%esp
  809b85:	5b                   	pop    %ebx
  809b86:	5e                   	pop    %esi
  809b87:	5f                   	pop    %edi
  809b88:	5d                   	pop    %ebp
  809b89:	c3                   	ret    
  LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
  809b8a:	83 ec 04             	sub    $0x4,%esp
  809b8d:	68 dc 28 81 00       	push   $0x8128dc
  809b92:	68 1b 04 00 00       	push   $0x41b
  809b97:	68 fa 27 81 00       	push   $0x8127fa
  809b9c:	e8 a6 4d 00 00       	call   80e947 <_panic>
  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  809ba1:	83 ec 04             	sub    $0x4,%esp
  809ba4:	68 70 28 81 00       	push   $0x812870
  809ba9:	68 22 04 00 00       	push   $0x422
  809bae:	68 fa 27 81 00       	push   $0x8127fa
  809bb3:	e8 8f 4d 00 00       	call   80e947 <_panic>
    return ERR_MEM;
  809bb8:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
  809bbd:	eb c1                	jmp    809b80 <etharp_request+0xe6>

00809bbf <etharp_query>:
{
  809bbf:	f3 0f 1e fb          	endbr32 
  809bc3:	55                   	push   %ebp
  809bc4:	89 e5                	mov    %esp,%ebp
  809bc6:	57                   	push   %edi
  809bc7:	56                   	push   %esi
  809bc8:	53                   	push   %ebx
  809bc9:	83 ec 14             	sub    $0x14,%esp
  809bcc:	8b 75 0c             	mov    0xc(%ebp),%esi
  if (ip_addr_isbroadcast(ipaddr, netif) ||
  809bcf:	ff 75 08             	pushl  0x8(%ebp)
  809bd2:	56                   	push   %esi
  809bd3:	e8 05 cb ff ff       	call   8066dd <ip_addr_isbroadcast>
  809bd8:	83 c4 10             	add    $0x10,%esp
  809bdb:	84 c0                	test   %al,%al
  809bdd:	0f 85 9f 01 00 00    	jne    809d82 <etharp_query+0x1c3>
      ip_addr_ismulticast(ipaddr) ||
  809be3:	8b 1e                	mov    (%esi),%ebx
  809be5:	83 ec 0c             	sub    $0xc,%esp
  809be8:	68 00 00 00 f0       	push   $0xf0000000
  809bed:	e8 b6 df ff ff       	call   807ba8 <ntohl>
  809bf2:	21 c3                	and    %eax,%ebx
  809bf4:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  809bfb:	e8 a8 df ff ff       	call   807ba8 <ntohl>
  809c00:	83 c4 10             	add    $0x10,%esp
  809c03:	39 c3                	cmp    %eax,%ebx
  809c05:	0f 84 81 01 00 00    	je     809d8c <etharp_query+0x1cd>
      ip_addr_isany(ipaddr)) {
  809c0b:	83 3e 00             	cmpl   $0x0,(%esi)
  809c0e:	0f 84 82 01 00 00    	je     809d96 <etharp_query+0x1d7>
  i = find_entry(ipaddr, ETHARP_TRY_HARD);
  809c14:	ba 01 00 00 00       	mov    $0x1,%edx
  809c19:	89 f0                	mov    %esi,%eax
  809c1b:	e8 4b f7 ff ff       	call   80936b <find_entry>
  809c20:	89 c3                	mov    %eax,%ebx
  if (i < 0) {
  809c22:	84 c0                	test   %al,%al
  809c24:	0f 88 76 01 00 00    	js     809da0 <etharp_query+0x1e1>
  if (arp_table[i].state == ETHARP_STATE_EMPTY) {
  809c2a:	0f be f8             	movsbl %al,%edi
  809c2d:	6b c7 1c             	imul   $0x1c,%edi,%eax
  809c30:	8b 80 30 4a b3 00    	mov    0xb34a30(%eax),%eax
  809c36:	85 c0                	test   %eax,%eax
  809c38:	75 26                	jne    809c60 <etharp_query+0xa1>
    arp_table[i].state = ETHARP_STATE_PENDING;
  809c3a:	6b c7 1c             	imul   $0x1c,%edi,%eax
  809c3d:	c7 80 30 4a b3 00 01 	movl   $0x1,0xb34a30(%eax)
  809c44:	00 00 00 
    result = etharp_request(netif, ipaddr);
  809c47:	83 ec 08             	sub    $0x8,%esp
  809c4a:	56                   	push   %esi
  809c4b:	ff 75 08             	pushl  0x8(%ebp)
  809c4e:	e8 47 fe ff ff       	call   809a9a <etharp_request>
  809c53:	89 c6                	mov    %eax,%esi
  if (q != NULL) {
  809c55:	83 c4 10             	add    $0x10,%esp
  809c58:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  809c5c:	74 2d                	je     809c8b <etharp_query+0xcc>
  809c5e:	eb 18                	jmp    809c78 <etharp_query+0xb9>
  LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
  809c60:	8d 50 ff             	lea    -0x1(%eax),%edx
  809c63:	83 fa 01             	cmp    $0x1,%edx
  809c66:	77 2d                	ja     809c95 <etharp_query+0xd6>
  if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
  809c68:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  809c6c:	74 d9                	je     809c47 <etharp_query+0x88>
  809c6e:	83 f8 01             	cmp    $0x1,%eax
  809c71:	74 d4                	je     809c47 <etharp_query+0x88>
  err_t result = ERR_MEM;
  809c73:	be ff ff ff ff       	mov    $0xffffffff,%esi
    if (arp_table[i].state == ETHARP_STATE_STABLE) {
  809c78:	6b c7 1c             	imul   $0x1c,%edi,%eax
  809c7b:	8b 80 30 4a b3 00    	mov    0xb34a30(%eax),%eax
  809c81:	83 f8 02             	cmp    $0x2,%eax
  809c84:	74 26                	je     809cac <etharp_query+0xed>
    } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
  809c86:	83 f8 01             	cmp    $0x1,%eax
  809c89:	74 48                	je     809cd3 <etharp_query+0x114>
}
  809c8b:	89 f0                	mov    %esi,%eax
  809c8d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  809c90:	5b                   	pop    %ebx
  809c91:	5e                   	pop    %esi
  809c92:	5f                   	pop    %edi
  809c93:	5d                   	pop    %ebp
  809c94:	c3                   	ret    
  LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
  809c95:	83 ec 04             	sub    $0x4,%esp
  809c98:	68 10 29 81 00       	push   $0x812910
  809c9d:	68 90 03 00 00       	push   $0x390
  809ca2:	68 fa 27 81 00       	push   $0x8127fa
  809ca7:	e8 9b 4c 00 00       	call   80e947 <_panic>
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  809cac:	8b 45 08             	mov    0x8(%ebp),%eax
  809caf:	8d 48 25             	lea    0x25(%eax),%ecx
      result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
  809cb2:	83 ec 0c             	sub    $0xc,%esp
  809cb5:	0f be c3             	movsbl %bl,%eax
  809cb8:	6b c0 1c             	imul   $0x1c,%eax,%eax
  809cbb:	05 28 4a b3 00       	add    $0xb34a28,%eax
  809cc0:	50                   	push   %eax
  809cc1:	8b 55 10             	mov    0x10(%ebp),%edx
  809cc4:	8b 45 08             	mov    0x8(%ebp),%eax
  809cc7:	e8 1c f9 ff ff       	call   8095e8 <etharp_send_ip>
  809ccc:	89 c6                	mov    %eax,%esi
  809cce:	83 c4 10             	add    $0x10,%esp
  809cd1:	eb b8                	jmp    809c8b <etharp_query+0xcc>
      p = q;
  809cd3:	8b 45 10             	mov    0x10(%ebp),%eax
  809cd6:	eb 27                	jmp    809cff <etharp_query+0x140>
        LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
  809cd8:	83 ec 04             	sub    $0x4,%esp
  809cdb:	68 56 28 81 00       	push   $0x812856
  809ce0:	68 b1 03 00 00       	push   $0x3b1
  809ce5:	68 fa 27 81 00       	push   $0x8127fa
  809cea:	e8 58 4c 00 00       	call   80e947 <_panic>
        if(p->type != PBUF_ROM) {
  809cef:	80 78 0c 01          	cmpb   $0x1,0xc(%eax)
  809cf3:	75 23                	jne    809d18 <etharp_query+0x159>
        p = p->next;
  809cf5:	8b 00                	mov    (%eax),%eax
      while (p) {
  809cf7:	85 c0                	test   %eax,%eax
  809cf9:	0f 84 a8 00 00 00    	je     809da7 <etharp_query+0x1e8>
        LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
  809cff:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  809d03:	66 39 50 0a          	cmp    %dx,0xa(%eax)
  809d07:	75 e6                	jne    809cef <etharp_query+0x130>
  809d09:	83 38 00             	cmpl   $0x0,(%eax)
  809d0c:	75 ca                	jne    809cd8 <etharp_query+0x119>
        if(p->type != PBUF_ROM) {
  809d0e:	80 78 0c 01          	cmpb   $0x1,0xc(%eax)
  809d12:	0f 84 8f 00 00 00    	je     809da7 <etharp_query+0x1e8>
        p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  809d18:	83 ec 04             	sub    $0x4,%esp
  809d1b:	6a 00                	push   $0x0
  809d1d:	0f b7 d2             	movzwl %dx,%edx
  809d20:	52                   	push   %edx
  809d21:	6a 03                	push   $0x3
  809d23:	e8 c3 ad ff ff       	call   804aeb <pbuf_alloc>
  809d28:	89 c3                	mov    %eax,%ebx
        if(p != NULL) {
  809d2a:	83 c4 10             	add    $0x10,%esp
  809d2d:	85 c0                	test   %eax,%eax
  809d2f:	0f 84 56 ff ff ff    	je     809c8b <etharp_query+0xcc>
          if (pbuf_copy(p, q) != ERR_OK) {
  809d35:	83 ec 08             	sub    $0x8,%esp
  809d38:	ff 75 10             	pushl  0x10(%ebp)
  809d3b:	53                   	push   %ebx
  809d3c:	e8 91 b2 ff ff       	call   804fd2 <pbuf_copy>
  809d41:	83 c4 10             	add    $0x10,%esp
        p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  809d44:	89 5d 10             	mov    %ebx,0x10(%ebp)
          if (pbuf_copy(p, q) != ERR_OK) {
  809d47:	84 c0                	test   %al,%al
  809d49:	74 6a                	je     809db5 <etharp_query+0x1f6>
            pbuf_free(p);
  809d4b:	83 ec 0c             	sub    $0xc,%esp
  809d4e:	53                   	push   %ebx
  809d4f:	e8 cd ac ff ff       	call   804a21 <pbuf_free>
  809d54:	83 c4 10             	add    $0x10,%esp
  809d57:	e9 2f ff ff ff       	jmp    809c8b <etharp_query+0xcc>
            arp_table[i].q = new_entry;
  809d5c:	6b ff 1c             	imul   $0x1c,%edi,%edi
  809d5f:	89 87 20 4a b3 00    	mov    %eax,0xb34a20(%edi)
          result = ERR_OK;
  809d65:	be 00 00 00 00       	mov    $0x0,%esi
  809d6a:	e9 1c ff ff ff       	jmp    809c8b <etharp_query+0xcc>
          pbuf_free(p);
  809d6f:	83 ec 0c             	sub    $0xc,%esp
  809d72:	ff 75 10             	pushl  0x10(%ebp)
  809d75:	e8 a7 ac ff ff       	call   804a21 <pbuf_free>
  809d7a:	83 c4 10             	add    $0x10,%esp
  809d7d:	e9 09 ff ff ff       	jmp    809c8b <etharp_query+0xcc>
    return ERR_ARG;
  809d82:	be f6 ff ff ff       	mov    $0xfffffff6,%esi
  809d87:	e9 ff fe ff ff       	jmp    809c8b <etharp_query+0xcc>
  809d8c:	be f6 ff ff ff       	mov    $0xfffffff6,%esi
  809d91:	e9 f5 fe ff ff       	jmp    809c8b <etharp_query+0xcc>
  809d96:	be f6 ff ff ff       	mov    $0xfffffff6,%esi
  809d9b:	e9 eb fe ff ff       	jmp    809c8b <etharp_query+0xcc>
    return (err_t)i;
  809da0:	89 c6                	mov    %eax,%esi
  809da2:	e9 e4 fe ff ff       	jmp    809c8b <etharp_query+0xcc>
        pbuf_ref(p);
  809da7:	83 ec 0c             	sub    $0xc,%esp
  809daa:	ff 75 10             	pushl  0x10(%ebp)
  809dad:	e8 cc b0 ff ff       	call   804e7e <pbuf_ref>
  809db2:	83 c4 10             	add    $0x10,%esp
        new_entry = memp_malloc(MEMP_ARP_QUEUE);
  809db5:	83 ec 0c             	sub    $0xc,%esp
  809db8:	6a 0a                	push   $0xa
  809dba:	e8 85 a8 ff ff       	call   804644 <memp_malloc>
        if (new_entry != NULL) {
  809dbf:	83 c4 10             	add    $0x10,%esp
  809dc2:	85 c0                	test   %eax,%eax
  809dc4:	74 a9                	je     809d6f <etharp_query+0x1b0>
          new_entry->next = 0;
  809dc6:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
          new_entry->p = p;
  809dcc:	8b 4d 10             	mov    0x10(%ebp),%ecx
  809dcf:	89 48 04             	mov    %ecx,0x4(%eax)
          if(arp_table[i].q != NULL) {
  809dd2:	6b d7 1c             	imul   $0x1c,%edi,%edx
  809dd5:	8b 92 20 4a b3 00    	mov    0xb34a20(%edx),%edx
  809ddb:	85 d2                	test   %edx,%edx
  809ddd:	0f 84 79 ff ff ff    	je     809d5c <etharp_query+0x19d>
  809de3:	89 d1                	mov    %edx,%ecx
            while (r->next != NULL) {
  809de5:	8b 12                	mov    (%edx),%edx
  809de7:	85 d2                	test   %edx,%edx
  809de9:	75 f8                	jne    809de3 <etharp_query+0x224>
            r->next = new_entry;
  809deb:	89 01                	mov    %eax,(%ecx)
          result = ERR_OK;
  809ded:	be 00 00 00 00       	mov    $0x0,%esi
  809df2:	e9 94 fe ff ff       	jmp    809c8b <etharp_query+0xcc>

00809df7 <etharp_output>:
{
  809df7:	f3 0f 1e fb          	endbr32 
  809dfb:	55                   	push   %ebp
  809dfc:	89 e5                	mov    %esp,%ebp
  809dfe:	57                   	push   %edi
  809dff:	56                   	push   %esi
  809e00:	53                   	push   %ebx
  809e01:	83 ec 24             	sub    $0x24,%esp
  809e04:	8b 5d 08             	mov    0x8(%ebp),%ebx
  809e07:	8b 75 10             	mov    0x10(%ebp),%esi
  if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
  809e0a:	6a 0e                	push   $0xe
  809e0c:	ff 75 0c             	pushl  0xc(%ebp)
  809e0f:	e8 3a ab ff ff       	call   80494e <pbuf_header>
  809e14:	83 c4 10             	add    $0x10,%esp
  809e17:	84 c0                	test   %al,%al
  809e19:	0f 85 c0 00 00 00    	jne    809edf <etharp_output+0xe8>
  if (ip_addr_isbroadcast(ipaddr, netif)) {
  809e1f:	83 ec 08             	sub    $0x8,%esp
  809e22:	53                   	push   %ebx
  809e23:	56                   	push   %esi
  809e24:	e8 b4 c8 ff ff       	call   8066dd <ip_addr_isbroadcast>
  809e29:	83 c4 10             	add    $0x10,%esp
  809e2c:	84 c0                	test   %al,%al
  809e2e:	0f 85 8a 00 00 00    	jne    809ebe <etharp_output+0xc7>
  } else if (ip_addr_ismulticast(ipaddr)) {
  809e34:	8b 3e                	mov    (%esi),%edi
  809e36:	83 ec 0c             	sub    $0xc,%esp
  809e39:	68 00 00 00 f0       	push   $0xf0000000
  809e3e:	e8 65 dd ff ff       	call   807ba8 <ntohl>
  809e43:	21 c7                	and    %eax,%edi
  809e45:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  809e4c:	e8 57 dd ff ff       	call   807ba8 <ntohl>
  809e51:	83 c4 10             	add    $0x10,%esp
  809e54:	39 c7                	cmp    %eax,%edi
  809e56:	74 25                	je     809e7d <etharp_output+0x86>
    if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask))) {
  809e58:	8b 06                	mov    (%esi),%eax
  809e5a:	33 43 04             	xor    0x4(%ebx),%eax
  809e5d:	85 43 08             	test   %eax,0x8(%ebx)
  809e60:	74 09                	je     809e6b <etharp_output+0x74>
      if (netif->gw.addr != 0) {
  809e62:	83 7b 0c 00          	cmpl   $0x0,0xc(%ebx)
  809e66:	74 7e                	je     809ee6 <etharp_output+0xef>
        ipaddr = &(netif->gw);
  809e68:	8d 73 0c             	lea    0xc(%ebx),%esi
    return etharp_query(netif, ipaddr, q);
  809e6b:	83 ec 04             	sub    $0x4,%esp
  809e6e:	ff 75 0c             	pushl  0xc(%ebp)
  809e71:	56                   	push   %esi
  809e72:	53                   	push   %ebx
  809e73:	e8 47 fd ff ff       	call   809bbf <etharp_query>
  809e78:	83 c4 10             	add    $0x10,%esp
  809e7b:	eb 5a                	jmp    809ed7 <etharp_output+0xe0>
    mcastaddr.addr[0] = 0x01;
  809e7d:	c6 45 e2 01          	movb   $0x1,-0x1e(%ebp)
    mcastaddr.addr[1] = 0x00;
  809e81:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
    mcastaddr.addr[2] = 0x5e;
  809e85:	c6 45 e4 5e          	movb   $0x5e,-0x1c(%ebp)
    mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
  809e89:	83 ec 0c             	sub    $0xc,%esp
  809e8c:	ff 36                	pushl  (%esi)
  809e8e:	e8 15 dd ff ff       	call   807ba8 <ntohl>
  809e93:	c1 e8 10             	shr    $0x10,%eax
  809e96:	83 e0 7f             	and    $0x7f,%eax
  809e99:	88 45 e5             	mov    %al,-0x1b(%ebp)
    mcastaddr.addr[4] = ip4_addr3(ipaddr);
  809e9c:	83 c4 04             	add    $0x4,%esp
  809e9f:	ff 36                	pushl  (%esi)
  809ea1:	e8 02 dd ff ff       	call   807ba8 <ntohl>
  809ea6:	88 65 e6             	mov    %ah,-0x1a(%ebp)
    mcastaddr.addr[5] = ip4_addr4(ipaddr);
  809ea9:	83 c4 04             	add    $0x4,%esp
  809eac:	ff 36                	pushl  (%esi)
  809eae:	e8 f5 dc ff ff       	call   807ba8 <ntohl>
  809eb3:	88 45 e7             	mov    %al,-0x19(%ebp)
  809eb6:	83 c4 10             	add    $0x10,%esp
    dest = &mcastaddr;
  809eb9:	8d 45 e2             	lea    -0x1e(%ebp),%eax
  809ebc:	eb 05                	jmp    809ec3 <etharp_output+0xcc>
    dest = (struct eth_addr *)&ethbroadcast;
  809ebe:	b8 64 29 81 00       	mov    $0x812964,%eax
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
  809ec3:	8d 4b 25             	lea    0x25(%ebx),%ecx
  809ec6:	83 ec 0c             	sub    $0xc,%esp
  809ec9:	50                   	push   %eax
  809eca:	8b 55 0c             	mov    0xc(%ebp),%edx
  809ecd:	89 d8                	mov    %ebx,%eax
  809ecf:	e8 14 f7 ff ff       	call   8095e8 <etharp_send_ip>
  809ed4:	83 c4 10             	add    $0x10,%esp
}
  809ed7:	8d 65 f4             	lea    -0xc(%ebp),%esp
  809eda:	5b                   	pop    %ebx
  809edb:	5e                   	pop    %esi
  809edc:	5f                   	pop    %edi
  809edd:	5d                   	pop    %ebp
  809ede:	c3                   	ret    
    return ERR_BUF;
  809edf:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  809ee4:	eb f1                	jmp    809ed7 <etharp_output+0xe0>
        return ERR_RTE;
  809ee6:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  809eeb:	eb ea                	jmp    809ed7 <etharp_output+0xe0>

00809eed <ethernet_input>:
 * @param p the recevied packet, p->payload pointing to the ethernet header
 * @param netif the network interface on which the packet was received
 */
err_t
ethernet_input(struct pbuf *p, struct netif *netif)
{
  809eed:	f3 0f 1e fb          	endbr32 
  809ef1:	55                   	push   %ebp
  809ef2:	89 e5                	mov    %esp,%ebp
  809ef4:	56                   	push   %esi
  809ef5:	53                   	push   %ebx
  809ef6:	8b 5d 08             	mov    0x8(%ebp),%ebx
  809ef9:	8b 75 0c             	mov    0xc(%ebp),%esi
     (unsigned)ethhdr->dest.addr[3], (unsigned)ethhdr->dest.addr[4], (unsigned)ethhdr->dest.addr[5],
     (unsigned)ethhdr->src.addr[0], (unsigned)ethhdr->src.addr[1], (unsigned)ethhdr->src.addr[2],
     (unsigned)ethhdr->src.addr[3], (unsigned)ethhdr->src.addr[4], (unsigned)ethhdr->src.addr[5],
     (unsigned)htons(ethhdr->type)));

  switch (htons(ethhdr->type)) {
  809efc:	83 ec 0c             	sub    $0xc,%esp
  809eff:	8b 43 04             	mov    0x4(%ebx),%eax
  809f02:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  809f06:	50                   	push   %eax
  809f07:	e8 4d da ff ff       	call   807959 <htons>
  809f0c:	83 c4 10             	add    $0x10,%esp
  809f0f:	66 3d 00 08          	cmp    $0x800,%ax
  809f13:	74 14                	je     809f29 <ethernet_input+0x3c>
  809f15:	66 3d 06 08          	cmp    $0x806,%ax
  809f19:	74 50                	je     809f6b <ethernet_input+0x7e>
#endif /* PPPOE_SUPPORT */

    default:
      ETHARP_STATS_INC(etharp.proterr);
      ETHARP_STATS_INC(etharp.drop);
      pbuf_free(p);
  809f1b:	83 ec 0c             	sub    $0xc,%esp
  809f1e:	53                   	push   %ebx
  809f1f:	e8 fd aa ff ff       	call   804a21 <pbuf_free>
      p = NULL;
      break;
  809f24:	83 c4 10             	add    $0x10,%esp
  809f27:	eb 53                	jmp    809f7c <ethernet_input+0x8f>
      etharp_ip_input(netif, p);
  809f29:	83 ec 08             	sub    $0x8,%esp
  809f2c:	53                   	push   %ebx
  809f2d:	56                   	push   %esi
  809f2e:	e8 28 f9 ff ff       	call   80985b <etharp_ip_input>
      if(pbuf_header(p, -(s16_t)sizeof(struct eth_hdr))) {
  809f33:	83 c4 08             	add    $0x8,%esp
  809f36:	6a f2                	push   $0xfffffff2
  809f38:	53                   	push   %ebx
  809f39:	e8 10 aa ff ff       	call   80494e <pbuf_header>
  809f3e:	83 c4 10             	add    $0x10,%esp
  809f41:	84 c0                	test   %al,%al
  809f43:	75 0f                	jne    809f54 <ethernet_input+0x67>
        ip_input(p, netif);
  809f45:	83 ec 08             	sub    $0x8,%esp
  809f48:	56                   	push   %esi
  809f49:	53                   	push   %ebx
  809f4a:	e8 36 c8 ff ff       	call   806785 <ip_input>
      break;
  809f4f:	83 c4 10             	add    $0x10,%esp
  809f52:	eb 28                	jmp    809f7c <ethernet_input+0x8f>
        LWIP_ASSERT("Can't move over header in packet", 0);
  809f54:	83 ec 04             	sub    $0x4,%esp
  809f57:	68 38 29 81 00       	push   $0x812938
  809f5c:	68 7e 04 00 00       	push   $0x47e
  809f61:	68 fa 27 81 00       	push   $0x8127fa
  809f66:	e8 dc 49 00 00       	call   80e947 <_panic>
      etharp_arp_input(netif, (struct eth_addr*)(netif->hwaddr), p);
  809f6b:	83 ec 04             	sub    $0x4,%esp
  809f6e:	53                   	push   %ebx
  809f6f:	8d 46 25             	lea    0x25(%esi),%eax
  809f72:	50                   	push   %eax
  809f73:	56                   	push   %esi
  809f74:	e8 32 f9 ff ff       	call   8098ab <etharp_arp_input>
      break;
  809f79:	83 c4 10             	add    $0x10,%esp
  }

  /* This means the pbuf is freed or consumed,
     so the caller doesn't have to free it again */
  return ERR_OK;
}
  809f7c:	b8 00 00 00 00       	mov    $0x0,%eax
  809f81:	8d 65 f8             	lea    -0x8(%ebp),%esp
  809f84:	5b                   	pop    %ebx
  809f85:	5e                   	pop    %esi
  809f86:	5d                   	pop    %ebp
  809f87:	c3                   	ret    

00809f88 <lwip_thread_entry>:
    void *arg;
};

static void
lwip_thread_entry(uint32_t arg)
{
  809f88:	f3 0f 1e fb          	endbr32 
  809f8c:	55                   	push   %ebp
  809f8d:	89 e5                	mov    %esp,%ebp
  809f8f:	53                   	push   %ebx
  809f90:	83 ec 10             	sub    $0x10,%esp
  809f93:	8b 5d 08             	mov    0x8(%ebp),%ebx
    struct lwip_thread *lt = (struct lwip_thread *)arg;
    lwip_core_lock();
    lt->func(lt->arg);
  809f96:	ff 73 04             	pushl  0x4(%ebx)
  809f99:	ff 13                	call   *(%ebx)
    lwip_core_unlock();
    free(lt);
  809f9b:	89 1c 24             	mov    %ebx,(%esp)
  809f9e:	e8 b1 68 00 00       	call   810854 <free>
}
  809fa3:	83 c4 10             	add    $0x10,%esp
  809fa6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  809fa9:	c9                   	leave  
  809faa:	c3                   	ret    

00809fab <timeout_cleanup>:
    return tid;
}

static void
timeout_cleanup(thread_id_t tid)
{
  809fab:	f3 0f 1e fb          	endbr32 
  809faf:	55                   	push   %ebp
  809fb0:	89 e5                	mov    %esp,%ebp
  809fb2:	83 ec 08             	sub    $0x8,%esp
  809fb5:	8b 4d 08             	mov    0x8(%ebp),%ecx
    lwip_core_lock();

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  809fb8:	ba 01 ff 00 ff       	mov    $0xff00ff01,%edx
  809fbd:	89 c8                	mov    %ecx,%eax
  809fbf:	f7 e2                	mul    %edx
  809fc1:	89 d0                	mov    %edx,%eax
  809fc3:	c1 e8 08             	shr    $0x8,%eax
  809fc6:	b2 00                	mov    $0x0,%dl
  809fc8:	01 c2                	add    %eax,%edx
  809fca:	89 c8                	mov    %ecx,%eax
  809fcc:	29 d0                	sub    %edx,%eax
  809fce:	8b 04 85 40 4b b3 00 	mov    0xb34b40(,%eax,4),%eax
  809fd5:	85 c0                	test   %eax,%eax
  809fd7:	74 2a                	je     80a003 <timeout_cleanup+0x58>
	if (t->tid == tid) {
  809fd9:	39 08                	cmp    %ecx,(%eax)
  809fdb:	74 05                	je     809fe2 <timeout_cleanup+0x37>
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  809fdd:	8b 40 08             	mov    0x8(%eax),%eax
  809fe0:	eb f3                	jmp    809fd5 <timeout_cleanup+0x2a>
	    LIST_REMOVE(t, link);
  809fe2:	8b 50 08             	mov    0x8(%eax),%edx
  809fe5:	85 d2                	test   %edx,%edx
  809fe7:	74 06                	je     809fef <timeout_cleanup+0x44>
  809fe9:	8b 48 0c             	mov    0xc(%eax),%ecx
  809fec:	89 4a 0c             	mov    %ecx,0xc(%edx)
  809fef:	8b 50 0c             	mov    0xc(%eax),%edx
  809ff2:	8b 48 08             	mov    0x8(%eax),%ecx
  809ff5:	89 0a                	mov    %ecx,(%edx)
	    free(t);
  809ff7:	83 ec 0c             	sub    $0xc,%esp
  809ffa:	50                   	push   %eax
  809ffb:	e8 54 68 00 00       	call   810854 <free>
	    goto done;
  80a000:	83 c4 10             	add    $0x10,%esp
	}

    if (debug) cprintf("timeout_cleanup: bogus tid %ld\n", tid);
 done:
    lwip_core_unlock();
}
  80a003:	c9                   	leave  
  80a004:	c3                   	ret    

0080a005 <sys_init>:
{
  80a005:	f3 0f 1e fb          	endbr32 
  80a009:	55                   	push   %ebp
  80a00a:	89 e5                	mov    %esp,%ebp
  80a00c:	56                   	push   %esi
  80a00d:	53                   	push   %ebx
  80a00e:	8b 0d 60 9d b3 00    	mov    0xb39d60,%ecx
  80a014:	b8 80 9d b3 00       	mov    $0xb39d80,%eax
  80a019:	be 80 b1 b3 00       	mov    $0xb3b180,%esi
  80a01e:	eb 0e                	jmp    80a02e <sys_init+0x29>
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
  80a020:	c7 41 10 60 9d b3 00 	movl   $0xb39d60,0x10(%ecx)
  80a027:	83 c0 14             	add    $0x14,%eax
    for (i = 0; i < NSEM; i++) {
  80a02a:	39 f0                	cmp    %esi,%eax
  80a02c:	74 19                	je     80a047 <sys_init+0x42>
  80a02e:	89 ca                	mov    %ecx,%edx
  80a030:	89 c1                	mov    %eax,%ecx
	sems[i].freed = 1;
  80a032:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
  80a038:	89 50 0c             	mov    %edx,0xc(%eax)
  80a03b:	85 d2                	test   %edx,%edx
  80a03d:	74 e1                	je     80a020 <sys_init+0x1b>
  80a03f:	8d 58 0c             	lea    0xc(%eax),%ebx
  80a042:	89 5a 10             	mov    %ebx,0x10(%edx)
  80a045:	eb d9                	jmp    80a020 <sys_init+0x1b>
  80a047:	c7 05 60 9d b3 00 6c 	movl   $0xb3b16c,0xb39d60
  80a04e:	b1 b3 00 
  80a051:	8b 0d 44 4f b3 00    	mov    0xb34f44,%ecx
  80a057:	b8 60 4f b3 00       	mov    $0xb34f60,%eax
  80a05c:	be 60 9d b3 00       	mov    $0xb39d60,%esi
  80a061:	eb 13                	jmp    80a076 <sys_init+0x71>
	LIST_INSERT_HEAD(&mbox_free, &mboxes[i], link);
  80a063:	c7 81 98 00 00 00 44 	movl   $0xb34f44,0x98(%ecx)
  80a06a:	4f b3 00 
  80a06d:	05 9c 00 00 00       	add    $0x9c,%eax
    for (i = 0; i < NMBOX; i++) {
  80a072:	39 f0                	cmp    %esi,%eax
  80a074:	74 22                	je     80a098 <sys_init+0x93>
  80a076:	89 ca                	mov    %ecx,%edx
  80a078:	89 c1                	mov    %eax,%ecx
	mboxes[i].freed = 1;
  80a07a:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
	LIST_INSERT_HEAD(&mbox_free, &mboxes[i], link);
  80a080:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
  80a086:	85 d2                	test   %edx,%edx
  80a088:	74 d9                	je     80a063 <sys_init+0x5e>
  80a08a:	8d 98 94 00 00 00    	lea    0x94(%eax),%ebx
  80a090:	89 9a 98 00 00 00    	mov    %ebx,0x98(%edx)
  80a096:	eb cb                	jmp    80a063 <sys_init+0x5e>
  80a098:	c7 05 44 4f b3 00 c4 	movl   $0xb39cc4,0xb34f44
  80a09f:	9c b3 00 
}
  80a0a2:	5b                   	pop    %ebx
  80a0a3:	5e                   	pop    %esi
  80a0a4:	5d                   	pop    %ebp
  80a0a5:	c3                   	ret    

0080a0a6 <sys_sem_new>:
{
  80a0a6:	f3 0f 1e fb          	endbr32 
  80a0aa:	55                   	push   %ebp
  80a0ab:	89 e5                	mov    %esp,%ebp
  80a0ad:	53                   	push   %ebx
  80a0ae:	83 ec 04             	sub    $0x4,%esp
  80a0b1:	8b 55 08             	mov    0x8(%ebp),%edx
    struct sys_sem_entry *se = LIST_FIRST(&sem_free);
  80a0b4:	a1 60 9d b3 00       	mov    0xb39d60,%eax
    if (!se) {
  80a0b9:	85 c0                	test   %eax,%eax
  80a0bb:	74 3e                	je     80a0fb <sys_sem_new+0x55>
    LIST_REMOVE(se, link);
  80a0bd:	8b 48 0c             	mov    0xc(%eax),%ecx
  80a0c0:	85 c9                	test   %ecx,%ecx
  80a0c2:	74 06                	je     80a0ca <sys_sem_new+0x24>
  80a0c4:	8b 58 10             	mov    0x10(%eax),%ebx
  80a0c7:	89 59 10             	mov    %ebx,0x10(%ecx)
  80a0ca:	8b 48 10             	mov    0x10(%eax),%ecx
  80a0cd:	8b 58 0c             	mov    0xc(%eax),%ebx
  80a0d0:	89 19                	mov    %ebx,(%ecx)
    assert(se->freed);
  80a0d2:	83 38 00             	cmpl   $0x0,(%eax)
  80a0d5:	74 3b                	je     80a112 <sys_sem_new+0x6c>
    se->freed = 0;
  80a0d7:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    se->counter = count;
  80a0dd:	0f b6 d2             	movzbl %dl,%edx
  80a0e0:	66 89 50 08          	mov    %dx,0x8(%eax)
    se->gen++;
  80a0e4:	83 40 04 01          	addl   $0x1,0x4(%eax)
    return se - &sems[0];
  80a0e8:	2d 80 9d b3 00       	sub    $0xb39d80,%eax
  80a0ed:	c1 f8 02             	sar    $0x2,%eax
  80a0f0:	69 c0 cd cc cc cc    	imul   $0xcccccccd,%eax,%eax
}
  80a0f6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80a0f9:	c9                   	leave  
  80a0fa:	c3                   	ret    
	cprintf("lwip: sys_sem_new: out of semaphores\n");
  80a0fb:	83 ec 0c             	sub    $0xc,%esp
  80a0fe:	68 6c 29 81 00       	push   $0x81296c
  80a103:	e8 26 49 00 00       	call   80ea2e <cprintf>
	return SYS_SEM_NULL;
  80a108:	83 c4 10             	add    $0x10,%esp
  80a10b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80a110:	eb e4                	jmp    80a0f6 <sys_sem_new+0x50>
    assert(se->freed);
  80a112:	68 e1 2a 81 00       	push   $0x812ae1
  80a117:	68 eb 2a 81 00       	push   $0x812aeb
  80a11c:	68 8d 00 00 00       	push   $0x8d
  80a121:	68 00 2b 81 00       	push   $0x812b00
  80a126:	e8 1c 48 00 00       	call   80e947 <_panic>

0080a12b <sys_sem_free>:
{
  80a12b:	f3 0f 1e fb          	endbr32 
  80a12f:	55                   	push   %ebp
  80a130:	89 e5                	mov    %esp,%ebp
  80a132:	83 ec 08             	sub    $0x8,%esp
  80a135:	8b 45 08             	mov    0x8(%ebp),%eax
    assert(!sems[sem].freed);
  80a138:	8d 14 80             	lea    (%eax,%eax,4),%edx
  80a13b:	83 3c 95 80 9d b3 00 	cmpl   $0x0,0xb39d80(,%edx,4)
  80a142:	00 
  80a143:	75 5a                	jne    80a19f <sys_sem_free+0x74>
    sems[sem].freed = 1;
  80a145:	8d 14 80             	lea    (%eax,%eax,4),%edx
  80a148:	c1 e2 02             	shl    $0x2,%edx
  80a14b:	c7 82 80 9d b3 00 01 	movl   $0x1,0xb39d80(%edx)
  80a152:	00 00 00 
    sems[sem].gen++;
  80a155:	83 82 84 9d b3 00 01 	addl   $0x1,0xb39d84(%edx)
    LIST_INSERT_HEAD(&sem_free, &sems[sem], link);
  80a15c:	8b 0d 60 9d b3 00    	mov    0xb39d60,%ecx
  80a162:	89 8a 8c 9d b3 00    	mov    %ecx,0xb39d8c(%edx)
  80a168:	85 c9                	test   %ecx,%ecx
  80a16a:	74 0d                	je     80a179 <sys_sem_free+0x4e>
  80a16c:	8d 14 80             	lea    (%eax,%eax,4),%edx
  80a16f:	8d 14 95 8c 9d b3 00 	lea    0xb39d8c(,%edx,4),%edx
  80a176:	89 51 10             	mov    %edx,0x10(%ecx)
  80a179:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  80a180:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  80a183:	8d 0c 8d 80 9d b3 00 	lea    0xb39d80(,%ecx,4),%ecx
  80a18a:	89 0d 60 9d b3 00    	mov    %ecx,0xb39d60
  80a190:	01 d0                	add    %edx,%eax
  80a192:	c7 04 85 90 9d b3 00 	movl   $0xb39d60,0xb39d90(,%eax,4)
  80a199:	60 9d b3 00 
}
  80a19d:	c9                   	leave  
  80a19e:	c3                   	ret    
    assert(!sems[sem].freed);
  80a19f:	68 1d 2b 81 00       	push   $0x812b1d
  80a1a4:	68 eb 2a 81 00       	push   $0x812aeb
  80a1a9:	68 98 00 00 00       	push   $0x98
  80a1ae:	68 00 2b 81 00       	push   $0x812b00
  80a1b3:	e8 8f 47 00 00       	call   80e947 <_panic>

0080a1b8 <sys_mbox_free>:
{
  80a1b8:	f3 0f 1e fb          	endbr32 
  80a1bc:	55                   	push   %ebp
  80a1bd:	89 e5                	mov    %esp,%ebp
  80a1bf:	56                   	push   %esi
  80a1c0:	53                   	push   %ebx
  80a1c1:	8b 5d 08             	mov    0x8(%ebp),%ebx
    assert(!mboxes[mbox].freed);
  80a1c4:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a1ca:	83 b8 60 4f b3 00 00 	cmpl   $0x0,0xb34f60(%eax)
  80a1d1:	75 72                	jne    80a245 <sys_mbox_free+0x8d>
    sys_sem_free(mboxes[mbox].queued_msg);
  80a1d3:	83 ec 0c             	sub    $0xc,%esp
  80a1d6:	69 f3 9c 00 00 00    	imul   $0x9c,%ebx,%esi
  80a1dc:	ff b6 ec 4f b3 00    	pushl  0xb34fec(%esi)
  80a1e2:	e8 44 ff ff ff       	call   80a12b <sys_sem_free>
    sys_sem_free(mboxes[mbox].free_msg);
  80a1e7:	83 c4 04             	add    $0x4,%esp
  80a1ea:	ff b6 f0 4f b3 00    	pushl  0xb34ff0(%esi)
  80a1f0:	e8 36 ff ff ff       	call   80a12b <sys_sem_free>
    LIST_INSERT_HEAD(&mbox_free, &mboxes[mbox], link);
  80a1f5:	a1 44 4f b3 00       	mov    0xb34f44,%eax
  80a1fa:	89 86 f4 4f b3 00    	mov    %eax,0xb34ff4(%esi)
  80a200:	83 c4 10             	add    $0x10,%esp
  80a203:	85 c0                	test   %eax,%eax
  80a205:	74 12                	je     80a219 <sys_mbox_free+0x61>
  80a207:	69 d3 9c 00 00 00    	imul   $0x9c,%ebx,%edx
  80a20d:	81 c2 f4 4f b3 00    	add    $0xb34ff4,%edx
  80a213:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
  80a219:	69 db 9c 00 00 00    	imul   $0x9c,%ebx,%ebx
  80a21f:	8d 83 60 4f b3 00    	lea    0xb34f60(%ebx),%eax
  80a225:	a3 44 4f b3 00       	mov    %eax,0xb34f44
  80a22a:	c7 83 f8 4f b3 00 44 	movl   $0xb34f44,0xb34ff8(%ebx)
  80a231:	4f b3 00 
    mboxes[mbox].freed = 1;
  80a234:	c7 83 60 4f b3 00 01 	movl   $0x1,0xb34f60(%ebx)
  80a23b:	00 00 00 
}
  80a23e:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80a241:	5b                   	pop    %ebx
  80a242:	5e                   	pop    %esi
  80a243:	5d                   	pop    %ebp
  80a244:	c3                   	ret    
    assert(!mboxes[mbox].freed);
  80a245:	68 2e 2b 81 00       	push   $0x812b2e
  80a24a:	68 eb 2a 81 00       	push   $0x812aeb
  80a24f:	6a 62                	push   $0x62
  80a251:	68 00 2b 81 00       	push   $0x812b00
  80a256:	e8 ec 46 00 00       	call   80e947 <_panic>

0080a25b <sys_mbox_new>:
{
  80a25b:	f3 0f 1e fb          	endbr32 
  80a25f:	55                   	push   %ebp
  80a260:	89 e5                	mov    %esp,%ebp
  80a262:	57                   	push   %edi
  80a263:	56                   	push   %esi
  80a264:	53                   	push   %ebx
  80a265:	83 ec 0c             	sub    $0xc,%esp
    assert(size < MBOXSLOTS);
  80a268:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
  80a26c:	0f 8f 9f 00 00 00    	jg     80a311 <sys_mbox_new+0xb6>
    struct sys_mbox_entry *mbe = LIST_FIRST(&mbox_free);
  80a272:	8b 1d 44 4f b3 00    	mov    0xb34f44,%ebx
    if (!mbe) {
  80a278:	85 db                	test   %ebx,%ebx
  80a27a:	0f 84 a7 00 00 00    	je     80a327 <sys_mbox_new+0xcc>
    LIST_REMOVE(mbe, link);
  80a280:	8b 83 94 00 00 00    	mov    0x94(%ebx),%eax
  80a286:	85 c0                	test   %eax,%eax
  80a288:	74 0c                	je     80a296 <sys_mbox_new+0x3b>
  80a28a:	8b 93 98 00 00 00    	mov    0x98(%ebx),%edx
  80a290:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
  80a296:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
  80a29c:	8b 93 94 00 00 00    	mov    0x94(%ebx),%edx
  80a2a2:	89 10                	mov    %edx,(%eax)
    assert(mbe->freed);
  80a2a4:	83 3b 00             	cmpl   $0x0,(%ebx)
  80a2a7:	0f 84 91 00 00 00    	je     80a33e <sys_mbox_new+0xe3>
    mbe->freed = 0;
  80a2ad:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
    int i = mbe - &mboxes[0];
  80a2b3:	89 de                	mov    %ebx,%esi
  80a2b5:	81 ee 60 4f b3 00    	sub    $0xb34f60,%esi
  80a2bb:	c1 fe 02             	sar    $0x2,%esi
  80a2be:	69 f6 97 6f f9 96    	imul   $0x96f96f97,%esi,%esi
  80a2c4:	89 f7                	mov    %esi,%edi
    mbe->head = -1;
  80a2c6:	c7 43 04 ff ff ff ff 	movl   $0xffffffff,0x4(%ebx)
    mbe->nextq = 0;
  80a2cd:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    mbe->queued_msg = sys_sem_new(0);
  80a2d4:	83 ec 0c             	sub    $0xc,%esp
  80a2d7:	6a 00                	push   $0x0
  80a2d9:	e8 c8 fd ff ff       	call   80a0a6 <sys_sem_new>
  80a2de:	89 83 8c 00 00 00    	mov    %eax,0x8c(%ebx)
    mbe->free_msg = sys_sem_new(MBOXSLOTS);
  80a2e4:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
  80a2eb:	e8 b6 fd ff ff       	call   80a0a6 <sys_sem_new>
  80a2f0:	89 83 90 00 00 00    	mov    %eax,0x90(%ebx)
    if (mbe->queued_msg == SYS_SEM_NULL ||
  80a2f6:	83 c4 10             	add    $0x10,%esp
  80a2f9:	83 bb 8c 00 00 00 ff 	cmpl   $0xffffffff,0x8c(%ebx)
  80a300:	74 52                	je     80a354 <sys_mbox_new+0xf9>
  80a302:	83 f8 ff             	cmp    $0xffffffff,%eax
  80a305:	74 4d                	je     80a354 <sys_mbox_new+0xf9>
}
  80a307:	89 f8                	mov    %edi,%eax
  80a309:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a30c:	5b                   	pop    %ebx
  80a30d:	5e                   	pop    %esi
  80a30e:	5f                   	pop    %edi
  80a30f:	5d                   	pop    %ebp
  80a310:	c3                   	ret    
    assert(size < MBOXSLOTS);
  80a311:	68 42 2b 81 00       	push   $0x812b42
  80a316:	68 eb 2a 81 00       	push   $0x812aeb
  80a31b:	6a 45                	push   $0x45
  80a31d:	68 00 2b 81 00       	push   $0x812b00
  80a322:	e8 20 46 00 00       	call   80e947 <_panic>
	cprintf("lwip: sys_mbox_new: out of mailboxes\n");
  80a327:	83 ec 0c             	sub    $0xc,%esp
  80a32a:	68 94 29 81 00       	push   $0x812994
  80a32f:	e8 fa 46 00 00       	call   80ea2e <cprintf>
	return SYS_MBOX_NULL;
  80a334:	83 c4 10             	add    $0x10,%esp
  80a337:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  80a33c:	eb c9                	jmp    80a307 <sys_mbox_new+0xac>
    assert(mbe->freed);
  80a33e:	68 53 2b 81 00       	push   $0x812b53
  80a343:	68 eb 2a 81 00       	push   $0x812aeb
  80a348:	6a 4c                	push   $0x4c
  80a34a:	68 00 2b 81 00       	push   $0x812b00
  80a34f:	e8 f3 45 00 00       	call   80e947 <_panic>
	sys_mbox_free(i);
  80a354:	83 ec 0c             	sub    $0xc,%esp
  80a357:	56                   	push   %esi
  80a358:	e8 5b fe ff ff       	call   80a1b8 <sys_mbox_free>
	cprintf("lwip: sys_mbox_new: can't get semaphore\n");
  80a35d:	c7 04 24 bc 29 81 00 	movl   $0x8129bc,(%esp)
  80a364:	e8 c5 46 00 00       	call   80ea2e <cprintf>
	return SYS_MBOX_NULL;
  80a369:	83 c4 10             	add    $0x10,%esp
  80a36c:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  80a371:	eb 94                	jmp    80a307 <sys_mbox_new+0xac>

0080a373 <sys_sem_signal>:
{
  80a373:	f3 0f 1e fb          	endbr32 
  80a377:	55                   	push   %ebp
  80a378:	89 e5                	mov    %esp,%ebp
  80a37a:	83 ec 08             	sub    $0x8,%esp
  80a37d:	8b 45 08             	mov    0x8(%ebp),%eax
    assert(!sems[sem].freed);
  80a380:	8d 14 80             	lea    (%eax,%eax,4),%edx
  80a383:	83 3c 95 80 9d b3 00 	cmpl   $0x0,0xb39d80(,%edx,4)
  80a38a:	00 
  80a38b:	75 18                	jne    80a3a5 <sys_sem_signal+0x32>
    sems[sem].counter++;
  80a38d:	8d 14 80             	lea    (%eax,%eax,4),%edx
  80a390:	8d 14 95 80 9d b3 00 	lea    0xb39d80(,%edx,4),%edx
  80a397:	66 83 42 08 01       	addw   $0x1,0x8(%edx)
    if (sems[sem].waiters) {
  80a39c:	66 83 7a 0a 00       	cmpw   $0x0,0xa(%edx)
  80a3a1:	75 1b                	jne    80a3be <sys_sem_signal+0x4b>
}
  80a3a3:	c9                   	leave  
  80a3a4:	c3                   	ret    
    assert(!sems[sem].freed);
  80a3a5:	68 1d 2b 81 00       	push   $0x812b1d
  80a3aa:	68 eb 2a 81 00       	push   $0x812aeb
  80a3af:	68 a1 00 00 00       	push   $0xa1
  80a3b4:	68 00 2b 81 00       	push   $0x812b00
  80a3b9:	e8 89 45 00 00       	call   80e947 <_panic>
	sems[sem].waiters = 0;
  80a3be:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  80a3c5:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  80a3c8:	66 c7 04 8d 8a 9d b3 	movw   $0x0,0xb39d8a(,%ecx,4)
  80a3cf:	00 00 00 
	thread_wakeup(&sems[sem].v);
  80a3d2:	83 ec 0c             	sub    $0xc,%esp
  80a3d5:	8d 04 8d 88 9d b3 00 	lea    0xb39d88(,%ecx,4),%eax
  80a3dc:	50                   	push   %eax
  80a3dd:	e8 cf 04 00 00       	call   80a8b1 <thread_wakeup>
  80a3e2:	83 c4 10             	add    $0x10,%esp
}
  80a3e5:	eb bc                	jmp    80a3a3 <sys_sem_signal+0x30>

0080a3e7 <sys_arch_sem_wait>:
{
  80a3e7:	f3 0f 1e fb          	endbr32 
  80a3eb:	55                   	push   %ebp
  80a3ec:	89 e5                	mov    %esp,%ebp
  80a3ee:	57                   	push   %edi
  80a3ef:	56                   	push   %esi
  80a3f0:	53                   	push   %ebx
  80a3f1:	83 ec 1c             	sub    $0x1c,%esp
  80a3f4:	8b 75 0c             	mov    0xc(%ebp),%esi
    assert(!sems[sem].freed);
  80a3f7:	8b 45 08             	mov    0x8(%ebp),%eax
  80a3fa:	8d 04 80             	lea    (%eax,%eax,4),%eax
  80a3fd:	83 3c 85 80 9d b3 00 	cmpl   $0x0,0xb39d80(,%eax,4)
  80a404:	00 
  80a405:	75 2c                	jne    80a433 <sys_arch_sem_wait+0x4c>
    int gen = sems[sem].gen;
  80a407:	8b 45 08             	mov    0x8(%ebp),%eax
  80a40a:	c1 e0 02             	shl    $0x2,%eax
  80a40d:	89 c2                	mov    %eax,%edx
  80a40f:	03 55 08             	add    0x8(%ebp),%edx
  80a412:	8b 1c 95 84 9d b3 00 	mov    0xb39d84(,%edx,4),%ebx
  80a419:	89 5d d8             	mov    %ebx,-0x28(%ebp)
	    thread_wait(&sems[sem].v, cur_v, sleep_until);
  80a41c:	8d 04 95 88 9d b3 00 	lea    0xb39d88(,%edx,4),%eax
  80a423:	89 45 dc             	mov    %eax,-0x24(%ebp)
    u32_t waited = 0;
  80a426:	bb 00 00 00 00       	mov    $0x0,%ebx
	if (sems[sem].counter > 0) {
  80a42b:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    while (tm_msec == 0 || waited < tm_msec) {
  80a42e:	e9 80 00 00 00       	jmp    80a4b3 <sys_arch_sem_wait+0xcc>
    assert(!sems[sem].freed);
  80a433:	68 1d 2b 81 00       	push   $0x812b1d
  80a438:	68 eb 2a 81 00       	push   $0x812aeb
  80a43d:	68 ac 00 00 00       	push   $0xac
  80a442:	68 00 2b 81 00       	push   $0x812b00
  80a447:	e8 fb 44 00 00       	call   80e947 <_panic>
	if (sems[sem].counter > 0) {
  80a44c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80a44f:	0f b7 04 85 88 9d b3 	movzwl 0xb39d88(,%eax,4),%eax
  80a456:	00 
  80a457:	66 85 c0             	test   %ax,%ax
  80a45a:	75 6e                	jne    80a4ca <sys_arch_sem_wait+0xe3>
 	} else if (tm_msec == SYS_ARCH_NOWAIT) {
  80a45c:	83 fe fe             	cmp    $0xfffffffe,%esi
  80a45f:	0f 84 8f 00 00 00    	je     80a4f4 <sys_arch_sem_wait+0x10d>
	    uint32_t a = sys_time_msec();
  80a465:	e8 21 52 00 00       	call   80f68b <sys_time_msec>
  80a46a:	89 c1                	mov    %eax,%ecx
  80a46c:	89 45 e0             	mov    %eax,-0x20(%ebp)
	    uint32_t sleep_until = tm_msec ? a + (tm_msec - waited) : ~0;
  80a46f:	89 f0                	mov    %esi,%eax
  80a471:	29 d8                	sub    %ebx,%eax
  80a473:	01 c8                	add    %ecx,%eax
  80a475:	85 f6                	test   %esi,%esi
  80a477:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  80a47c:	0f 44 c2             	cmove  %edx,%eax
	    sems[sem].waiters = 1;
  80a47f:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80a482:	8d 3c 95 80 9d b3 00 	lea    0xb39d80(,%edx,4),%edi
  80a489:	66 c7 47 0a 01 00    	movw   $0x1,0xa(%edi)
	    thread_wait(&sems[sem].v, cur_v, sleep_until);
  80a48f:	83 ec 04             	sub    $0x4,%esp
  80a492:	50                   	push   %eax
  80a493:	ff 77 08             	pushl  0x8(%edi)
  80a496:	ff 75 dc             	pushl  -0x24(%ebp)
  80a499:	e8 3e 06 00 00       	call   80aadc <thread_wait>
	    if (gen != sems[sem].gen) {
  80a49e:	83 c4 10             	add    $0x10,%esp
  80a4a1:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80a4a4:	39 47 04             	cmp    %eax,0x4(%edi)
  80a4a7:	75 34                	jne    80a4dd <sys_arch_sem_wait+0xf6>
	    uint32_t b = sys_time_msec();
  80a4a9:	e8 dd 51 00 00       	call   80f68b <sys_time_msec>
	    waited += (b - a);
  80a4ae:	2b 45 e0             	sub    -0x20(%ebp),%eax
  80a4b1:	01 c3                	add    %eax,%ebx
    while (tm_msec == 0 || waited < tm_msec) {
  80a4b3:	85 f6                	test   %esi,%esi
  80a4b5:	74 95                	je     80a44c <sys_arch_sem_wait+0x65>
  80a4b7:	39 f3                	cmp    %esi,%ebx
  80a4b9:	72 91                	jb     80a44c <sys_arch_sem_wait+0x65>
    return SYS_ARCH_TIMEOUT;
  80a4bb:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
}
  80a4c0:	89 d8                	mov    %ebx,%eax
  80a4c2:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a4c5:	5b                   	pop    %ebx
  80a4c6:	5e                   	pop    %esi
  80a4c7:	5f                   	pop    %edi
  80a4c8:	5d                   	pop    %ebp
  80a4c9:	c3                   	ret    
	    sems[sem].counter--;
  80a4ca:	8b 55 08             	mov    0x8(%ebp),%edx
  80a4cd:	8d 14 92             	lea    (%edx,%edx,4),%edx
  80a4d0:	83 e8 01             	sub    $0x1,%eax
  80a4d3:	66 89 04 95 88 9d b3 	mov    %ax,0xb39d88(,%edx,4)
  80a4da:	00 
	    return waited;
  80a4db:	eb e3                	jmp    80a4c0 <sys_arch_sem_wait+0xd9>
		cprintf("sys_arch_sem_wait: sem freed under waiter!\n");
  80a4dd:	83 ec 0c             	sub    $0xc,%esp
  80a4e0:	68 e8 29 81 00       	push   $0x8129e8
  80a4e5:	e8 44 45 00 00       	call   80ea2e <cprintf>
		return SYS_ARCH_TIMEOUT;
  80a4ea:	83 c4 10             	add    $0x10,%esp
  80a4ed:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  80a4f2:	eb cc                	jmp    80a4c0 <sys_arch_sem_wait+0xd9>
	    return SYS_ARCH_TIMEOUT;
  80a4f4:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  80a4f9:	eb c5                	jmp    80a4c0 <sys_arch_sem_wait+0xd9>

0080a4fb <sys_mbox_trypost>:
{
  80a4fb:	f3 0f 1e fb          	endbr32 
  80a4ff:	55                   	push   %ebp
  80a500:	89 e5                	mov    %esp,%ebp
  80a502:	57                   	push   %edi
  80a503:	56                   	push   %esi
  80a504:	53                   	push   %ebx
  80a505:	83 ec 0c             	sub    $0xc,%esp
  80a508:	8b 5d 08             	mov    0x8(%ebp),%ebx
    assert(!mboxes[mbox].freed);
  80a50b:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a511:	83 b8 60 4f b3 00 00 	cmpl   $0x0,0xb34f60(%eax)
  80a518:	75 7f                	jne    80a599 <sys_mbox_trypost+0x9e>
    sys_arch_sem_wait(mboxes[mbox].free_msg, 0);
  80a51a:	83 ec 08             	sub    $0x8,%esp
  80a51d:	6a 00                	push   $0x0
  80a51f:	69 f3 9c 00 00 00    	imul   $0x9c,%ebx,%esi
  80a525:	ff b6 f0 4f b3 00    	pushl  0xb34ff0(%esi)
  80a52b:	e8 b7 fe ff ff       	call   80a3e7 <sys_arch_sem_wait>
    if (mboxes[mbox].nextq == mboxes[mbox].head)
  80a530:	8b 96 68 4f b3 00    	mov    0xb34f68(%esi),%edx
  80a536:	8b 8e 64 4f b3 00    	mov    0xb34f64(%esi),%ecx
  80a53c:	83 c4 10             	add    $0x10,%esp
  80a53f:	39 ca                	cmp    %ecx,%edx
  80a541:	74 7a                	je     80a5bd <sys_mbox_trypost+0xc2>
    mboxes[mbox].nextq = (slot + 1) % MBOXSLOTS;
  80a543:	69 f3 9c 00 00 00    	imul   $0x9c,%ebx,%esi
  80a549:	8d 42 01             	lea    0x1(%edx),%eax
  80a54c:	89 c7                	mov    %eax,%edi
  80a54e:	c1 ff 1f             	sar    $0x1f,%edi
  80a551:	c1 ef 1b             	shr    $0x1b,%edi
  80a554:	01 f8                	add    %edi,%eax
  80a556:	83 e0 1f             	and    $0x1f,%eax
  80a559:	29 f8                	sub    %edi,%eax
  80a55b:	89 86 68 4f b3 00    	mov    %eax,0xb34f68(%esi)
    mboxes[mbox].msg[slot] = msg;
  80a561:	6b c3 27             	imul   $0x27,%ebx,%eax
  80a564:	01 d0                	add    %edx,%eax
  80a566:	8b 75 0c             	mov    0xc(%ebp),%esi
  80a569:	89 34 85 6c 4f b3 00 	mov    %esi,0xb34f6c(,%eax,4)
    if (mboxes[mbox].head == -1)
  80a570:	83 f9 ff             	cmp    $0xffffffff,%ecx
  80a573:	74 3a                	je     80a5af <sys_mbox_trypost+0xb4>
    sys_sem_signal(mboxes[mbox].queued_msg);
  80a575:	83 ec 0c             	sub    $0xc,%esp
  80a578:	69 db 9c 00 00 00    	imul   $0x9c,%ebx,%ebx
  80a57e:	ff b3 ec 4f b3 00    	pushl  0xb34fec(%ebx)
  80a584:	e8 ea fd ff ff       	call   80a373 <sys_sem_signal>
    return ERR_OK;
  80a589:	83 c4 10             	add    $0x10,%esp
  80a58c:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80a591:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a594:	5b                   	pop    %ebx
  80a595:	5e                   	pop    %esi
  80a596:	5f                   	pop    %edi
  80a597:	5d                   	pop    %ebp
  80a598:	c3                   	ret    
    assert(!mboxes[mbox].freed);
  80a599:	68 2e 2b 81 00       	push   $0x812b2e
  80a59e:	68 eb 2a 81 00       	push   $0x812aeb
  80a5a3:	6a 72                	push   $0x72
  80a5a5:	68 00 2b 81 00       	push   $0x812b00
  80a5aa:	e8 98 43 00 00       	call   80e947 <_panic>
	mboxes[mbox].head = slot;
  80a5af:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a5b5:	89 90 64 4f b3 00    	mov    %edx,0xb34f64(%eax)
  80a5bb:	eb b8                	jmp    80a575 <sys_mbox_trypost+0x7a>
	return ERR_MEM;
  80a5bd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80a5c2:	eb cd                	jmp    80a591 <sys_mbox_trypost+0x96>

0080a5c4 <sys_mbox_post>:
{
  80a5c4:	f3 0f 1e fb          	endbr32 
  80a5c8:	55                   	push   %ebp
  80a5c9:	89 e5                	mov    %esp,%ebp
  80a5cb:	83 ec 10             	sub    $0x10,%esp
    assert(sys_mbox_trypost(mbox, msg) == ERR_OK);
  80a5ce:	ff 75 0c             	pushl  0xc(%ebp)
  80a5d1:	ff 75 08             	pushl  0x8(%ebp)
  80a5d4:	e8 22 ff ff ff       	call   80a4fb <sys_mbox_trypost>
  80a5d9:	83 c4 10             	add    $0x10,%esp
  80a5dc:	84 c0                	test   %al,%al
  80a5de:	75 02                	jne    80a5e2 <sys_mbox_post+0x1e>
}
  80a5e0:	c9                   	leave  
  80a5e1:	c3                   	ret    
    assert(sys_mbox_trypost(mbox, msg) == ERR_OK);
  80a5e2:	68 14 2a 81 00       	push   $0x812a14
  80a5e7:	68 eb 2a 81 00       	push   $0x812aeb
  80a5ec:	6a 6c                	push   $0x6c
  80a5ee:	68 00 2b 81 00       	push   $0x812b00
  80a5f3:	e8 4f 43 00 00       	call   80e947 <_panic>

0080a5f8 <sys_arch_mbox_fetch>:
{
  80a5f8:	f3 0f 1e fb          	endbr32 
  80a5fc:	55                   	push   %ebp
  80a5fd:	89 e5                	mov    %esp,%ebp
  80a5ff:	57                   	push   %edi
  80a600:	56                   	push   %esi
  80a601:	53                   	push   %ebx
  80a602:	83 ec 0c             	sub    $0xc,%esp
  80a605:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80a608:	8b 7d 0c             	mov    0xc(%ebp),%edi
    assert(!mboxes[mbox].freed);
  80a60b:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a611:	83 b8 60 4f b3 00 00 	cmpl   $0x0,0xb34f60(%eax)
  80a618:	0f 85 8a 00 00 00    	jne    80a6a8 <sys_arch_mbox_fetch+0xb0>
    u32_t waited = sys_arch_sem_wait(mboxes[mbox].queued_msg, tm_msec);
  80a61e:	83 ec 08             	sub    $0x8,%esp
  80a621:	ff 75 10             	pushl  0x10(%ebp)
  80a624:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a62a:	ff b0 ec 4f b3 00    	pushl  0xb34fec(%eax)
  80a630:	e8 b2 fd ff ff       	call   80a3e7 <sys_arch_sem_wait>
  80a635:	89 c6                	mov    %eax,%esi
    if (waited == SYS_ARCH_TIMEOUT)
  80a637:	83 c4 10             	add    $0x10,%esp
  80a63a:	83 f8 ff             	cmp    $0xffffffff,%eax
  80a63d:	74 5f                	je     80a69e <sys_arch_mbox_fetch+0xa6>
    int slot = mboxes[mbox].head;
  80a63f:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a645:	8b 80 64 4f b3 00    	mov    0xb34f64(%eax),%eax
    if (slot == -1)
  80a64b:	83 f8 ff             	cmp    $0xffffffff,%eax
  80a64e:	74 71                	je     80a6c1 <sys_arch_mbox_fetch+0xc9>
    if (msg)
  80a650:	85 ff                	test   %edi,%edi
  80a652:	74 0e                	je     80a662 <sys_arch_mbox_fetch+0x6a>
	*msg = mboxes[mbox].msg[slot];
  80a654:	6b d3 27             	imul   $0x27,%ebx,%edx
  80a657:	01 c2                	add    %eax,%edx
  80a659:	8b 14 95 6c 4f b3 00 	mov    0xb34f6c(,%edx,4),%edx
  80a660:	89 17                	mov    %edx,(%edi)
    mboxes[mbox].head = (slot + 1) % MBOXSLOTS;
  80a662:	83 c0 01             	add    $0x1,%eax
  80a665:	99                   	cltd   
  80a666:	c1 ea 1b             	shr    $0x1b,%edx
  80a669:	01 d0                	add    %edx,%eax
  80a66b:	83 e0 1f             	and    $0x1f,%eax
  80a66e:	29 d0                	sub    %edx,%eax
  80a670:	69 d3 9c 00 00 00    	imul   $0x9c,%ebx,%edx
  80a676:	89 82 64 4f b3 00    	mov    %eax,0xb34f64(%edx)
  80a67c:	81 c2 60 4f b3 00    	add    $0xb34f60,%edx
    if (mboxes[mbox].head == mboxes[mbox].nextq)
  80a682:	3b 42 08             	cmp    0x8(%edx),%eax
  80a685:	74 51                	je     80a6d8 <sys_arch_mbox_fetch+0xe0>
    sys_sem_signal(mboxes[mbox].free_msg);
  80a687:	83 ec 0c             	sub    $0xc,%esp
  80a68a:	69 db 9c 00 00 00    	imul   $0x9c,%ebx,%ebx
  80a690:	ff b3 f0 4f b3 00    	pushl  0xb34ff0(%ebx)
  80a696:	e8 d8 fc ff ff       	call   80a373 <sys_sem_signal>
    return waited;
  80a69b:	83 c4 10             	add    $0x10,%esp
}
  80a69e:	89 f0                	mov    %esi,%eax
  80a6a0:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a6a3:	5b                   	pop    %ebx
  80a6a4:	5e                   	pop    %esi
  80a6a5:	5f                   	pop    %edi
  80a6a6:	5d                   	pop    %ebp
  80a6a7:	c3                   	ret    
    assert(!mboxes[mbox].freed);
  80a6a8:	68 2e 2b 81 00       	push   $0x812b2e
  80a6ad:	68 eb 2a 81 00       	push   $0x812aeb
  80a6b2:	68 ce 00 00 00       	push   $0xce
  80a6b7:	68 00 2b 81 00       	push   $0x812b00
  80a6bc:	e8 86 42 00 00       	call   80e947 <_panic>
	panic("lwip: sys_arch_mbox_fetch: no message");
  80a6c1:	83 ec 04             	sub    $0x4,%esp
  80a6c4:	68 3c 2a 81 00       	push   $0x812a3c
  80a6c9:	68 d6 00 00 00       	push   $0xd6
  80a6ce:	68 00 2b 81 00       	push   $0x812b00
  80a6d3:	e8 6f 42 00 00       	call   80e947 <_panic>
	mboxes[mbox].head = -1;
  80a6d8:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a6de:	c7 80 64 4f b3 00 ff 	movl   $0xffffffff,0xb34f64(%eax)
  80a6e5:	ff ff ff 
  80a6e8:	eb 9d                	jmp    80a687 <sys_arch_mbox_fetch+0x8f>

0080a6ea <sys_arch_mbox_tryfetch>:
{
  80a6ea:	f3 0f 1e fb          	endbr32 
  80a6ee:	55                   	push   %ebp
  80a6ef:	89 e5                	mov    %esp,%ebp
  80a6f1:	83 ec 0c             	sub    $0xc,%esp
    return sys_arch_mbox_fetch(mbox, msg, SYS_ARCH_NOWAIT);
  80a6f4:	6a fe                	push   $0xfffffffe
  80a6f6:	ff 75 0c             	pushl  0xc(%ebp)
  80a6f9:	ff 75 08             	pushl  0x8(%ebp)
  80a6fc:	e8 f7 fe ff ff       	call   80a5f8 <sys_arch_mbox_fetch>
}
  80a701:	c9                   	leave  
  80a702:	c3                   	ret    

0080a703 <sys_thread_new>:
{
  80a703:	f3 0f 1e fb          	endbr32 
  80a707:	55                   	push   %ebp
  80a708:	89 e5                	mov    %esp,%ebp
  80a70a:	83 ec 24             	sub    $0x24,%esp
    struct lwip_thread *lt = malloc(sizeof(*lt));
  80a70d:	6a 08                	push   $0x8
  80a70f:	e8 f0 61 00 00       	call   810904 <malloc>
    if (lt == 0)
  80a714:	83 c4 10             	add    $0x10,%esp
  80a717:	85 c0                	test   %eax,%eax
  80a719:	74 32                	je     80a74d <sys_thread_new+0x4a>
    if (stacksize > PGSIZE)
  80a71b:	81 7d 14 00 10 00 00 	cmpl   $0x1000,0x14(%ebp)
  80a722:	7f 40                	jg     80a764 <sys_thread_new+0x61>
    lt->func = thread;
  80a724:	8b 55 0c             	mov    0xc(%ebp),%edx
  80a727:	89 10                	mov    %edx,(%eax)
    lt->arg = arg;
  80a729:	8b 55 10             	mov    0x10(%ebp),%edx
  80a72c:	89 50 04             	mov    %edx,0x4(%eax)
    int r = thread_create(&tid, name, lwip_thread_entry, (uint32_t)lt);
  80a72f:	50                   	push   %eax
  80a730:	68 88 9f 80 00       	push   $0x809f88
  80a735:	ff 75 08             	pushl  0x8(%ebp)
  80a738:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80a73b:	50                   	push   %eax
  80a73c:	e8 e7 01 00 00       	call   80a928 <thread_create>
    if (r < 0)
  80a741:	83 c4 10             	add    $0x10,%esp
  80a744:	85 c0                	test   %eax,%eax
  80a746:	78 33                	js     80a77b <sys_thread_new+0x78>
}
  80a748:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80a74b:	c9                   	leave  
  80a74c:	c3                   	ret    
	panic("sys_thread_new: cannot allocate thread struct");
  80a74d:	83 ec 04             	sub    $0x4,%esp
  80a750:	68 64 2a 81 00       	push   $0x812a64
  80a755:	68 fd 00 00 00       	push   $0xfd
  80a75a:	68 00 2b 81 00       	push   $0x812b00
  80a75f:	e8 e3 41 00 00       	call   80e947 <_panic>
	panic("large stack %d", stacksize);
  80a764:	ff 75 14             	pushl  0x14(%ebp)
  80a767:	68 5e 2b 81 00       	push   $0x812b5e
  80a76c:	68 00 01 00 00       	push   $0x100
  80a771:	68 00 2b 81 00       	push   $0x812b00
  80a776:	e8 cc 41 00 00       	call   80e947 <_panic>
	panic("lwip: sys_thread_new: cannot create: %s\n", e2s(r));
  80a77b:	83 ec 0c             	sub    $0xc,%esp
  80a77e:	50                   	push   %eax
  80a77f:	e8 f9 04 00 00       	call   80ac7d <e2s>
  80a784:	50                   	push   %eax
  80a785:	68 94 2a 81 00       	push   $0x812a94
  80a78a:	68 09 01 00 00       	push   $0x109
  80a78f:	68 00 2b 81 00       	push   $0x812b00
  80a794:	e8 ae 41 00 00       	call   80e947 <_panic>

0080a799 <sys_arch_timeouts>:

struct sys_timeouts *
sys_arch_timeouts(void)
{
  80a799:	f3 0f 1e fb          	endbr32 
  80a79d:	55                   	push   %ebp
  80a79e:	89 e5                	mov    %esp,%ebp
  80a7a0:	57                   	push   %edi
  80a7a1:	56                   	push   %esi
  80a7a2:	53                   	push   %ebx
  80a7a3:	83 ec 0c             	sub    $0xc,%esp
    thread_id_t tid = thread_id();
  80a7a6:	e8 fa 00 00 00       	call   80a8a5 <thread_id>
  80a7ab:	89 c6                	mov    %eax,%esi

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  80a7ad:	ba 01 ff 00 ff       	mov    $0xff00ff01,%edx
  80a7b2:	f7 e2                	mul    %edx
  80a7b4:	89 d7                	mov    %edx,%edi
  80a7b6:	c1 ef 08             	shr    $0x8,%edi
  80a7b9:	b2 00                	mov    $0x0,%dl
  80a7bb:	01 d7                	add    %edx,%edi
  80a7bd:	89 f0                	mov    %esi,%eax
  80a7bf:	29 f8                	sub    %edi,%eax
  80a7c1:	89 c7                	mov    %eax,%edi
  80a7c3:	8b 1c 85 40 4b b3 00 	mov    0xb34b40(,%eax,4),%ebx
  80a7ca:	85 db                	test   %ebx,%ebx
  80a7cc:	74 09                	je     80a7d7 <sys_arch_timeouts+0x3e>
	if (t->tid == tid)
  80a7ce:	39 33                	cmp    %esi,(%ebx)
  80a7d0:	74 66                	je     80a838 <sys_arch_timeouts+0x9f>
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  80a7d2:	8b 5b 08             	mov    0x8(%ebx),%ebx
  80a7d5:	eb f3                	jmp    80a7ca <sys_arch_timeouts+0x31>
	    goto out;

    t = malloc(sizeof(*t));
  80a7d7:	83 ec 0c             	sub    $0xc,%esp
  80a7da:	6a 10                	push   $0x10
  80a7dc:	e8 23 61 00 00       	call   810904 <malloc>
  80a7e1:	89 c3                	mov    %eax,%ebx
    if (t == 0)
  80a7e3:	83 c4 10             	add    $0x10,%esp
  80a7e6:	85 c0                	test   %eax,%eax
  80a7e8:	74 59                	je     80a843 <sys_arch_timeouts+0xaa>
	panic("sys_arch_timeouts: cannot malloc");

    int r = thread_onhalt(timeout_cleanup);
  80a7ea:	83 ec 0c             	sub    $0xc,%esp
  80a7ed:	68 ab 9f 80 00       	push   $0x809fab
  80a7f2:	e8 03 01 00 00       	call   80a8fa <thread_onhalt>
    if (r < 0)
  80a7f7:	83 c4 10             	add    $0x10,%esp
  80a7fa:	85 c0                	test   %eax,%eax
  80a7fc:	78 5c                	js     80a85a <sys_arch_timeouts+0xc1>
	panic("thread_onhalt failed: %s", e2s(r));

    t->tid = tid;
  80a7fe:	89 33                	mov    %esi,(%ebx)
    memset(&t->tmo, 0, sizeof(t->tmo));
  80a800:	83 ec 04             	sub    $0x4,%esp
  80a803:	6a 04                	push   $0x4
  80a805:	6a 00                	push   $0x0
  80a807:	8d 43 04             	lea    0x4(%ebx),%eax
  80a80a:	50                   	push   %eax
  80a80b:	e8 92 49 00 00       	call   80f1a2 <memset>
    LIST_INSERT_HEAD(&threads[tid % thread_hash_size], t, link);
  80a810:	8b 04 bd 40 4b b3 00 	mov    0xb34b40(,%edi,4),%eax
  80a817:	89 43 08             	mov    %eax,0x8(%ebx)
  80a81a:	83 c4 10             	add    $0x10,%esp
  80a81d:	85 c0                	test   %eax,%eax
  80a81f:	74 06                	je     80a827 <sys_arch_timeouts+0x8e>
  80a821:	8d 53 08             	lea    0x8(%ebx),%edx
  80a824:	89 50 0c             	mov    %edx,0xc(%eax)
  80a827:	89 1c bd 40 4b b3 00 	mov    %ebx,0xb34b40(,%edi,4)
  80a82e:	8d 04 bd 40 4b b3 00 	lea    0xb34b40(,%edi,4),%eax
  80a835:	89 43 0c             	mov    %eax,0xc(%ebx)

out:
    return &t->tmo;
  80a838:	8d 43 04             	lea    0x4(%ebx),%eax
}
  80a83b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a83e:	5b                   	pop    %ebx
  80a83f:	5e                   	pop    %esi
  80a840:	5f                   	pop    %edi
  80a841:	5d                   	pop    %ebp
  80a842:	c3                   	ret    
	panic("sys_arch_timeouts: cannot malloc");
  80a843:	83 ec 04             	sub    $0x4,%esp
  80a846:	68 c0 2a 81 00       	push   $0x812ac0
  80a84b:	68 2c 01 00 00       	push   $0x12c
  80a850:	68 00 2b 81 00       	push   $0x812b00
  80a855:	e8 ed 40 00 00       	call   80e947 <_panic>
	panic("thread_onhalt failed: %s", e2s(r));
  80a85a:	83 ec 0c             	sub    $0xc,%esp
  80a85d:	50                   	push   %eax
  80a85e:	e8 1a 04 00 00       	call   80ac7d <e2s>
  80a863:	50                   	push   %eax
  80a864:	68 6d 2b 81 00       	push   $0x812b6d
  80a869:	68 30 01 00 00       	push   $0x130
  80a86e:	68 00 2b 81 00       	push   $0x812b00
  80a873:	e8 cf 40 00 00       	call   80e947 <_panic>

0080a878 <lwip_core_lock>:

void
lwip_core_lock(void)
{
  80a878:	f3 0f 1e fb          	endbr32 
}
  80a87c:	c3                   	ret    

0080a87d <lwip_core_unlock>:

void
lwip_core_unlock(void)
{
  80a87d:	f3 0f 1e fb          	endbr32 
}
  80a881:	c3                   	ret    

0080a882 <thread_init>:

static struct thread_queue thread_queue;
static struct thread_queue kill_queue;

void
thread_init(void) {
  80a882:	f3 0f 1e fb          	endbr32 
};

static inline void 
threadq_init(struct thread_queue *tq)
{
    tq->tq_first = 0;
  80a886:	c7 05 88 b1 b3 00 00 	movl   $0x0,0xb3b188
  80a88d:	00 00 00 
    tq->tq_last = 0;
  80a890:	c7 05 8c b1 b3 00 00 	movl   $0x0,0xb3b18c
  80a897:	00 00 00 
    threadq_init(&thread_queue);
    max_tid = 0;
  80a89a:	c7 05 94 b1 b3 00 00 	movl   $0x0,0xb3b194
  80a8a1:	00 00 00 
}
  80a8a4:	c3                   	ret    

0080a8a5 <thread_id>:

uint32_t
thread_id(void) {
  80a8a5:	f3 0f 1e fb          	endbr32 
    return cur_tc->tc_tid;
  80a8a9:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
  80a8ae:	8b 00                	mov    (%eax),%eax
}
  80a8b0:	c3                   	ret    

0080a8b1 <thread_wakeup>:

void
thread_wakeup(volatile uint32_t *addr) {
  80a8b1:	f3 0f 1e fb          	endbr32 
  80a8b5:	55                   	push   %ebp
  80a8b6:	89 e5                	mov    %esp,%ebp
  80a8b8:	8b 55 08             	mov    0x8(%ebp),%edx
    struct thread_context *tc = thread_queue.tq_first;
  80a8bb:	a1 88 b1 b3 00       	mov    0xb3b188,%eax
    while (tc) {
  80a8c0:	eb 07                	jmp    80a8c9 <thread_wakeup+0x18>
	if (tc->tc_wait_addr == addr)
	    tc->tc_wakeup = 1;
  80a8c2:	c6 40 4c 01          	movb   $0x1,0x4c(%eax)
	tc = tc->tc_queue_link;
  80a8c6:	8b 40 64             	mov    0x64(%eax),%eax
    while (tc) {
  80a8c9:	85 c0                	test   %eax,%eax
  80a8cb:	74 07                	je     80a8d4 <thread_wakeup+0x23>
	if (tc->tc_wait_addr == addr)
  80a8cd:	39 50 48             	cmp    %edx,0x48(%eax)
  80a8d0:	75 f4                	jne    80a8c6 <thread_wakeup+0x15>
  80a8d2:	eb ee                	jmp    80a8c2 <thread_wakeup+0x11>
    }
}
  80a8d4:	5d                   	pop    %ebp
  80a8d5:	c3                   	ret    

0080a8d6 <thread_wakeups_pending>:
    cur_tc->tc_wakeup = 0;
}

int
thread_wakeups_pending(void)
{
  80a8d6:	f3 0f 1e fb          	endbr32 
    struct thread_context *tc = thread_queue.tq_first;
  80a8da:	a1 88 b1 b3 00       	mov    0xb3b188,%eax
    int n = 0;
  80a8df:	b9 00 00 00 00       	mov    $0x0,%ecx
    while (tc) {
  80a8e4:	85 c0                	test   %eax,%eax
  80a8e6:	74 0f                	je     80a8f7 <thread_wakeups_pending+0x21>
	if (tc->tc_wakeup)
  80a8e8:	0f b6 50 4c          	movzbl 0x4c(%eax),%edx
	    ++n;
  80a8ec:	80 fa 01             	cmp    $0x1,%dl
  80a8ef:	83 d9 ff             	sbb    $0xffffffff,%ecx
	tc = tc->tc_queue_link;
  80a8f2:	8b 40 64             	mov    0x64(%eax),%eax
  80a8f5:	eb ed                	jmp    80a8e4 <thread_wakeups_pending+0xe>
    }
    return n;
}
  80a8f7:	89 c8                	mov    %ecx,%eax
  80a8f9:	c3                   	ret    

0080a8fa <thread_onhalt>:

int
thread_onhalt(void (*fun)(thread_id_t)) {
  80a8fa:	f3 0f 1e fb          	endbr32 
    if (cur_tc->tc_nonhalt >= THREAD_NUM_ONHALT)
  80a8fe:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
  80a903:	8b 50 60             	mov    0x60(%eax),%edx
  80a906:	83 fa 03             	cmp    $0x3,%edx
  80a909:	7f 17                	jg     80a922 <thread_onhalt+0x28>
thread_onhalt(void (*fun)(thread_id_t)) {
  80a90b:	55                   	push   %ebp
  80a90c:	89 e5                	mov    %esp,%ebp
	return -E_NO_MEM;

    cur_tc->tc_onhalt[cur_tc->tc_nonhalt++] = fun;
  80a90e:	8d 4a 01             	lea    0x1(%edx),%ecx
  80a911:	89 48 60             	mov    %ecx,0x60(%eax)
  80a914:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80a917:	89 4c 90 50          	mov    %ecx,0x50(%eax,%edx,4)
    return 0;
  80a91b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80a920:	5d                   	pop    %ebp
  80a921:	c3                   	ret    
	return -E_NO_MEM;
  80a922:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
}
  80a927:	c3                   	ret    

0080a928 <thread_create>:
    thread_halt();
}

int
thread_create(thread_id_t *tid, const char *name, 
		void (*entry)(uint32_t), uint32_t arg) {
  80a928:	f3 0f 1e fb          	endbr32 
  80a92c:	55                   	push   %ebp
  80a92d:	89 e5                	mov    %esp,%ebp
  80a92f:	57                   	push   %edi
  80a930:	56                   	push   %esi
  80a931:	53                   	push   %ebx
  80a932:	83 ec 18             	sub    $0x18,%esp
  80a935:	8b 75 08             	mov    0x8(%ebp),%esi
    struct thread_context *tc = malloc(sizeof(struct thread_context));
  80a938:	6a 68                	push   $0x68
  80a93a:	e8 c5 5f 00 00       	call   810904 <malloc>
    if (!tc)
  80a93f:	83 c4 10             	add    $0x10,%esp
  80a942:	85 c0                	test   %eax,%eax
  80a944:	0f 84 04 01 00 00    	je     80aa4e <thread_create+0x126>
  80a94a:	89 c3                	mov    %eax,%ebx
	return -E_NO_MEM;

    memset(tc, 0, sizeof(struct thread_context));
  80a94c:	83 ec 04             	sub    $0x4,%esp
  80a94f:	6a 68                	push   $0x68
  80a951:	6a 00                	push   $0x0
  80a953:	50                   	push   %eax
  80a954:	e8 49 48 00 00       	call   80f1a2 <memset>
    strncpy(tc->tc_name, name, name_size - 1);
  80a959:	83 c4 0c             	add    $0xc,%esp
  80a95c:	6a 1f                	push   $0x1f
  80a95e:	ff 75 0c             	pushl  0xc(%ebp)
  80a961:	8d 43 08             	lea    0x8(%ebx),%eax
  80a964:	50                   	push   %eax
  80a965:	e8 1d 47 00 00       	call   80f087 <strncpy>
    tc->tc_name[name_size - 1] = 0;
  80a96a:	c6 43 27 00          	movb   $0x0,0x27(%ebx)
    int tid = max_tid++;
  80a96e:	a1 94 b1 b3 00       	mov    0xb3b194,%eax
  80a973:	8d 50 01             	lea    0x1(%eax),%edx
  80a976:	89 15 94 b1 b3 00    	mov    %edx,0xb3b194
    if (max_tid == (uint32_t)~0)
  80a97c:	83 c4 10             	add    $0x10,%esp
  80a97f:	83 fa ff             	cmp    $0xffffffff,%edx
  80a982:	0f 84 91 00 00 00    	je     80aa19 <thread_create+0xf1>
    
    thread_set_name(tc, name);
    tc->tc_tid = alloc_tid();
  80a988:	89 03                	mov    %eax,(%ebx)

    tc->tc_stack_bottom = malloc(stack_size);
  80a98a:	83 ec 0c             	sub    $0xc,%esp
  80a98d:	68 00 10 00 00       	push   $0x1000
  80a992:	e8 6d 5f 00 00       	call   810904 <malloc>
  80a997:	89 43 04             	mov    %eax,0x4(%ebx)
    if (!tc->tc_stack_bottom) {
  80a99a:	83 c4 10             	add    $0x10,%esp
  80a99d:	85 c0                	test   %eax,%eax
  80a99f:	0f 84 88 00 00 00    	je     80aa2d <thread_create+0x105>
	return -E_NO_MEM;
    }

    void *stacktop = tc->tc_stack_bottom + stack_size;
    // Terminate stack unwinding
    stacktop = stacktop - 4;
  80a9a5:	8d b8 fc 0f 00 00    	lea    0xffc(%eax),%edi
    memset(stacktop, 0, 4);
  80a9ab:	83 ec 04             	sub    $0x4,%esp
  80a9ae:	6a 04                	push   $0x4
  80a9b0:	6a 00                	push   $0x0
  80a9b2:	57                   	push   %edi
  80a9b3:	e8 ea 47 00 00       	call   80f1a2 <memset>
    
    memset(&tc->tc_jb, 0, sizeof(tc->tc_jb));
  80a9b8:	83 c4 0c             	add    $0xc,%esp
  80a9bb:	6a 18                	push   $0x18
  80a9bd:	6a 00                	push   $0x0
  80a9bf:	8d 43 30             	lea    0x30(%ebx),%eax
  80a9c2:	50                   	push   %eax
  80a9c3:	e8 da 47 00 00       	call   80f1a2 <memset>
    tc->tc_jb.jb_esp = (uint32_t)stacktop;
  80a9c8:	89 7b 34             	mov    %edi,0x34(%ebx)
    tc->tc_jb.jb_eip = (uint32_t)&thread_entry;
  80a9cb:	c7 43 30 e5 ab 80 00 	movl   $0x80abe5,0x30(%ebx)
    tc->tc_entry = entry;
  80a9d2:	8b 45 10             	mov    0x10(%ebp),%eax
  80a9d5:	89 43 28             	mov    %eax,0x28(%ebx)
    tc->tc_arg = arg;
  80a9d8:	8b 45 14             	mov    0x14(%ebp),%eax
  80a9db:	89 43 2c             	mov    %eax,0x2c(%ebx)
}

static inline void
threadq_push(struct thread_queue *tq, struct thread_context *tc)
{
    tc->tc_queue_link = 0;
  80a9de:	c7 43 64 00 00 00 00 	movl   $0x0,0x64(%ebx)
    if (!tq->tq_first) {
  80a9e5:	83 c4 10             	add    $0x10,%esp
  80a9e8:	83 3d 88 b1 b3 00 00 	cmpl   $0x0,0xb3b188
  80a9ef:	74 4f                	je     80aa40 <thread_create+0x118>
	tq->tq_first = tc;
	tq->tq_last = tc;
    } else {
	tq->tq_last->tc_queue_link = tc;
  80a9f1:	a1 8c b1 b3 00       	mov    0xb3b18c,%eax
  80a9f6:	89 58 64             	mov    %ebx,0x64(%eax)
	tq->tq_last = tc;
  80a9f9:	89 1d 8c b1 b3 00    	mov    %ebx,0xb3b18c

    threadq_push(&thread_queue, tc);

    if (tid)
	*tid = tc->tc_tid;
    return 0;
  80a9ff:	b8 00 00 00 00       	mov    $0x0,%eax
    if (tid)
  80aa04:	85 f6                	test   %esi,%esi
  80aa06:	74 09                	je     80aa11 <thread_create+0xe9>
	*tid = tc->tc_tid;
  80aa08:	8b 03                	mov    (%ebx),%eax
  80aa0a:	89 06                	mov    %eax,(%esi)
    return 0;
  80aa0c:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80aa11:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80aa14:	5b                   	pop    %ebx
  80aa15:	5e                   	pop    %esi
  80aa16:	5f                   	pop    %edi
  80aa17:	5d                   	pop    %ebp
  80aa18:	c3                   	ret    
	panic("alloc_tid: no more thread ids");
  80aa19:	83 ec 04             	sub    $0x4,%esp
  80aa1c:	68 86 2b 81 00       	push   $0x812b86
  80aa21:	6a 54                	push   $0x54
  80aa23:	68 a4 2b 81 00       	push   $0x812ba4
  80aa28:	e8 1a 3f 00 00       	call   80e947 <_panic>
	free(tc);
  80aa2d:	83 ec 0c             	sub    $0xc,%esp
  80aa30:	53                   	push   %ebx
  80aa31:	e8 1e 5e 00 00       	call   810854 <free>
	return -E_NO_MEM;
  80aa36:	83 c4 10             	add    $0x10,%esp
  80aa39:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80aa3e:	eb d1                	jmp    80aa11 <thread_create+0xe9>
	tq->tq_first = tc;
  80aa40:	89 1d 88 b1 b3 00    	mov    %ebx,0xb3b188
	tq->tq_last = tc;
  80aa46:	89 1d 8c b1 b3 00    	mov    %ebx,0xb3b18c
  80aa4c:	eb b1                	jmp    80a9ff <thread_create+0xd7>
	return -E_NO_MEM;
  80aa4e:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80aa53:	eb bc                	jmp    80aa11 <thread_create+0xe9>

0080aa55 <thread_yield>:
    // when yield has no thread to run, it will return here!
    exit();
}

void
thread_yield(void) {
  80aa55:	f3 0f 1e fb          	endbr32 
  80aa59:	55                   	push   %ebp
  80aa5a:	89 e5                	mov    %esp,%ebp
  80aa5c:	53                   	push   %ebx
  80aa5d:	83 ec 04             	sub    $0x4,%esp
}

static inline struct thread_context *
threadq_pop(struct thread_queue *tq)
{
    if (!tq->tq_first)
  80aa60:	8b 1d 88 b1 b3 00    	mov    0xb3b188,%ebx
  80aa66:	85 db                	test   %ebx,%ebx
  80aa68:	74 2b                	je     80aa95 <thread_yield+0x40>
	return 0;

    struct thread_context *tc = tq->tq_first;
    tq->tq_first = tc->tc_queue_link;
  80aa6a:	8b 43 64             	mov    0x64(%ebx),%eax
  80aa6d:	a3 88 b1 b3 00       	mov    %eax,0xb3b188
    tc->tc_queue_link = 0;
  80aa72:	c7 43 64 00 00 00 00 	movl   $0x0,0x64(%ebx)
    struct thread_context *next_tc = threadq_pop(&thread_queue);

    if (!next_tc)
	return;

    if (cur_tc) {
  80aa79:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
  80aa7e:	85 c0                	test   %eax,%eax
  80aa80:	74 3b                	je     80aabd <thread_yield+0x68>
	if (jos_setjmp(&cur_tc->tc_jb) != 0)
  80aa82:	83 ec 0c             	sub    $0xc,%esp
  80aa85:	83 c0 30             	add    $0x30,%eax
  80aa88:	50                   	push   %eax
  80aa89:	e8 82 01 00 00       	call   80ac10 <jos_setjmp>
  80aa8e:	83 c4 10             	add    $0x10,%esp
  80aa91:	85 c0                	test   %eax,%eax
  80aa93:	74 05                	je     80aa9a <thread_yield+0x45>
	threadq_push(&thread_queue, cur_tc);
    }

    cur_tc = next_tc;
    jos_longjmp(&cur_tc->tc_jb, 1);
}
  80aa95:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80aa98:	c9                   	leave  
  80aa99:	c3                   	ret    
	threadq_push(&thread_queue, cur_tc);
  80aa9a:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
    tc->tc_queue_link = 0;
  80aa9f:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)
    if (!tq->tq_first) {
  80aaa6:	83 3d 88 b1 b3 00 00 	cmpl   $0x0,0xb3b188
  80aaad:	74 21                	je     80aad0 <thread_yield+0x7b>
	tq->tq_last->tc_queue_link = tc;
  80aaaf:	8b 15 8c b1 b3 00    	mov    0xb3b18c,%edx
  80aab5:	89 42 64             	mov    %eax,0x64(%edx)
	tq->tq_last = tc;
  80aab8:	a3 8c b1 b3 00       	mov    %eax,0xb3b18c
    cur_tc = next_tc;
  80aabd:	89 1d 90 b1 b3 00    	mov    %ebx,0xb3b190
    jos_longjmp(&cur_tc->tc_jb, 1);
  80aac3:	8d 43 30             	lea    0x30(%ebx),%eax
  80aac6:	ba 01 00 00 00       	mov    $0x1,%edx
  80aacb:	e8 70 01 00 00       	call   80ac40 <jos_longjmp>
	tq->tq_first = tc;
  80aad0:	a3 88 b1 b3 00       	mov    %eax,0xb3b188
	tq->tq_last = tc;
  80aad5:	a3 8c b1 b3 00       	mov    %eax,0xb3b18c
  80aada:	eb e1                	jmp    80aabd <thread_yield+0x68>

0080aadc <thread_wait>:
thread_wait(volatile uint32_t *addr, uint32_t val, uint32_t msec) {
  80aadc:	f3 0f 1e fb          	endbr32 
  80aae0:	55                   	push   %ebp
  80aae1:	89 e5                	mov    %esp,%ebp
  80aae3:	57                   	push   %edi
  80aae4:	56                   	push   %esi
  80aae5:	53                   	push   %ebx
  80aae6:	83 ec 0c             	sub    $0xc,%esp
  80aae9:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80aaec:	8b 7d 10             	mov    0x10(%ebp),%edi
    uint32_t s = sys_time_msec();
  80aaef:	e8 97 4b 00 00       	call   80f68b <sys_time_msec>
  80aaf4:	89 c6                	mov    %eax,%esi
    cur_tc->tc_wait_addr = addr;
  80aaf6:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
  80aafb:	89 58 48             	mov    %ebx,0x48(%eax)
    cur_tc->tc_wakeup = 0;
  80aafe:	c6 40 4c 00          	movb   $0x0,0x4c(%eax)
    uint32_t p = s;
  80ab02:	89 f0                	mov    %esi,%eax
    while (p < msec) {
  80ab04:	eb 17                	jmp    80ab1d <thread_wait+0x41>
	if (cur_tc->tc_wakeup)
  80ab06:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
  80ab0b:	0f b6 40 4c          	movzbl 0x4c(%eax),%eax
  80ab0f:	84 c0                	test   %al,%al
  80ab11:	75 1d                	jne    80ab30 <thread_wait+0x54>
	thread_yield();
  80ab13:	e8 3d ff ff ff       	call   80aa55 <thread_yield>
	p = sys_time_msec();
  80ab18:	e8 6e 4b 00 00       	call   80f68b <sys_time_msec>
	if (p < s)
  80ab1d:	39 f0                	cmp    %esi,%eax
  80ab1f:	72 0f                	jb     80ab30 <thread_wait+0x54>
  80ab21:	39 f8                	cmp    %edi,%eax
  80ab23:	73 0b                	jae    80ab30 <thread_wait+0x54>
	if (addr && *addr != val)
  80ab25:	85 db                	test   %ebx,%ebx
  80ab27:	74 dd                	je     80ab06 <thread_wait+0x2a>
  80ab29:	8b 03                	mov    (%ebx),%eax
  80ab2b:	3b 45 0c             	cmp    0xc(%ebp),%eax
  80ab2e:	74 d6                	je     80ab06 <thread_wait+0x2a>
    cur_tc->tc_wait_addr = 0;
  80ab30:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
  80ab35:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
    cur_tc->tc_wakeup = 0;
  80ab3c:	c6 40 4c 00          	movb   $0x0,0x4c(%eax)
}
  80ab40:	83 c4 0c             	add    $0xc,%esp
  80ab43:	5b                   	pop    %ebx
  80ab44:	5e                   	pop    %esi
  80ab45:	5f                   	pop    %edi
  80ab46:	5d                   	pop    %ebp
  80ab47:	c3                   	ret    

0080ab48 <thread_halt>:
thread_halt() {
  80ab48:	f3 0f 1e fb          	endbr32 
  80ab4c:	55                   	push   %ebp
  80ab4d:	89 e5                	mov    %esp,%ebp
  80ab4f:	56                   	push   %esi
  80ab50:	53                   	push   %ebx
    if (!tq->tq_first)
  80ab51:	8b 1d 80 b1 b3 00    	mov    0xb3b180,%ebx
  80ab57:	85 db                	test   %ebx,%ebx
  80ab59:	74 40                	je     80ab9b <thread_halt+0x53>
    tq->tq_first = tc->tc_queue_link;
  80ab5b:	8b 43 64             	mov    0x64(%ebx),%eax
  80ab5e:	a3 80 b1 b3 00       	mov    %eax,0xb3b180
    tc->tc_queue_link = 0;
  80ab63:	c7 43 64 00 00 00 00 	movl   $0x0,0x64(%ebx)
  80ab6a:	be 00 00 00 00       	mov    $0x0,%esi
  80ab6f:	eb 0f                	jmp    80ab80 <thread_halt+0x38>
	tc->tc_onhalt[i](tc->tc_tid);
  80ab71:	83 ec 0c             	sub    $0xc,%esp
  80ab74:	ff 33                	pushl  (%ebx)
  80ab76:	ff 54 b3 50          	call   *0x50(%ebx,%esi,4)
    for (i = 0; i < tc->tc_nonhalt; i++)
  80ab7a:	83 c6 01             	add    $0x1,%esi
  80ab7d:	83 c4 10             	add    $0x10,%esp
  80ab80:	3b 73 60             	cmp    0x60(%ebx),%esi
  80ab83:	7c ec                	jl     80ab71 <thread_halt+0x29>
    free(tc->tc_stack_bottom);
  80ab85:	83 ec 0c             	sub    $0xc,%esp
  80ab88:	ff 73 04             	pushl  0x4(%ebx)
  80ab8b:	e8 c4 5c 00 00       	call   810854 <free>
    free(tc);
  80ab90:	89 1c 24             	mov    %ebx,(%esp)
  80ab93:	e8 bc 5c 00 00       	call   810854 <free>
  80ab98:	83 c4 10             	add    $0x10,%esp
    threadq_push(&kill_queue, cur_tc);
  80ab9b:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
    tc->tc_queue_link = 0;
  80aba0:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)
    if (!tq->tq_first) {
  80aba7:	83 3d 80 b1 b3 00 00 	cmpl   $0x0,0xb3b180
  80abae:	74 29                	je     80abd9 <thread_halt+0x91>
	tq->tq_last->tc_queue_link = tc;
  80abb0:	8b 15 84 b1 b3 00    	mov    0xb3b184,%edx
  80abb6:	89 42 64             	mov    %eax,0x64(%edx)
	tq->tq_last = tc;
  80abb9:	a3 84 b1 b3 00       	mov    %eax,0xb3b184
    cur_tc = NULL;
  80abbe:	c7 05 90 b1 b3 00 00 	movl   $0x0,0xb3b190
  80abc5:	00 00 00 
    thread_yield();
  80abc8:	e8 88 fe ff ff       	call   80aa55 <thread_yield>
    exit();
  80abcd:	e8 57 3d 00 00       	call   80e929 <exit>
}
  80abd2:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80abd5:	5b                   	pop    %ebx
  80abd6:	5e                   	pop    %esi
  80abd7:	5d                   	pop    %ebp
  80abd8:	c3                   	ret    
	tq->tq_first = tc;
  80abd9:	a3 80 b1 b3 00       	mov    %eax,0xb3b180
	tq->tq_last = tc;
  80abde:	a3 84 b1 b3 00       	mov    %eax,0xb3b184
  80abe3:	eb d9                	jmp    80abbe <thread_halt+0x76>

0080abe5 <thread_entry>:
thread_entry(void) {
  80abe5:	f3 0f 1e fb          	endbr32 
  80abe9:	55                   	push   %ebp
  80abea:	89 e5                	mov    %esp,%ebp
  80abec:	83 ec 14             	sub    $0x14,%esp
    cur_tc->tc_entry(cur_tc->tc_arg);
  80abef:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
  80abf4:	ff 70 2c             	pushl  0x2c(%eax)
  80abf7:	ff 50 28             	call   *0x28(%eax)
    thread_halt();
  80abfa:	e8 49 ff ff ff       	call   80ab48 <thread_halt>
}
  80abff:	83 c4 10             	add    $0x10,%esp
  80ac02:	c9                   	leave  
  80ac03:	c3                   	ret    
  80ac04:	66 90                	xchg   %ax,%ax
  80ac06:	66 90                	xchg   %ax,%ax
  80ac08:	66 90                	xchg   %ax,%ax
  80ac0a:	66 90                	xchg   %ax,%ax
  80ac0c:	66 90                	xchg   %ax,%ax
  80ac0e:	66 90                	xchg   %ax,%ax

0080ac10 <jos_setjmp>:
#define ENTRY(x) \
        .text; _ALIGN_TEXT; .globl x; .type x,@function; x:


ENTRY(jos_setjmp)
	movl	4(%esp), %ecx	// jos_jmp_buf
  80ac10:	8b 4c 24 04          	mov    0x4(%esp),%ecx

	movl	0(%esp), %edx	// %eip as pushed by call
  80ac14:	8b 14 24             	mov    (%esp),%edx
	movl	%edx,  0(%ecx)
  80ac17:	89 11                	mov    %edx,(%ecx)

	leal	4(%esp), %edx	// where %esp will point when we return
  80ac19:	8d 54 24 04          	lea    0x4(%esp),%edx
	movl	%edx,  4(%ecx)
  80ac1d:	89 51 04             	mov    %edx,0x4(%ecx)

	movl	%ebp,  8(%ecx)
  80ac20:	89 69 08             	mov    %ebp,0x8(%ecx)
	movl	%ebx, 12(%ecx)
  80ac23:	89 59 0c             	mov    %ebx,0xc(%ecx)
	movl	%esi, 16(%ecx)
  80ac26:	89 71 10             	mov    %esi,0x10(%ecx)
	movl	%edi, 20(%ecx)
  80ac29:	89 79 14             	mov    %edi,0x14(%ecx)

	movl	$0, %eax
  80ac2c:	b8 00 00 00 00       	mov    $0x0,%eax
	ret
  80ac31:	c3                   	ret    
  80ac32:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  80ac39:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

0080ac40 <jos_longjmp>:

ENTRY(jos_longjmp)
	// %eax is the jos_jmp_buf*
	// %edx is the return value

	movl	 0(%eax), %ecx	// %eip
  80ac40:	8b 08                	mov    (%eax),%ecx
	movl	 4(%eax), %esp
  80ac42:	8b 60 04             	mov    0x4(%eax),%esp
	movl	 8(%eax), %ebp
  80ac45:	8b 68 08             	mov    0x8(%eax),%ebp
	movl	12(%eax), %ebx
  80ac48:	8b 58 0c             	mov    0xc(%eax),%ebx
	movl	16(%eax), %esi
  80ac4b:	8b 70 10             	mov    0x10(%eax),%esi
	movl	20(%eax), %edi
  80ac4e:	8b 78 14             	mov    0x14(%eax),%edi

	movl	%edx, %eax
  80ac51:	89 d0                	mov    %edx,%eax
	jmp	*%ecx
  80ac53:	ff e1                	jmp    *%ecx

0080ac55 <perror>:
  [ENSRQUERYDOMAINTOOLONG] = "ENSRQUERYDOMAINTOOLONG",  /* Domain name is too long */
  [ENSRCNAMELOOP] = "ENSRCNAMELOOP" /* Domain name is too long */
};

void
perror(const char *s) {
  80ac55:	f3 0f 1e fb          	endbr32 
  80ac59:	55                   	push   %ebp
  80ac5a:	89 e5                	mov    %esp,%ebp
  80ac5c:	83 ec 0c             	sub    $0xc,%esp
	cprintf("%s: %s\n", s, e2s(err));
}

const char *
e2s(int err) {
	return sys_errlist[err];
  80ac5f:	a1 e0 b1 b3 00       	mov    0xb3b1e0,%eax
	cprintf("%s: %s\n", s, e2s(err));
  80ac64:	ff 34 85 20 40 81 00 	pushl  0x814020(,%eax,4)
  80ac6b:	ff 75 08             	pushl  0x8(%ebp)
  80ac6e:	68 bf 2b 81 00       	push   $0x812bbf
  80ac73:	e8 b6 3d 00 00       	call   80ea2e <cprintf>
}
  80ac78:	83 c4 10             	add    $0x10,%esp
  80ac7b:	c9                   	leave  
  80ac7c:	c3                   	ret    

0080ac7d <e2s>:
e2s(int err) {
  80ac7d:	f3 0f 1e fb          	endbr32 
  80ac81:	55                   	push   %ebp
  80ac82:	89 e5                	mov    %esp,%ebp
	return sys_errlist[err];
  80ac84:	8b 45 08             	mov    0x8(%ebp),%eax
  80ac87:	8b 04 85 20 40 81 00 	mov    0x814020(,%eax,4),%eax
}
  80ac8e:	5d                   	pop    %ebp
  80ac8f:	c3                   	ret    

0080ac90 <low_level_output>:
 * might be chained.
 *
 */
static err_t
low_level_output(struct netif *netif, struct pbuf *p)
{
  80ac90:	f3 0f 1e fb          	endbr32 
  80ac94:	55                   	push   %ebp
  80ac95:	89 e5                	mov    %esp,%ebp
  80ac97:	57                   	push   %edi
  80ac98:	56                   	push   %esi
  80ac99:	53                   	push   %ebx
  80ac9a:	83 ec 20             	sub    $0x20,%esp
  80ac9d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    int r = sys_page_alloc(0, (void *)PKTMAP, PTE_U|PTE_W|PTE_P);
  80aca0:	6a 07                	push   $0x7
  80aca2:	68 00 00 00 10       	push   $0x10000000
  80aca7:	6a 00                	push   $0x0
  80aca9:	e8 cc 47 00 00       	call   80f47a <sys_page_alloc>
    if (r < 0)
  80acae:	83 c4 10             	add    $0x10,%esp
  80acb1:	85 c0                	test   %eax,%eax
  80acb3:	78 49                	js     80acfe <low_level_output+0x6e>
	panic("jif: could not allocate page of memory");
    struct jif_pkt *pkt = (struct jif_pkt *)PKTMAP;

    struct jif *jif;
    jif = netif->state;
  80acb5:	8b 45 08             	mov    0x8(%ebp),%eax
  80acb8:	8b 40 1c             	mov    0x1c(%eax),%eax
  80acbb:	89 45 e4             	mov    %eax,-0x1c(%ebp)

    char *txbuf = pkt->jp_data;
  80acbe:	bf 04 00 00 10       	mov    $0x10000004,%edi
    int txsize = 0;
  80acc3:	be 00 00 00 00       	mov    $0x0,%esi
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  80acc8:	85 db                	test   %ebx,%ebx
  80acca:	74 5c                	je     80ad28 <low_level_output+0x98>
	/* Send the data from the pbuf to the interface, one pbuf at a
	   time. The size of the data in each pbuf is kept in the ->len
	   variable. */

	if (txsize + q->len > 2000)
  80accc:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80acd0:	0f b7 d0             	movzwl %ax,%edx
  80acd3:	8d 0c 32             	lea    (%edx,%esi,1),%ecx
  80acd6:	81 f9 d0 07 00 00    	cmp    $0x7d0,%ecx
  80acdc:	7f 34                	jg     80ad12 <low_level_output+0x82>
	    panic("oversized packet, fragment %d txsize %d\n", q->len, txsize);
	memcpy(&txbuf[txsize], q->payload, q->len);
  80acde:	83 ec 04             	sub    $0x4,%esp
  80ace1:	0f b7 c0             	movzwl %ax,%eax
  80ace4:	50                   	push   %eax
  80ace5:	ff 73 04             	pushl  0x4(%ebx)
  80ace8:	8d 04 37             	lea    (%edi,%esi,1),%eax
  80aceb:	50                   	push   %eax
  80acec:	e8 63 45 00 00       	call   80f254 <memcpy>
	txsize += q->len;
  80acf1:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80acf5:	01 c6                	add    %eax,%esi
    for (q = p; q != NULL; q = q->next) {
  80acf7:	8b 1b                	mov    (%ebx),%ebx
  80acf9:	83 c4 10             	add    $0x10,%esp
  80acfc:	eb ca                	jmp    80acc8 <low_level_output+0x38>
	panic("jif: could not allocate page of memory");
  80acfe:	83 ec 04             	sub    $0x4,%esp
  80ad01:	68 a4 30 81 00       	push   $0x8130a4
  80ad06:	6a 55                	push   $0x55
  80ad08:	68 f5 30 81 00       	push   $0x8130f5
  80ad0d:	e8 35 3c 00 00       	call   80e947 <_panic>
	    panic("oversized packet, fragment %d txsize %d\n", q->len, txsize);
  80ad12:	83 ec 0c             	sub    $0xc,%esp
  80ad15:	56                   	push   %esi
  80ad16:	52                   	push   %edx
  80ad17:	68 cc 30 81 00       	push   $0x8130cc
  80ad1c:	6a 64                	push   $0x64
  80ad1e:	68 f5 30 81 00       	push   $0x8130f5
  80ad23:	e8 1f 3c 00 00       	call   80e947 <_panic>
    }

    pkt->jp_len = txsize;
  80ad28:	89 35 00 00 00 10    	mov    %esi,0x10000000

    ipc_send(jif->envid, NSREQ_OUTPUT, (void *)pkt, PTE_P|PTE_W|PTE_U);
  80ad2e:	6a 07                	push   $0x7
  80ad30:	68 00 00 00 10       	push   $0x10000000
  80ad35:	6a 0b                	push   $0xb
  80ad37:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80ad3a:	ff 70 04             	pushl  0x4(%eax)
  80ad3d:	e8 76 4d 00 00       	call   80fab8 <ipc_send>
    sys_page_unmap(0, (void *)pkt);
  80ad42:	83 c4 08             	add    $0x8,%esp
  80ad45:	68 00 00 00 10       	push   $0x10000000
  80ad4a:	6a 00                	push   $0x0
  80ad4c:	e8 b6 47 00 00       	call   80f507 <sys_page_unmap>

    return ERR_OK;
}
  80ad51:	b8 00 00 00 00       	mov    $0x0,%eax
  80ad56:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80ad59:	5b                   	pop    %ebx
  80ad5a:	5e                   	pop    %esi
  80ad5b:	5f                   	pop    %edi
  80ad5c:	5d                   	pop    %ebp
  80ad5d:	c3                   	ret    

0080ad5e <jif_output>:
 */

static err_t
jif_output(struct netif *netif, struct pbuf *p,
      struct ip_addr *ipaddr)
{
  80ad5e:	f3 0f 1e fb          	endbr32 
  80ad62:	55                   	push   %ebp
  80ad63:	89 e5                	mov    %esp,%ebp
  80ad65:	83 ec 0c             	sub    $0xc,%esp
    /* resolve hardware address, then send (or queue) packet */
    return etharp_output(netif, p, ipaddr);
  80ad68:	ff 75 10             	pushl  0x10(%ebp)
  80ad6b:	ff 75 0c             	pushl  0xc(%ebp)
  80ad6e:	ff 75 08             	pushl  0x8(%ebp)
  80ad71:	e8 81 f0 ff ff       	call   809df7 <etharp_output>
}
  80ad76:	c9                   	leave  
  80ad77:	c3                   	ret    

0080ad78 <jif_input>:
 *
 */

void
jif_input(struct netif *netif, void *va)
{
  80ad78:	f3 0f 1e fb          	endbr32 
  80ad7c:	55                   	push   %ebp
  80ad7d:	89 e5                	mov    %esp,%ebp
  80ad7f:	57                   	push   %edi
  80ad80:	56                   	push   %esi
  80ad81:	53                   	push   %ebx
  80ad82:	83 ec 20             	sub    $0x20,%esp
  80ad85:	8b 7d 0c             	mov    0xc(%ebp),%edi
    struct jif *jif;
    struct eth_hdr *ethhdr;
    struct pbuf *p;

    jif = netif->state;
  80ad88:	8b 45 08             	mov    0x8(%ebp),%eax
  80ad8b:	8b 40 1c             	mov    0x1c(%eax),%eax
  80ad8e:	89 45 d8             	mov    %eax,-0x28(%ebp)
    s16_t len = pkt->jp_len;
  80ad91:	8b 07                	mov    (%edi),%eax
  80ad93:	89 c6                	mov    %eax,%esi
    struct pbuf *p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
  80ad95:	6a 03                	push   $0x3
  80ad97:	0f b7 c0             	movzwl %ax,%eax
  80ad9a:	50                   	push   %eax
  80ad9b:	6a 03                	push   $0x3
  80ad9d:	e8 49 9d ff ff       	call   804aeb <pbuf_alloc>
    if (p == 0)
  80ada2:	83 c4 10             	add    $0x10,%esp
  80ada5:	85 c0                	test   %eax,%eax
  80ada7:	0f 84 9c 00 00 00    	je     80ae49 <jif_input+0xd1>
  80adad:	89 c3                	mov    %eax,%ebx
    void *rxbuf = (void *) pkt->jp_data;
  80adaf:	8d 47 04             	lea    0x4(%edi),%eax
  80adb2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    for (q = p; q != NULL; q = q->next) {
  80adb5:	89 df                	mov    %ebx,%edi
    int copied = 0;
  80adb7:	ba 00 00 00 00       	mov    $0x0,%edx
	if (bytes > (len - copied))
  80adbc:	0f bf c6             	movswl %si,%eax
  80adbf:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80adc2:	89 5d dc             	mov    %ebx,-0x24(%ebp)
  80adc5:	89 d3                	mov    %edx,%ebx
	int bytes = q->len;
  80adc7:	0f b7 47 0a          	movzwl 0xa(%edi),%eax
	if (bytes > (len - copied))
  80adcb:	8b 75 e0             	mov    -0x20(%ebp),%esi
  80adce:	29 de                	sub    %ebx,%esi
  80add0:	39 c6                	cmp    %eax,%esi
  80add2:	0f 4f f0             	cmovg  %eax,%esi
	memcpy(q->payload, rxbuf + copied, bytes);
  80add5:	83 ec 04             	sub    $0x4,%esp
  80add8:	56                   	push   %esi
  80add9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80addc:	01 d8                	add    %ebx,%eax
  80adde:	50                   	push   %eax
  80addf:	ff 77 04             	pushl  0x4(%edi)
  80ade2:	e8 6d 44 00 00       	call   80f254 <memcpy>
	copied += bytes;
  80ade7:	01 f3                	add    %esi,%ebx
    for (q = p; q != NULL; q = q->next) {
  80ade9:	8b 3f                	mov    (%edi),%edi
  80adeb:	83 c4 10             	add    $0x10,%esp
  80adee:	85 ff                	test   %edi,%edi
  80adf0:	75 d5                	jne    80adc7 <jif_input+0x4f>
  80adf2:	8b 5d dc             	mov    -0x24(%ebp),%ebx
    /* no packet could be read, silently ignore this */
    if (p == NULL) return;
    /* points to packet payload, which starts with an Ethernet header */
    ethhdr = p->payload;

    switch (htons(ethhdr->type)) {
  80adf5:	83 ec 0c             	sub    $0xc,%esp
  80adf8:	8b 43 04             	mov    0x4(%ebx),%eax
  80adfb:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80adff:	50                   	push   %eax
  80ae00:	e8 54 cb ff ff       	call   807959 <htons>
  80ae05:	83 c4 10             	add    $0x10,%esp
  80ae08:	66 3d 00 08          	cmp    $0x800,%ax
  80ae0c:	74 14                	je     80ae22 <jif_input+0xaa>
  80ae0e:	66 3d 06 08          	cmp    $0x806,%ax
  80ae12:	74 3d                	je     80ae51 <jif_input+0xd9>
	/* pass p to ARP module  */
	etharp_arp_input(netif, jif->ethaddr, p);
	break;

    default:
	pbuf_free(p);
  80ae14:	83 ec 0c             	sub    $0xc,%esp
  80ae17:	53                   	push   %ebx
  80ae18:	e8 04 9c ff ff       	call   804a21 <pbuf_free>
  80ae1d:	83 c4 10             	add    $0x10,%esp
  80ae20:	eb 27                	jmp    80ae49 <jif_input+0xd1>
	etharp_ip_input(netif, p);
  80ae22:	83 ec 08             	sub    $0x8,%esp
  80ae25:	53                   	push   %ebx
  80ae26:	ff 75 08             	pushl  0x8(%ebp)
  80ae29:	e8 2d ea ff ff       	call   80985b <etharp_ip_input>
	pbuf_header(p, -(int)sizeof(struct eth_hdr));
  80ae2e:	83 c4 08             	add    $0x8,%esp
  80ae31:	6a f2                	push   $0xfffffff2
  80ae33:	53                   	push   %ebx
  80ae34:	e8 15 9b ff ff       	call   80494e <pbuf_header>
	netif->input(p, netif);
  80ae39:	83 c4 08             	add    $0x8,%esp
  80ae3c:	ff 75 08             	pushl  0x8(%ebp)
  80ae3f:	53                   	push   %ebx
  80ae40:	8b 45 08             	mov    0x8(%ebp),%eax
  80ae43:	ff 50 10             	call   *0x10(%eax)
	break;
  80ae46:	83 c4 10             	add    $0x10,%esp
    }
}
  80ae49:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80ae4c:	5b                   	pop    %ebx
  80ae4d:	5e                   	pop    %esi
  80ae4e:	5f                   	pop    %edi
  80ae4f:	5d                   	pop    %ebp
  80ae50:	c3                   	ret    
	etharp_arp_input(netif, jif->ethaddr, p);
  80ae51:	83 ec 04             	sub    $0x4,%esp
  80ae54:	53                   	push   %ebx
  80ae55:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80ae58:	ff 30                	pushl  (%eax)
  80ae5a:	ff 75 08             	pushl  0x8(%ebp)
  80ae5d:	e8 49 ea ff ff       	call   8098ab <etharp_arp_input>
	break;
  80ae62:	83 c4 10             	add    $0x10,%esp
  80ae65:	eb e2                	jmp    80ae49 <jif_input+0xd1>

0080ae67 <jif_init>:
 *
 */

err_t
jif_init(struct netif *netif)
{
  80ae67:	f3 0f 1e fb          	endbr32 
  80ae6b:	55                   	push   %ebp
  80ae6c:	89 e5                	mov    %esp,%ebp
  80ae6e:	57                   	push   %edi
  80ae6f:	56                   	push   %esi
  80ae70:	53                   	push   %ebx
  80ae71:	83 ec 28             	sub    $0x28,%esp
  80ae74:	8b 5d 08             	mov    0x8(%ebp),%ebx
    struct jif *jif;
    envid_t *output_envid; 

    jif = mem_malloc(sizeof(struct jif));
  80ae77:	6a 08                	push   $0x8
  80ae79:	e8 65 95 ff ff       	call   8043e3 <mem_malloc>

    if (jif == NULL) {
  80ae7e:	83 c4 10             	add    $0x10,%esp
  80ae81:	85 c0                	test   %eax,%eax
  80ae83:	0f 84 87 00 00 00    	je     80af10 <jif_init+0xa9>
  80ae89:	89 c6                	mov    %eax,%esi
	LWIP_DEBUGF(NETIF_DEBUG, ("jif_init: out of memory\n"));
	return ERR_MEM;
    }

    output_envid = (envid_t *)netif->state;
  80ae8b:	8b 7b 1c             	mov    0x1c(%ebx),%edi

    netif->state = jif;
  80ae8e:	89 43 1c             	mov    %eax,0x1c(%ebx)
    netif->output = jif_output;
  80ae91:	c7 43 14 5e ad 80 00 	movl   $0x80ad5e,0x14(%ebx)
    netif->linkoutput = low_level_output;
  80ae98:	c7 43 18 90 ac 80 00 	movl   $0x80ac90,0x18(%ebx)
    memcpy(&netif->name[0], "en", 2);
  80ae9f:	83 ec 04             	sub    $0x4,%esp
  80aea2:	6a 02                	push   $0x2
  80aea4:	68 cc 3d 81 00       	push   $0x813dcc
  80aea9:	8d 43 2f             	lea    0x2f(%ebx),%eax
  80aeac:	50                   	push   %eax
  80aead:	e8 a2 43 00 00       	call   80f254 <memcpy>

    jif->ethaddr = (struct eth_addr *)&(netif->hwaddr[0]);
  80aeb2:	8d 43 25             	lea    0x25(%ebx),%eax
  80aeb5:	89 06                	mov    %eax,(%esi)
    jif->envid = *output_envid; 
  80aeb7:	8b 07                	mov    (%edi),%eax
  80aeb9:	89 46 04             	mov    %eax,0x4(%esi)
    netif->hwaddr_len = 6;
  80aebc:	c6 43 24 06          	movb   $0x6,0x24(%ebx)
    netif->mtu = 1500;
  80aec0:	66 c7 43 2c dc 05    	movw   $0x5dc,0x2c(%ebx)
    netif->flags = NETIF_FLAG_BROADCAST;
  80aec6:	c6 43 2e 02          	movb   $0x2,0x2e(%ebx)
    netif->hwaddr[0] = 0x52;
  80aeca:	c6 43 25 52          	movb   $0x52,0x25(%ebx)
    netif->hwaddr[1] = 0x54;
  80aece:	c6 43 26 54          	movb   $0x54,0x26(%ebx)
    netif->hwaddr[2] = 0x00;
  80aed2:	c6 43 27 00          	movb   $0x0,0x27(%ebx)
    netif->hwaddr[3] = 0x12;
  80aed6:	c6 43 28 12          	movb   $0x12,0x28(%ebx)
    netif->hwaddr[4] = 0x34;
  80aeda:	c6 43 29 34          	movb   $0x34,0x29(%ebx)
    netif->hwaddr[5] = 0x56;
  80aede:	c6 43 2a 56          	movb   $0x56,0x2a(%ebx)
    etharp_init();

    // qemu user-net is dumb; if the host OS does not send and ARP request
    // first, the qemu will send packets destined for the host using the mac
    // addr 00:00:00:00:00; do a arp request for the user-net NAT at 10.0.2.2
    uint32_t ipaddr = inet_addr("10.0.2.2");
  80aee2:	c7 04 24 eb 14 81 00 	movl   $0x8114eb,(%esp)
  80aee9:	e8 94 cc ff ff       	call   807b82 <inet_addr>
  80aeee:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    etharp_query(netif, (struct ip_addr *) &ipaddr, 0);
  80aef1:	83 c4 0c             	add    $0xc,%esp
  80aef4:	6a 00                	push   $0x0
  80aef6:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80aef9:	50                   	push   %eax
  80aefa:	53                   	push   %ebx
  80aefb:	e8 bf ec ff ff       	call   809bbf <etharp_query>

    return ERR_OK;
  80af00:	83 c4 10             	add    $0x10,%esp
  80af03:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80af08:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80af0b:	5b                   	pop    %ebx
  80af0c:	5e                   	pop    %esi
  80af0d:	5f                   	pop    %edi
  80af0e:	5d                   	pop    %ebp
  80af0f:	c3                   	ret    
	return ERR_MEM;
  80af10:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80af15:	eb f1                	jmp    80af08 <jif_init+0xa1>

0080af17 <netconn_new_with_proto_and_callback>:
 * @return a newly allocated struct netconn or
 *         NULL on memory error
 */
struct netconn*
netconn_new_with_proto_and_callback(enum netconn_type t, u8_t proto, netconn_callback callback)
{
  80af17:	f3 0f 1e fb          	endbr32 
  80af1b:	55                   	push   %ebp
  80af1c:	89 e5                	mov    %esp,%ebp
  80af1e:	56                   	push   %esi
  80af1f:	53                   	push   %ebx
  80af20:	83 ec 28             	sub    $0x28,%esp
  80af23:	8b 75 0c             	mov    0xc(%ebp),%esi
  struct netconn *conn;
  struct api_msg msg;

  conn = netconn_alloc(t, callback);
  80af26:	ff 75 10             	pushl  0x10(%ebp)
  80af29:	ff 75 08             	pushl  0x8(%ebp)
  80af2c:	e8 9b 0f 00 00       	call   80becc <netconn_alloc>
  80af31:	89 c3                	mov    %eax,%ebx
  
  if (conn != NULL ) {
  80af33:	83 c4 10             	add    $0x10,%esp
  80af36:	85 c0                	test   %eax,%eax
  80af38:	74 63                	je     80af9d <netconn_new_with_proto_and_callback+0x86>
    msg.function = do_newconn;
  80af3a:	c7 45 e4 bf bd 80 00 	movl   $0x80bdbf,-0x1c(%ebp)
    msg.msg.msg.n.proto = proto;
  80af41:	89 f0                	mov    %esi,%eax
  80af43:	88 45 ec             	mov    %al,-0x14(%ebp)
    msg.msg.conn = conn;
  80af46:	89 5d e8             	mov    %ebx,-0x18(%ebp)
    TCPIP_APIMSG(&msg);
  80af49:	83 ec 0c             	sub    $0xc,%esp
  80af4c:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80af4f:	50                   	push   %eax
  80af50:	e8 a8 75 ff ff       	call   8024fd <tcpip_apimsg>

    if (conn->err != ERR_OK) {
  80af55:	83 c4 10             	add    $0x10,%esp
  80af58:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
  80af5c:	74 3f                	je     80af9d <netconn_new_with_proto_and_callback+0x86>
      LWIP_ASSERT("freeing conn without freeing pcb", conn->pcb.tcp == NULL);
  80af5e:	8b 73 08             	mov    0x8(%ebx),%esi
  80af61:	85 f6                	test   %esi,%esi
  80af63:	75 41                	jne    80afa6 <netconn_new_with_proto_and_callback+0x8f>
      LWIP_ASSERT("conn has no op_completed", conn->op_completed != SYS_SEM_NULL);
  80af65:	8b 43 10             	mov    0x10(%ebx),%eax
  80af68:	83 f8 ff             	cmp    $0xffffffff,%eax
  80af6b:	74 4d                	je     80afba <netconn_new_with_proto_and_callback+0xa3>
      LWIP_ASSERT("conn has no recvmbox", conn->recvmbox != SYS_MBOX_NULL);
  80af6d:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80af71:	74 5b                	je     80afce <netconn_new_with_proto_and_callback+0xb7>
      LWIP_ASSERT("conn->acceptmbox shouldn't exist", conn->acceptmbox == SYS_MBOX_NULL);
  80af73:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80af77:	75 69                	jne    80afe2 <netconn_new_with_proto_and_callback+0xcb>
      sys_sem_free(conn->op_completed);
  80af79:	83 ec 0c             	sub    $0xc,%esp
  80af7c:	50                   	push   %eax
  80af7d:	e8 a9 f1 ff ff       	call   80a12b <sys_sem_free>
      sys_mbox_free(conn->recvmbox);
  80af82:	83 c4 04             	add    $0x4,%esp
  80af85:	ff 73 14             	pushl  0x14(%ebx)
  80af88:	e8 2b f2 ff ff       	call   80a1b8 <sys_mbox_free>
      memp_free(MEMP_NETCONN, conn);
  80af8d:	83 c4 08             	add    $0x8,%esp
  80af90:	53                   	push   %ebx
  80af91:	6a 07                	push   $0x7
  80af93:	e8 06 97 ff ff       	call   80469e <memp_free>
      return NULL;
  80af98:	83 c4 10             	add    $0x10,%esp
  80af9b:	89 f3                	mov    %esi,%ebx
    }
  }
  return conn;
}
  80af9d:	89 d8                	mov    %ebx,%eax
  80af9f:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80afa2:	5b                   	pop    %ebx
  80afa3:	5e                   	pop    %esi
  80afa4:	5d                   	pop    %ebp
  80afa5:	c3                   	ret    
      LWIP_ASSERT("freeing conn without freeing pcb", conn->pcb.tcp == NULL);
  80afa6:	83 ec 04             	sub    $0x4,%esp
  80afa9:	68 0c 31 81 00       	push   $0x81310c
  80afae:	6a 52                	push   $0x52
  80afb0:	68 be 31 81 00       	push   $0x8131be
  80afb5:	e8 8d 39 00 00       	call   80e947 <_panic>
      LWIP_ASSERT("conn has no op_completed", conn->op_completed != SYS_SEM_NULL);
  80afba:	83 ec 04             	sub    $0x4,%esp
  80afbd:	68 d5 31 81 00       	push   $0x8131d5
  80afc2:	6a 53                	push   $0x53
  80afc4:	68 be 31 81 00       	push   $0x8131be
  80afc9:	e8 79 39 00 00       	call   80e947 <_panic>
      LWIP_ASSERT("conn has no recvmbox", conn->recvmbox != SYS_MBOX_NULL);
  80afce:	83 ec 04             	sub    $0x4,%esp
  80afd1:	68 ee 31 81 00       	push   $0x8131ee
  80afd6:	6a 54                	push   $0x54
  80afd8:	68 be 31 81 00       	push   $0x8131be
  80afdd:	e8 65 39 00 00       	call   80e947 <_panic>
      LWIP_ASSERT("conn->acceptmbox shouldn't exist", conn->acceptmbox == SYS_MBOX_NULL);
  80afe2:	83 ec 04             	sub    $0x4,%esp
  80afe5:	68 30 31 81 00       	push   $0x813130
  80afea:	6a 55                	push   $0x55
  80afec:	68 be 31 81 00       	push   $0x8131be
  80aff1:	e8 51 39 00 00       	call   80e947 <_panic>

0080aff6 <netconn_delete>:
 * @param conn the netconn to delete
 * @return ERR_OK if the connection was deleted
 */
err_t
netconn_delete(struct netconn *conn)
{
  80aff6:	f3 0f 1e fb          	endbr32 
  80affa:	55                   	push   %ebp
  80affb:	89 e5                	mov    %esp,%ebp
  80affd:	53                   	push   %ebx
  80affe:	83 ec 24             	sub    $0x24,%esp
  80b001:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  /* No ASSERT here because possible to get a (conn == NULL) if we got an accept error */
  if (conn == NULL) {
  80b004:	85 db                	test   %ebx,%ebx
  80b006:	74 28                	je     80b030 <netconn_delete+0x3a>
    return ERR_OK;
  }

  msg.function = do_delconn;
  80b008:	c7 45 e4 17 c1 80 00 	movl   $0x80c117,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b00f:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  tcpip_apimsg(&msg);
  80b012:	83 ec 0c             	sub    $0xc,%esp
  80b015:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b018:	50                   	push   %eax
  80b019:	e8 df 74 ff ff       	call   8024fd <tcpip_apimsg>

  conn->pcb.tcp = NULL;
  80b01e:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  netconn_free(conn);
  80b025:	89 1c 24             	mov    %ebx,(%esp)
  80b028:	e8 51 0f 00 00       	call   80bf7e <netconn_free>

  return ERR_OK;
  80b02d:	83 c4 10             	add    $0x10,%esp
}
  80b030:	b8 00 00 00 00       	mov    $0x0,%eax
  80b035:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b038:	c9                   	leave  
  80b039:	c3                   	ret    

0080b03a <netconn_type>:
 * @param conn the netconn of which to get the type
 * @return the netconn_type of conn
 */
enum netconn_type
netconn_type(struct netconn *conn)
{
  80b03a:	f3 0f 1e fb          	endbr32 
  80b03e:	55                   	push   %ebp
  80b03f:	89 e5                	mov    %esp,%ebp
  80b041:	83 ec 08             	sub    $0x8,%esp
  80b044:	8b 45 08             	mov    0x8(%ebp),%eax
  LWIP_ERROR("netconn_type: invalid conn", (conn != NULL), return NETCONN_INVALID;);
  80b047:	85 c0                	test   %eax,%eax
  80b049:	74 04                	je     80b04f <netconn_type+0x15>
  80b04b:	8b 00                	mov    (%eax),%eax
  return conn->type;
}
  80b04d:	c9                   	leave  
  80b04e:	c3                   	ret    
  LWIP_ERROR("netconn_type: invalid conn", (conn != NULL), return NETCONN_INVALID;);
  80b04f:	83 ec 04             	sub    $0x4,%esp
  80b052:	68 03 32 81 00       	push   $0x813203
  80b057:	68 84 00 00 00       	push   $0x84
  80b05c:	68 be 31 81 00       	push   $0x8131be
  80b061:	e8 e1 38 00 00       	call   80e947 <_panic>

0080b066 <netconn_getaddr>:
 * @return ERR_CONN for invalid connections
 *         ERR_OK if the information was retrieved
 */
err_t
netconn_getaddr(struct netconn *conn, struct ip_addr *addr, u16_t *port, u8_t local)
{
  80b066:	f3 0f 1e fb          	endbr32 
  80b06a:	55                   	push   %ebp
  80b06b:	89 e5                	mov    %esp,%ebp
  80b06d:	53                   	push   %ebx
  80b06e:	83 ec 24             	sub    $0x24,%esp
  80b071:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b074:	8b 55 0c             	mov    0xc(%ebp),%edx
  80b077:	8b 45 10             	mov    0x10(%ebp),%eax
  80b07a:	8b 4d 14             	mov    0x14(%ebp),%ecx
  struct api_msg msg;

  LWIP_ERROR("netconn_getaddr: invalid conn", (conn != NULL), return ERR_ARG;);
  80b07d:	85 db                	test   %ebx,%ebx
  80b07f:	74 30                	je     80b0b1 <netconn_getaddr+0x4b>
  LWIP_ERROR("netconn_getaddr: invalid addr", (addr != NULL), return ERR_ARG;);
  80b081:	85 d2                	test   %edx,%edx
  80b083:	74 43                	je     80b0c8 <netconn_getaddr+0x62>
  LWIP_ERROR("netconn_getaddr: invalid port", (port != NULL), return ERR_ARG;);
  80b085:	85 c0                	test   %eax,%eax
  80b087:	74 56                	je     80b0df <netconn_getaddr+0x79>

  msg.function = do_getaddr;
  80b089:	c7 45 e4 86 c5 80 00 	movl   $0x80c586,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b090:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.ad.ipaddr = addr;
  80b093:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.ad.port = port;
  80b096:	89 45 f0             	mov    %eax,-0x10(%ebp)
  msg.msg.msg.ad.local = local;
  80b099:	88 4d f4             	mov    %cl,-0xc(%ebp)
  TCPIP_APIMSG(&msg);
  80b09c:	83 ec 0c             	sub    $0xc,%esp
  80b09f:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b0a2:	50                   	push   %eax
  80b0a3:	e8 55 74 ff ff       	call   8024fd <tcpip_apimsg>

  return conn->err;
  80b0a8:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80b0ac:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b0af:	c9                   	leave  
  80b0b0:	c3                   	ret    
  LWIP_ERROR("netconn_getaddr: invalid conn", (conn != NULL), return ERR_ARG;);
  80b0b1:	83 ec 04             	sub    $0x4,%esp
  80b0b4:	68 1e 32 81 00       	push   $0x81321e
  80b0b9:	68 98 00 00 00       	push   $0x98
  80b0be:	68 be 31 81 00       	push   $0x8131be
  80b0c3:	e8 7f 38 00 00       	call   80e947 <_panic>
  LWIP_ERROR("netconn_getaddr: invalid addr", (addr != NULL), return ERR_ARG;);
  80b0c8:	83 ec 04             	sub    $0x4,%esp
  80b0cb:	68 3c 32 81 00       	push   $0x81323c
  80b0d0:	68 99 00 00 00       	push   $0x99
  80b0d5:	68 be 31 81 00       	push   $0x8131be
  80b0da:	e8 68 38 00 00       	call   80e947 <_panic>
  LWIP_ERROR("netconn_getaddr: invalid port", (port != NULL), return ERR_ARG;);
  80b0df:	83 ec 04             	sub    $0x4,%esp
  80b0e2:	68 5a 32 81 00       	push   $0x81325a
  80b0e7:	68 9a 00 00 00       	push   $0x9a
  80b0ec:	68 be 31 81 00       	push   $0x8131be
  80b0f1:	e8 51 38 00 00       	call   80e947 <_panic>

0080b0f6 <netconn_bind>:
 * @param port the local port to bind the netconn to (not used for RAW)
 * @return ERR_OK if bound, any other err_t on failure
 */
err_t
netconn_bind(struct netconn *conn, struct ip_addr *addr, u16_t port)
{
  80b0f6:	f3 0f 1e fb          	endbr32 
  80b0fa:	55                   	push   %ebp
  80b0fb:	89 e5                	mov    %esp,%ebp
  80b0fd:	53                   	push   %ebx
  80b0fe:	83 ec 24             	sub    $0x24,%esp
  80b101:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b104:	8b 45 10             	mov    0x10(%ebp),%eax
  struct api_msg msg;

  LWIP_ERROR("netconn_bind: invalid conn", (conn != NULL), return ERR_ARG;);
  80b107:	85 db                	test   %ebx,%ebx
  80b109:	74 29                	je     80b134 <netconn_bind+0x3e>

  msg.function = do_bind;
  80b10b:	c7 45 e4 c4 c1 80 00 	movl   $0x80c1c4,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b112:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.bc.ipaddr = addr;
  80b115:	8b 55 0c             	mov    0xc(%ebp),%edx
  80b118:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.bc.port = port;
  80b11b:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
  TCPIP_APIMSG(&msg);
  80b11f:	83 ec 0c             	sub    $0xc,%esp
  80b122:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b125:	50                   	push   %eax
  80b126:	e8 d2 73 ff ff       	call   8024fd <tcpip_apimsg>
  return conn->err;
  80b12b:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80b12f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b132:	c9                   	leave  
  80b133:	c3                   	ret    
  LWIP_ERROR("netconn_bind: invalid conn", (conn != NULL), return ERR_ARG;);
  80b134:	83 ec 04             	sub    $0x4,%esp
  80b137:	68 78 32 81 00       	push   $0x813278
  80b13c:	68 b5 00 00 00       	push   $0xb5
  80b141:	68 be 31 81 00       	push   $0x8131be
  80b146:	e8 fc 37 00 00       	call   80e947 <_panic>

0080b14b <netconn_connect>:
 * @param port the remote port to connect to (no used for RAW)
 * @return ERR_OK if connected, return value of tcp_/udp_/raw_connect otherwise
 */
err_t
netconn_connect(struct netconn *conn, struct ip_addr *addr, u16_t port)
{
  80b14b:	f3 0f 1e fb          	endbr32 
  80b14f:	55                   	push   %ebp
  80b150:	89 e5                	mov    %esp,%ebp
  80b152:	53                   	push   %ebx
  80b153:	83 ec 24             	sub    $0x24,%esp
  80b156:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b159:	8b 45 10             	mov    0x10(%ebp),%eax
  struct api_msg msg;

  LWIP_ERROR("netconn_connect: invalid conn", (conn != NULL), return ERR_ARG;);
  80b15c:	85 db                	test   %ebx,%ebx
  80b15e:	74 29                	je     80b189 <netconn_connect+0x3e>

  msg.function = do_connect;
  80b160:	c7 45 e4 58 c2 80 00 	movl   $0x80c258,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b167:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.bc.ipaddr = addr;
  80b16a:	8b 55 0c             	mov    0xc(%ebp),%edx
  80b16d:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.bc.port = port;
  80b170:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
  /* This is the only function which need to not block tcpip_thread */
  tcpip_apimsg(&msg);
  80b174:	83 ec 0c             	sub    $0xc,%esp
  80b177:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b17a:	50                   	push   %eax
  80b17b:	e8 7d 73 ff ff       	call   8024fd <tcpip_apimsg>
  return conn->err;
  80b180:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80b184:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b187:	c9                   	leave  
  80b188:	c3                   	ret    
  LWIP_ERROR("netconn_connect: invalid conn", (conn != NULL), return ERR_ARG;);
  80b189:	83 ec 04             	sub    $0x4,%esp
  80b18c:	68 93 32 81 00       	push   $0x813293
  80b191:	68 cc 00 00 00       	push   $0xcc
  80b196:	68 be 31 81 00       	push   $0x8131be
  80b19b:	e8 a7 37 00 00       	call   80e947 <_panic>

0080b1a0 <netconn_disconnect>:
 * @param conn the netconn to disconnect
 * @return TODO: return value is not set here...
 */
err_t
netconn_disconnect(struct netconn *conn)
{
  80b1a0:	f3 0f 1e fb          	endbr32 
  80b1a4:	55                   	push   %ebp
  80b1a5:	89 e5                	mov    %esp,%ebp
  80b1a7:	53                   	push   %ebx
  80b1a8:	83 ec 24             	sub    $0x24,%esp
  80b1ab:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  LWIP_ERROR("netconn_disconnect: invalid conn", (conn != NULL), return ERR_ARG;);
  80b1ae:	85 db                	test   %ebx,%ebx
  80b1b0:	74 1f                	je     80b1d1 <netconn_disconnect+0x31>

  msg.function = do_disconnect;
  80b1b2:	c7 45 e4 11 c3 80 00 	movl   $0x80c311,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b1b9:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  TCPIP_APIMSG(&msg);
  80b1bc:	83 ec 0c             	sub    $0xc,%esp
  80b1bf:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b1c2:	50                   	push   %eax
  80b1c3:	e8 35 73 ff ff       	call   8024fd <tcpip_apimsg>
  return conn->err;
  80b1c8:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80b1cc:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b1cf:	c9                   	leave  
  80b1d0:	c3                   	ret    
  LWIP_ERROR("netconn_disconnect: invalid conn", (conn != NULL), return ERR_ARG;);
  80b1d1:	83 ec 04             	sub    $0x4,%esp
  80b1d4:	68 54 31 81 00       	push   $0x813154
  80b1d9:	68 e2 00 00 00       	push   $0xe2
  80b1de:	68 be 31 81 00       	push   $0x8131be
  80b1e3:	e8 5f 37 00 00       	call   80e947 <_panic>

0080b1e8 <netconn_listen_with_backlog>:
 * @return ERR_OK if the netconn was set to listen (UDP and RAW netconns
 *         don't return any error (yet?))
 */
err_t
netconn_listen_with_backlog(struct netconn *conn, u8_t backlog)
{
  80b1e8:	f3 0f 1e fb          	endbr32 
  80b1ec:	55                   	push   %ebp
  80b1ed:	89 e5                	mov    %esp,%ebp
  80b1ef:	53                   	push   %ebx
  80b1f0:	83 ec 24             	sub    $0x24,%esp
  80b1f3:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  /* This does no harm. If TCP_LISTEN_BACKLOG is off, backlog is unused. */
  LWIP_UNUSED_ARG(backlog);

  LWIP_ERROR("netconn_listen: invalid conn", (conn != NULL), return ERR_ARG;);
  80b1f6:	85 db                	test   %ebx,%ebx
  80b1f8:	74 1f                	je     80b219 <netconn_listen_with_backlog+0x31>

  msg.function = do_listen;
  80b1fa:	c7 45 e4 52 c3 80 00 	movl   $0x80c352,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b201:	89 5d e8             	mov    %ebx,-0x18(%ebp)
#if TCP_LISTEN_BACKLOG
  msg.msg.msg.lb.backlog = backlog;
#endif /* TCP_LISTEN_BACKLOG */
  TCPIP_APIMSG(&msg);
  80b204:	83 ec 0c             	sub    $0xc,%esp
  80b207:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b20a:	50                   	push   %eax
  80b20b:	e8 ed 72 ff ff       	call   8024fd <tcpip_apimsg>
  return conn->err;
  80b210:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80b214:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b217:	c9                   	leave  
  80b218:	c3                   	ret    
  LWIP_ERROR("netconn_listen: invalid conn", (conn != NULL), return ERR_ARG;);
  80b219:	83 ec 04             	sub    $0x4,%esp
  80b21c:	68 b1 32 81 00       	push   $0x8132b1
  80b221:	68 fa 00 00 00       	push   $0xfa
  80b226:	68 be 31 81 00       	push   $0x8131be
  80b22b:	e8 17 37 00 00       	call   80e947 <_panic>

0080b230 <netconn_accept>:
 * @param conn the TCP listen netconn
 * @return the newly accepted netconn or NULL on timeout
 */
struct netconn *
netconn_accept(struct netconn *conn)
{
  80b230:	f3 0f 1e fb          	endbr32 
  80b234:	55                   	push   %ebp
  80b235:	89 e5                	mov    %esp,%ebp
  80b237:	53                   	push   %ebx
  80b238:	83 ec 14             	sub    $0x14,%esp
  80b23b:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct netconn *newconn;

  LWIP_ERROR("netconn_accept: invalid conn",       (conn != NULL),                      return NULL;);
  80b23e:	85 db                	test   %ebx,%ebx
  80b240:	74 36                	je     80b278 <netconn_accept+0x48>
  LWIP_ERROR("netconn_accept: invalid acceptmbox", (conn->acceptmbox != SYS_MBOX_NULL), return NULL;);
  80b242:	8b 43 18             	mov    0x18(%ebx),%eax
  80b245:	83 f8 ff             	cmp    $0xffffffff,%eax
  80b248:	74 45                	je     80b28f <netconn_accept+0x5f>
#if LWIP_SO_RCVTIMEO
  if (sys_arch_mbox_fetch(conn->acceptmbox, (void *)&newconn, conn->recv_timeout) == SYS_ARCH_TIMEOUT) {
    newconn = NULL;
  } else
#else
  sys_arch_mbox_fetch(conn->acceptmbox, (void *)&newconn, 0);
  80b24a:	83 ec 04             	sub    $0x4,%esp
  80b24d:	6a 00                	push   $0x0
  80b24f:	8d 55 f4             	lea    -0xc(%ebp),%edx
  80b252:	52                   	push   %edx
  80b253:	50                   	push   %eax
  80b254:	e8 9f f3 ff ff       	call   80a5f8 <sys_arch_mbox_fetch>
#endif /* LWIP_SO_RCVTIMEO*/
  {
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, 0);
  80b259:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b25c:	83 c4 10             	add    $0x10,%esp
  80b25f:	85 c0                	test   %eax,%eax
  80b261:	74 0d                	je     80b270 <netconn_accept+0x40>
  80b263:	83 ec 04             	sub    $0x4,%esp
  80b266:	6a 00                	push   $0x0
  80b268:	6a 01                	push   $0x1
  80b26a:	53                   	push   %ebx
  80b26b:	ff d0                	call   *%eax
  80b26d:	83 c4 10             	add    $0x10,%esp
    }
#endif /* TCP_LISTEN_BACKLOG */
  }

  return newconn;
}
  80b270:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80b273:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b276:	c9                   	leave  
  80b277:	c3                   	ret    
  LWIP_ERROR("netconn_accept: invalid conn",       (conn != NULL),                      return NULL;);
  80b278:	83 ec 04             	sub    $0x4,%esp
  80b27b:	68 ce 32 81 00       	push   $0x8132ce
  80b280:	68 10 01 00 00       	push   $0x110
  80b285:	68 be 31 81 00       	push   $0x8131be
  80b28a:	e8 b8 36 00 00       	call   80e947 <_panic>
  LWIP_ERROR("netconn_accept: invalid acceptmbox", (conn->acceptmbox != SYS_MBOX_NULL), return NULL;);
  80b28f:	83 ec 04             	sub    $0x4,%esp
  80b292:	68 78 31 81 00       	push   $0x813178
  80b297:	68 11 01 00 00       	push   $0x111
  80b29c:	68 be 31 81 00       	push   $0x8131be
  80b2a1:	e8 a1 36 00 00       	call   80e947 <_panic>

0080b2a6 <netconn_recv>:
 * @param conn the netconn from which to receive data
 * @return a new netbuf containing received data or NULL on memory error or timeout
 */
struct netbuf *
netconn_recv(struct netconn *conn)
{
  80b2a6:	f3 0f 1e fb          	endbr32 
  80b2aa:	55                   	push   %ebp
  80b2ab:	89 e5                	mov    %esp,%ebp
  80b2ad:	53                   	push   %ebx
  80b2ae:	83 ec 24             	sub    $0x24,%esp
  80b2b1:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;
  struct netbuf *buf = NULL;
  80b2b4:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  struct pbuf *p;
  u16_t len;

  LWIP_ERROR("netconn_recv: invalid conn",  (conn != NULL), return NULL;);
  80b2bb:	85 db                	test   %ebx,%ebx
  80b2bd:	0f 84 cc 00 00 00    	je     80b38f <netconn_recv+0xe9>

  if (conn->recvmbox == SYS_MBOX_NULL) {
  80b2c3:	8b 43 14             	mov    0x14(%ebx),%eax
  80b2c6:	83 f8 ff             	cmp    $0xffffffff,%eax
  80b2c9:	0f 84 d7 00 00 00    	je     80b3a6 <netconn_recv+0x100>
    /* TCP listen conns don't have a recvmbox! */
    conn->err = ERR_CONN;
    return NULL;
  }

  if (ERR_IS_FATAL(conn->err)) {
  80b2cf:	80 7b 0c fc          	cmpb   $0xfc,0xc(%ebx)
  80b2d3:	0f 8c 27 01 00 00    	jl     80b400 <netconn_recv+0x15a>
    return NULL;
  }

  if (conn->type == NETCONN_TCP) {
  80b2d9:	83 3b 10             	cmpl   $0x10,(%ebx)
  80b2dc:	0f 85 e0 00 00 00    	jne    80b3c2 <netconn_recv+0x11c>
#if LWIP_TCP
    if (conn->state == NETCONN_LISTEN) {
  80b2e2:	83 7b 04 02          	cmpl   $0x2,0x4(%ebx)
  80b2e6:	0f 84 c5 00 00 00    	je     80b3b1 <netconn_recv+0x10b>
      /* @todo: should calling netconn_recv on a TCP listen conn be fatal?? */
      conn->err = ERR_CONN;
      return NULL;
    }

    buf = memp_malloc(MEMP_NETBUF);
  80b2ec:	83 ec 0c             	sub    $0xc,%esp
  80b2ef:	6a 06                	push   $0x6
  80b2f1:	e8 4e 93 ff ff       	call   804644 <memp_malloc>
  80b2f6:	89 45 e0             	mov    %eax,-0x20(%ebp)

    if (buf == NULL) {
  80b2f9:	83 c4 10             	add    $0x10,%esp
  80b2fc:	85 c0                	test   %eax,%eax
  80b2fe:	0f 84 b8 00 00 00    	je     80b3bc <netconn_recv+0x116>
    if (sys_arch_mbox_fetch(conn->recvmbox, (void *)&p, conn->recv_timeout)==SYS_ARCH_TIMEOUT) {
      conn->err = ERR_TIMEOUT;
      p = NULL;
    }
#else
    sys_arch_mbox_fetch(conn->recvmbox, (void *)&p, 0);
  80b304:	83 ec 04             	sub    $0x4,%esp
  80b307:	6a 00                	push   $0x0
  80b309:	8d 45 dc             	lea    -0x24(%ebp),%eax
  80b30c:	50                   	push   %eax
  80b30d:	ff 73 14             	pushl  0x14(%ebx)
  80b310:	e8 e3 f2 ff ff       	call   80a5f8 <sys_arch_mbox_fetch>
#endif /* LWIP_SO_RCVTIMEO*/

    if (p != NULL) {
  80b315:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80b318:	83 c4 10             	add    $0x10,%esp
  80b31b:	85 c0                	test   %eax,%eax
  80b31d:	0f 84 e4 00 00 00    	je     80b407 <netconn_recv+0x161>
      len = p->tot_len;
  80b323:	0f b7 50 08          	movzwl 0x8(%eax),%edx
      SYS_ARCH_DEC(conn->recv_avail, len);
  80b327:	66 29 53 20          	sub    %dx,0x20(%ebx)
    } else {
      len = 0;
    }

    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, len);
  80b32b:	8b 4b 2c             	mov    0x2c(%ebx),%ecx
  80b32e:	85 c9                	test   %ecx,%ecx
  80b330:	74 1a                	je     80b34c <netconn_recv+0xa6>
  80b332:	83 ec 04             	sub    $0x4,%esp
  80b335:	0f b7 d2             	movzwl %dx,%edx
  80b338:	52                   	push   %edx
  80b339:	6a 01                	push   $0x1
  80b33b:	53                   	push   %ebx
  80b33c:	ff d1                	call   *%ecx

    /* If we are closed, we indicate that we no longer wish to use the socket */
    if (p == NULL) {
  80b33e:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80b341:	83 c4 10             	add    $0x10,%esp
  80b344:	85 c0                	test   %eax,%eax
  80b346:	0f 84 cb 00 00 00    	je     80b417 <netconn_recv+0x171>
        conn->err = ERR_CLSD;
      }
      return NULL;
    }

    buf->p = p;
  80b34c:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80b34f:	89 02                	mov    %eax,(%edx)
    buf->ptr = p;
  80b351:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80b354:	89 42 04             	mov    %eax,0x4(%edx)
    buf->port = 0;
  80b357:	66 c7 42 0c 00 00    	movw   $0x0,0xc(%edx)
    buf->addr = NULL;
  80b35d:	c7 42 08 00 00 00 00 	movl   $0x0,0x8(%edx)

    /* Let the stack know that we have taken the data. */
    msg.function = do_recv;
  80b364:	c7 45 e4 e8 c4 80 00 	movl   $0x80c4e8,-0x1c(%ebp)
    msg.msg.conn = conn;
  80b36b:	89 5d e8             	mov    %ebx,-0x18(%ebp)
    if (buf != NULL) {
      msg.msg.msg.r.len = buf->p->tot_len;
  80b36e:	8b 02                	mov    (%edx),%eax
  80b370:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80b374:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    } else {
      msg.msg.msg.r.len = 1;
    }
    TCPIP_APIMSG(&msg);
  80b378:	83 ec 0c             	sub    $0xc,%esp
  80b37b:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b37e:	50                   	push   %eax
  80b37f:	e8 79 71 ff ff       	call   8024fd <tcpip_apimsg>
  80b384:	83 c4 10             	add    $0x10,%esp
#endif /* (LWIP_UDP || LWIP_RAW) */
  }

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_recv: received %p (err %d)\n", (void *)buf, conn->err));

  return buf;
  80b387:	8b 45 e0             	mov    -0x20(%ebp),%eax
}
  80b38a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b38d:	c9                   	leave  
  80b38e:	c3                   	ret    
  LWIP_ERROR("netconn_recv: invalid conn",  (conn != NULL), return NULL;);
  80b38f:	83 ec 04             	sub    $0x4,%esp
  80b392:	68 eb 32 81 00       	push   $0x8132eb
  80b397:	68 3a 01 00 00       	push   $0x13a
  80b39c:	68 be 31 81 00       	push   $0x8131be
  80b3a1:	e8 a1 35 00 00       	call   80e947 <_panic>
    conn->err = ERR_CONN;
  80b3a6:	c6 43 0c f8          	movb   $0xf8,0xc(%ebx)
    return NULL;
  80b3aa:	b8 00 00 00 00       	mov    $0x0,%eax
  80b3af:	eb d9                	jmp    80b38a <netconn_recv+0xe4>
      conn->err = ERR_CONN;
  80b3b1:	c6 43 0c f8          	movb   $0xf8,0xc(%ebx)
      return NULL;
  80b3b5:	b8 00 00 00 00       	mov    $0x0,%eax
  80b3ba:	eb ce                	jmp    80b38a <netconn_recv+0xe4>
      conn->err = ERR_MEM;
  80b3bc:	c6 43 0c ff          	movb   $0xff,0xc(%ebx)
      return NULL;
  80b3c0:	eb c8                	jmp    80b38a <netconn_recv+0xe4>
    sys_arch_mbox_fetch(conn->recvmbox, (void *)&buf, 0);
  80b3c2:	83 ec 04             	sub    $0x4,%esp
  80b3c5:	6a 00                	push   $0x0
  80b3c7:	8d 55 e0             	lea    -0x20(%ebp),%edx
  80b3ca:	52                   	push   %edx
  80b3cb:	50                   	push   %eax
  80b3cc:	e8 27 f2 ff ff       	call   80a5f8 <sys_arch_mbox_fetch>
    if (buf!=NULL) {
  80b3d1:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80b3d4:	83 c4 10             	add    $0x10,%esp
  80b3d7:	85 c0                	test   %eax,%eax
  80b3d9:	74 ac                	je     80b387 <netconn_recv+0xe1>
      SYS_ARCH_DEC(conn->recv_avail, buf->p->tot_len);
  80b3db:	8b 10                	mov    (%eax),%edx
  80b3dd:	0f b7 52 08          	movzwl 0x8(%edx),%edx
  80b3e1:	66 29 53 20          	sub    %dx,0x20(%ebx)
      API_EVENT(conn, NETCONN_EVT_RCVMINUS, buf->p->tot_len);
  80b3e5:	8b 53 2c             	mov    0x2c(%ebx),%edx
  80b3e8:	85 d2                	test   %edx,%edx
  80b3ea:	74 9b                	je     80b387 <netconn_recv+0xe1>
  80b3ec:	83 ec 04             	sub    $0x4,%esp
  80b3ef:	8b 00                	mov    (%eax),%eax
  80b3f1:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80b3f5:	50                   	push   %eax
  80b3f6:	6a 01                	push   $0x1
  80b3f8:	53                   	push   %ebx
  80b3f9:	ff d2                	call   *%edx
  80b3fb:	83 c4 10             	add    $0x10,%esp
  80b3fe:	eb 87                	jmp    80b387 <netconn_recv+0xe1>
    return NULL;
  80b400:	b8 00 00 00 00       	mov    $0x0,%eax
  80b405:	eb 83                	jmp    80b38a <netconn_recv+0xe4>
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, len);
  80b407:	8b 4b 2c             	mov    0x2c(%ebx),%ecx
      len = 0;
  80b40a:	ba 00 00 00 00       	mov    $0x0,%edx
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, len);
  80b40f:	85 c9                	test   %ecx,%ecx
  80b411:	0f 85 1b ff ff ff    	jne    80b332 <netconn_recv+0x8c>
      memp_free(MEMP_NETBUF, buf);
  80b417:	83 ec 08             	sub    $0x8,%esp
  80b41a:	ff 75 e0             	pushl  -0x20(%ebp)
  80b41d:	6a 06                	push   $0x6
  80b41f:	e8 7a 92 ff ff       	call   80469e <memp_free>
      if (conn->err == ERR_OK) {
  80b424:	83 c4 10             	add    $0x10,%esp
      return NULL;
  80b427:	b8 00 00 00 00       	mov    $0x0,%eax
      if (conn->err == ERR_OK) {
  80b42c:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
  80b430:	0f 85 54 ff ff ff    	jne    80b38a <netconn_recv+0xe4>
        conn->err = ERR_CLSD;
  80b436:	c6 43 0c f9          	movb   $0xf9,0xc(%ebx)
  80b43a:	e9 4b ff ff ff       	jmp    80b38a <netconn_recv+0xe4>

0080b43f <netconn_send>:
 * @param buf a netbuf containing the data to send
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_send(struct netconn *conn, struct netbuf *buf)
{
  80b43f:	f3 0f 1e fb          	endbr32 
  80b443:	55                   	push   %ebp
  80b444:	89 e5                	mov    %esp,%ebp
  80b446:	53                   	push   %ebx
  80b447:	83 ec 24             	sub    $0x24,%esp
  80b44a:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  LWIP_ERROR("netconn_send: invalid conn",  (conn != NULL), return ERR_ARG;);
  80b44d:	85 db                	test   %ebx,%ebx
  80b44f:	74 25                	je     80b476 <netconn_send+0x37>

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_send: sending %d bytes\n", buf->p->tot_len));
  msg.function = do_send;
  80b451:	c7 45 e4 3e c4 80 00 	movl   $0x80c43e,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b458:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.b = buf;
  80b45b:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b45e:	89 45 ec             	mov    %eax,-0x14(%ebp)
  TCPIP_APIMSG(&msg);
  80b461:	83 ec 0c             	sub    $0xc,%esp
  80b464:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b467:	50                   	push   %eax
  80b468:	e8 90 70 ff ff       	call   8024fd <tcpip_apimsg>
  return conn->err;
  80b46d:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80b471:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b474:	c9                   	leave  
  80b475:	c3                   	ret    
  LWIP_ERROR("netconn_send: invalid conn",  (conn != NULL), return ERR_ARG;);
  80b476:	83 ec 04             	sub    $0x4,%esp
  80b479:	68 06 33 81 00       	push   $0x813306
  80b47e:	68 b9 01 00 00       	push   $0x1b9
  80b483:	68 be 31 81 00       	push   $0x8131be
  80b488:	e8 ba 34 00 00       	call   80e947 <_panic>

0080b48d <netconn_sendto>:
{
  80b48d:	f3 0f 1e fb          	endbr32 
  80b491:	55                   	push   %ebp
  80b492:	89 e5                	mov    %esp,%ebp
  80b494:	83 ec 08             	sub    $0x8,%esp
  80b497:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b49a:	8b 55 14             	mov    0x14(%ebp),%edx
  if (buf != NULL) {
  80b49d:	85 c0                	test   %eax,%eax
  80b49f:	74 1b                	je     80b4bc <netconn_sendto+0x2f>
    buf->addr = addr;
  80b4a1:	8b 4d 10             	mov    0x10(%ebp),%ecx
  80b4a4:	89 48 08             	mov    %ecx,0x8(%eax)
    buf->port = port;
  80b4a7:	66 89 50 0c          	mov    %dx,0xc(%eax)
    return netconn_send(conn, buf);
  80b4ab:	83 ec 08             	sub    $0x8,%esp
  80b4ae:	50                   	push   %eax
  80b4af:	ff 75 08             	pushl  0x8(%ebp)
  80b4b2:	e8 88 ff ff ff       	call   80b43f <netconn_send>
  80b4b7:	83 c4 10             	add    $0x10,%esp
}
  80b4ba:	c9                   	leave  
  80b4bb:	c3                   	ret    
  return ERR_VAL;
  80b4bc:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  80b4c1:	eb f7                	jmp    80b4ba <netconn_sendto+0x2d>

0080b4c3 <netconn_write>:
 * - NETCONN_MORE (0x02) for TCP connection, PSH flag will be set on last segment sent
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_write(struct netconn *conn, const void *dataptr, int size, u8_t apiflags)
{
  80b4c3:	f3 0f 1e fb          	endbr32 
  80b4c7:	55                   	push   %ebp
  80b4c8:	89 e5                	mov    %esp,%ebp
  80b4ca:	53                   	push   %ebx
  80b4cb:	83 ec 24             	sub    $0x24,%esp
  80b4ce:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b4d1:	8b 45 14             	mov    0x14(%ebp),%eax
  struct api_msg msg;

  LWIP_ERROR("netconn_write: invalid conn",  (conn != NULL), return ERR_ARG;);
  80b4d4:	85 db                	test   %ebx,%ebx
  80b4d6:	74 33                	je     80b50b <netconn_write+0x48>
  LWIP_ERROR("netconn_write: invalid conn->type",  (conn->type == NETCONN_TCP), return ERR_VAL;);
  80b4d8:	83 3b 10             	cmpl   $0x10,(%ebx)
  80b4db:	75 45                	jne    80b522 <netconn_write+0x5f>

  msg.function = do_write;
  80b4dd:	c7 45 e4 32 c5 80 00 	movl   $0x80c532,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b4e4:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.w.dataptr = dataptr;
  80b4e7:	8b 55 0c             	mov    0xc(%ebp),%edx
  80b4ea:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.w.apiflags = apiflags;
  80b4ed:	88 45 f4             	mov    %al,-0xc(%ebp)
  msg.msg.msg.w.len = size;
  80b4f0:	8b 45 10             	mov    0x10(%ebp),%eax
  80b4f3:	89 45 f0             	mov    %eax,-0x10(%ebp)
  /* For locking the core: this _can_ be delayed on low memory/low send buffer,
     but if it is, this is done inside api_msg.c:do_write(), so we can use the
     non-blocking version here. */
  TCPIP_APIMSG(&msg);
  80b4f6:	83 ec 0c             	sub    $0xc,%esp
  80b4f9:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b4fc:	50                   	push   %eax
  80b4fd:	e8 fb 6f ff ff       	call   8024fd <tcpip_apimsg>
  return conn->err;
  80b502:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80b506:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b509:	c9                   	leave  
  80b50a:	c3                   	ret    
  LWIP_ERROR("netconn_write: invalid conn",  (conn != NULL), return ERR_ARG;);
  80b50b:	83 ec 04             	sub    $0x4,%esp
  80b50e:	68 21 33 81 00       	push   $0x813321
  80b513:	68 d3 01 00 00       	push   $0x1d3
  80b518:	68 be 31 81 00       	push   $0x8131be
  80b51d:	e8 25 34 00 00       	call   80e947 <_panic>
  LWIP_ERROR("netconn_write: invalid conn->type",  (conn->type == NETCONN_TCP), return ERR_VAL;);
  80b522:	83 ec 04             	sub    $0x4,%esp
  80b525:	68 9c 31 81 00       	push   $0x81319c
  80b52a:	68 d4 01 00 00       	push   $0x1d4
  80b52f:	68 be 31 81 00       	push   $0x8131be
  80b534:	e8 0e 34 00 00       	call   80e947 <_panic>

0080b539 <netconn_close>:
 * @param conn the TCP netconn to close
 * @return ERR_OK if the netconn was closed, any other err_t on error
 */
err_t
netconn_close(struct netconn *conn)
{
  80b539:	f3 0f 1e fb          	endbr32 
  80b53d:	55                   	push   %ebp
  80b53e:	89 e5                	mov    %esp,%ebp
  80b540:	53                   	push   %ebx
  80b541:	83 ec 24             	sub    $0x24,%esp
  80b544:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  LWIP_ERROR("netconn_close: invalid conn",  (conn != NULL), return ERR_ARG;);
  80b547:	85 db                	test   %ebx,%ebx
  80b549:	74 1f                	je     80b56a <netconn_close+0x31>

  msg.function = do_close;
  80b54b:	c7 45 e4 51 c6 80 00 	movl   $0x80c651,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b552:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  tcpip_apimsg(&msg);
  80b555:	83 ec 0c             	sub    $0xc,%esp
  80b558:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b55b:	50                   	push   %eax
  80b55c:	e8 9c 6f ff ff       	call   8024fd <tcpip_apimsg>
  return conn->err;
  80b561:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80b565:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b568:	c9                   	leave  
  80b569:	c3                   	ret    
  LWIP_ERROR("netconn_close: invalid conn",  (conn != NULL), return ERR_ARG;);
  80b56a:	83 ec 04             	sub    $0x4,%esp
  80b56d:	68 3d 33 81 00       	push   $0x81333d
  80b572:	68 ed 01 00 00       	push   $0x1ed
  80b577:	68 be 31 81 00       	push   $0x8131be
  80b57c:	e8 c6 33 00 00       	call   80e947 <_panic>

0080b581 <recv_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.recv) for parameters and return value
 */
static err_t
recv_tcp(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
  80b581:	f3 0f 1e fb          	endbr32 
  80b585:	55                   	push   %ebp
  80b586:	89 e5                	mov    %esp,%ebp
  80b588:	56                   	push   %esi
  80b589:	53                   	push   %ebx
  80b58a:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b58d:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b590:	8b 75 10             	mov    0x10(%ebp),%esi
  80b593:	8b 55 14             	mov    0x14(%ebp),%edx
  struct netconn *conn;
  u16_t len;

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("recv_tcp must have a pcb argument", pcb != NULL);
  80b596:	85 c0                	test   %eax,%eax
  80b598:	74 5a                	je     80b5f4 <recv_tcp+0x73>
  LWIP_ASSERT("recv_tcp must have an argument", arg != NULL);
  80b59a:	85 db                	test   %ebx,%ebx
  80b59c:	74 6d                	je     80b60b <recv_tcp+0x8a>
  conn = arg;
  LWIP_ASSERT("recv_tcp: recv for wrong pcb!", conn->pcb.tcp == pcb);
  80b59e:	39 43 08             	cmp    %eax,0x8(%ebx)
  80b5a1:	75 7f                	jne    80b622 <recv_tcp+0xa1>

  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
  80b5a3:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80b5a7:	0f 84 8c 00 00 00    	je     80b639 <recv_tcp+0xb8>
    return ERR_VAL;
  }

  conn->err = err;
  80b5ad:	88 53 0c             	mov    %dl,0xc(%ebx)
  if (p != NULL) {
    len = p->tot_len;
    SYS_ARCH_INC(conn->recv_avail, len);
  } else {
    len = 0;
  80b5b0:	b8 00 00 00 00       	mov    $0x0,%eax
  if (p != NULL) {
  80b5b5:	85 f6                	test   %esi,%esi
  80b5b7:	74 08                	je     80b5c1 <recv_tcp+0x40>
    len = p->tot_len;
  80b5b9:	0f b7 46 08          	movzwl 0x8(%esi),%eax
    SYS_ARCH_INC(conn->recv_avail, len);
  80b5bd:	66 01 43 20          	add    %ax,0x20(%ebx)
  }
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
  80b5c1:	8b 53 2c             	mov    0x2c(%ebx),%edx
  80b5c4:	85 d2                	test   %edx,%edx
  80b5c6:	74 0f                	je     80b5d7 <recv_tcp+0x56>
  80b5c8:	83 ec 04             	sub    $0x4,%esp
  80b5cb:	0f b7 c0             	movzwl %ax,%eax
  80b5ce:	50                   	push   %eax
  80b5cf:	6a 00                	push   $0x0
  80b5d1:	53                   	push   %ebx
  80b5d2:	ff d2                	call   *%edx
  80b5d4:	83 c4 10             	add    $0x10,%esp
  if (sys_mbox_trypost(conn->recvmbox, p) != ERR_OK) {
  80b5d7:	83 ec 08             	sub    $0x8,%esp
  80b5da:	56                   	push   %esi
  80b5db:	ff 73 14             	pushl  0x14(%ebx)
  80b5de:	e8 18 ef ff ff       	call   80a4fb <sys_mbox_trypost>
  80b5e3:	83 c4 10             	add    $0x10,%esp
  80b5e6:	84 c0                	test   %al,%al
  80b5e8:	0f 95 c0             	setne  %al
  80b5eb:	f7 d8                	neg    %eax
    return ERR_MEM;
  }

  return ERR_OK;
}
  80b5ed:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80b5f0:	5b                   	pop    %ebx
  80b5f1:	5e                   	pop    %esi
  80b5f2:	5d                   	pop    %ebp
  80b5f3:	c3                   	ret    
  LWIP_ASSERT("recv_tcp must have a pcb argument", pcb != NULL);
  80b5f4:	83 ec 04             	sub    $0x4,%esp
  80b5f7:	68 5c 33 81 00       	push   $0x81335c
  80b5fc:	68 c1 00 00 00       	push   $0xc1
  80b601:	68 a6 34 81 00       	push   $0x8134a6
  80b606:	e8 3c 33 00 00       	call   80e947 <_panic>
  LWIP_ASSERT("recv_tcp must have an argument", arg != NULL);
  80b60b:	83 ec 04             	sub    $0x4,%esp
  80b60e:	68 80 33 81 00       	push   $0x813380
  80b613:	68 c2 00 00 00       	push   $0xc2
  80b618:	68 a6 34 81 00       	push   $0x8134a6
  80b61d:	e8 25 33 00 00       	call   80e947 <_panic>
  LWIP_ASSERT("recv_tcp: recv for wrong pcb!", conn->pcb.tcp == pcb);
  80b622:	83 ec 04             	sub    $0x4,%esp
  80b625:	68 bd 34 81 00       	push   $0x8134bd
  80b62a:	68 c4 00 00 00       	push   $0xc4
  80b62f:	68 a6 34 81 00       	push   $0x8134a6
  80b634:	e8 0e 33 00 00       	call   80e947 <_panic>
    return ERR_VAL;
  80b639:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  80b63e:	eb ad                	jmp    80b5ed <recv_tcp+0x6c>

0080b640 <recv_udp>:
{
  80b640:	f3 0f 1e fb          	endbr32 
  80b644:	55                   	push   %ebp
  80b645:	89 e5                	mov    %esp,%ebp
  80b647:	57                   	push   %edi
  80b648:	56                   	push   %esi
  80b649:	53                   	push   %ebx
  80b64a:	83 ec 1c             	sub    $0x1c,%esp
  80b64d:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b650:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b653:	8b 7d 10             	mov    0x10(%ebp),%edi
  80b656:	8b 4d 18             	mov    0x18(%ebp),%ecx
  80b659:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  LWIP_ASSERT("recv_udp must have a pcb argument", pcb != NULL);
  80b65c:	85 c0                	test   %eax,%eax
  80b65e:	74 7f                	je     80b6df <recv_udp+0x9f>
  LWIP_ASSERT("recv_udp must have an argument", arg != NULL);
  80b660:	85 db                	test   %ebx,%ebx
  80b662:	0f 84 8e 00 00 00    	je     80b6f6 <recv_udp+0xb6>
  LWIP_ASSERT("recv_udp: recv for wrong pcb!", conn->pcb.udp == pcb);
  80b668:	39 43 08             	cmp    %eax,0x8(%ebx)
  80b66b:	0f 85 9c 00 00 00    	jne    80b70d <recv_udp+0xcd>
  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
  80b671:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80b675:	0f 84 a9 00 00 00    	je     80b724 <recv_udp+0xe4>
  buf = memp_malloc(MEMP_NETBUF);
  80b67b:	83 ec 0c             	sub    $0xc,%esp
  80b67e:	6a 06                	push   $0x6
  80b680:	e8 bf 8f ff ff       	call   804644 <memp_malloc>
  80b685:	89 c6                	mov    %eax,%esi
  if (buf == NULL) {
  80b687:	83 c4 10             	add    $0x10,%esp
  80b68a:	85 c0                	test   %eax,%eax
  80b68c:	0f 84 a0 00 00 00    	je     80b732 <recv_udp+0xf2>
    buf->p = p;
  80b692:	89 38                	mov    %edi,(%eax)
    buf->ptr = p;
  80b694:	89 78 04             	mov    %edi,0x4(%eax)
    buf->addr = addr;
  80b697:	8b 45 14             	mov    0x14(%ebp),%eax
  80b69a:	89 46 08             	mov    %eax,0x8(%esi)
    buf->port = port;
  80b69d:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  80b6a1:	66 89 46 0c          	mov    %ax,0xc(%esi)
  SYS_ARCH_INC(conn->recv_avail, p->tot_len);
  80b6a5:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80b6a9:	66 01 43 20          	add    %ax,0x20(%ebx)
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, p->tot_len);
  80b6ad:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b6b0:	85 c0                	test   %eax,%eax
  80b6b2:	74 10                	je     80b6c4 <recv_udp+0x84>
  80b6b4:	83 ec 04             	sub    $0x4,%esp
  80b6b7:	0f b7 57 08          	movzwl 0x8(%edi),%edx
  80b6bb:	52                   	push   %edx
  80b6bc:	6a 00                	push   $0x0
  80b6be:	53                   	push   %ebx
  80b6bf:	ff d0                	call   *%eax
  80b6c1:	83 c4 10             	add    $0x10,%esp
  if (sys_mbox_trypost(conn->recvmbox, buf) != ERR_OK) {
  80b6c4:	83 ec 08             	sub    $0x8,%esp
  80b6c7:	56                   	push   %esi
  80b6c8:	ff 73 14             	pushl  0x14(%ebx)
  80b6cb:	e8 2b ee ff ff       	call   80a4fb <sys_mbox_trypost>
  80b6d0:	83 c4 10             	add    $0x10,%esp
  80b6d3:	84 c0                	test   %al,%al
  80b6d5:	75 69                	jne    80b740 <recv_udp+0x100>
}
  80b6d7:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80b6da:	5b                   	pop    %ebx
  80b6db:	5e                   	pop    %esi
  80b6dc:	5f                   	pop    %edi
  80b6dd:	5d                   	pop    %ebp
  80b6de:	c3                   	ret    
  LWIP_ASSERT("recv_udp must have a pcb argument", pcb != NULL);
  80b6df:	83 ec 04             	sub    $0x4,%esp
  80b6e2:	68 a0 33 81 00       	push   $0x8133a0
  80b6e7:	68 8e 00 00 00       	push   $0x8e
  80b6ec:	68 a6 34 81 00       	push   $0x8134a6
  80b6f1:	e8 51 32 00 00       	call   80e947 <_panic>
  LWIP_ASSERT("recv_udp must have an argument", arg != NULL);
  80b6f6:	83 ec 04             	sub    $0x4,%esp
  80b6f9:	68 c4 33 81 00       	push   $0x8133c4
  80b6fe:	68 8f 00 00 00       	push   $0x8f
  80b703:	68 a6 34 81 00       	push   $0x8134a6
  80b708:	e8 3a 32 00 00       	call   80e947 <_panic>
  LWIP_ASSERT("recv_udp: recv for wrong pcb!", conn->pcb.udp == pcb);
  80b70d:	83 ec 04             	sub    $0x4,%esp
  80b710:	68 db 34 81 00       	push   $0x8134db
  80b715:	68 91 00 00 00       	push   $0x91
  80b71a:	68 a6 34 81 00       	push   $0x8134a6
  80b71f:	e8 23 32 00 00       	call   80e947 <_panic>
    pbuf_free(p);
  80b724:	83 ec 0c             	sub    $0xc,%esp
  80b727:	57                   	push   %edi
  80b728:	e8 f4 92 ff ff       	call   804a21 <pbuf_free>
    return;
  80b72d:	83 c4 10             	add    $0x10,%esp
  80b730:	eb a5                	jmp    80b6d7 <recv_udp+0x97>
    pbuf_free(p);
  80b732:	83 ec 0c             	sub    $0xc,%esp
  80b735:	57                   	push   %edi
  80b736:	e8 e6 92 ff ff       	call   804a21 <pbuf_free>
    return;
  80b73b:	83 c4 10             	add    $0x10,%esp
  80b73e:	eb 97                	jmp    80b6d7 <recv_udp+0x97>
    netbuf_delete(buf);
  80b740:	83 ec 0c             	sub    $0xc,%esp
  80b743:	56                   	push   %esi
  80b744:	e8 b8 6e ff ff       	call   802601 <netbuf_delete>
    return;
  80b749:	83 c4 10             	add    $0x10,%esp
  80b74c:	eb 89                	jmp    80b6d7 <recv_udp+0x97>

0080b74e <recv_raw>:
{
  80b74e:	f3 0f 1e fb          	endbr32 
  80b752:	55                   	push   %ebp
  80b753:	89 e5                	mov    %esp,%ebp
  80b755:	57                   	push   %edi
  80b756:	56                   	push   %esi
  80b757:	53                   	push   %ebx
  80b758:	83 ec 0c             	sub    $0xc,%esp
  80b75b:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if ((conn != NULL) && (conn->recvmbox != SYS_MBOX_NULL)) {
  80b75e:	85 db                	test   %ebx,%ebx
  80b760:	74 06                	je     80b768 <recv_raw+0x1a>
  80b762:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80b766:	75 0d                	jne    80b775 <recv_raw+0x27>
}
  80b768:	b8 00 00 00 00       	mov    $0x0,%eax
  80b76d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80b770:	5b                   	pop    %ebx
  80b771:	5e                   	pop    %esi
  80b772:	5f                   	pop    %edi
  80b773:	5d                   	pop    %ebp
  80b774:	c3                   	ret    
    q = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  80b775:	83 ec 04             	sub    $0x4,%esp
  80b778:	6a 00                	push   $0x0
  80b77a:	8b 45 10             	mov    0x10(%ebp),%eax
  80b77d:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80b781:	50                   	push   %eax
  80b782:	6a 03                	push   $0x3
  80b784:	e8 62 93 ff ff       	call   804aeb <pbuf_alloc>
  80b789:	89 c6                	mov    %eax,%esi
    if(q != NULL) {
  80b78b:	83 c4 10             	add    $0x10,%esp
  80b78e:	85 c0                	test   %eax,%eax
  80b790:	74 d6                	je     80b768 <recv_raw+0x1a>
      if (pbuf_copy(q, p) != ERR_OK) {
  80b792:	83 ec 08             	sub    $0x8,%esp
  80b795:	ff 75 10             	pushl  0x10(%ebp)
  80b798:	50                   	push   %eax
  80b799:	e8 34 98 ff ff       	call   804fd2 <pbuf_copy>
  80b79e:	83 c4 10             	add    $0x10,%esp
  80b7a1:	84 c0                	test   %al,%al
  80b7a3:	75 73                	jne    80b818 <recv_raw+0xca>
      buf = memp_malloc(MEMP_NETBUF);
  80b7a5:	83 ec 0c             	sub    $0xc,%esp
  80b7a8:	6a 06                	push   $0x6
  80b7aa:	e8 95 8e ff ff       	call   804644 <memp_malloc>
  80b7af:	89 c7                	mov    %eax,%edi
      if (buf == NULL) {
  80b7b1:	83 c4 10             	add    $0x10,%esp
  80b7b4:	85 c0                	test   %eax,%eax
  80b7b6:	74 71                	je     80b829 <recv_raw+0xdb>
      buf->p = q;
  80b7b8:	89 37                	mov    %esi,(%edi)
      buf->ptr = q;
  80b7ba:	89 77 04             	mov    %esi,0x4(%edi)
      buf->addr = &(((struct ip_hdr*)(q->payload))->src);
  80b7bd:	8b 46 04             	mov    0x4(%esi),%eax
  80b7c0:	83 c0 0c             	add    $0xc,%eax
  80b7c3:	89 47 08             	mov    %eax,0x8(%edi)
      buf->port = pcb->protocol;
  80b7c6:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b7c9:	0f b6 40 10          	movzbl 0x10(%eax),%eax
  80b7cd:	66 89 47 0c          	mov    %ax,0xc(%edi)
      SYS_ARCH_INC(conn->recv_avail, q->tot_len);
  80b7d1:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80b7d5:	66 01 43 20          	add    %ax,0x20(%ebx)
      API_EVENT(conn, NETCONN_EVT_RCVPLUS, q->tot_len);
  80b7d9:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b7dc:	85 c0                	test   %eax,%eax
  80b7de:	74 10                	je     80b7f0 <recv_raw+0xa2>
  80b7e0:	83 ec 04             	sub    $0x4,%esp
  80b7e3:	0f b7 56 08          	movzwl 0x8(%esi),%edx
  80b7e7:	52                   	push   %edx
  80b7e8:	6a 00                	push   $0x0
  80b7ea:	53                   	push   %ebx
  80b7eb:	ff d0                	call   *%eax
  80b7ed:	83 c4 10             	add    $0x10,%esp
      if (sys_mbox_trypost(conn->recvmbox, buf) != ERR_OK) {
  80b7f0:	83 ec 08             	sub    $0x8,%esp
  80b7f3:	57                   	push   %edi
  80b7f4:	ff 73 14             	pushl  0x14(%ebx)
  80b7f7:	e8 ff ec ff ff       	call   80a4fb <sys_mbox_trypost>
  80b7fc:	83 c4 10             	add    $0x10,%esp
  80b7ff:	84 c0                	test   %al,%al
  80b801:	0f 84 61 ff ff ff    	je     80b768 <recv_raw+0x1a>
        netbuf_delete(buf);
  80b807:	83 ec 0c             	sub    $0xc,%esp
  80b80a:	57                   	push   %edi
  80b80b:	e8 f1 6d ff ff       	call   802601 <netbuf_delete>
  80b810:	83 c4 10             	add    $0x10,%esp
  80b813:	e9 50 ff ff ff       	jmp    80b768 <recv_raw+0x1a>
        pbuf_free(q);
  80b818:	83 ec 0c             	sub    $0xc,%esp
  80b81b:	56                   	push   %esi
  80b81c:	e8 00 92 ff ff       	call   804a21 <pbuf_free>
  80b821:	83 c4 10             	add    $0x10,%esp
  80b824:	e9 3f ff ff ff       	jmp    80b768 <recv_raw+0x1a>
        pbuf_free(q);
  80b829:	83 ec 0c             	sub    $0xc,%esp
  80b82c:	56                   	push   %esi
  80b82d:	e8 ef 91 ff ff       	call   804a21 <pbuf_free>
        return 0;
  80b832:	83 c4 10             	add    $0x10,%esp
  80b835:	e9 2e ff ff ff       	jmp    80b768 <recv_raw+0x1a>

0080b83a <setup_tcp>:
 *
 * @param conn the TCP netconn to setup
 */
static void
setup_tcp(struct netconn *conn)
{
  80b83a:	55                   	push   %ebp
  80b83b:	89 e5                	mov    %esp,%ebp
  80b83d:	53                   	push   %ebx
  80b83e:	83 ec 0c             	sub    $0xc,%esp
  struct tcp_pcb *pcb;

  pcb = conn->pcb.tcp;
  80b841:	8b 58 08             	mov    0x8(%eax),%ebx
  tcp_arg(pcb, conn);
  80b844:	50                   	push   %eax
  80b845:	53                   	push   %ebx
  80b846:	e8 ef a1 ff ff       	call   805a3a <tcp_arg>
  tcp_recv(pcb, recv_tcp);
  80b84b:	83 c4 08             	add    $0x8,%esp
  80b84e:	68 81 b5 80 00       	push   $0x80b581
  80b853:	53                   	push   %ebx
  80b854:	e8 f3 a1 ff ff       	call   805a4c <tcp_recv>
  tcp_sent(pcb, sent_tcp);
  80b859:	83 c4 08             	add    $0x8,%esp
  80b85c:	68 28 bd 80 00       	push   $0x80bd28
  80b861:	53                   	push   %ebx
  80b862:	e8 fa a1 ff ff       	call   805a61 <tcp_sent>
  tcp_poll(pcb, poll_tcp, 4);
  80b867:	83 c4 0c             	add    $0xc,%esp
  80b86a:	6a 04                	push   $0x4
  80b86c:	68 de bc 80 00       	push   $0x80bcde
  80b871:	53                   	push   %ebx
  80b872:	e8 26 a2 ff ff       	call   805a9d <tcp_poll>
  tcp_err(pcb, err_tcp);
  80b877:	83 c4 08             	add    $0x8,%esp
  80b87a:	68 dd b8 80 00       	push   $0x80b8dd
  80b87f:	53                   	push   %ebx
  80b880:	e8 f1 a1 ff ff       	call   805a76 <tcp_err>
}
  80b885:	83 c4 10             	add    $0x10,%esp
  80b888:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b88b:	c9                   	leave  
  80b88c:	c3                   	ret    

0080b88d <do_connected>:
 *
 * @see tcp.h (struct tcp_pcb.connected) for parameters and return values
 */
static err_t
do_connected(void *arg, struct tcp_pcb *pcb, err_t err)
{
  80b88d:	f3 0f 1e fb          	endbr32 
  80b891:	55                   	push   %ebp
  80b892:	89 e5                	mov    %esp,%ebp
  80b894:	53                   	push   %ebx
  80b895:	83 ec 04             	sub    $0x4,%esp
  80b898:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b89b:	8b 45 10             	mov    0x10(%ebp),%eax

  LWIP_UNUSED_ARG(pcb);

  conn = arg;

  if (conn == NULL) {
  80b89e:	85 db                	test   %ebx,%ebx
  80b8a0:	74 34                	je     80b8d6 <do_connected+0x49>
    return ERR_VAL;
  }

  conn->err = err;
  80b8a2:	88 43 0c             	mov    %al,0xc(%ebx)
  if ((conn->type == NETCONN_TCP) && (err == ERR_OK)) {
  80b8a5:	83 3b 10             	cmpl   $0x10,(%ebx)
  80b8a8:	75 04                	jne    80b8ae <do_connected+0x21>
  80b8aa:	84 c0                	test   %al,%al
  80b8ac:	74 1f                	je     80b8cd <do_connected+0x40>
    setup_tcp(conn);
  }
  conn->state = NETCONN_NONE;
  80b8ae:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  sys_sem_signal(conn->op_completed);
  80b8b5:	83 ec 0c             	sub    $0xc,%esp
  80b8b8:	ff 73 10             	pushl  0x10(%ebx)
  80b8bb:	e8 b3 ea ff ff       	call   80a373 <sys_sem_signal>
  return ERR_OK;
  80b8c0:	83 c4 10             	add    $0x10,%esp
  80b8c3:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80b8c8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b8cb:	c9                   	leave  
  80b8cc:	c3                   	ret    
    setup_tcp(conn);
  80b8cd:	89 d8                	mov    %ebx,%eax
  80b8cf:	e8 66 ff ff ff       	call   80b83a <setup_tcp>
  80b8d4:	eb d8                	jmp    80b8ae <do_connected+0x21>
    return ERR_VAL;
  80b8d6:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  80b8db:	eb eb                	jmp    80b8c8 <do_connected+0x3b>

0080b8dd <err_tcp>:
{
  80b8dd:	f3 0f 1e fb          	endbr32 
  80b8e1:	55                   	push   %ebp
  80b8e2:	89 e5                	mov    %esp,%ebp
  80b8e4:	53                   	push   %ebx
  80b8e5:	83 ec 04             	sub    $0x4,%esp
  80b8e8:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b8eb:	8b 45 0c             	mov    0xc(%ebp),%eax
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80b8ee:	85 db                	test   %ebx,%ebx
  80b8f0:	74 7e                	je     80b970 <err_tcp+0x93>
  conn->pcb.tcp = NULL;
  80b8f2:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  conn->err = err;
  80b8f9:	88 43 0c             	mov    %al,0xc(%ebx)
  if (conn->recvmbox != SYS_MBOX_NULL) {
  80b8fc:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80b900:	74 24                	je     80b926 <err_tcp+0x49>
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80b902:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b905:	85 c0                	test   %eax,%eax
  80b907:	74 0d                	je     80b916 <err_tcp+0x39>
  80b909:	83 ec 04             	sub    $0x4,%esp
  80b90c:	6a 00                	push   $0x0
  80b90e:	6a 00                	push   $0x0
  80b910:	53                   	push   %ebx
  80b911:	ff d0                	call   *%eax
  80b913:	83 c4 10             	add    $0x10,%esp
    sys_mbox_post(conn->recvmbox, NULL);
  80b916:	83 ec 08             	sub    $0x8,%esp
  80b919:	6a 00                	push   $0x0
  80b91b:	ff 73 14             	pushl  0x14(%ebx)
  80b91e:	e8 a1 ec ff ff       	call   80a5c4 <sys_mbox_post>
  80b923:	83 c4 10             	add    $0x10,%esp
  if (conn->op_completed != SYS_SEM_NULL && conn->state == NETCONN_CONNECT) {
  80b926:	8b 43 10             	mov    0x10(%ebx),%eax
  80b929:	83 f8 ff             	cmp    $0xffffffff,%eax
  80b92c:	74 06                	je     80b934 <err_tcp+0x57>
  80b92e:	83 7b 04 03          	cmpl   $0x3,0x4(%ebx)
  80b932:	74 53                	je     80b987 <err_tcp+0xaa>
  if (conn->acceptmbox != SYS_MBOX_NULL) {
  80b934:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80b938:	74 24                	je     80b95e <err_tcp+0x81>
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80b93a:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b93d:	85 c0                	test   %eax,%eax
  80b93f:	74 0d                	je     80b94e <err_tcp+0x71>
  80b941:	83 ec 04             	sub    $0x4,%esp
  80b944:	6a 00                	push   $0x0
  80b946:	6a 00                	push   $0x0
  80b948:	53                   	push   %ebx
  80b949:	ff d0                	call   *%eax
  80b94b:	83 c4 10             	add    $0x10,%esp
    sys_mbox_post(conn->acceptmbox, NULL);
  80b94e:	83 ec 08             	sub    $0x8,%esp
  80b951:	6a 00                	push   $0x0
  80b953:	ff 73 18             	pushl  0x18(%ebx)
  80b956:	e8 69 ec ff ff       	call   80a5c4 <sys_mbox_post>
  80b95b:	83 c4 10             	add    $0x10,%esp
  if ((conn->state == NETCONN_WRITE) || (conn->state == NETCONN_CLOSE)) {
  80b95e:	8b 43 04             	mov    0x4(%ebx),%eax
  80b961:	83 f8 01             	cmp    $0x1,%eax
  80b964:	74 36                	je     80b99c <err_tcp+0xbf>
  80b966:	83 f8 04             	cmp    $0x4,%eax
  80b969:	74 31                	je     80b99c <err_tcp+0xbf>
}
  80b96b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b96e:	c9                   	leave  
  80b96f:	c3                   	ret    
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80b970:	83 ec 04             	sub    $0x4,%esp
  80b973:	68 f9 34 81 00       	push   $0x8134f9
  80b978:	68 22 01 00 00       	push   $0x122
  80b97d:	68 a6 34 81 00       	push   $0x8134a6
  80b982:	e8 c0 2f 00 00       	call   80e947 <_panic>
    conn->state = NETCONN_NONE;
  80b987:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    sys_sem_signal(conn->op_completed);
  80b98e:	83 ec 0c             	sub    $0xc,%esp
  80b991:	50                   	push   %eax
  80b992:	e8 dc e9 ff ff       	call   80a373 <sys_sem_signal>
  80b997:	83 c4 10             	add    $0x10,%esp
  80b99a:	eb 98                	jmp    80b934 <err_tcp+0x57>
    conn->state = NETCONN_NONE;
  80b99c:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    sys_sem_signal(conn->op_completed);
  80b9a3:	83 ec 0c             	sub    $0xc,%esp
  80b9a6:	ff 73 10             	pushl  0x10(%ebx)
  80b9a9:	e8 c5 e9 ff ff       	call   80a373 <sys_sem_signal>
  80b9ae:	83 c4 10             	add    $0x10,%esp
}
  80b9b1:	eb b8                	jmp    80b96b <err_tcp+0x8e>

0080b9b3 <do_writemore>:
 * @return ERR_OK
 *         ERR_MEM if LWIP_TCPIP_CORE_LOCKING=1 and sending hasn't yet finished
 */
static err_t
do_writemore(struct netconn *conn)
{
  80b9b3:	55                   	push   %ebp
  80b9b4:	89 e5                	mov    %esp,%ebp
  80b9b6:	57                   	push   %edi
  80b9b7:	56                   	push   %esi
  80b9b8:	53                   	push   %ebx
  80b9b9:	83 ec 0c             	sub    $0xc,%esp
  err_t err;
  void *dataptr;
  u16_t len, available;
  u8_t write_finished = 0;

  LWIP_ASSERT("conn->state == NETCONN_WRITE", (conn->state == NETCONN_WRITE));
  80b9bc:	83 78 04 01          	cmpl   $0x1,0x4(%eax)
  80b9c0:	0f 85 c9 00 00 00    	jne    80ba8f <do_writemore+0xdc>
  80b9c6:	89 c3                	mov    %eax,%ebx

  dataptr = (u8_t*)conn->write_msg->msg.w.dataptr + conn->write_offset;
  80b9c8:	8b 40 24             	mov    0x24(%eax),%eax
  80b9cb:	8b 7b 28             	mov    0x28(%ebx),%edi
  80b9ce:	89 fa                	mov    %edi,%edx
  80b9d0:	03 50 04             	add    0x4(%eax),%edx
  if ((conn->write_msg->msg.w.len - conn->write_offset > 0xffff)) { /* max_u16_t */
  80b9d3:	8b 70 08             	mov    0x8(%eax),%esi
  80b9d6:	89 f1                	mov    %esi,%ecx
  80b9d8:	29 f9                	sub    %edi,%ecx
    len = 0xffff;
#if LWIP_TCPIP_CORE_LOCKING
    conn->write_delayed = 1;
#endif
  } else {
    len = conn->write_msg->msg.w.len - conn->write_offset;
  80b9da:	29 fe                	sub    %edi,%esi
  80b9dc:	81 f9 00 00 01 00    	cmp    $0x10000,%ecx
  80b9e2:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
  80b9e7:	0f 4d f1             	cmovge %ecx,%esi
  }
  available = tcp_sndbuf(conn->pcb.tcp);
  80b9ea:	8b 4b 08             	mov    0x8(%ebx),%ecx
#if LWIP_TCPIP_CORE_LOCKING
    conn->write_delayed = 1;
#endif
  }

  err = tcp_write(conn->pcb.tcp, dataptr, len, conn->write_msg->msg.w.apiflags);
  80b9ed:	66 39 71 6e          	cmp    %si,0x6e(%ecx)
  80b9f1:	66 0f 46 71 6e       	cmovbe 0x6e(%ecx),%si
  80b9f6:	0f b7 f6             	movzwl %si,%esi
  80b9f9:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
  80b9fd:	50                   	push   %eax
  80b9fe:	56                   	push   %esi
  80b9ff:	52                   	push   %edx
  80ba00:	51                   	push   %ecx
  80ba01:	e8 7e c8 ff ff       	call   808284 <tcp_write>
  LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->write_msg->msg.w.len));
  80ba06:	89 f2                	mov    %esi,%edx
  80ba08:	03 53 28             	add    0x28(%ebx),%edx
  80ba0b:	8b 4b 24             	mov    0x24(%ebx),%ecx
  80ba0e:	83 c4 10             	add    $0x10,%esp
  80ba11:	3b 51 08             	cmp    0x8(%ecx),%edx
  80ba14:	0f 8f 8c 00 00 00    	jg     80baa6 <do_writemore+0xf3>
  if (err == ERR_OK) {
  80ba1a:	84 c0                	test   %al,%al
  80ba1c:	0f 85 bf 00 00 00    	jne    80bae1 <do_writemore+0x12e>
    conn->write_offset += len;
  80ba22:	89 53 28             	mov    %edx,0x28(%ebx)
  u8_t write_finished = 0;
  80ba25:	bf 00 00 00 00       	mov    $0x0,%edi
    if (conn->write_offset == conn->write_msg->msg.w.len) {
  80ba2a:	3b 51 08             	cmp    0x8(%ecx),%edx
  80ba2d:	0f 84 8a 00 00 00    	je     80babd <do_writemore+0x10a>
      /* everything was written */
      write_finished = 1;
      conn->write_msg = NULL;
      conn->write_offset = 0;
    }
    err = tcp_output_nagle(conn->pcb.tcp);
  80ba33:	8b 43 08             	mov    0x8(%ebx),%eax
  80ba36:	83 78 78 00          	cmpl   $0x0,0x78(%eax)
  80ba3a:	74 1a                	je     80ba56 <do_writemore+0xa3>
  80ba3c:	f6 40 20 40          	testb  $0x40,0x20(%eax)
  80ba40:	75 14                	jne    80ba56 <do_writemore+0xa3>
  80ba42:	8b 50 74             	mov    0x74(%eax),%edx
  80ba45:	85 d2                	test   %edx,%edx
  80ba47:	0f 84 88 00 00 00    	je     80bad5 <do_writemore+0x122>
  80ba4d:	83 3a 00             	cmpl   $0x0,(%edx)
  80ba50:	0f 84 85 00 00 00    	je     80badb <do_writemore+0x128>
  80ba56:	83 ec 0c             	sub    $0xc,%esp
  80ba59:	50                   	push   %eax
  80ba5a:	e8 80 c8 ff ff       	call   8082df <tcp_output>
    conn->err = err;
  80ba5f:	88 43 0c             	mov    %al,0xc(%ebx)
    if ((err == ERR_OK) && (tcp_sndbuf(conn->pcb.tcp) <= TCP_SNDLOWAT)) {
  80ba62:	83 c4 10             	add    $0x10,%esp
  80ba65:	84 c0                	test   %al,%al
  80ba67:	75 1e                	jne    80ba87 <do_writemore+0xd4>
  80ba69:	8b 43 08             	mov    0x8(%ebx),%eax
  80ba6c:	66 81 78 6e a0 2d    	cmpw   $0x2da0,0x6e(%eax)
  80ba72:	77 13                	ja     80ba87 <do_writemore+0xd4>
      API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
  80ba74:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80ba77:	85 c0                	test   %eax,%eax
  80ba79:	74 0c                	je     80ba87 <do_writemore+0xd4>
  80ba7b:	83 ec 04             	sub    $0x4,%esp
  80ba7e:	56                   	push   %esi
  80ba7f:	6a 03                	push   $0x3
  80ba81:	53                   	push   %ebx
  80ba82:	ff d0                	call   *%eax
  80ba84:	83 c4 10             	add    $0x10,%esp
       the error to the application thread. */
    conn->err = err;
    write_finished = 1;
  }

  if (write_finished) {
  80ba87:	89 f8                	mov    %edi,%eax
  80ba89:	84 c0                	test   %al,%al
  80ba8b:	74 70                	je     80bafd <do_writemore+0x14a>
  80ba8d:	eb 59                	jmp    80bae8 <do_writemore+0x135>
  LWIP_ASSERT("conn->state == NETCONN_WRITE", (conn->state == NETCONN_WRITE));
  80ba8f:	83 ec 04             	sub    $0x4,%esp
  80ba92:	68 06 35 81 00       	push   $0x813506
  80ba97:	68 b8 03 00 00       	push   $0x3b8
  80ba9c:	68 a6 34 81 00       	push   $0x8134a6
  80baa1:	e8 a1 2e 00 00       	call   80e947 <_panic>
  LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->write_msg->msg.w.len));
  80baa6:	83 ec 04             	sub    $0x4,%esp
  80baa9:	68 23 35 81 00       	push   $0x813523
  80baae:	68 cd 03 00 00       	push   $0x3cd
  80bab3:	68 a6 34 81 00       	push   $0x8134a6
  80bab8:	e8 8a 2e 00 00       	call   80e947 <_panic>
      conn->write_msg = NULL;
  80babd:	c7 43 24 00 00 00 00 	movl   $0x0,0x24(%ebx)
      conn->write_offset = 0;
  80bac4:	c7 43 28 00 00 00 00 	movl   $0x0,0x28(%ebx)
      write_finished = 1;
  80bacb:	bf 01 00 00 00       	mov    $0x1,%edi
  80bad0:	e9 5e ff ff ff       	jmp    80ba33 <do_writemore+0x80>
    conn->err = err;
  80bad5:	c6 43 0c 00          	movb   $0x0,0xc(%ebx)
  80bad9:	eb 8e                	jmp    80ba69 <do_writemore+0xb6>
  80badb:	c6 43 0c 00          	movb   $0x0,0xc(%ebx)
  80badf:	eb 88                	jmp    80ba69 <do_writemore+0xb6>
  } else if (err == ERR_MEM) {
  80bae1:	3c ff                	cmp    $0xff,%al
  80bae3:	74 25                	je     80bb0a <do_writemore+0x157>
    conn->err = err;
  80bae5:	88 43 0c             	mov    %al,0xc(%ebx)
    /* everything was written: set back connection state
       and back to application task */
    conn->state = NETCONN_NONE;
  80bae8:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
#if LWIP_TCPIP_CORE_LOCKING
    if (conn->write_delayed != 0)
#endif
    {
      sys_sem_signal(conn->op_completed);
  80baef:	83 ec 0c             	sub    $0xc,%esp
  80baf2:	ff 73 10             	pushl  0x10(%ebx)
  80baf5:	e8 79 e8 ff ff       	call   80a373 <sys_sem_signal>
  80bafa:	83 c4 10             	add    $0x10,%esp
#if LWIP_TCPIP_CORE_LOCKING
  else
    return ERR_MEM;
#endif
  return ERR_OK;
}
  80bafd:	b8 00 00 00 00       	mov    $0x0,%eax
  80bb02:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80bb05:	5b                   	pop    %ebx
  80bb06:	5e                   	pop    %esi
  80bb07:	5f                   	pop    %edi
  80bb08:	5d                   	pop    %ebp
  80bb09:	c3                   	ret    
    err = tcp_output(conn->pcb.tcp);
  80bb0a:	83 ec 0c             	sub    $0xc,%esp
  80bb0d:	ff 73 08             	pushl  0x8(%ebx)
  80bb10:	e8 ca c7 ff ff       	call   8082df <tcp_output>
  80bb15:	83 c4 10             	add    $0x10,%esp
  80bb18:	eb e3                	jmp    80bafd <do_writemore+0x14a>

0080bb1a <do_close_internal>:
{
  80bb1a:	55                   	push   %ebp
  80bb1b:	89 e5                	mov    %esp,%ebp
  80bb1d:	53                   	push   %ebx
  80bb1e:	83 ec 04             	sub    $0x4,%esp
  LWIP_ASSERT("invalid conn", (conn != NULL));
  80bb21:	85 c0                	test   %eax,%eax
  80bb23:	0f 84 e2 00 00 00    	je     80bc0b <do_close_internal+0xf1>
  80bb29:	89 c3                	mov    %eax,%ebx
  LWIP_ASSERT("this is for tcp netconns only", (conn->type == NETCONN_TCP));
  80bb2b:	83 38 10             	cmpl   $0x10,(%eax)
  80bb2e:	0f 85 ee 00 00 00    	jne    80bc22 <do_close_internal+0x108>
  LWIP_ASSERT("conn must be in state NETCONN_CLOSE", (conn->state == NETCONN_CLOSE));
  80bb34:	83 78 04 04          	cmpl   $0x4,0x4(%eax)
  80bb38:	0f 85 fb 00 00 00    	jne    80bc39 <do_close_internal+0x11f>
  LWIP_ASSERT("pcb already closed", (conn->pcb.tcp != NULL));
  80bb3e:	8b 40 08             	mov    0x8(%eax),%eax
  80bb41:	85 c0                	test   %eax,%eax
  80bb43:	0f 84 07 01 00 00    	je     80bc50 <do_close_internal+0x136>
  tcp_arg(conn->pcb.tcp, NULL);
  80bb49:	83 ec 08             	sub    $0x8,%esp
  80bb4c:	6a 00                	push   $0x0
  80bb4e:	50                   	push   %eax
  80bb4f:	e8 e6 9e ff ff       	call   805a3a <tcp_arg>
  if (conn->pcb.tcp->state == LISTEN) {
  80bb54:	8b 43 08             	mov    0x8(%ebx),%eax
  80bb57:	83 c4 10             	add    $0x10,%esp
  80bb5a:	83 78 10 01          	cmpl   $0x1,0x10(%eax)
  80bb5e:	0f 84 03 01 00 00    	je     80bc67 <do_close_internal+0x14d>
    tcp_recv(conn->pcb.tcp, NULL);
  80bb64:	83 ec 08             	sub    $0x8,%esp
  80bb67:	6a 00                	push   $0x0
  80bb69:	50                   	push   %eax
  80bb6a:	e8 dd 9e ff ff       	call   805a4c <tcp_recv>
    tcp_accept(conn->pcb.tcp, NULL);
  80bb6f:	83 c4 08             	add    $0x8,%esp
  80bb72:	6a 00                	push   $0x0
  80bb74:	ff 73 08             	pushl  0x8(%ebx)
  80bb77:	e8 0f 9f ff ff       	call   805a8b <tcp_accept>
    tcp_sent(conn->pcb.tcp, NULL);
  80bb7c:	83 c4 08             	add    $0x8,%esp
  80bb7f:	6a 00                	push   $0x0
  80bb81:	ff 73 08             	pushl  0x8(%ebx)
  80bb84:	e8 d8 9e ff ff       	call   805a61 <tcp_sent>
    tcp_poll(conn->pcb.tcp, NULL, 4);
  80bb89:	83 c4 0c             	add    $0xc,%esp
  80bb8c:	6a 04                	push   $0x4
  80bb8e:	6a 00                	push   $0x0
  80bb90:	ff 73 08             	pushl  0x8(%ebx)
  80bb93:	e8 05 9f ff ff       	call   805a9d <tcp_poll>
    tcp_err(conn->pcb.tcp, NULL);
  80bb98:	83 c4 08             	add    $0x8,%esp
  80bb9b:	6a 00                	push   $0x0
  80bb9d:	ff 73 08             	pushl  0x8(%ebx)
  80bba0:	e8 d1 9e ff ff       	call   805a76 <tcp_err>
  80bba5:	83 c4 10             	add    $0x10,%esp
  err = tcp_close(conn->pcb.tcp);
  80bba8:	83 ec 0c             	sub    $0xc,%esp
  80bbab:	ff 73 08             	pushl  0x8(%ebx)
  80bbae:	e8 99 a0 ff ff       	call   805c4c <tcp_close>
  if (err == ERR_OK) {
  80bbb3:	83 c4 10             	add    $0x10,%esp
  80bbb6:	84 c0                	test   %al,%al
  80bbb8:	0f 85 bc 00 00 00    	jne    80bc7a <do_close_internal+0x160>
    conn->state = NETCONN_NONE;
  80bbbe:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    conn->pcb.tcp = NULL;
  80bbc5:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    conn->err = ERR_OK;
  80bbcc:	c6 43 0c 00          	movb   $0x0,0xc(%ebx)
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80bbd0:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80bbd3:	85 c0                	test   %eax,%eax
  80bbd5:	74 21                	je     80bbf8 <do_close_internal+0xde>
  80bbd7:	83 ec 04             	sub    $0x4,%esp
  80bbda:	6a 00                	push   $0x0
  80bbdc:	6a 00                	push   $0x0
  80bbde:	53                   	push   %ebx
  80bbdf:	ff d0                	call   *%eax
    API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
  80bbe1:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80bbe4:	83 c4 10             	add    $0x10,%esp
  80bbe7:	85 c0                	test   %eax,%eax
  80bbe9:	74 0d                	je     80bbf8 <do_close_internal+0xde>
  80bbeb:	83 ec 04             	sub    $0x4,%esp
  80bbee:	6a 00                	push   $0x0
  80bbf0:	6a 02                	push   $0x2
  80bbf2:	53                   	push   %ebx
  80bbf3:	ff d0                	call   *%eax
  80bbf5:	83 c4 10             	add    $0x10,%esp
    sys_sem_signal(conn->op_completed);
  80bbf8:	83 ec 0c             	sub    $0xc,%esp
  80bbfb:	ff 73 10             	pushl  0x10(%ebx)
  80bbfe:	e8 70 e7 ff ff       	call   80a373 <sys_sem_signal>
  80bc03:	83 c4 10             	add    $0x10,%esp
}
  80bc06:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80bc09:	c9                   	leave  
  80bc0a:	c3                   	ret    
  LWIP_ASSERT("invalid conn", (conn != NULL));
  80bc0b:	83 ec 04             	sub    $0x4,%esp
  80bc0e:	68 14 33 81 00       	push   $0x813314
  80bc13:	68 53 02 00 00       	push   $0x253
  80bc18:	68 a6 34 81 00       	push   $0x8134a6
  80bc1d:	e8 25 2d 00 00       	call   80e947 <_panic>
  LWIP_ASSERT("this is for tcp netconns only", (conn->type == NETCONN_TCP));
  80bc22:	83 ec 04             	sub    $0x4,%esp
  80bc25:	68 41 35 81 00       	push   $0x813541
  80bc2a:	68 54 02 00 00       	push   $0x254
  80bc2f:	68 a6 34 81 00       	push   $0x8134a6
  80bc34:	e8 0e 2d 00 00       	call   80e947 <_panic>
  LWIP_ASSERT("conn must be in state NETCONN_CLOSE", (conn->state == NETCONN_CLOSE));
  80bc39:	83 ec 04             	sub    $0x4,%esp
  80bc3c:	68 e4 33 81 00       	push   $0x8133e4
  80bc41:	68 55 02 00 00       	push   $0x255
  80bc46:	68 a6 34 81 00       	push   $0x8134a6
  80bc4b:	e8 f7 2c 00 00       	call   80e947 <_panic>
  LWIP_ASSERT("pcb already closed", (conn->pcb.tcp != NULL));
  80bc50:	83 ec 04             	sub    $0x4,%esp
  80bc53:	68 5f 35 81 00       	push   $0x81355f
  80bc58:	68 56 02 00 00       	push   $0x256
  80bc5d:	68 a6 34 81 00       	push   $0x8134a6
  80bc62:	e8 e0 2c 00 00       	call   80e947 <_panic>
    tcp_accept(conn->pcb.tcp, NULL);
  80bc67:	83 ec 08             	sub    $0x8,%esp
  80bc6a:	6a 00                	push   $0x0
  80bc6c:	50                   	push   %eax
  80bc6d:	e8 19 9e ff ff       	call   805a8b <tcp_accept>
  80bc72:	83 c4 10             	add    $0x10,%esp
  80bc75:	e9 2e ff ff ff       	jmp    80bba8 <do_close_internal+0x8e>
    LWIP_ASSERT("Closing a listen pcb may not fail!", (conn->pcb.tcp->state != LISTEN));
  80bc7a:	8b 43 08             	mov    0x8(%ebx),%eax
  80bc7d:	83 78 10 01          	cmpl   $0x1,0x10(%eax)
  80bc81:	74 44                	je     80bcc7 <do_close_internal+0x1ad>
    tcp_sent(conn->pcb.tcp, sent_tcp);
  80bc83:	83 ec 08             	sub    $0x8,%esp
  80bc86:	68 28 bd 80 00       	push   $0x80bd28
  80bc8b:	50                   	push   %eax
  80bc8c:	e8 d0 9d ff ff       	call   805a61 <tcp_sent>
    tcp_poll(conn->pcb.tcp, poll_tcp, 4);
  80bc91:	83 c4 0c             	add    $0xc,%esp
  80bc94:	6a 04                	push   $0x4
  80bc96:	68 de bc 80 00       	push   $0x80bcde
  80bc9b:	ff 73 08             	pushl  0x8(%ebx)
  80bc9e:	e8 fa 9d ff ff       	call   805a9d <tcp_poll>
    tcp_err(conn->pcb.tcp, err_tcp);
  80bca3:	83 c4 08             	add    $0x8,%esp
  80bca6:	68 dd b8 80 00       	push   $0x80b8dd
  80bcab:	ff 73 08             	pushl  0x8(%ebx)
  80bcae:	e8 c3 9d ff ff       	call   805a76 <tcp_err>
    tcp_arg(conn->pcb.tcp, conn);
  80bcb3:	83 c4 08             	add    $0x8,%esp
  80bcb6:	53                   	push   %ebx
  80bcb7:	ff 73 08             	pushl  0x8(%ebx)
  80bcba:	e8 7b 9d ff ff       	call   805a3a <tcp_arg>
  80bcbf:	83 c4 10             	add    $0x10,%esp
}
  80bcc2:	e9 3f ff ff ff       	jmp    80bc06 <do_close_internal+0xec>
    LWIP_ASSERT("Closing a listen pcb may not fail!", (conn->pcb.tcp->state != LISTEN));
  80bcc7:	83 ec 04             	sub    $0x4,%esp
  80bcca:	68 08 34 81 00       	push   $0x813408
  80bccf:	68 75 02 00 00       	push   $0x275
  80bcd4:	68 a6 34 81 00       	push   $0x8134a6
  80bcd9:	e8 69 2c 00 00       	call   80e947 <_panic>

0080bcde <poll_tcp>:
{
  80bcde:	f3 0f 1e fb          	endbr32 
  80bce2:	55                   	push   %ebp
  80bce3:	89 e5                	mov    %esp,%ebp
  80bce5:	83 ec 08             	sub    $0x8,%esp
  80bce8:	8b 45 08             	mov    0x8(%ebp),%eax
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80bceb:	85 c0                	test   %eax,%eax
  80bced:	74 14                	je     80bd03 <poll_tcp+0x25>
  if (conn->state == NETCONN_WRITE) {
  80bcef:	8b 50 04             	mov    0x4(%eax),%edx
  80bcf2:	83 fa 01             	cmp    $0x1,%edx
  80bcf5:	74 23                	je     80bd1a <poll_tcp+0x3c>
  } else if (conn->state == NETCONN_CLOSE) {
  80bcf7:	83 fa 04             	cmp    $0x4,%edx
  80bcfa:	74 25                	je     80bd21 <poll_tcp+0x43>
}
  80bcfc:	b8 00 00 00 00       	mov    $0x0,%eax
  80bd01:	c9                   	leave  
  80bd02:	c3                   	ret    
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80bd03:	83 ec 04             	sub    $0x4,%esp
  80bd06:	68 f9 34 81 00       	push   $0x8134f9
  80bd0b:	68 eb 00 00 00       	push   $0xeb
  80bd10:	68 a6 34 81 00       	push   $0x8134a6
  80bd15:	e8 2d 2c 00 00       	call   80e947 <_panic>
    do_writemore(conn);
  80bd1a:	e8 94 fc ff ff       	call   80b9b3 <do_writemore>
  80bd1f:	eb db                	jmp    80bcfc <poll_tcp+0x1e>
    do_close_internal(conn);
  80bd21:	e8 f4 fd ff ff       	call   80bb1a <do_close_internal>
  80bd26:	eb d4                	jmp    80bcfc <poll_tcp+0x1e>

0080bd28 <sent_tcp>:
{
  80bd28:	f3 0f 1e fb          	endbr32 
  80bd2c:	55                   	push   %ebp
  80bd2d:	89 e5                	mov    %esp,%ebp
  80bd2f:	56                   	push   %esi
  80bd30:	53                   	push   %ebx
  80bd31:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80bd34:	8b 75 10             	mov    0x10(%ebp),%esi
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80bd37:	85 db                	test   %ebx,%ebx
  80bd39:	74 3e                	je     80bd79 <sent_tcp+0x51>
  if (conn->state == NETCONN_WRITE) {
  80bd3b:	8b 43 04             	mov    0x4(%ebx),%eax
  80bd3e:	83 f8 01             	cmp    $0x1,%eax
  80bd41:	74 4d                	je     80bd90 <sent_tcp+0x68>
  } else if (conn->state == NETCONN_CLOSE) {
  80bd43:	83 f8 04             	cmp    $0x4,%eax
  80bd46:	74 6e                	je     80bdb6 <sent_tcp+0x8e>
    if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT)) {
  80bd48:	8b 43 08             	mov    0x8(%ebx),%eax
  80bd4b:	85 c0                	test   %eax,%eax
  80bd4d:	74 1e                	je     80bd6d <sent_tcp+0x45>
  80bd4f:	66 81 78 6e a0 2d    	cmpw   $0x2da0,0x6e(%eax)
  80bd55:	76 16                	jbe    80bd6d <sent_tcp+0x45>
      API_EVENT(conn, NETCONN_EVT_SENDPLUS, len);
  80bd57:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80bd5a:	85 c0                	test   %eax,%eax
  80bd5c:	74 0f                	je     80bd6d <sent_tcp+0x45>
  80bd5e:	83 ec 04             	sub    $0x4,%esp
  80bd61:	0f b7 f6             	movzwl %si,%esi
  80bd64:	56                   	push   %esi
  80bd65:	6a 02                	push   $0x2
  80bd67:	53                   	push   %ebx
  80bd68:	ff d0                	call   *%eax
  80bd6a:	83 c4 10             	add    $0x10,%esp
}
  80bd6d:	b8 00 00 00 00       	mov    $0x0,%eax
  80bd72:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80bd75:	5b                   	pop    %ebx
  80bd76:	5e                   	pop    %esi
  80bd77:	5d                   	pop    %ebp
  80bd78:	c3                   	ret    
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80bd79:	83 ec 04             	sub    $0x4,%esp
  80bd7c:	68 f9 34 81 00       	push   $0x8134f9
  80bd81:	68 03 01 00 00       	push   $0x103
  80bd86:	68 a6 34 81 00       	push   $0x8134a6
  80bd8b:	e8 b7 2b 00 00       	call   80e947 <_panic>
    LWIP_ASSERT("conn->pcb.tcp != NULL", conn->pcb.tcp != NULL);
  80bd90:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
  80bd94:	74 09                	je     80bd9f <sent_tcp+0x77>
    do_writemore(conn);
  80bd96:	89 d8                	mov    %ebx,%eax
  80bd98:	e8 16 fc ff ff       	call   80b9b3 <do_writemore>
  80bd9d:	eb a9                	jmp    80bd48 <sent_tcp+0x20>
    LWIP_ASSERT("conn->pcb.tcp != NULL", conn->pcb.tcp != NULL);
  80bd9f:	83 ec 04             	sub    $0x4,%esp
  80bda2:	68 72 35 81 00       	push   $0x813572
  80bda7:	68 06 01 00 00       	push   $0x106
  80bdac:	68 a6 34 81 00       	push   $0x8134a6
  80bdb1:	e8 91 2b 00 00       	call   80e947 <_panic>
    do_close_internal(conn);
  80bdb6:	89 d8                	mov    %ebx,%eax
  80bdb8:	e8 5d fd ff ff       	call   80bb1a <do_close_internal>
  80bdbd:	eb 89                	jmp    80bd48 <sent_tcp+0x20>

0080bdbf <do_newconn>:
{
  80bdbf:	f3 0f 1e fb          	endbr32 
  80bdc3:	55                   	push   %ebp
  80bdc4:	89 e5                	mov    %esp,%ebp
  80bdc6:	56                   	push   %esi
  80bdc7:	53                   	push   %ebx
  80bdc8:	8b 5d 08             	mov    0x8(%ebp),%ebx
   if(msg->conn->pcb.tcp == NULL) {
  80bdcb:	8b 03                	mov    (%ebx),%eax
  80bdcd:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80bdd1:	74 17                	je     80bdea <do_newconn+0x2b>
   TCPIP_APIMSG_ACK(msg);
  80bdd3:	83 ec 0c             	sub    $0xc,%esp
  80bdd6:	8b 03                	mov    (%ebx),%eax
  80bdd8:	ff 70 10             	pushl  0x10(%eax)
  80bddb:	e8 93 e5 ff ff       	call   80a373 <sys_sem_signal>
}
  80bde0:	83 c4 10             	add    $0x10,%esp
  80bde3:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80bde6:	5b                   	pop    %ebx
  80bde7:	5e                   	pop    %esi
  80bde8:	5d                   	pop    %ebp
  80bde9:	c3                   	ret    
   msg->conn->err = ERR_OK;
  80bdea:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
   LWIP_ASSERT("pcb_new: pcb already allocated", msg->conn->pcb.tcp == NULL);
  80bdee:	8b 33                	mov    (%ebx),%esi
  80bdf0:	83 7e 08 00          	cmpl   $0x0,0x8(%esi)
  80bdf4:	75 20                	jne    80be16 <do_newconn+0x57>
   switch(NETCONNTYPE_GROUP(msg->conn->type)) {
  80bdf6:	8b 06                	mov    (%esi),%eax
  80bdf8:	25 f0 00 00 00       	and    $0xf0,%eax
  80bdfd:	83 f8 20             	cmp    $0x20,%eax
  80be00:	74 67                	je     80be69 <do_newconn+0xaa>
  80be02:	83 f8 40             	cmp    $0x40,%eax
  80be05:	74 26                	je     80be2d <do_newconn+0x6e>
  80be07:	83 f8 10             	cmp    $0x10,%eax
  80be0a:	0f 84 99 00 00 00    	je     80bea9 <do_newconn+0xea>
     msg->conn->err = ERR_VAL;
  80be10:	c6 46 0c f7          	movb   $0xf7,0xc(%esi)
     break;
  80be14:	eb bd                	jmp    80bdd3 <do_newconn+0x14>
   LWIP_ASSERT("pcb_new: pcb already allocated", msg->conn->pcb.tcp == NULL);
  80be16:	83 ec 04             	sub    $0x4,%esp
  80be19:	68 2c 34 81 00       	push   $0x81342c
  80be1e:	68 8a 01 00 00       	push   $0x18a
  80be23:	68 a6 34 81 00       	push   $0x8134a6
  80be28:	e8 1a 2b 00 00       	call   80e947 <_panic>
     msg->conn->pcb.raw = raw_new(msg->msg.n.proto);
  80be2d:	83 ec 0c             	sub    $0xc,%esp
  80be30:	0f b6 43 04          	movzbl 0x4(%ebx),%eax
  80be34:	50                   	push   %eax
  80be35:	e8 6a 25 00 00       	call   80e3a4 <raw_new>
  80be3a:	89 46 08             	mov    %eax,0x8(%esi)
     if(msg->conn->pcb.raw == NULL) {
  80be3d:	8b 03                	mov    (%ebx),%eax
  80be3f:	8b 50 08             	mov    0x8(%eax),%edx
  80be42:	83 c4 10             	add    $0x10,%esp
  80be45:	85 d2                	test   %edx,%edx
  80be47:	74 17                	je     80be60 <do_newconn+0xa1>
     raw_recv(msg->conn->pcb.raw, recv_raw, msg->conn);
  80be49:	83 ec 04             	sub    $0x4,%esp
  80be4c:	50                   	push   %eax
  80be4d:	68 4e b7 80 00       	push   $0x80b74e
  80be52:	52                   	push   %edx
  80be53:	e8 c0 23 00 00       	call   80e218 <raw_recv>
     break;
  80be58:	83 c4 10             	add    $0x10,%esp
  80be5b:	e9 73 ff ff ff       	jmp    80bdd3 <do_newconn+0x14>
       msg->conn->err = ERR_MEM;
  80be60:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
       break;
  80be64:	e9 6a ff ff ff       	jmp    80bdd3 <do_newconn+0x14>
     msg->conn->pcb.udp = udp_new();
  80be69:	e8 44 d4 ff ff       	call   8092b2 <udp_new>
  80be6e:	89 46 08             	mov    %eax,0x8(%esi)
     if(msg->conn->pcb.udp == NULL) {
  80be71:	8b 03                	mov    (%ebx),%eax
  80be73:	8b 50 08             	mov    0x8(%eax),%edx
  80be76:	85 d2                	test   %edx,%edx
  80be78:	74 20                	je     80be9a <do_newconn+0xdb>
     if (msg->conn->type==NETCONN_UDPNOCHKSUM) {
  80be7a:	83 38 22             	cmpl   $0x22,(%eax)
  80be7d:	74 24                	je     80bea3 <do_newconn+0xe4>
     udp_recv(msg->conn->pcb.udp, recv_udp, msg->conn);
  80be7f:	8b 03                	mov    (%ebx),%eax
  80be81:	83 ec 04             	sub    $0x4,%esp
  80be84:	50                   	push   %eax
  80be85:	68 40 b6 80 00       	push   $0x80b640
  80be8a:	ff 70 08             	pushl  0x8(%eax)
  80be8d:	e8 c0 d3 ff ff       	call   809252 <udp_recv>
     break;
  80be92:	83 c4 10             	add    $0x10,%esp
  80be95:	e9 39 ff ff ff       	jmp    80bdd3 <do_newconn+0x14>
       msg->conn->err = ERR_MEM;
  80be9a:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
       break;
  80be9e:	e9 30 ff ff ff       	jmp    80bdd3 <do_newconn+0x14>
       udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_NOCHKSUM);
  80bea3:	c6 42 10 01          	movb   $0x1,0x10(%edx)
  80bea7:	eb d6                	jmp    80be7f <do_newconn+0xc0>
     msg->conn->pcb.tcp = tcp_new();
  80bea9:	e8 60 a6 ff ff       	call   80650e <tcp_new>
  80beae:	89 46 08             	mov    %eax,0x8(%esi)
     if(msg->conn->pcb.tcp == NULL) {
  80beb1:	8b 03                	mov    (%ebx),%eax
  80beb3:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80beb7:	74 0a                	je     80bec3 <do_newconn+0x104>
     setup_tcp(msg->conn);
  80beb9:	e8 7c f9 ff ff       	call   80b83a <setup_tcp>
     break;
  80bebe:	e9 10 ff ff ff       	jmp    80bdd3 <do_newconn+0x14>
       msg->conn->err = ERR_MEM;
  80bec3:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
       break;
  80bec7:	e9 07 ff ff ff       	jmp    80bdd3 <do_newconn+0x14>

0080becc <netconn_alloc>:
{
  80becc:	f3 0f 1e fb          	endbr32 
  80bed0:	55                   	push   %ebp
  80bed1:	89 e5                	mov    %esp,%ebp
  80bed3:	53                   	push   %ebx
  80bed4:	83 ec 10             	sub    $0x10,%esp
  conn = memp_malloc(MEMP_NETCONN);
  80bed7:	6a 07                	push   $0x7
  80bed9:	e8 66 87 ff ff       	call   804644 <memp_malloc>
  80bede:	89 c3                	mov    %eax,%ebx
  if (conn == NULL) {
  80bee0:	83 c4 10             	add    $0x10,%esp
  80bee3:	85 c0                	test   %eax,%eax
  80bee5:	74 5b                	je     80bf42 <netconn_alloc+0x76>
  conn->err = ERR_OK;
  80bee7:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
  conn->type = t;
  80beeb:	8b 45 08             	mov    0x8(%ebp),%eax
  80beee:	89 03                	mov    %eax,(%ebx)
  conn->pcb.tcp = NULL;
  80bef0:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  if ((conn->op_completed = sys_sem_new(0)) == SYS_SEM_NULL) {
  80bef7:	83 ec 0c             	sub    $0xc,%esp
  80befa:	6a 00                	push   $0x0
  80befc:	e8 a5 e1 ff ff       	call   80a0a6 <sys_sem_new>
  80bf01:	89 43 10             	mov    %eax,0x10(%ebx)
  80bf04:	83 c4 10             	add    $0x10,%esp
  80bf07:	83 f8 ff             	cmp    $0xffffffff,%eax
  80bf0a:	74 3d                	je     80bf49 <netconn_alloc+0x7d>
  if ((conn->recvmbox = sys_mbox_new(size)) == SYS_MBOX_NULL) {
  80bf0c:	83 ec 0c             	sub    $0xc,%esp
  80bf0f:	6a 00                	push   $0x0
  80bf11:	e8 45 e3 ff ff       	call   80a25b <sys_mbox_new>
  80bf16:	89 43 14             	mov    %eax,0x14(%ebx)
  80bf19:	83 c4 10             	add    $0x10,%esp
  80bf1c:	83 f8 ff             	cmp    $0xffffffff,%eax
  80bf1f:	74 3d                	je     80bf5e <netconn_alloc+0x92>
  conn->acceptmbox   = SYS_MBOX_NULL;
  80bf21:	c7 43 18 ff ff ff ff 	movl   $0xffffffff,0x18(%ebx)
  conn->state        = NETCONN_NONE;
  80bf28:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  conn->socket       = -1;
  80bf2f:	c7 43 1c ff ff ff ff 	movl   $0xffffffff,0x1c(%ebx)
  conn->callback     = callback;
  80bf36:	8b 45 0c             	mov    0xc(%ebp),%eax
  80bf39:	89 43 2c             	mov    %eax,0x2c(%ebx)
  conn->recv_avail   = 0;
  80bf3c:	66 c7 43 20 00 00    	movw   $0x0,0x20(%ebx)
}
  80bf42:	89 d8                	mov    %ebx,%eax
  80bf44:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80bf47:	c9                   	leave  
  80bf48:	c3                   	ret    
    memp_free(MEMP_NETCONN, conn);
  80bf49:	83 ec 08             	sub    $0x8,%esp
  80bf4c:	53                   	push   %ebx
  80bf4d:	6a 07                	push   $0x7
  80bf4f:	e8 4a 87 ff ff       	call   80469e <memp_free>
    return NULL;
  80bf54:	83 c4 10             	add    $0x10,%esp
  80bf57:	bb 00 00 00 00       	mov    $0x0,%ebx
  80bf5c:	eb e4                	jmp    80bf42 <netconn_alloc+0x76>
    sys_sem_free(conn->op_completed);
  80bf5e:	83 ec 0c             	sub    $0xc,%esp
  80bf61:	ff 73 10             	pushl  0x10(%ebx)
  80bf64:	e8 c2 e1 ff ff       	call   80a12b <sys_sem_free>
    memp_free(MEMP_NETCONN, conn);
  80bf69:	83 c4 08             	add    $0x8,%esp
  80bf6c:	53                   	push   %ebx
  80bf6d:	6a 07                	push   $0x7
  80bf6f:	e8 2a 87 ff ff       	call   80469e <memp_free>
    return NULL;
  80bf74:	83 c4 10             	add    $0x10,%esp
  80bf77:	bb 00 00 00 00       	mov    $0x0,%ebx
  80bf7c:	eb c4                	jmp    80bf42 <netconn_alloc+0x76>

0080bf7e <netconn_free>:
{
  80bf7e:	f3 0f 1e fb          	endbr32 
  80bf82:	55                   	push   %ebp
  80bf83:	89 e5                	mov    %esp,%ebp
  80bf85:	56                   	push   %esi
  80bf86:	53                   	push   %ebx
  80bf87:	83 ec 10             	sub    $0x10,%esp
  80bf8a:	8b 5d 08             	mov    0x8(%ebp),%ebx
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);
  80bf8d:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
  80bf91:	75 0b                	jne    80bf9e <netconn_free+0x20>
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
  80bf93:	8d 75 f4             	lea    -0xc(%ebp),%esi
  if (conn->recvmbox != SYS_MBOX_NULL) {
  80bf96:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80bf9a:	75 27                	jne    80bfc3 <netconn_free+0x45>
  80bf9c:	eb 68                	jmp    80c006 <netconn_free+0x88>
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);
  80bf9e:	83 ec 04             	sub    $0x4,%esp
  80bfa1:	68 4c 34 81 00       	push   $0x81344c
  80bfa6:	68 26 02 00 00       	push   $0x226
  80bfab:	68 a6 34 81 00       	push   $0x8134a6
  80bfb0:	e8 92 29 00 00       	call   80e947 <_panic>
        netbuf_delete((struct netbuf *)mem);
  80bfb5:	83 ec 0c             	sub    $0xc,%esp
  80bfb8:	ff 75 f4             	pushl  -0xc(%ebp)
  80bfbb:	e8 41 66 ff ff       	call   802601 <netbuf_delete>
  80bfc0:	83 c4 10             	add    $0x10,%esp
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
  80bfc3:	83 ec 08             	sub    $0x8,%esp
  80bfc6:	56                   	push   %esi
  80bfc7:	ff 73 14             	pushl  0x14(%ebx)
  80bfca:	e8 1b e7 ff ff       	call   80a6ea <sys_arch_mbox_tryfetch>
  80bfcf:	83 c4 10             	add    $0x10,%esp
  80bfd2:	83 f8 ff             	cmp    $0xffffffff,%eax
  80bfd5:	74 1a                	je     80bff1 <netconn_free+0x73>
      if (conn->type == NETCONN_TCP) {
  80bfd7:	83 3b 10             	cmpl   $0x10,(%ebx)
  80bfda:	75 d9                	jne    80bfb5 <netconn_free+0x37>
        if(mem != NULL) {
  80bfdc:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80bfdf:	85 c0                	test   %eax,%eax
  80bfe1:	74 e0                	je     80bfc3 <netconn_free+0x45>
          pbuf_free((struct pbuf *)mem);
  80bfe3:	83 ec 0c             	sub    $0xc,%esp
  80bfe6:	50                   	push   %eax
  80bfe7:	e8 35 8a ff ff       	call   804a21 <pbuf_free>
  80bfec:	83 c4 10             	add    $0x10,%esp
  80bfef:	eb d2                	jmp    80bfc3 <netconn_free+0x45>
    sys_mbox_free(conn->recvmbox);
  80bff1:	83 ec 0c             	sub    $0xc,%esp
  80bff4:	ff 73 14             	pushl  0x14(%ebx)
  80bff7:	e8 bc e1 ff ff       	call   80a1b8 <sys_mbox_free>
    conn->recvmbox = SYS_MBOX_NULL;
  80bffc:	c7 43 14 ff ff ff ff 	movl   $0xffffffff,0x14(%ebx)
  80c003:	83 c4 10             	add    $0x10,%esp
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
  80c006:	8d 75 f4             	lea    -0xc(%ebp),%esi
  if (conn->acceptmbox != SYS_MBOX_NULL) {
  80c009:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80c00d:	75 10                	jne    80c01f <netconn_free+0xa1>
  80c00f:	eb 37                	jmp    80c048 <netconn_free+0xca>
      netconn_delete((struct netconn *)mem);
  80c011:	83 ec 0c             	sub    $0xc,%esp
  80c014:	ff 75 f4             	pushl  -0xc(%ebp)
  80c017:	e8 da ef ff ff       	call   80aff6 <netconn_delete>
  80c01c:	83 c4 10             	add    $0x10,%esp
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
  80c01f:	83 ec 08             	sub    $0x8,%esp
  80c022:	56                   	push   %esi
  80c023:	ff 73 18             	pushl  0x18(%ebx)
  80c026:	e8 bf e6 ff ff       	call   80a6ea <sys_arch_mbox_tryfetch>
  80c02b:	83 c4 10             	add    $0x10,%esp
  80c02e:	83 f8 ff             	cmp    $0xffffffff,%eax
  80c031:	75 de                	jne    80c011 <netconn_free+0x93>
    sys_mbox_free(conn->acceptmbox);
  80c033:	83 ec 0c             	sub    $0xc,%esp
  80c036:	ff 73 18             	pushl  0x18(%ebx)
  80c039:	e8 7a e1 ff ff       	call   80a1b8 <sys_mbox_free>
    conn->acceptmbox = SYS_MBOX_NULL;
  80c03e:	c7 43 18 ff ff ff ff 	movl   $0xffffffff,0x18(%ebx)
  80c045:	83 c4 10             	add    $0x10,%esp
  sys_sem_free(conn->op_completed);
  80c048:	83 ec 0c             	sub    $0xc,%esp
  80c04b:	ff 73 10             	pushl  0x10(%ebx)
  80c04e:	e8 d8 e0 ff ff       	call   80a12b <sys_sem_free>
  conn->op_completed = SYS_SEM_NULL;
  80c053:	c7 43 10 ff ff ff ff 	movl   $0xffffffff,0x10(%ebx)
  memp_free(MEMP_NETCONN, conn);
  80c05a:	83 c4 08             	add    $0x8,%esp
  80c05d:	53                   	push   %ebx
  80c05e:	6a 07                	push   $0x7
  80c060:	e8 39 86 ff ff       	call   80469e <memp_free>
}
  80c065:	83 c4 10             	add    $0x10,%esp
  80c068:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80c06b:	5b                   	pop    %ebx
  80c06c:	5e                   	pop    %esi
  80c06d:	5d                   	pop    %ebp
  80c06e:	c3                   	ret    

0080c06f <accept_function>:
{
  80c06f:	f3 0f 1e fb          	endbr32 
  80c073:	55                   	push   %ebp
  80c074:	89 e5                	mov    %esp,%ebp
  80c076:	57                   	push   %edi
  80c077:	56                   	push   %esi
  80c078:	53                   	push   %ebx
  80c079:	83 ec 0c             	sub    $0xc,%esp
  80c07c:	8b 75 08             	mov    0x8(%ebp),%esi
  80c07f:	8b 7d 10             	mov    0x10(%ebp),%edi
  LWIP_ERROR("accept_function: invalid conn->acceptmbox",
  80c082:	83 7e 18 ff          	cmpl   $0xffffffff,0x18(%esi)
  80c086:	74 57                	je     80c0df <accept_function+0x70>
  newconn = netconn_alloc(conn->type, conn->callback);
  80c088:	83 ec 08             	sub    $0x8,%esp
  80c08b:	ff 76 2c             	pushl  0x2c(%esi)
  80c08e:	ff 36                	pushl  (%esi)
  80c090:	e8 37 fe ff ff       	call   80becc <netconn_alloc>
  80c095:	89 c3                	mov    %eax,%ebx
  if (newconn == NULL) {
  80c097:	83 c4 10             	add    $0x10,%esp
  80c09a:	85 c0                	test   %eax,%eax
  80c09c:	74 72                	je     80c110 <accept_function+0xa1>
  newconn->pcb.tcp = newpcb;
  80c09e:	8b 45 0c             	mov    0xc(%ebp),%eax
  80c0a1:	89 43 08             	mov    %eax,0x8(%ebx)
  setup_tcp(newconn);
  80c0a4:	89 d8                	mov    %ebx,%eax
  80c0a6:	e8 8f f7 ff ff       	call   80b83a <setup_tcp>
  newconn->err = err;
  80c0ab:	89 f8                	mov    %edi,%eax
  80c0ad:	88 43 0c             	mov    %al,0xc(%ebx)
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80c0b0:	8b 46 2c             	mov    0x2c(%esi),%eax
  80c0b3:	85 c0                	test   %eax,%eax
  80c0b5:	74 0d                	je     80c0c4 <accept_function+0x55>
  80c0b7:	83 ec 04             	sub    $0x4,%esp
  80c0ba:	6a 00                	push   $0x0
  80c0bc:	6a 00                	push   $0x0
  80c0be:	56                   	push   %esi
  80c0bf:	ff d0                	call   *%eax
  80c0c1:	83 c4 10             	add    $0x10,%esp
  if (sys_mbox_trypost(conn->acceptmbox, newconn) != ERR_OK) {
  80c0c4:	83 ec 08             	sub    $0x8,%esp
  80c0c7:	53                   	push   %ebx
  80c0c8:	ff 76 18             	pushl  0x18(%esi)
  80c0cb:	e8 2b e4 ff ff       	call   80a4fb <sys_mbox_trypost>
  80c0d0:	83 c4 10             	add    $0x10,%esp
  80c0d3:	84 c0                	test   %al,%al
  80c0d5:	75 1f                	jne    80c0f6 <accept_function+0x87>
}
  80c0d7:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80c0da:	5b                   	pop    %ebx
  80c0db:	5e                   	pop    %esi
  80c0dc:	5f                   	pop    %edi
  80c0dd:	5d                   	pop    %ebp
  80c0de:	c3                   	ret    
  LWIP_ERROR("accept_function: invalid conn->acceptmbox",
  80c0df:	83 ec 04             	sub    $0x4,%esp
  80c0e2:	68 7c 34 81 00       	push   $0x81347c
  80c0e7:	68 64 01 00 00       	push   $0x164
  80c0ec:	68 a6 34 81 00       	push   $0x8134a6
  80c0f1:	e8 51 28 00 00       	call   80e947 <_panic>
    newconn->pcb.tcp = NULL;
  80c0f6:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    netconn_free(newconn);
  80c0fd:	83 ec 0c             	sub    $0xc,%esp
  80c100:	53                   	push   %ebx
  80c101:	e8 78 fe ff ff       	call   80bf7e <netconn_free>
    return ERR_MEM;
  80c106:	83 c4 10             	add    $0x10,%esp
  80c109:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80c10e:	eb c7                	jmp    80c0d7 <accept_function+0x68>
    return ERR_MEM;
  80c110:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80c115:	eb c0                	jmp    80c0d7 <accept_function+0x68>

0080c117 <do_delconn>:
{
  80c117:	f3 0f 1e fb          	endbr32 
  80c11b:	55                   	push   %ebp
  80c11c:	89 e5                	mov    %esp,%ebp
  80c11e:	53                   	push   %ebx
  80c11f:	83 ec 04             	sub    $0x4,%esp
  80c122:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (msg->conn->pcb.tcp != NULL) {
  80c125:	8b 13                	mov    (%ebx),%edx
  80c127:	8b 4a 08             	mov    0x8(%edx),%ecx
  80c12a:	85 c9                	test   %ecx,%ecx
  80c12c:	74 16                	je     80c144 <do_delconn+0x2d>
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80c12e:	8b 02                	mov    (%edx),%eax
  80c130:	25 f0 00 00 00       	and    $0xf0,%eax
  80c135:	83 f8 20             	cmp    $0x20,%eax
  80c138:	74 53                	je     80c18d <do_delconn+0x76>
  80c13a:	83 f8 40             	cmp    $0x40,%eax
  80c13d:	74 40                	je     80c17f <do_delconn+0x68>
  80c13f:	83 f8 10             	cmp    $0x10,%eax
  80c142:	74 62                	je     80c1a6 <do_delconn+0x8f>
  API_EVENT(msg->conn, NETCONN_EVT_RCVPLUS, 0);
  80c144:	8b 13                	mov    (%ebx),%edx
  80c146:	8b 42 2c             	mov    0x2c(%edx),%eax
  80c149:	85 c0                	test   %eax,%eax
  80c14b:	74 23                	je     80c170 <do_delconn+0x59>
  80c14d:	83 ec 04             	sub    $0x4,%esp
  80c150:	6a 00                	push   $0x0
  80c152:	6a 00                	push   $0x0
  80c154:	52                   	push   %edx
  80c155:	ff d0                	call   *%eax
  API_EVENT(msg->conn, NETCONN_EVT_SENDPLUS, 0);
  80c157:	8b 13                	mov    (%ebx),%edx
  80c159:	8b 42 2c             	mov    0x2c(%edx),%eax
  80c15c:	83 c4 10             	add    $0x10,%esp
  80c15f:	85 c0                	test   %eax,%eax
  80c161:	74 0d                	je     80c170 <do_delconn+0x59>
  80c163:	83 ec 04             	sub    $0x4,%esp
  80c166:	6a 00                	push   $0x0
  80c168:	6a 02                	push   $0x2
  80c16a:	52                   	push   %edx
  80c16b:	ff d0                	call   *%eax
  80c16d:	83 c4 10             	add    $0x10,%esp
  if (msg->conn->op_completed != SYS_SEM_NULL) {
  80c170:	8b 03                	mov    (%ebx),%eax
  80c172:	8b 40 10             	mov    0x10(%eax),%eax
  80c175:	83 f8 ff             	cmp    $0xffffffff,%eax
  80c178:	75 3c                	jne    80c1b6 <do_delconn+0x9f>
}
  80c17a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80c17d:	c9                   	leave  
  80c17e:	c3                   	ret    
      raw_remove(msg->conn->pcb.raw);
  80c17f:	83 ec 0c             	sub    $0xc,%esp
  80c182:	51                   	push   %ecx
  80c183:	e8 d4 21 00 00       	call   80e35c <raw_remove>
      break;
  80c188:	83 c4 10             	add    $0x10,%esp
  80c18b:	eb b7                	jmp    80c144 <do_delconn+0x2d>
      msg->conn->pcb.udp->recv_arg = NULL;
  80c18d:	c7 41 1c 00 00 00 00 	movl   $0x0,0x1c(%ecx)
      udp_remove(msg->conn->pcb.udp);
  80c194:	83 ec 0c             	sub    $0xc,%esp
  80c197:	8b 03                	mov    (%ebx),%eax
  80c199:	ff 70 08             	pushl  0x8(%eax)
  80c19c:	e8 c9 d0 ff ff       	call   80926a <udp_remove>
      break;
  80c1a1:	83 c4 10             	add    $0x10,%esp
  80c1a4:	eb 9e                	jmp    80c144 <do_delconn+0x2d>
      msg->conn->state = NETCONN_CLOSE;
  80c1a6:	c7 42 04 04 00 00 00 	movl   $0x4,0x4(%edx)
      do_close_internal(msg->conn);
  80c1ad:	8b 03                	mov    (%ebx),%eax
  80c1af:	e8 66 f9 ff ff       	call   80bb1a <do_close_internal>
      return;
  80c1b4:	eb c4                	jmp    80c17a <do_delconn+0x63>
    sys_sem_signal(msg->conn->op_completed);
  80c1b6:	83 ec 0c             	sub    $0xc,%esp
  80c1b9:	50                   	push   %eax
  80c1ba:	e8 b4 e1 ff ff       	call   80a373 <sys_sem_signal>
  80c1bf:	83 c4 10             	add    $0x10,%esp
  80c1c2:	eb b6                	jmp    80c17a <do_delconn+0x63>

0080c1c4 <do_bind>:
{
  80c1c4:	f3 0f 1e fb          	endbr32 
  80c1c8:	55                   	push   %ebp
  80c1c9:	89 e5                	mov    %esp,%ebp
  80c1cb:	56                   	push   %esi
  80c1cc:	53                   	push   %ebx
  80c1cd:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80c1d0:	8b 33                	mov    (%ebx),%esi
  80c1d2:	80 7e 0c fc          	cmpb   $0xfc,0xc(%esi)
  80c1d6:	7c 1d                	jl     80c1f5 <do_bind+0x31>
    if (msg->conn->pcb.tcp != NULL) {
  80c1d8:	8b 56 08             	mov    0x8(%esi),%edx
  80c1db:	85 d2                	test   %edx,%edx
  80c1dd:	74 73                	je     80c252 <do_bind+0x8e>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80c1df:	8b 06                	mov    (%esi),%eax
  80c1e1:	25 f0 00 00 00       	and    $0xf0,%eax
  80c1e6:	83 f8 20             	cmp    $0x20,%eax
  80c1e9:	74 35                	je     80c220 <do_bind+0x5c>
  80c1eb:	83 f8 40             	cmp    $0x40,%eax
  80c1ee:	74 1c                	je     80c20c <do_bind+0x48>
  80c1f0:	83 f8 10             	cmp    $0x10,%eax
  80c1f3:	74 44                	je     80c239 <do_bind+0x75>
  TCPIP_APIMSG_ACK(msg);
  80c1f5:	83 ec 0c             	sub    $0xc,%esp
  80c1f8:	8b 03                	mov    (%ebx),%eax
  80c1fa:	ff 70 10             	pushl  0x10(%eax)
  80c1fd:	e8 71 e1 ff ff       	call   80a373 <sys_sem_signal>
}
  80c202:	83 c4 10             	add    $0x10,%esp
  80c205:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80c208:	5b                   	pop    %ebx
  80c209:	5e                   	pop    %esi
  80c20a:	5d                   	pop    %ebp
  80c20b:	c3                   	ret    
        msg->conn->err = raw_bind(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
  80c20c:	83 ec 08             	sub    $0x8,%esp
  80c20f:	ff 73 04             	pushl  0x4(%ebx)
  80c212:	52                   	push   %edx
  80c213:	e8 bd 1f 00 00       	call   80e1d5 <raw_bind>
  80c218:	88 46 0c             	mov    %al,0xc(%esi)
        break;
  80c21b:	83 c4 10             	add    $0x10,%esp
  80c21e:	eb d5                	jmp    80c1f5 <do_bind+0x31>
        msg->conn->err = udp_bind(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  80c220:	83 ec 04             	sub    $0x4,%esp
  80c223:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80c227:	50                   	push   %eax
  80c228:	ff 73 04             	pushl  0x4(%ebx)
  80c22b:	52                   	push   %edx
  80c22c:	e8 cd cc ff ff       	call   808efe <udp_bind>
  80c231:	88 46 0c             	mov    %al,0xc(%esi)
        break;
  80c234:	83 c4 10             	add    $0x10,%esp
  80c237:	eb bc                	jmp    80c1f5 <do_bind+0x31>
        msg->conn->err = tcp_bind(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  80c239:	83 ec 04             	sub    $0x4,%esp
  80c23c:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80c240:	50                   	push   %eax
  80c241:	ff 73 04             	pushl  0x4(%ebx)
  80c244:	52                   	push   %edx
  80c245:	e8 c7 93 ff ff       	call   805611 <tcp_bind>
  80c24a:	88 46 0c             	mov    %al,0xc(%esi)
        break;
  80c24d:	83 c4 10             	add    $0x10,%esp
  80c250:	eb a3                	jmp    80c1f5 <do_bind+0x31>
      msg->conn->err = ERR_VAL;
  80c252:	c6 46 0c f7          	movb   $0xf7,0xc(%esi)
  80c256:	eb 9d                	jmp    80c1f5 <do_bind+0x31>

0080c258 <do_connect>:
{
  80c258:	f3 0f 1e fb          	endbr32 
  80c25c:	55                   	push   %ebp
  80c25d:	89 e5                	mov    %esp,%ebp
  80c25f:	56                   	push   %esi
  80c260:	53                   	push   %ebx
  80c261:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (msg->conn->pcb.tcp == NULL) {
  80c264:	8b 33                	mov    (%ebx),%esi
  80c266:	8b 56 08             	mov    0x8(%esi),%edx
  80c269:	85 d2                	test   %edx,%edx
  80c26b:	74 1d                	je     80c28a <do_connect+0x32>
  switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80c26d:	8b 06                	mov    (%esi),%eax
  80c26f:	25 f0 00 00 00       	and    $0xf0,%eax
  80c274:	83 f8 20             	cmp    $0x20,%eax
  80c277:	74 42                	je     80c2bb <do_connect+0x63>
  80c279:	83 f8 40             	cmp    $0x40,%eax
  80c27c:	74 1c                	je     80c29a <do_connect+0x42>
  80c27e:	83 f8 10             	cmp    $0x10,%eax
  80c281:	74 5e                	je     80c2e1 <do_connect+0x89>
}
  80c283:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80c286:	5b                   	pop    %ebx
  80c287:	5e                   	pop    %esi
  80c288:	5d                   	pop    %ebp
  80c289:	c3                   	ret    
    sys_sem_signal(msg->conn->op_completed);
  80c28a:	83 ec 0c             	sub    $0xc,%esp
  80c28d:	ff 76 10             	pushl  0x10(%esi)
  80c290:	e8 de e0 ff ff       	call   80a373 <sys_sem_signal>
    return;
  80c295:	83 c4 10             	add    $0x10,%esp
  80c298:	eb e9                	jmp    80c283 <do_connect+0x2b>
    msg->conn->err = raw_connect(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
  80c29a:	83 ec 08             	sub    $0x8,%esp
  80c29d:	ff 73 04             	pushl  0x4(%ebx)
  80c2a0:	52                   	push   %edx
  80c2a1:	e8 50 1f 00 00       	call   80e1f6 <raw_connect>
  80c2a6:	88 46 0c             	mov    %al,0xc(%esi)
    sys_sem_signal(msg->conn->op_completed);
  80c2a9:	83 c4 04             	add    $0x4,%esp
  80c2ac:	8b 03                	mov    (%ebx),%eax
  80c2ae:	ff 70 10             	pushl  0x10(%eax)
  80c2b1:	e8 bd e0 ff ff       	call   80a373 <sys_sem_signal>
    break;
  80c2b6:	83 c4 10             	add    $0x10,%esp
  80c2b9:	eb c8                	jmp    80c283 <do_connect+0x2b>
    msg->conn->err = udp_connect(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  80c2bb:	83 ec 04             	sub    $0x4,%esp
  80c2be:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80c2c2:	50                   	push   %eax
  80c2c3:	ff 73 04             	pushl  0x4(%ebx)
  80c2c6:	52                   	push   %edx
  80c2c7:	e8 f2 ce ff ff       	call   8091be <udp_connect>
  80c2cc:	88 46 0c             	mov    %al,0xc(%esi)
    sys_sem_signal(msg->conn->op_completed);
  80c2cf:	83 c4 04             	add    $0x4,%esp
  80c2d2:	8b 03                	mov    (%ebx),%eax
  80c2d4:	ff 70 10             	pushl  0x10(%eax)
  80c2d7:	e8 97 e0 ff ff       	call   80a373 <sys_sem_signal>
    break;
  80c2dc:	83 c4 10             	add    $0x10,%esp
  80c2df:	eb a2                	jmp    80c283 <do_connect+0x2b>
    msg->conn->state = NETCONN_CONNECT;
  80c2e1:	c7 46 04 03 00 00 00 	movl   $0x3,0x4(%esi)
    setup_tcp(msg->conn);
  80c2e8:	8b 03                	mov    (%ebx),%eax
  80c2ea:	e8 4b f5 ff ff       	call   80b83a <setup_tcp>
    msg->conn->err = tcp_connect(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port,
  80c2ef:	8b 33                	mov    (%ebx),%esi
  80c2f1:	68 8d b8 80 00       	push   $0x80b88d
  80c2f6:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80c2fa:	50                   	push   %eax
  80c2fb:	ff 73 04             	pushl  0x4(%ebx)
  80c2fe:	ff 76 08             	pushl  0x8(%esi)
  80c301:	e8 56 a2 ff ff       	call   80655c <tcp_connect>
  80c306:	88 46 0c             	mov    %al,0xc(%esi)
    break;
  80c309:	83 c4 10             	add    $0x10,%esp
  80c30c:	e9 72 ff ff ff       	jmp    80c283 <do_connect+0x2b>

0080c311 <do_disconnect>:
{
  80c311:	f3 0f 1e fb          	endbr32 
  80c315:	55                   	push   %ebp
  80c316:	89 e5                	mov    %esp,%ebp
  80c318:	53                   	push   %ebx
  80c319:	83 ec 04             	sub    $0x4,%esp
  80c31c:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_UDP) {
  80c31f:	8b 13                	mov    (%ebx),%edx
  80c321:	8b 02                	mov    (%edx),%eax
  80c323:	25 f0 00 00 00       	and    $0xf0,%eax
  80c328:	83 f8 20             	cmp    $0x20,%eax
  80c32b:	74 15                	je     80c342 <do_disconnect+0x31>
  TCPIP_APIMSG_ACK(msg);
  80c32d:	83 ec 0c             	sub    $0xc,%esp
  80c330:	8b 03                	mov    (%ebx),%eax
  80c332:	ff 70 10             	pushl  0x10(%eax)
  80c335:	e8 39 e0 ff ff       	call   80a373 <sys_sem_signal>
}
  80c33a:	83 c4 10             	add    $0x10,%esp
  80c33d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80c340:	c9                   	leave  
  80c341:	c3                   	ret    
    udp_disconnect(msg->conn->pcb.udp);
  80c342:	83 ec 0c             	sub    $0xc,%esp
  80c345:	ff 72 08             	pushl  0x8(%edx)
  80c348:	e8 e6 ce ff ff       	call   809233 <udp_disconnect>
  80c34d:	83 c4 10             	add    $0x10,%esp
  80c350:	eb db                	jmp    80c32d <do_disconnect+0x1c>

0080c352 <do_listen>:
{
  80c352:	f3 0f 1e fb          	endbr32 
  80c356:	55                   	push   %ebp
  80c357:	89 e5                	mov    %esp,%ebp
  80c359:	57                   	push   %edi
  80c35a:	56                   	push   %esi
  80c35b:	53                   	push   %ebx
  80c35c:	83 ec 0c             	sub    $0xc,%esp
  80c35f:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80c362:	8b 03                	mov    (%ebx),%eax
  80c364:	80 78 0c fc          	cmpb   $0xfc,0xc(%eax)
  80c368:	7c 0c                	jl     80c376 <do_listen+0x24>
    if (msg->conn->pcb.tcp != NULL) {
  80c36a:	8b 50 08             	mov    0x8(%eax),%edx
  80c36d:	85 d2                	test   %edx,%edx
  80c36f:	74 05                	je     80c376 <do_listen+0x24>
      if (msg->conn->type == NETCONN_TCP) {
  80c371:	83 38 10             	cmpl   $0x10,(%eax)
  80c374:	74 18                	je     80c38e <do_listen+0x3c>
  TCPIP_APIMSG_ACK(msg);
  80c376:	83 ec 0c             	sub    $0xc,%esp
  80c379:	8b 03                	mov    (%ebx),%eax
  80c37b:	ff 70 10             	pushl  0x10(%eax)
  80c37e:	e8 f0 df ff ff       	call   80a373 <sys_sem_signal>
}
  80c383:	83 c4 10             	add    $0x10,%esp
  80c386:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80c389:	5b                   	pop    %ebx
  80c38a:	5e                   	pop    %esi
  80c38b:	5f                   	pop    %edi
  80c38c:	5d                   	pop    %ebp
  80c38d:	c3                   	ret    
        if (msg->conn->pcb.tcp->state == CLOSED) {
  80c38e:	83 7a 10 00          	cmpl   $0x0,0x10(%edx)
  80c392:	74 06                	je     80c39a <do_listen+0x48>
          msg->conn->err = ERR_CONN;
  80c394:	c6 40 0c f8          	movb   $0xf8,0xc(%eax)
  80c398:	eb dc                	jmp    80c376 <do_listen+0x24>
          struct tcp_pcb* lpcb = tcp_listen(msg->conn->pcb.tcp);
  80c39a:	83 ec 08             	sub    $0x8,%esp
  80c39d:	68 ff 00 00 00       	push   $0xff
  80c3a2:	52                   	push   %edx
  80c3a3:	e8 b8 93 ff ff       	call   805760 <tcp_listen_with_backlog>
  80c3a8:	89 c6                	mov    %eax,%esi
          if (lpcb == NULL) {
  80c3aa:	83 c4 10             	add    $0x10,%esp
  80c3ad:	85 c0                	test   %eax,%eax
  80c3af:	74 4e                	je     80c3ff <do_listen+0xad>
            if (msg->conn->recvmbox != SYS_MBOX_NULL) {
  80c3b1:	8b 03                	mov    (%ebx),%eax
  80c3b3:	8b 40 14             	mov    0x14(%eax),%eax
  80c3b6:	83 f8 ff             	cmp    $0xffffffff,%eax
  80c3b9:	75 4f                	jne    80c40a <do_listen+0xb8>
            if (msg->conn->acceptmbox == SYS_MBOX_NULL) {
  80c3bb:	8b 3b                	mov    (%ebx),%edi
  80c3bd:	83 7f 18 ff          	cmpl   $0xffffffff,0x18(%edi)
  80c3c1:	74 5e                	je     80c421 <do_listen+0xcf>
            if (msg->conn->err == ERR_OK) {
  80c3c3:	8b 03                	mov    (%ebx),%eax
  80c3c5:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80c3c9:	75 ab                	jne    80c376 <do_listen+0x24>
              msg->conn->state = NETCONN_LISTEN;
  80c3cb:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
              msg->conn->pcb.tcp = lpcb;
  80c3d2:	8b 03                	mov    (%ebx),%eax
  80c3d4:	89 70 08             	mov    %esi,0x8(%eax)
              tcp_arg(msg->conn->pcb.tcp, msg->conn);
  80c3d7:	8b 03                	mov    (%ebx),%eax
  80c3d9:	83 ec 08             	sub    $0x8,%esp
  80c3dc:	50                   	push   %eax
  80c3dd:	ff 70 08             	pushl  0x8(%eax)
  80c3e0:	e8 55 96 ff ff       	call   805a3a <tcp_arg>
              tcp_accept(msg->conn->pcb.tcp, accept_function);
  80c3e5:	83 c4 08             	add    $0x8,%esp
  80c3e8:	68 6f c0 80 00       	push   $0x80c06f
  80c3ed:	8b 03                	mov    (%ebx),%eax
  80c3ef:	ff 70 08             	pushl  0x8(%eax)
  80c3f2:	e8 94 96 ff ff       	call   805a8b <tcp_accept>
  80c3f7:	83 c4 10             	add    $0x10,%esp
  80c3fa:	e9 77 ff ff ff       	jmp    80c376 <do_listen+0x24>
            msg->conn->err = ERR_MEM;
  80c3ff:	8b 03                	mov    (%ebx),%eax
  80c401:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80c405:	e9 6c ff ff ff       	jmp    80c376 <do_listen+0x24>
              sys_mbox_free(msg->conn->recvmbox);
  80c40a:	83 ec 0c             	sub    $0xc,%esp
  80c40d:	50                   	push   %eax
  80c40e:	e8 a5 dd ff ff       	call   80a1b8 <sys_mbox_free>
              msg->conn->recvmbox = SYS_MBOX_NULL;
  80c413:	8b 03                	mov    (%ebx),%eax
  80c415:	c7 40 14 ff ff ff ff 	movl   $0xffffffff,0x14(%eax)
  80c41c:	83 c4 10             	add    $0x10,%esp
  80c41f:	eb 9a                	jmp    80c3bb <do_listen+0x69>
              if ((msg->conn->acceptmbox = sys_mbox_new(DEFAULT_ACCEPTMBOX_SIZE)) == SYS_MBOX_NULL) {
  80c421:	83 ec 0c             	sub    $0xc,%esp
  80c424:	6a 00                	push   $0x0
  80c426:	e8 30 de ff ff       	call   80a25b <sys_mbox_new>
  80c42b:	89 47 18             	mov    %eax,0x18(%edi)
  80c42e:	83 c4 10             	add    $0x10,%esp
  80c431:	83 f8 ff             	cmp    $0xffffffff,%eax
  80c434:	75 8d                	jne    80c3c3 <do_listen+0x71>
                msg->conn->err = ERR_MEM;
  80c436:	8b 03                	mov    (%ebx),%eax
  80c438:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80c43c:	eb 85                	jmp    80c3c3 <do_listen+0x71>

0080c43e <do_send>:
{
  80c43e:	f3 0f 1e fb          	endbr32 
  80c442:	55                   	push   %ebp
  80c443:	89 e5                	mov    %esp,%ebp
  80c445:	57                   	push   %edi
  80c446:	56                   	push   %esi
  80c447:	53                   	push   %ebx
  80c448:	83 ec 0c             	sub    $0xc,%esp
  80c44b:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80c44e:	8b 33                	mov    (%ebx),%esi
  80c450:	80 7e 0c fc          	cmpb   $0xfc,0xc(%esi)
  80c454:	7c 34                	jl     80c48a <do_send+0x4c>
    if (msg->conn->pcb.tcp != NULL) {
  80c456:	8b 56 08             	mov    0x8(%esi),%edx
  80c459:	85 d2                	test   %edx,%edx
  80c45b:	74 2d                	je     80c48a <do_send+0x4c>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80c45d:	8b 06                	mov    (%esi),%eax
  80c45f:	25 f0 00 00 00       	and    $0xf0,%eax
  80c464:	83 f8 20             	cmp    $0x20,%eax
  80c467:	74 4c                	je     80c4b5 <do_send+0x77>
  80c469:	83 f8 40             	cmp    $0x40,%eax
  80c46c:	75 1c                	jne    80c48a <do_send+0x4c>
        if (msg->msg.b->addr == NULL) {
  80c46e:	8b 43 04             	mov    0x4(%ebx),%eax
  80c471:	8b 48 08             	mov    0x8(%eax),%ecx
  80c474:	85 c9                	test   %ecx,%ecx
  80c476:	74 2a                	je     80c4a2 <do_send+0x64>
          msg->conn->err = raw_sendto(msg->conn->pcb.raw, msg->msg.b->p, msg->msg.b->addr);
  80c478:	83 ec 04             	sub    $0x4,%esp
  80c47b:	51                   	push   %ecx
  80c47c:	ff 30                	pushl  (%eax)
  80c47e:	52                   	push   %edx
  80c47f:	e8 ac 1d 00 00       	call   80e230 <raw_sendto>
  80c484:	88 46 0c             	mov    %al,0xc(%esi)
  80c487:	83 c4 10             	add    $0x10,%esp
  TCPIP_APIMSG_ACK(msg);
  80c48a:	83 ec 0c             	sub    $0xc,%esp
  80c48d:	8b 03                	mov    (%ebx),%eax
  80c48f:	ff 70 10             	pushl  0x10(%eax)
  80c492:	e8 dc de ff ff       	call   80a373 <sys_sem_signal>
}
  80c497:	83 c4 10             	add    $0x10,%esp
  80c49a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80c49d:	5b                   	pop    %ebx
  80c49e:	5e                   	pop    %esi
  80c49f:	5f                   	pop    %edi
  80c4a0:	5d                   	pop    %ebp
  80c4a1:	c3                   	ret    
          msg->conn->err = raw_send(msg->conn->pcb.raw, msg->msg.b->p);
  80c4a2:	83 ec 08             	sub    $0x8,%esp
  80c4a5:	ff 30                	pushl  (%eax)
  80c4a7:	52                   	push   %edx
  80c4a8:	e8 93 1e 00 00       	call   80e340 <raw_send>
  80c4ad:	88 46 0c             	mov    %al,0xc(%esi)
  80c4b0:	83 c4 10             	add    $0x10,%esp
  80c4b3:	eb d5                	jmp    80c48a <do_send+0x4c>
        if (msg->msg.b->addr == NULL) {
  80c4b5:	8b 43 04             	mov    0x4(%ebx),%eax
  80c4b8:	8b 48 08             	mov    0x8(%eax),%ecx
  80c4bb:	85 c9                	test   %ecx,%ecx
  80c4bd:	74 16                	je     80c4d5 <do_send+0x97>
          msg->conn->err = udp_sendto(msg->conn->pcb.udp, msg->msg.b->p, msg->msg.b->addr, msg->msg.b->port);
  80c4bf:	0f b7 78 0c          	movzwl 0xc(%eax),%edi
  80c4c3:	57                   	push   %edi
  80c4c4:	51                   	push   %ecx
  80c4c5:	ff 30                	pushl  (%eax)
  80c4c7:	52                   	push   %edx
  80c4c8:	e8 8c cc ff ff       	call   809159 <udp_sendto>
  80c4cd:	88 46 0c             	mov    %al,0xc(%esi)
  80c4d0:	83 c4 10             	add    $0x10,%esp
  80c4d3:	eb b5                	jmp    80c48a <do_send+0x4c>
          msg->conn->err = udp_send(msg->conn->pcb.udp, msg->msg.b->p);
  80c4d5:	83 ec 08             	sub    $0x8,%esp
  80c4d8:	ff 30                	pushl  (%eax)
  80c4da:	52                   	push   %edx
  80c4db:	e8 bd cc ff ff       	call   80919d <udp_send>
  80c4e0:	88 46 0c             	mov    %al,0xc(%esi)
  80c4e3:	83 c4 10             	add    $0x10,%esp
  80c4e6:	eb a2                	jmp    80c48a <do_send+0x4c>

0080c4e8 <do_recv>:
{
  80c4e8:	f3 0f 1e fb          	endbr32 
  80c4ec:	55                   	push   %ebp
  80c4ed:	89 e5                	mov    %esp,%ebp
  80c4ef:	53                   	push   %ebx
  80c4f0:	83 ec 04             	sub    $0x4,%esp
  80c4f3:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80c4f6:	8b 03                	mov    (%ebx),%eax
  80c4f8:	80 78 0c fc          	cmpb   $0xfc,0xc(%eax)
  80c4fc:	7c 0c                	jl     80c50a <do_recv+0x22>
    if (msg->conn->pcb.tcp != NULL) {
  80c4fe:	8b 50 08             	mov    0x8(%eax),%edx
  80c501:	85 d2                	test   %edx,%edx
  80c503:	74 05                	je     80c50a <do_recv+0x22>
      if (msg->conn->type == NETCONN_TCP) {
  80c505:	83 38 10             	cmpl   $0x10,(%eax)
  80c508:	74 15                	je     80c51f <do_recv+0x37>
  TCPIP_APIMSG_ACK(msg);
  80c50a:	83 ec 0c             	sub    $0xc,%esp
  80c50d:	8b 03                	mov    (%ebx),%eax
  80c50f:	ff 70 10             	pushl  0x10(%eax)
  80c512:	e8 5c de ff ff       	call   80a373 <sys_sem_signal>
}
  80c517:	83 c4 10             	add    $0x10,%esp
  80c51a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80c51d:	c9                   	leave  
  80c51e:	c3                   	ret    
          tcp_recved(msg->conn->pcb.tcp, msg->msg.r.len);
  80c51f:	83 ec 08             	sub    $0x8,%esp
  80c522:	0f b7 43 04          	movzwl 0x4(%ebx),%eax
  80c526:	50                   	push   %eax
  80c527:	52                   	push   %edx
  80c528:	e8 3b 93 ff ff       	call   805868 <tcp_recved>
  80c52d:	83 c4 10             	add    $0x10,%esp
  80c530:	eb d8                	jmp    80c50a <do_recv+0x22>

0080c532 <do_write>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_write(struct api_msg_msg *msg)
{
  80c532:	f3 0f 1e fb          	endbr32 
  80c536:	55                   	push   %ebp
  80c537:	89 e5                	mov    %esp,%ebp
  80c539:	83 ec 08             	sub    $0x8,%esp
  80c53c:	8b 55 08             	mov    0x8(%ebp),%edx
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80c53f:	8b 02                	mov    (%edx),%eax
  80c541:	80 78 0c fc          	cmpb   $0xfc,0xc(%eax)
  80c545:	7c 0f                	jl     80c556 <do_write+0x24>
    if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
  80c547:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80c54b:	74 05                	je     80c552 <do_write+0x20>
  80c54d:	83 38 10             	cmpl   $0x10,(%eax)
  80c550:	74 16                	je     80c568 <do_write+0x36>
      /* for both cases: if do_writemore was called, don't ACK the APIMSG! */
      return;
#endif /* LWIP_TCP */
#if (LWIP_UDP || LWIP_RAW)
    } else {
      msg->conn->err = ERR_VAL;
  80c552:	c6 40 0c f7          	movb   $0xf7,0xc(%eax)
#endif /* (LWIP_UDP || LWIP_RAW) */
    }
  }
  TCPIP_APIMSG_ACK(msg);
  80c556:	83 ec 0c             	sub    $0xc,%esp
  80c559:	8b 02                	mov    (%edx),%eax
  80c55b:	ff 70 10             	pushl  0x10(%eax)
  80c55e:	e8 10 de ff ff       	call   80a373 <sys_sem_signal>
  80c563:	83 c4 10             	add    $0x10,%esp
}
  80c566:	c9                   	leave  
  80c567:	c3                   	ret    
      msg->conn->state = NETCONN_WRITE;
  80c568:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
      msg->conn->write_msg = msg;
  80c56f:	8b 02                	mov    (%edx),%eax
  80c571:	89 50 24             	mov    %edx,0x24(%eax)
      msg->conn->write_offset = 0;
  80c574:	8b 02                	mov    (%edx),%eax
  80c576:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
      do_writemore(msg->conn);
  80c57d:	8b 02                	mov    (%edx),%eax
  80c57f:	e8 2f f4 ff ff       	call   80b9b3 <do_writemore>
      return;
  80c584:	eb e0                	jmp    80c566 <do_write+0x34>

0080c586 <do_getaddr>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_getaddr(struct api_msg_msg *msg)
{
  80c586:	f3 0f 1e fb          	endbr32 
  80c58a:	55                   	push   %ebp
  80c58b:	89 e5                	mov    %esp,%ebp
  80c58d:	83 ec 08             	sub    $0x8,%esp
  80c590:	8b 45 08             	mov    0x8(%ebp),%eax
  if (msg->conn->pcb.ip != NULL) {
  80c593:	8b 08                	mov    (%eax),%ecx
  80c595:	8b 51 08             	mov    0x8(%ecx),%edx
  80c598:	85 d2                	test   %edx,%edx
  80c59a:	0f 84 a8 00 00 00    	je     80c648 <do_getaddr+0xc2>
    *(msg->msg.ad.ipaddr) = (msg->msg.ad.local?msg->conn->pcb.ip->local_ip:msg->conn->pcb.ip->remote_ip);
  80c5a0:	8b 48 04             	mov    0x4(%eax),%ecx
  80c5a3:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80c5a7:	74 2f                	je     80c5d8 <do_getaddr+0x52>
  80c5a9:	8b 12                	mov    (%edx),%edx
  80c5ab:	89 11                	mov    %edx,(%ecx)
    
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80c5ad:	8b 08                	mov    (%eax),%ecx
  80c5af:	8b 11                	mov    (%ecx),%edx
  80c5b1:	81 e2 f0 00 00 00    	and    $0xf0,%edx
  80c5b7:	83 fa 20             	cmp    $0x20,%edx
  80c5ba:	74 3e                	je     80c5fa <do_getaddr+0x74>
  80c5bc:	83 fa 40             	cmp    $0x40,%edx
  80c5bf:	74 1e                	je     80c5df <do_getaddr+0x59>
  80c5c1:	83 fa 10             	cmp    $0x10,%edx
  80c5c4:	74 64                	je     80c62a <do_getaddr+0xa4>
#endif /* LWIP_TCP */
    }
  } else {
    msg->conn->err = ERR_CONN;
  }
  TCPIP_APIMSG_ACK(msg);
  80c5c6:	83 ec 0c             	sub    $0xc,%esp
  80c5c9:	8b 00                	mov    (%eax),%eax
  80c5cb:	ff 70 10             	pushl  0x10(%eax)
  80c5ce:	e8 a0 dd ff ff       	call   80a373 <sys_sem_signal>
}
  80c5d3:	83 c4 10             	add    $0x10,%esp
  80c5d6:	c9                   	leave  
  80c5d7:	c3                   	ret    
    *(msg->msg.ad.ipaddr) = (msg->msg.ad.local?msg->conn->pcb.ip->local_ip:msg->conn->pcb.ip->remote_ip);
  80c5d8:	8b 52 04             	mov    0x4(%edx),%edx
  80c5db:	89 11                	mov    %edx,(%ecx)
  80c5dd:	eb ce                	jmp    80c5ad <do_getaddr+0x27>
      if (msg->msg.ad.local) {
  80c5df:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80c5e3:	74 0f                	je     80c5f4 <do_getaddr+0x6e>
        *(msg->msg.ad.port) = msg->conn->pcb.raw->protocol;
  80c5e5:	8b 50 08             	mov    0x8(%eax),%edx
  80c5e8:	8b 49 08             	mov    0x8(%ecx),%ecx
  80c5eb:	0f b6 49 10          	movzbl 0x10(%ecx),%ecx
  80c5ef:	66 89 0a             	mov    %cx,(%edx)
  80c5f2:	eb d2                	jmp    80c5c6 <do_getaddr+0x40>
        msg->conn->err = ERR_CONN;
  80c5f4:	c6 41 0c f8          	movb   $0xf8,0xc(%ecx)
  80c5f8:	eb cc                	jmp    80c5c6 <do_getaddr+0x40>
      if (msg->msg.ad.local) {
  80c5fa:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80c5fe:	74 0f                	je     80c60f <do_getaddr+0x89>
        *(msg->msg.ad.port) = msg->conn->pcb.udp->local_port;
  80c600:	8b 50 08             	mov    0x8(%eax),%edx
  80c603:	8b 49 08             	mov    0x8(%ecx),%ecx
  80c606:	0f b7 49 12          	movzwl 0x12(%ecx),%ecx
  80c60a:	66 89 0a             	mov    %cx,(%edx)
  80c60d:	eb b7                	jmp    80c5c6 <do_getaddr+0x40>
        if ((msg->conn->pcb.udp->flags & UDP_FLAGS_CONNECTED) == 0) {
  80c60f:	8b 51 08             	mov    0x8(%ecx),%edx
  80c612:	f6 42 10 04          	testb  $0x4,0x10(%edx)
  80c616:	75 06                	jne    80c61e <do_getaddr+0x98>
          msg->conn->err = ERR_CONN;
  80c618:	c6 41 0c f8          	movb   $0xf8,0xc(%ecx)
  80c61c:	eb a8                	jmp    80c5c6 <do_getaddr+0x40>
          *(msg->msg.ad.port) = msg->conn->pcb.udp->remote_port;
  80c61e:	8b 48 08             	mov    0x8(%eax),%ecx
  80c621:	0f b7 52 14          	movzwl 0x14(%edx),%edx
  80c625:	66 89 11             	mov    %dx,(%ecx)
  80c628:	eb 9c                	jmp    80c5c6 <do_getaddr+0x40>
      *(msg->msg.ad.port) = (msg->msg.ad.local?msg->conn->pcb.tcp->local_port:msg->conn->pcb.tcp->remote_port);
  80c62a:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80c62e:	74 0f                	je     80c63f <do_getaddr+0xb9>
  80c630:	8b 51 08             	mov    0x8(%ecx),%edx
  80c633:	0f b7 4a 1c          	movzwl 0x1c(%edx),%ecx
  80c637:	8b 50 08             	mov    0x8(%eax),%edx
  80c63a:	66 89 0a             	mov    %cx,(%edx)
      break;
  80c63d:	eb 87                	jmp    80c5c6 <do_getaddr+0x40>
      *(msg->msg.ad.port) = (msg->msg.ad.local?msg->conn->pcb.tcp->local_port:msg->conn->pcb.tcp->remote_port);
  80c63f:	8b 51 08             	mov    0x8(%ecx),%edx
  80c642:	0f b7 4a 1e          	movzwl 0x1e(%edx),%ecx
  80c646:	eb ef                	jmp    80c637 <do_getaddr+0xb1>
    msg->conn->err = ERR_CONN;
  80c648:	c6 41 0c f8          	movb   $0xf8,0xc(%ecx)
  80c64c:	e9 75 ff ff ff       	jmp    80c5c6 <do_getaddr+0x40>

0080c651 <do_close>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_close(struct api_msg_msg *msg)
{
  80c651:	f3 0f 1e fb          	endbr32 
  80c655:	55                   	push   %ebp
  80c656:	89 e5                	mov    %esp,%ebp
  80c658:	83 ec 08             	sub    $0x8,%esp
  80c65b:	8b 55 08             	mov    0x8(%ebp),%edx
#if LWIP_TCP
  if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
  80c65e:	8b 02                	mov    (%edx),%eax
  80c660:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80c664:	74 05                	je     80c66b <do_close+0x1a>
  80c666:	83 38 10             	cmpl   $0x10,(%eax)
  80c669:	74 16                	je     80c681 <do_close+0x30>
      do_close_internal(msg->conn);
      /* for tcp netconns, do_close_internal ACKs the message */
  } else
#endif /* LWIP_TCP */
  {
    msg->conn->err = ERR_VAL;
  80c66b:	c6 40 0c f7          	movb   $0xf7,0xc(%eax)
    TCPIP_APIMSG_ACK(msg);
  80c66f:	83 ec 0c             	sub    $0xc,%esp
  80c672:	8b 02                	mov    (%edx),%eax
  80c674:	ff 70 10             	pushl  0x10(%eax)
  80c677:	e8 f7 dc ff ff       	call   80a373 <sys_sem_signal>
  80c67c:	83 c4 10             	add    $0x10,%esp
  }
}
  80c67f:	c9                   	leave  
  80c680:	c3                   	ret    
      msg->conn->state = NETCONN_CLOSE;
  80c681:	c7 40 04 04 00 00 00 	movl   $0x4,0x4(%eax)
      do_close_internal(msg->conn);
  80c688:	8b 02                	mov    (%edx),%eax
  80c68a:	e8 8b f4 ff ff       	call   80bb1a <do_close_internal>
  80c68f:	eb ee                	jmp    80c67f <do_close+0x2e>

0080c691 <tcp_parseopt>:
 *
 * @param pcb the tcp_pcb for which a segment arrived
 */
static void
tcp_parseopt(struct tcp_pcb *pcb)
{
  80c691:	55                   	push   %ebp
  80c692:	89 e5                	mov    %esp,%ebp
  80c694:	57                   	push   %edi
  80c695:	56                   	push   %esi
  80c696:	53                   	push   %ebx
  80c697:	83 ec 18             	sub    $0x18,%esp
  80c69a:	89 c7                	mov    %eax,%edi
  u8_t c;
  u8_t *opts, opt;
  u16_t mss;

  opts = (u8_t *)tcphdr + TCP_HLEN;
  80c69c:	8b 35 b0 b1 b3 00    	mov    0xb3b1b0,%esi

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
  80c6a2:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  80c6a6:	50                   	push   %eax
  80c6a7:	e8 be b2 ff ff       	call   80796a <ntohs>
  80c6ac:	83 c4 10             	add    $0x10,%esp
  80c6af:	66 3d ff 5f          	cmp    $0x5fff,%ax
  80c6b3:	0f 86 84 00 00 00    	jbe    80c73d <tcp_parseopt+0xac>
  opts = (u8_t *)tcphdr + TCP_HLEN;
  80c6b9:	83 c6 14             	add    $0x14,%esi
    for(c = 0; c < (TCPH_HDRLEN(tcphdr) - 5) << 2 ;) {
  80c6bc:	bb 00 00 00 00       	mov    $0x0,%ebx
  80c6c1:	eb 10                	jmp    80c6d3 <tcp_parseopt+0x42>
      opt = opts[c];
      if (opt == 0x00) {
        /* End of options. */
        break;
      } else if (opt == 0x01) {
        ++c;
  80c6c3:	83 c3 01             	add    $0x1,%ebx
  80c6c6:	eb 0b                	jmp    80c6d3 <tcp_parseopt+0x42>
        pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;

        /* And we are done processing options. */
        break;
      } else {
        if (opts[c + 1] == 0) {
  80c6c8:	0f b6 44 16 01       	movzbl 0x1(%esi,%edx,1),%eax
  80c6cd:	84 c0                	test   %al,%al
  80c6cf:	74 6c                	je     80c73d <tcp_parseopt+0xac>
             and we don't process them further. */
          break;
        }
        /* All other options have a length field, so that we easily
           can skip past them. */
        c += opts[c + 1];
  80c6d1:	01 c3                	add    %eax,%ebx
    for(c = 0; c < (TCPH_HDRLEN(tcphdr) - 5) << 2 ;) {
  80c6d3:	83 ec 0c             	sub    $0xc,%esp
  80c6d6:	a1 b0 b1 b3 00       	mov    0xb3b1b0,%eax
  80c6db:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c6df:	50                   	push   %eax
  80c6e0:	e8 85 b2 ff ff       	call   80796a <ntohs>
  80c6e5:	0f b6 d3             	movzbl %bl,%edx
  80c6e8:	66 c1 e8 0c          	shr    $0xc,%ax
  80c6ec:	0f b7 c0             	movzwl %ax,%eax
  80c6ef:	8d 04 85 ec ff ff ff 	lea    -0x14(,%eax,4),%eax
  80c6f6:	83 c4 10             	add    $0x10,%esp
  80c6f9:	39 c2                	cmp    %eax,%edx
  80c6fb:	7d 40                	jge    80c73d <tcp_parseopt+0xac>
      opt = opts[c];
  80c6fd:	0f b6 d3             	movzbl %bl,%edx
  80c700:	0f b6 04 16          	movzbl (%esi,%edx,1),%eax
      if (opt == 0x00) {
  80c704:	84 c0                	test   %al,%al
  80c706:	74 35                	je     80c73d <tcp_parseopt+0xac>
      } else if (opt == 0x01) {
  80c708:	3c 01                	cmp    $0x1,%al
  80c70a:	74 b7                	je     80c6c3 <tcp_parseopt+0x32>
      } else if (opt == 0x02 &&
  80c70c:	3c 02                	cmp    $0x2,%al
  80c70e:	75 b8                	jne    80c6c8 <tcp_parseopt+0x37>
  80c710:	80 7c 16 01 04       	cmpb   $0x4,0x1(%esi,%edx,1)
  80c715:	75 b1                	jne    80c6c8 <tcp_parseopt+0x37>
        mss = (opts[c + 2] << 8) | opts[c + 3];
  80c717:	0f b6 4c 16 02       	movzbl 0x2(%esi,%edx,1),%ecx
  80c71c:	c1 e1 08             	shl    $0x8,%ecx
  80c71f:	0f b6 54 16 03       	movzbl 0x3(%esi,%edx,1),%edx
  80c724:	89 d0                	mov    %edx,%eax
  80c726:	09 c8                	or     %ecx,%eax
        pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
  80c728:	83 e8 01             	sub    $0x1,%eax
  80c72b:	09 d1                	or     %edx,%ecx
  80c72d:	66 3d b4 05          	cmp    $0x5b4,%ax
  80c731:	b8 b4 05 00 00       	mov    $0x5b4,%eax
  80c736:	0f 42 c1             	cmovb  %ecx,%eax
  80c739:	66 89 47 34          	mov    %ax,0x34(%edi)
      }
    }
  }
}
  80c73d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80c740:	5b                   	pop    %ebx
  80c741:	5e                   	pop    %esi
  80c742:	5f                   	pop    %edi
  80c743:	5d                   	pop    %ebp
  80c744:	c3                   	ret    

0080c745 <tcp_receive>:
{
  80c745:	55                   	push   %ebp
  80c746:	89 e5                	mov    %esp,%ebp
  80c748:	57                   	push   %edi
  80c749:	56                   	push   %esi
  80c74a:	53                   	push   %ebx
  80c74b:	83 ec 1c             	sub    $0x1c,%esp
  80c74e:	89 c7                	mov    %eax,%edi
  if (flags & TCP_ACK) {
  80c750:	f6 05 a0 b1 b3 00 10 	testb  $0x10,0xb3b1a0
  80c757:	0f 84 24 04 00 00    	je     80cb81 <tcp_receive+0x43c>
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl1;
  80c75d:	0f b7 48 5c          	movzwl 0x5c(%eax),%ecx
  80c761:	8b 50 60             	mov    0x60(%eax),%edx
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
  80c764:	a1 a8 b1 b3 00       	mov    0xb3b1a8,%eax
  80c769:	39 c2                	cmp    %eax,%edx
  80c76b:	78 53                	js     80c7c0 <tcp_receive+0x7b>
  80c76d:	39 c2                	cmp    %eax,%edx
  80c76f:	74 36                	je     80c7a7 <tcp_receive+0x62>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
  80c771:	8b 35 a4 b1 b3 00    	mov    0xb3b1a4,%esi
  80c777:	39 77 64             	cmp    %esi,0x64(%edi)
  80c77a:	74 38                	je     80c7b4 <tcp_receive+0x6f>
    if (pcb->lastack == ackno) {
  80c77c:	8b 5f 48             	mov    0x48(%edi),%ebx
  80c77f:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80c784:	39 c3                	cmp    %eax,%ebx
  80c786:	74 68                	je     80c7f0 <tcp_receive+0xab>
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_max)){
  80c788:	8d 50 ff             	lea    -0x1(%eax),%edx
  80c78b:	39 da                	cmp    %ebx,%edx
  80c78d:	78 0d                	js     80c79c <tcp_receive+0x57>
  80c78f:	89 c2                	mov    %eax,%edx
  80c791:	2b 57 58             	sub    0x58(%edi),%edx
  80c794:	85 d2                	test   %edx,%edx
  80c796:	0f 8e fa 00 00 00    	jle    80c896 <tcp_receive+0x151>
      pcb->acked = 0;
  80c79c:	66 c7 47 6c 00 00    	movw   $0x0,0x6c(%edi)
  80c7a2:	e9 c3 02 00 00       	jmp    80ca6a <tcp_receive+0x325>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
  80c7a7:	8b 35 a4 b1 b3 00    	mov    0xb3b1a4,%esi
  80c7ad:	39 77 64             	cmp    %esi,0x64(%edi)
  80c7b0:	79 bf                	jns    80c771 <tcp_receive+0x2c>
  80c7b2:	eb 0c                	jmp    80c7c0 <tcp_receive+0x7b>
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
  80c7b4:	8b 1d b0 b1 b3 00    	mov    0xb3b1b0,%ebx
  80c7ba:	66 3b 4b 0e          	cmp    0xe(%ebx),%cx
  80c7be:	73 bc                	jae    80c77c <tcp_receive+0x37>
      pcb->snd_wnd = tcphdr->wnd;
  80c7c0:	8b 1d b0 b1 b3 00    	mov    0xb3b1b0,%ebx
  80c7c6:	0f b7 5b 0e          	movzwl 0xe(%ebx),%ebx
  80c7ca:	66 89 5f 5c          	mov    %bx,0x5c(%edi)
      pcb->snd_wl1 = seqno;
  80c7ce:	89 47 60             	mov    %eax,0x60(%edi)
      pcb->snd_wl2 = ackno;
  80c7d1:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80c7d6:	89 47 64             	mov    %eax,0x64(%edi)
      if (pcb->snd_wnd > 0 && pcb->persist_backoff > 0) {
  80c7d9:	66 85 db             	test   %bx,%bx
  80c7dc:	74 9e                	je     80c77c <tcp_receive+0x37>
  80c7de:	80 bf a4 00 00 00 00 	cmpb   $0x0,0xa4(%edi)
  80c7e5:	74 95                	je     80c77c <tcp_receive+0x37>
          pcb->persist_backoff = 0;
  80c7e7:	c6 87 a4 00 00 00 00 	movb   $0x0,0xa4(%edi)
  80c7ee:	eb 8c                	jmp    80c77c <tcp_receive+0x37>
      pcb->acked = 0;
  80c7f0:	66 c7 47 6c 00 00    	movw   $0x0,0x6c(%edi)
      if (pcb->snd_wl1 + pcb->snd_wnd == right_wnd_edge){
  80c7f6:	0f b7 47 5c          	movzwl 0x5c(%edi),%eax
  80c7fa:	03 47 60             	add    0x60(%edi),%eax
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl1;
  80c7fd:	0f b7 c9             	movzwl %cx,%ecx
  80c800:	01 ca                	add    %ecx,%edx
      if (pcb->snd_wl1 + pcb->snd_wnd == right_wnd_edge){
  80c802:	39 d0                	cmp    %edx,%eax
  80c804:	0f 85 60 02 00 00    	jne    80ca6a <tcp_receive+0x325>
        ++pcb->dupacks;
  80c80a:	0f b6 47 4c          	movzbl 0x4c(%edi),%eax
  80c80e:	83 c0 01             	add    $0x1,%eax
  80c811:	88 47 4c             	mov    %al,0x4c(%edi)
        if (pcb->dupacks >= 3 && pcb->unacked != NULL) {
  80c814:	3c 02                	cmp    $0x2,%al
  80c816:	0f 86 4e 02 00 00    	jbe    80ca6a <tcp_receive+0x325>
  80c81c:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80c820:	0f 84 44 02 00 00    	je     80ca6a <tcp_receive+0x325>
          if (!(pcb->flags & TF_INFR)) {
  80c826:	f6 47 20 04          	testb  $0x4,0x20(%edi)
  80c82a:	74 1c                	je     80c848 <tcp_receive+0x103>
            if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
  80c82c:	0f b7 57 4e          	movzwl 0x4e(%edi),%edx
  80c830:	89 d0                	mov    %edx,%eax
  80c832:	66 03 47 34          	add    0x34(%edi),%ax
  80c836:	66 39 c2             	cmp    %ax,%dx
  80c839:	0f 83 2b 02 00 00    	jae    80ca6a <tcp_receive+0x325>
              pcb->cwnd += pcb->mss;
  80c83f:	66 89 47 4e          	mov    %ax,0x4e(%edi)
  80c843:	e9 22 02 00 00       	jmp    80ca6a <tcp_receive+0x325>
            tcp_rexmit(pcb);
  80c848:	83 ec 0c             	sub    $0xc,%esp
  80c84b:	57                   	push   %edi
  80c84c:	e8 bc c0 ff ff       	call   80890d <tcp_rexmit>
            if (pcb->cwnd > pcb->snd_wnd)
  80c851:	0f b7 5f 4e          	movzwl 0x4e(%edi),%ebx
  80c855:	0f b7 47 5c          	movzwl 0x5c(%edi),%eax
  80c859:	83 c4 10             	add    $0x10,%esp
              pcb->ssthresh = pcb->snd_wnd / 2;
  80c85c:	89 c2                	mov    %eax,%edx
  80c85e:	66 d1 ea             	shr    %dx
  80c861:	89 d9                	mov    %ebx,%ecx
  80c863:	66 d1 e9             	shr    %cx
  80c866:	66 39 c3             	cmp    %ax,%bx
  80c869:	0f 47 ca             	cmova  %edx,%ecx
            if (pcb->ssthresh < 2*pcb->mss) {
  80c86c:	0f b7 47 34          	movzwl 0x34(%edi),%eax
  80c870:	0f b7 f1             	movzwl %cx,%esi
  80c873:	0f b7 d8             	movzwl %ax,%ebx
  80c876:	01 db                	add    %ebx,%ebx
              pcb->ssthresh = 2*pcb->mss;
  80c878:	8d 14 00             	lea    (%eax,%eax,1),%edx
  80c87b:	39 de                	cmp    %ebx,%esi
  80c87d:	0f 4d d1             	cmovge %ecx,%edx
  80c880:	66 89 57 50          	mov    %dx,0x50(%edi)
            pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
  80c884:	8d 04 40             	lea    (%eax,%eax,2),%eax
  80c887:	01 d0                	add    %edx,%eax
  80c889:	66 89 47 4e          	mov    %ax,0x4e(%edi)
            pcb->flags |= TF_INFR;
  80c88d:	80 4f 20 04          	orb    $0x4,0x20(%edi)
  80c891:	e9 d4 01 00 00       	jmp    80ca6a <tcp_receive+0x325>
      if (pcb->flags & TF_INFR) {
  80c896:	0f b6 57 20          	movzbl 0x20(%edi),%edx
  80c89a:	f6 c2 04             	test   $0x4,%dl
  80c89d:	74 0e                	je     80c8ad <tcp_receive+0x168>
        pcb->flags &= ~TF_INFR;
  80c89f:	83 e2 fb             	and    $0xfffffffb,%edx
  80c8a2:	88 57 20             	mov    %dl,0x20(%edi)
        pcb->cwnd = pcb->ssthresh;
  80c8a5:	0f b7 57 50          	movzwl 0x50(%edi),%edx
  80c8a9:	66 89 57 4e          	mov    %dx,0x4e(%edi)
      pcb->nrtx = 0;
  80c8ad:	c6 47 46 00          	movb   $0x0,0x46(%edi)
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
  80c8b1:	0f b7 57 40          	movzwl 0x40(%edi),%edx
  80c8b5:	66 c1 fa 03          	sar    $0x3,%dx
  80c8b9:	66 03 57 42          	add    0x42(%edi),%dx
  80c8bd:	66 89 57 44          	mov    %dx,0x44(%edi)
      pcb->acked = (u16_t)(ackno - pcb->lastack);
  80c8c1:	89 c2                	mov    %eax,%edx
  80c8c3:	29 da                	sub    %ebx,%edx
  80c8c5:	66 89 57 6c          	mov    %dx,0x6c(%edi)
      pcb->snd_buf += pcb->acked;
  80c8c9:	66 01 57 6e          	add    %dx,0x6e(%edi)
      pcb->dupacks = 0;
  80c8cd:	c6 47 4c 00          	movb   $0x0,0x4c(%edi)
      pcb->lastack = ackno;
  80c8d1:	89 47 48             	mov    %eax,0x48(%edi)
      if (pcb->state >= ESTABLISHED) {
  80c8d4:	83 7f 10 03          	cmpl   $0x3,0x10(%edi)
  80c8d8:	76 1d                	jbe    80c8f7 <tcp_receive+0x1b2>
        if (pcb->cwnd < pcb->ssthresh) {
  80c8da:	0f b7 4f 4e          	movzwl 0x4e(%edi),%ecx
  80c8de:	66 3b 4f 50          	cmp    0x50(%edi),%cx
  80c8e2:	0f 83 da 00 00 00    	jae    80c9c2 <tcp_receive+0x27d>
          if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
  80c8e8:	89 c8                	mov    %ecx,%eax
  80c8ea:	66 03 47 34          	add    0x34(%edi),%ax
  80c8ee:	66 39 c1             	cmp    %ax,%cx
  80c8f1:	73 04                	jae    80c8f7 <tcp_receive+0x1b2>
            pcb->cwnd += pcb->mss;
  80c8f3:	66 89 47 4e          	mov    %ax,0x4e(%edi)
      while (pcb->unacked != NULL &&
  80c8f7:	8b 47 78             	mov    0x78(%edi),%eax
  80c8fa:	85 c0                	test   %eax,%eax
  80c8fc:	0f 84 19 01 00 00    	je     80ca1b <tcp_receive+0x2d6>
             TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) +
  80c902:	83 ec 0c             	sub    $0xc,%esp
  80c905:	8b 40 10             	mov    0x10(%eax),%eax
  80c908:	ff 70 04             	pushl  0x4(%eax)
  80c90b:	e8 98 b2 ff ff       	call   807ba8 <ntohl>
  80c910:	89 c3                	mov    %eax,%ebx
  80c912:	8b 47 78             	mov    0x78(%edi),%eax
  80c915:	0f b7 70 0c          	movzwl 0xc(%eax),%esi
  80c919:	8b 40 10             	mov    0x10(%eax),%eax
  80c91c:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c920:	89 04 24             	mov    %eax,(%esp)
  80c923:	e8 42 b0 ff ff       	call   80796a <ntohs>
  80c928:	89 c2                	mov    %eax,%edx
  80c92a:	83 c4 10             	add    $0x10,%esp
  80c92d:	b8 01 00 00 00       	mov    $0x1,%eax
  80c932:	f6 c2 01             	test   $0x1,%dl
  80c935:	0f 84 bf 00 00 00    	je     80c9fa <tcp_receive+0x2b5>
  80c93b:	2b 1d a4 b1 b3 00    	sub    0xb3b1a4,%ebx
  80c941:	01 c6                	add    %eax,%esi
  80c943:	01 f3                	add    %esi,%ebx
      while (pcb->unacked != NULL &&
  80c945:	85 db                	test   %ebx,%ebx
  80c947:	0f 8f ce 00 00 00    	jg     80ca1b <tcp_receive+0x2d6>
        next = pcb->unacked;
  80c94d:	8b 5f 78             	mov    0x78(%edi),%ebx
        pcb->unacked = pcb->unacked->next;
  80c950:	8b 03                	mov    (%ebx),%eax
  80c952:	89 47 78             	mov    %eax,0x78(%edi)
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  80c955:	0f b7 77 70          	movzwl 0x70(%edi),%esi
  80c959:	83 ec 0c             	sub    $0xc,%esp
  80c95c:	ff 73 04             	pushl  0x4(%ebx)
  80c95f:	e8 fc 84 ff ff       	call   804e60 <pbuf_clen>
  80c964:	0f b6 c0             	movzbl %al,%eax
  80c967:	83 c4 10             	add    $0x10,%esp
  80c96a:	66 39 c6             	cmp    %ax,%si
  80c96d:	72 74                	jb     80c9e3 <tcp_receive+0x29e>
        pcb->snd_queuelen -= pbuf_clen(next->p);
  80c96f:	83 ec 0c             	sub    $0xc,%esp
  80c972:	ff 73 04             	pushl  0x4(%ebx)
  80c975:	e8 e6 84 ff ff       	call   804e60 <pbuf_clen>
  80c97a:	0f b6 c0             	movzbl %al,%eax
  80c97d:	66 29 47 70          	sub    %ax,0x70(%edi)
        tcp_seg_free(next);
  80c981:	89 1c 24             	mov    %ebx,(%esp)
  80c984:	e8 ee 8f ff ff       	call   805977 <tcp_seg_free>
        if (pcb->snd_queuelen != 0) {
  80c989:	83 c4 10             	add    $0x10,%esp
  80c98c:	66 83 7f 70 00       	cmpw   $0x0,0x70(%edi)
  80c991:	0f 84 60 ff ff ff    	je     80c8f7 <tcp_receive+0x1b2>
          LWIP_ASSERT("tcp_receive: valid queue length", pcb->unacked != NULL ||
  80c997:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80c99b:	0f 85 56 ff ff ff    	jne    80c8f7 <tcp_receive+0x1b2>
  80c9a1:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  80c9a5:	0f 85 4c ff ff ff    	jne    80c8f7 <tcp_receive+0x1b2>
  80c9ab:	83 ec 04             	sub    $0x4,%esp
  80c9ae:	68 b0 35 81 00       	push   $0x8135b0
  80c9b3:	68 5b 03 00 00       	push   $0x35b
  80c9b8:	68 f4 36 81 00       	push   $0x8136f4
  80c9bd:	e8 85 1f 00 00       	call   80e947 <_panic>
          u16_t new_cwnd = (pcb->cwnd + pcb->mss * pcb->mss / pcb->cwnd);
  80c9c2:	0f b7 47 34          	movzwl 0x34(%edi),%eax
  80c9c6:	0f af c0             	imul   %eax,%eax
  80c9c9:	0f b7 d9             	movzwl %cx,%ebx
  80c9cc:	99                   	cltd   
  80c9cd:	f7 fb                	idiv   %ebx
  80c9cf:	01 c8                	add    %ecx,%eax
          if (new_cwnd > pcb->cwnd) {
  80c9d1:	66 39 c1             	cmp    %ax,%cx
  80c9d4:	0f 83 1d ff ff ff    	jae    80c8f7 <tcp_receive+0x1b2>
            pcb->cwnd = new_cwnd;
  80c9da:	66 89 47 4e          	mov    %ax,0x4e(%edi)
  80c9de:	e9 14 ff ff ff       	jmp    80c8f7 <tcp_receive+0x1b2>
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  80c9e3:	83 ec 04             	sub    $0x4,%esp
  80c9e6:	68 88 35 81 00       	push   $0x813588
  80c9eb:	68 55 03 00 00       	push   $0x355
  80c9f0:	68 f4 36 81 00       	push   $0x8136f4
  80c9f5:	e8 4d 1f 00 00       	call   80e947 <_panic>
             TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) +
  80c9fa:	83 ec 0c             	sub    $0xc,%esp
  80c9fd:	8b 47 78             	mov    0x78(%edi),%eax
  80ca00:	8b 40 10             	mov    0x10(%eax),%eax
  80ca03:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80ca07:	50                   	push   %eax
  80ca08:	e8 5d af ff ff       	call   80796a <ntohs>
  80ca0d:	66 d1 e8             	shr    %ax
  80ca10:	83 e0 01             	and    $0x1,%eax
  80ca13:	83 c4 10             	add    $0x10,%esp
  80ca16:	e9 20 ff ff ff       	jmp    80c93b <tcp_receive+0x1f6>
      if(pcb->unacked == NULL)
  80ca1b:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80ca1f:	0f 94 c0             	sete   %al
  80ca22:	0f b6 c0             	movzbl %al,%eax
  80ca25:	f7 d8                	neg    %eax
  80ca27:	66 89 47 32          	mov    %ax,0x32(%edi)
      pcb->polltmr = 0;
  80ca2b:	c6 47 30 00          	movb   $0x0,0x30(%edi)
  80ca2f:	eb 39                	jmp    80ca6a <tcp_receive+0x325>
      LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  80ca31:	83 ec 04             	sub    $0x4,%esp
  80ca34:	68 88 35 81 00       	push   $0x813588
  80ca39:	68 7f 03 00 00       	push   $0x37f
  80ca3e:	68 f4 36 81 00       	push   $0x8136f4
  80ca43:	e8 ff 1e 00 00       	call   80e947 <_panic>
        LWIP_ASSERT("tcp_receive: valid queue length",
  80ca48:	83 ec 04             	sub    $0x4,%esp
  80ca4b:	68 b0 35 81 00       	push   $0x8135b0
  80ca50:	68 84 03 00 00       	push   $0x384
  80ca55:	68 f4 36 81 00       	push   $0x8136f4
  80ca5a:	e8 e8 1e 00 00       	call   80e947 <_panic>
      if (pcb->unsent != NULL) {
  80ca5f:	8b 47 74             	mov    0x74(%edi),%eax
  80ca62:	85 c0                	test   %eax,%eax
  80ca64:	0f 85 cb 00 00 00    	jne    80cb35 <tcp_receive+0x3f0>
    while (pcb->unsent != NULL &&
  80ca6a:	8b 47 74             	mov    0x74(%edi),%eax
  80ca6d:	85 c0                	test   %eax,%eax
  80ca6f:	0f 84 fa 00 00 00    	je     80cb6f <tcp_receive+0x42a>
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_max)
  80ca75:	8b 35 a4 b1 b3 00    	mov    0xb3b1a4,%esi
  80ca7b:	83 ec 0c             	sub    $0xc,%esp
  80ca7e:	8b 40 10             	mov    0x10(%eax),%eax
  80ca81:	ff 70 04             	pushl  0x4(%eax)
  80ca84:	e8 1f b1 ff ff       	call   807ba8 <ntohl>
  80ca89:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80ca8c:	8b 47 74             	mov    0x74(%edi),%eax
  80ca8f:	0f b7 58 0c          	movzwl 0xc(%eax),%ebx
  80ca93:	8b 40 10             	mov    0x10(%eax),%eax
  80ca96:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80ca9a:	89 04 24             	mov    %eax,(%esp)
  80ca9d:	e8 c8 ae ff ff       	call   80796a <ntohs>
  80caa2:	89 c2                	mov    %eax,%edx
  80caa4:	83 c4 10             	add    $0x10,%esp
  80caa7:	b8 01 00 00 00       	mov    $0x1,%eax
  80caac:	f6 c2 01             	test   $0x1,%dl
  80caaf:	0f 84 99 00 00 00    	je     80cb4e <tcp_receive+0x409>
  80cab5:	2b 75 e4             	sub    -0x1c(%ebp),%esi
  80cab8:	01 c3                	add    %eax,%ebx
    while (pcb->unsent != NULL &&
  80caba:	39 de                	cmp    %ebx,%esi
  80cabc:	0f 88 ad 00 00 00    	js     80cb6f <tcp_receive+0x42a>
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_max)
  80cac2:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80cac7:	2b 47 58             	sub    0x58(%edi),%eax
  80caca:	85 c0                	test   %eax,%eax
  80cacc:	0f 8f 9d 00 00 00    	jg     80cb6f <tcp_receive+0x42a>
      next = pcb->unsent;
  80cad2:	8b 5f 74             	mov    0x74(%edi),%ebx
      pcb->unsent = pcb->unsent->next;
  80cad5:	8b 03                	mov    (%ebx),%eax
  80cad7:	89 47 74             	mov    %eax,0x74(%edi)
      LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  80cada:	0f b7 77 70          	movzwl 0x70(%edi),%esi
  80cade:	83 ec 0c             	sub    $0xc,%esp
  80cae1:	ff 73 04             	pushl  0x4(%ebx)
  80cae4:	e8 77 83 ff ff       	call   804e60 <pbuf_clen>
  80cae9:	0f b6 c0             	movzbl %al,%eax
  80caec:	83 c4 10             	add    $0x10,%esp
  80caef:	66 39 c6             	cmp    %ax,%si
  80caf2:	0f 82 39 ff ff ff    	jb     80ca31 <tcp_receive+0x2ec>
      pcb->snd_queuelen -= pbuf_clen(next->p);
  80caf8:	83 ec 0c             	sub    $0xc,%esp
  80cafb:	ff 73 04             	pushl  0x4(%ebx)
  80cafe:	e8 5d 83 ff ff       	call   804e60 <pbuf_clen>
  80cb03:	0f b6 c0             	movzbl %al,%eax
  80cb06:	66 29 47 70          	sub    %ax,0x70(%edi)
      tcp_seg_free(next);
  80cb0a:	89 1c 24             	mov    %ebx,(%esp)
  80cb0d:	e8 65 8e ff ff       	call   805977 <tcp_seg_free>
      if (pcb->snd_queuelen != 0) {
  80cb12:	83 c4 10             	add    $0x10,%esp
  80cb15:	66 83 7f 70 00       	cmpw   $0x0,0x70(%edi)
  80cb1a:	0f 84 3f ff ff ff    	je     80ca5f <tcp_receive+0x31a>
        LWIP_ASSERT("tcp_receive: valid queue length",
  80cb20:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80cb24:	0f 85 35 ff ff ff    	jne    80ca5f <tcp_receive+0x31a>
  80cb2a:	8b 47 74             	mov    0x74(%edi),%eax
  80cb2d:	85 c0                	test   %eax,%eax
  80cb2f:	0f 84 13 ff ff ff    	je     80ca48 <tcp_receive+0x303>
        pcb->snd_nxt = htonl(pcb->unsent->tcphdr->seqno);
  80cb35:	83 ec 0c             	sub    $0xc,%esp
  80cb38:	8b 40 10             	mov    0x10(%eax),%eax
  80cb3b:	ff 70 04             	pushl  0x4(%eax)
  80cb3e:	e8 38 ae ff ff       	call   80797b <htonl>
  80cb43:	89 47 54             	mov    %eax,0x54(%edi)
  80cb46:	83 c4 10             	add    $0x10,%esp
  80cb49:	e9 1c ff ff ff       	jmp    80ca6a <tcp_receive+0x325>
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_max)
  80cb4e:	83 ec 0c             	sub    $0xc,%esp
  80cb51:	8b 47 74             	mov    0x74(%edi),%eax
  80cb54:	8b 40 10             	mov    0x10(%eax),%eax
  80cb57:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cb5b:	50                   	push   %eax
  80cb5c:	e8 09 ae ff ff       	call   80796a <ntohs>
  80cb61:	66 d1 e8             	shr    %ax
  80cb64:	83 e0 01             	and    $0x1,%eax
  80cb67:	83 c4 10             	add    $0x10,%esp
  80cb6a:	e9 46 ff ff ff       	jmp    80cab5 <tcp_receive+0x370>
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
  80cb6f:	8b 47 38             	mov    0x38(%edi),%eax
  80cb72:	85 c0                	test   %eax,%eax
  80cb74:	74 0b                	je     80cb81 <tcp_receive+0x43c>
  80cb76:	8b 0d a4 b1 b3 00    	mov    0xb3b1a4,%ecx
  80cb7c:	39 4f 3c             	cmp    %ecx,0x3c(%edi)
  80cb7f:	78 70                	js     80cbf1 <tcp_receive+0x4ac>
  if (tcplen > 0) {
  80cb81:	0f b7 05 9e b1 b3 00 	movzwl 0xb3b19e,%eax
  80cb88:	66 85 c0             	test   %ax,%ax
  80cb8b:	0f 84 57 08 00 00    	je     80d3e8 <tcp_receive+0xca3>
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)){
  80cb91:	8b 5f 24             	mov    0x24(%edi),%ebx
  80cb94:	8b 15 a8 b1 b3 00    	mov    0xb3b1a8,%edx
  80cb9a:	89 d9                	mov    %ebx,%ecx
  80cb9c:	29 d1                	sub    %edx,%ecx
  80cb9e:	89 ce                	mov    %ecx,%esi
  80cba0:	83 ee 01             	sub    $0x1,%esi
  80cba3:	78 16                	js     80cbbb <tcp_receive+0x476>
  80cba5:	be 01 00 00 00       	mov    $0x1,%esi
  80cbaa:	29 d6                	sub    %edx,%esi
  80cbac:	0f b7 c0             	movzwl %ax,%eax
  80cbaf:	29 c6                	sub    %eax,%esi
  80cbb1:	01 de                	add    %ebx,%esi
  80cbb3:	85 f6                	test   %esi,%esi
  80cbb5:	0f 8e 84 00 00 00    	jle    80cc3f <tcp_receive+0x4fa>
      if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
  80cbbb:	39 da                	cmp    %ebx,%edx
  80cbbd:	0f 88 bd 01 00 00    	js     80cd80 <tcp_receive+0x63b>
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
  80cbc3:	0f b7 47 28          	movzwl 0x28(%edi),%eax
  80cbc7:	89 d1                	mov    %edx,%ecx
  80cbc9:	29 c1                	sub    %eax,%ecx
  80cbcb:	8d 41 01             	lea    0x1(%ecx),%eax
  80cbce:	29 d8                	sub    %ebx,%eax
  80cbd0:	85 c0                	test   %eax,%eax
  80cbd2:	0f 8e bd 01 00 00    	jle    80cd95 <tcp_receive+0x650>
      tcp_ack_now(pcb);
  80cbd8:	80 4f 20 02          	orb    $0x2,0x20(%edi)
  80cbdc:	83 ec 0c             	sub    $0xc,%esp
  80cbdf:	57                   	push   %edi
  80cbe0:	e8 fa b6 ff ff       	call   8082df <tcp_output>
  80cbe5:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80cbe8:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  80cbec:	e9 2a 08 00 00       	jmp    80d41b <tcp_receive+0xcd6>
      m = (s16_t)(tcp_ticks - pcb->rttest);
  80cbf1:	8b 35 40 b2 b3 00    	mov    0xb3b240,%esi
      m = m - (pcb->sa >> 3);
  80cbf7:	0f b7 57 40          	movzwl 0x40(%edi),%edx
  80cbfb:	89 d3                	mov    %edx,%ebx
  80cbfd:	66 c1 fb 03          	sar    $0x3,%bx
      m = (s16_t)(tcp_ticks - pcb->rttest);
  80cc01:	89 f1                	mov    %esi,%ecx
  80cc03:	29 c1                	sub    %eax,%ecx
      m = m - (pcb->sa >> 3);
  80cc05:	29 d9                	sub    %ebx,%ecx
      pcb->sa += m;
  80cc07:	01 ca                	add    %ecx,%edx
  80cc09:	66 89 57 40          	mov    %dx,0x40(%edi)
        m = -m;
  80cc0d:	29 f0                	sub    %esi,%eax
  80cc0f:	01 d8                	add    %ebx,%eax
  80cc11:	66 85 c9             	test   %cx,%cx
  80cc14:	0f 49 c1             	cmovns %ecx,%eax
      m = m - (pcb->sv >> 2);
  80cc17:	0f b7 4f 42          	movzwl 0x42(%edi),%ecx
  80cc1b:	89 cb                	mov    %ecx,%ebx
  80cc1d:	66 c1 fb 02          	sar    $0x2,%bx
      pcb->sv += m;
  80cc21:	29 d9                	sub    %ebx,%ecx
  80cc23:	01 c8                	add    %ecx,%eax
  80cc25:	66 89 47 42          	mov    %ax,0x42(%edi)
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
  80cc29:	66 c1 fa 03          	sar    $0x3,%dx
  80cc2d:	01 d0                	add    %edx,%eax
  80cc2f:	66 89 47 44          	mov    %ax,0x44(%edi)
      pcb->rttest = 0;
  80cc33:	c7 47 38 00 00 00 00 	movl   $0x0,0x38(%edi)
  80cc3a:	e9 42 ff ff ff       	jmp    80cb81 <tcp_receive+0x43c>
      off = pcb->rcv_nxt - seqno;
  80cc3f:	89 c8                	mov    %ecx,%eax
      p = inseg.p;
  80cc41:	8b 1d b8 b1 b3 00    	mov    0xb3b1b8,%ebx
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
  80cc47:	85 db                	test   %ebx,%ebx
  80cc49:	0f 84 a4 00 00 00    	je     80ccf3 <tcp_receive+0x5ae>
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
  80cc4f:	81 f9 fe 7f 00 00    	cmp    $0x7ffe,%ecx
  80cc55:	0f 8f af 00 00 00    	jg     80cd0a <tcp_receive+0x5c5>
      if (inseg.p->len < off) {
  80cc5b:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  80cc5f:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  80cc62:	39 ca                	cmp    %ecx,%edx
  80cc64:	0f 8d e5 00 00 00    	jge    80cd4f <tcp_receive+0x60a>
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
  80cc6a:	0f b7 73 08          	movzwl 0x8(%ebx),%esi
  80cc6e:	0f b7 d6             	movzwl %si,%edx
  80cc71:	39 ca                	cmp    %ecx,%edx
  80cc73:	0f 8c a8 00 00 00    	jl     80cd21 <tcp_receive+0x5dc>
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
  80cc79:	29 ce                	sub    %ecx,%esi
  80cc7b:	89 f1                	mov    %esi,%ecx
  80cc7d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
          off -= p->len;
  80cc80:	29 d0                	sub    %edx,%eax
          p->tot_len = new_tot_len;
  80cc82:	66 89 4b 08          	mov    %cx,0x8(%ebx)
          p->len = 0;
  80cc86:	66 c7 43 0a 00 00    	movw   $0x0,0xa(%ebx)
          p = p->next;
  80cc8c:	8b 1b                	mov    (%ebx),%ebx
        while (p->len < off) {
  80cc8e:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  80cc92:	39 c2                	cmp    %eax,%edx
  80cc94:	7c ea                	jl     80cc80 <tcp_receive+0x53b>
        if(pbuf_header(p, (s16_t)-off)) {
  80cc96:	83 ec 08             	sub    $0x8,%esp
  80cc99:	f7 d8                	neg    %eax
  80cc9b:	98                   	cwtl   
  80cc9c:	50                   	push   %eax
  80cc9d:	53                   	push   %ebx
  80cc9e:	e8 ab 7c ff ff       	call   80494e <pbuf_header>
  80cca3:	83 c4 10             	add    $0x10,%esp
  80cca6:	84 c0                	test   %al,%al
  80cca8:	0f 85 8a 00 00 00    	jne    80cd38 <tcp_receive+0x5f3>
      inseg.dataptr = p->payload;
  80ccae:	8b 43 04             	mov    0x4(%ebx),%eax
  80ccb1:	a3 bc b1 b3 00       	mov    %eax,0xb3b1bc
      inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
  80ccb6:	8b 57 24             	mov    0x24(%edi),%edx
  80ccb9:	0f b7 05 c0 b1 b3 00 	movzwl 0xb3b1c0,%eax
  80ccc0:	66 03 05 a8 b1 b3 00 	add    0xb3b1a8,%ax
  80ccc7:	29 d0                	sub    %edx,%eax
  80ccc9:	66 a3 c0 b1 b3 00    	mov    %ax,0xb3b1c0
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
  80cccf:	89 15 a8 b1 b3 00    	mov    %edx,0xb3b1a8
  80ccd5:	a1 c4 b1 b3 00       	mov    0xb3b1c4,%eax
  80ccda:	89 50 04             	mov    %edx,0x4(%eax)
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
  80ccdd:	8b 15 a8 b1 b3 00    	mov    0xb3b1a8,%edx
  80cce3:	8b 5f 24             	mov    0x24(%edi),%ebx
  80cce6:	39 da                	cmp    %ebx,%edx
  80cce8:	0f 88 ea fe ff ff    	js     80cbd8 <tcp_receive+0x493>
  80ccee:	e9 d0 fe ff ff       	jmp    80cbc3 <tcp_receive+0x47e>
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
  80ccf3:	83 ec 04             	sub    $0x4,%esp
  80ccf6:	68 0b 37 81 00       	push   $0x81370b
  80ccfb:	68 e5 03 00 00       	push   $0x3e5
  80cd00:	68 f4 36 81 00       	push   $0x8136f4
  80cd05:	e8 3d 1c 00 00       	call   80e947 <_panic>
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
  80cd0a:	83 ec 04             	sub    $0x4,%esp
  80cd0d:	68 1b 37 81 00       	push   $0x81371b
  80cd12:	68 e6 03 00 00       	push   $0x3e6
  80cd17:	68 f4 36 81 00       	push   $0x8136f4
  80cd1c:	e8 26 1c 00 00       	call   80e947 <_panic>
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
  80cd21:	83 ec 04             	sub    $0x4,%esp
  80cd24:	68 2a 37 81 00       	push   $0x81372a
  80cd29:	68 e8 03 00 00       	push   $0x3e8
  80cd2e:	68 f4 36 81 00       	push   $0x8136f4
  80cd33:	e8 0f 1c 00 00       	call   80e947 <_panic>
          LWIP_ASSERT("pbuf_header failed", 0);
  80cd38:	83 ec 04             	sub    $0x4,%esp
  80cd3b:	68 3a 37 81 00       	push   $0x81373a
  80cd40:	68 f5 03 00 00       	push   $0x3f5
  80cd45:	68 f4 36 81 00       	push   $0x8136f4
  80cd4a:	e8 f8 1b 00 00       	call   80e947 <_panic>
        if(pbuf_header(inseg.p, (s16_t)-off)) {
  80cd4f:	83 ec 08             	sub    $0x8,%esp
  80cd52:	f7 d9                	neg    %ecx
  80cd54:	0f bf c1             	movswl %cx,%eax
  80cd57:	50                   	push   %eax
  80cd58:	53                   	push   %ebx
  80cd59:	e8 f0 7b ff ff       	call   80494e <pbuf_header>
  80cd5e:	83 c4 10             	add    $0x10,%esp
  80cd61:	84 c0                	test   %al,%al
  80cd63:	0f 84 45 ff ff ff    	je     80ccae <tcp_receive+0x569>
          LWIP_ASSERT("pbuf_header failed", 0);
  80cd69:	83 ec 04             	sub    $0x4,%esp
  80cd6c:	68 3a 37 81 00       	push   $0x81373a
  80cd71:	68 fa 03 00 00       	push   $0x3fa
  80cd76:	68 f4 36 81 00       	push   $0x8136f4
  80cd7b:	e8 c7 1b 00 00       	call   80e947 <_panic>
        tcp_ack_now(pcb);
  80cd80:	80 4f 20 02          	orb    $0x2,0x20(%edi)
  80cd84:	83 ec 0c             	sub    $0xc,%esp
  80cd87:	57                   	push   %edi
  80cd88:	e8 52 b5 ff ff       	call   8082df <tcp_output>
  80cd8d:	83 c4 10             	add    $0x10,%esp
  80cd90:	e9 48 ff ff ff       	jmp    80ccdd <tcp_receive+0x598>
      if (pcb->rcv_nxt == seqno) {
  80cd95:	39 da                	cmp    %ebx,%edx
  80cd97:	0f 85 d7 03 00 00    	jne    80d174 <tcp_receive+0xa2f>
        if (pcb->ooseq != NULL &&
  80cd9d:	8b 47 7c             	mov    0x7c(%edi),%eax
  80cda0:	85 c0                	test   %eax,%eax
  80cda2:	74 1d                	je     80cdc1 <tcp_receive+0x67c>
                TCP_SEQ_LEQ(pcb->ooseq->tcphdr->seqno, seqno + inseg.len)) {
  80cda4:	8b 48 10             	mov    0x10(%eax),%ecx
  80cda7:	8b 59 04             	mov    0x4(%ecx),%ebx
  80cdaa:	0f b7 0d c0 b1 b3 00 	movzwl 0xb3b1c0,%ecx
  80cdb1:	89 de                	mov    %ebx,%esi
  80cdb3:	29 ce                	sub    %ecx,%esi
  80cdb5:	89 f1                	mov    %esi,%ecx
  80cdb7:	29 d1                	sub    %edx,%ecx
        if (pcb->ooseq != NULL &&
  80cdb9:	85 c9                	test   %ecx,%ecx
  80cdbb:	0f 8e b2 00 00 00    	jle    80ce73 <tcp_receive+0x72e>
        tcplen = TCP_TCPLEN(&inseg);
  80cdc1:	0f b7 1d c0 b1 b3 00 	movzwl 0xb3b1c0,%ebx
  80cdc8:	83 ec 0c             	sub    $0xc,%esp
  80cdcb:	a1 c4 b1 b3 00       	mov    0xb3b1c4,%eax
  80cdd0:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cdd4:	50                   	push   %eax
  80cdd5:	e8 90 ab ff ff       	call   80796a <ntohs>
  80cdda:	89 c2                	mov    %eax,%edx
  80cddc:	83 c4 10             	add    $0x10,%esp
  80cddf:	b8 01 00 00 00       	mov    $0x1,%eax
  80cde4:	f6 c2 01             	test   $0x1,%dl
  80cde7:	0f 84 ff 00 00 00    	je     80ceec <tcp_receive+0x7a7>
  80cded:	01 d8                	add    %ebx,%eax
  80cdef:	66 a3 9e b1 b3 00    	mov    %ax,0xb3b19e
        if (pcb->state != CLOSE_WAIT) {
  80cdf5:	83 7f 10 07          	cmpl   $0x7,0x10(%edi)
  80cdf9:	74 06                	je     80ce01 <tcp_receive+0x6bc>
          pcb->rcv_nxt += tcplen;
  80cdfb:	0f b7 d0             	movzwl %ax,%edx
  80cdfe:	01 57 24             	add    %edx,0x24(%edi)
        if (pcb->rcv_wnd < tcplen) {
  80ce01:	0f b7 4f 28          	movzwl 0x28(%edi),%ecx
          pcb->rcv_wnd -= tcplen;
  80ce05:	89 ca                	mov    %ecx,%edx
  80ce07:	29 c2                	sub    %eax,%edx
  80ce09:	66 39 c8             	cmp    %cx,%ax
  80ce0c:	b9 00 00 00 00       	mov    $0x0,%ecx
  80ce11:	0f 47 d1             	cmova  %ecx,%edx
  80ce14:	66 89 57 28          	mov    %dx,0x28(%edi)
        if (pcb->rcv_ann_wnd < tcplen) {
  80ce18:	0f b7 4f 2a          	movzwl 0x2a(%edi),%ecx
          pcb->rcv_ann_wnd -= tcplen;
  80ce1c:	89 ca                	mov    %ecx,%edx
  80ce1e:	29 c2                	sub    %eax,%edx
  80ce20:	66 39 c8             	cmp    %cx,%ax
  80ce23:	b8 00 00 00 00       	mov    $0x0,%eax
  80ce28:	0f 46 c2             	cmovbe %edx,%eax
  80ce2b:	66 89 47 2a          	mov    %ax,0x2a(%edi)
        if (inseg.p->tot_len > 0) {
  80ce2f:	a1 b8 b1 b3 00       	mov    0xb3b1b8,%eax
  80ce34:	66 83 78 08 00       	cmpw   $0x0,0x8(%eax)
  80ce39:	74 0f                	je     80ce4a <tcp_receive+0x705>
          recv_data = inseg.p;
  80ce3b:	a3 98 b1 b3 00       	mov    %eax,0xb3b198
          inseg.p = NULL;
  80ce40:	c7 05 b8 b1 b3 00 00 	movl   $0x0,0xb3b1b8
  80ce47:	00 00 00 
        if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
  80ce4a:	83 ec 0c             	sub    $0xc,%esp
  80ce4d:	a1 c4 b1 b3 00       	mov    0xb3b1c4,%eax
  80ce52:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80ce56:	50                   	push   %eax
  80ce57:	e8 0e ab ff ff       	call   80796a <ntohs>
  80ce5c:	83 c4 10             	add    $0x10,%esp
  80ce5f:	a8 01                	test   $0x1,%al
  80ce61:	0f 84 d6 01 00 00    	je     80d03d <tcp_receive+0x8f8>
          recv_flags = TF_GOT_FIN;
  80ce67:	c6 05 9c b1 b3 00 20 	movb   $0x20,0xb3b19c
  80ce6e:	e9 ca 01 00 00       	jmp    80d03d <tcp_receive+0x8f8>
          if (pcb->ooseq->len > 0) {
  80ce73:	66 83 78 0c 00       	cmpw   $0x0,0xc(%eax)
  80ce78:	74 23                	je     80ce9d <tcp_receive+0x758>
            inseg.len = (u16_t)(pcb->ooseq->tcphdr->seqno - seqno);
  80ce7a:	29 d3                	sub    %edx,%ebx
  80ce7c:	66 89 1d c0 b1 b3 00 	mov    %bx,0xb3b1c0
            pbuf_realloc(inseg.p, inseg.len);
  80ce83:	83 ec 08             	sub    $0x8,%esp
  80ce86:	0f b7 db             	movzwl %bx,%ebx
  80ce89:	53                   	push   %ebx
  80ce8a:	ff 35 b8 b1 b3 00    	pushl  0xb3b1b8
  80ce90:	e8 b5 7e ff ff       	call   804d4a <pbuf_realloc>
  80ce95:	83 c4 10             	add    $0x10,%esp
  80ce98:	e9 24 ff ff ff       	jmp    80cdc1 <tcp_receive+0x67c>
            if ((TCPH_FLAGS(inseg.tcphdr) & (TCP_FIN|TCP_SYN)) ==
  80ce9d:	83 ec 0c             	sub    $0xc,%esp
  80cea0:	a1 c4 b1 b3 00       	mov    0xb3b1c4,%eax
  80cea5:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cea9:	50                   	push   %eax
  80ceaa:	e8 bb aa ff ff       	call   80796a <ntohs>
  80ceaf:	89 c3                	mov    %eax,%ebx
                (TCPH_FLAGS(pcb->ooseq->tcphdr) & (TCP_FIN|TCP_SYN))) {
  80ceb1:	8b 47 7c             	mov    0x7c(%edi),%eax
  80ceb4:	8b 40 10             	mov    0x10(%eax),%eax
  80ceb7:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cebb:	89 04 24             	mov    %eax,(%esp)
  80cebe:	e8 a7 aa ff ff       	call   80796a <ntohs>
            if ((TCPH_FLAGS(inseg.tcphdr) & (TCP_FIN|TCP_SYN)) ==
  80cec3:	31 c3                	xor    %eax,%ebx
  80cec5:	83 c4 10             	add    $0x10,%esp
  80cec8:	f6 c3 03             	test   $0x3,%bl
  80cecb:	0f 85 f0 fe ff ff    	jne    80cdc1 <tcp_receive+0x67c>
              struct tcp_seg *old_ooseq = pcb->ooseq;
  80ced1:	8b 47 7c             	mov    0x7c(%edi),%eax
              pcb->ooseq = pcb->ooseq->next;
  80ced4:	8b 10                	mov    (%eax),%edx
  80ced6:	89 57 7c             	mov    %edx,0x7c(%edi)
              memp_free(MEMP_TCP_SEG, old_ooseq);
  80ced9:	83 ec 08             	sub    $0x8,%esp
  80cedc:	50                   	push   %eax
  80cedd:	6a 04                	push   $0x4
  80cedf:	e8 ba 77 ff ff       	call   80469e <memp_free>
  80cee4:	83 c4 10             	add    $0x10,%esp
  80cee7:	e9 d5 fe ff ff       	jmp    80cdc1 <tcp_receive+0x67c>
        tcplen = TCP_TCPLEN(&inseg);
  80ceec:	83 ec 0c             	sub    $0xc,%esp
  80ceef:	a1 c4 b1 b3 00       	mov    0xb3b1c4,%eax
  80cef4:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cef8:	50                   	push   %eax
  80cef9:	e8 6c aa ff ff       	call   80796a <ntohs>
  80cefe:	66 d1 e8             	shr    %ax
  80cf01:	83 e0 01             	and    $0x1,%eax
  80cf04:	83 c4 10             	add    $0x10,%esp
  80cf07:	e9 e1 fe ff ff       	jmp    80cded <tcp_receive+0x6a8>
          pcb->rcv_nxt += TCP_TCPLEN(cseg);
  80cf0c:	83 ec 0c             	sub    $0xc,%esp
  80cf0f:	8b 43 10             	mov    0x10(%ebx),%eax
  80cf12:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cf16:	50                   	push   %eax
  80cf17:	e8 4e aa ff ff       	call   80796a <ntohs>
  80cf1c:	66 d1 e8             	shr    %ax
  80cf1f:	83 e0 01             	and    $0x1,%eax
  80cf22:	83 c4 10             	add    $0x10,%esp
  80cf25:	e9 56 01 00 00       	jmp    80d080 <tcp_receive+0x93b>
          if (pcb->rcv_wnd < TCP_TCPLEN(cseg)) {
  80cf2a:	83 ec 0c             	sub    $0xc,%esp
  80cf2d:	8b 43 10             	mov    0x10(%ebx),%eax
  80cf30:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cf34:	50                   	push   %eax
  80cf35:	e8 30 aa ff ff       	call   80796a <ntohs>
  80cf3a:	66 d1 e8             	shr    %ax
  80cf3d:	83 e0 01             	and    $0x1,%eax
  80cf40:	83 c4 10             	add    $0x10,%esp
  80cf43:	e9 6b 01 00 00       	jmp    80d0b3 <tcp_receive+0x96e>
            pcb->rcv_wnd -= TCP_TCPLEN(cseg);
  80cf48:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  80cf4c:	83 ec 0c             	sub    $0xc,%esp
  80cf4f:	8b 43 10             	mov    0x10(%ebx),%eax
  80cf52:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cf56:	50                   	push   %eax
  80cf57:	e8 0e aa ff ff       	call   80796a <ntohs>
  80cf5c:	89 c2                	mov    %eax,%edx
  80cf5e:	83 c4 10             	add    $0x10,%esp
  80cf61:	b8 01 00 00 00       	mov    $0x1,%eax
  80cf66:	f6 c2 01             	test   $0x1,%dl
  80cf69:	74 0b                	je     80cf76 <tcp_receive+0x831>
  80cf6b:	01 c6                	add    %eax,%esi
  80cf6d:	66 29 77 28          	sub    %si,0x28(%edi)
  80cf71:	e9 4e 01 00 00       	jmp    80d0c4 <tcp_receive+0x97f>
  80cf76:	83 ec 0c             	sub    $0xc,%esp
  80cf79:	8b 43 10             	mov    0x10(%ebx),%eax
  80cf7c:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cf80:	50                   	push   %eax
  80cf81:	e8 e4 a9 ff ff       	call   80796a <ntohs>
  80cf86:	66 d1 e8             	shr    %ax
  80cf89:	83 e0 01             	and    $0x1,%eax
  80cf8c:	83 c4 10             	add    $0x10,%esp
  80cf8f:	eb da                	jmp    80cf6b <tcp_receive+0x826>
          if (pcb->rcv_ann_wnd < TCP_TCPLEN(cseg)) {
  80cf91:	83 ec 0c             	sub    $0xc,%esp
  80cf94:	8b 43 10             	mov    0x10(%ebx),%eax
  80cf97:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cf9b:	50                   	push   %eax
  80cf9c:	e8 c9 a9 ff ff       	call   80796a <ntohs>
  80cfa1:	66 d1 e8             	shr    %ax
  80cfa4:	83 e0 01             	and    $0x1,%eax
  80cfa7:	83 c4 10             	add    $0x10,%esp
  80cfaa:	e9 43 01 00 00       	jmp    80d0f2 <tcp_receive+0x9ad>
            pcb->rcv_ann_wnd -= TCP_TCPLEN(cseg);
  80cfaf:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  80cfb3:	83 ec 0c             	sub    $0xc,%esp
  80cfb6:	8b 43 10             	mov    0x10(%ebx),%eax
  80cfb9:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cfbd:	50                   	push   %eax
  80cfbe:	e8 a7 a9 ff ff       	call   80796a <ntohs>
  80cfc3:	89 c2                	mov    %eax,%edx
  80cfc5:	83 c4 10             	add    $0x10,%esp
  80cfc8:	b8 01 00 00 00       	mov    $0x1,%eax
  80cfcd:	f6 c2 01             	test   $0x1,%dl
  80cfd0:	74 0b                	je     80cfdd <tcp_receive+0x898>
  80cfd2:	01 c6                	add    %eax,%esi
  80cfd4:	66 29 77 2a          	sub    %si,0x2a(%edi)
  80cfd8:	e9 26 01 00 00       	jmp    80d103 <tcp_receive+0x9be>
  80cfdd:	83 ec 0c             	sub    $0xc,%esp
  80cfe0:	8b 43 10             	mov    0x10(%ebx),%eax
  80cfe3:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cfe7:	50                   	push   %eax
  80cfe8:	e8 7d a9 ff ff       	call   80796a <ntohs>
  80cfed:	66 d1 e8             	shr    %ax
  80cff0:	83 e0 01             	and    $0x1,%eax
  80cff3:	83 c4 10             	add    $0x10,%esp
  80cff6:	eb da                	jmp    80cfd2 <tcp_receive+0x88d>
              recv_data = cseg->p;
  80cff8:	a3 98 b1 b3 00       	mov    %eax,0xb3b198
            cseg->p = NULL;
  80cffd:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
          if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
  80d004:	83 ec 0c             	sub    $0xc,%esp
  80d007:	8b 43 10             	mov    0x10(%ebx),%eax
  80d00a:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d00e:	50                   	push   %eax
  80d00f:	e8 56 a9 ff ff       	call   80796a <ntohs>
  80d014:	83 c4 10             	add    $0x10,%esp
  80d017:	a8 01                	test   $0x1,%al
  80d019:	74 11                	je     80d02c <tcp_receive+0x8e7>
            recv_flags = TF_GOT_FIN;
  80d01b:	c6 05 9c b1 b3 00 20 	movb   $0x20,0xb3b19c
            if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
  80d022:	83 7f 10 04          	cmpl   $0x4,0x10(%edi)
  80d026:	0f 84 05 01 00 00    	je     80d131 <tcp_receive+0x9ec>
          pcb->ooseq = cseg->next;
  80d02c:	8b 03                	mov    (%ebx),%eax
  80d02e:	89 47 7c             	mov    %eax,0x7c(%edi)
          tcp_seg_free(cseg);
  80d031:	83 ec 0c             	sub    $0xc,%esp
  80d034:	53                   	push   %ebx
  80d035:	e8 3d 89 ff ff       	call   805977 <tcp_seg_free>
  80d03a:	83 c4 10             	add    $0x10,%esp
        while (pcb->ooseq != NULL &&
  80d03d:	8b 5f 7c             	mov    0x7c(%edi),%ebx
  80d040:	85 db                	test   %ebx,%ebx
  80d042:	0f 84 f5 00 00 00    	je     80d13d <tcp_receive+0x9f8>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
  80d048:	8b 53 10             	mov    0x10(%ebx),%edx
  80d04b:	8b 42 04             	mov    0x4(%edx),%eax
        while (pcb->ooseq != NULL &&
  80d04e:	3b 47 24             	cmp    0x24(%edi),%eax
  80d051:	0f 85 e6 00 00 00    	jne    80d13d <tcp_receive+0x9f8>
          seqno = pcb->ooseq->tcphdr->seqno;
  80d057:	a3 a8 b1 b3 00       	mov    %eax,0xb3b1a8
          pcb->rcv_nxt += TCP_TCPLEN(cseg);
  80d05c:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  80d060:	83 ec 0c             	sub    $0xc,%esp
  80d063:	0f b7 42 0c          	movzwl 0xc(%edx),%eax
  80d067:	50                   	push   %eax
  80d068:	e8 fd a8 ff ff       	call   80796a <ntohs>
  80d06d:	89 c2                	mov    %eax,%edx
  80d06f:	83 c4 10             	add    $0x10,%esp
  80d072:	b8 01 00 00 00       	mov    $0x1,%eax
  80d077:	f6 c2 01             	test   $0x1,%dl
  80d07a:	0f 84 8c fe ff ff    	je     80cf0c <tcp_receive+0x7c7>
  80d080:	01 c6                	add    %eax,%esi
  80d082:	01 77 24             	add    %esi,0x24(%edi)
          if (pcb->rcv_wnd < TCP_TCPLEN(cseg)) {
  80d085:	0f b7 47 28          	movzwl 0x28(%edi),%eax
  80d089:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80d08c:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  80d090:	83 ec 0c             	sub    $0xc,%esp
  80d093:	8b 43 10             	mov    0x10(%ebx),%eax
  80d096:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d09a:	50                   	push   %eax
  80d09b:	e8 ca a8 ff ff       	call   80796a <ntohs>
  80d0a0:	89 c2                	mov    %eax,%edx
  80d0a2:	83 c4 10             	add    $0x10,%esp
  80d0a5:	b8 01 00 00 00       	mov    $0x1,%eax
  80d0aa:	f6 c2 01             	test   $0x1,%dl
  80d0ad:	0f 84 77 fe ff ff    	je     80cf2a <tcp_receive+0x7e5>
  80d0b3:	01 c6                	add    %eax,%esi
  80d0b5:	39 75 e4             	cmp    %esi,-0x1c(%ebp)
  80d0b8:	0f 8d 8a fe ff ff    	jge    80cf48 <tcp_receive+0x803>
            pcb->rcv_wnd = 0;
  80d0be:	66 c7 47 28 00 00    	movw   $0x0,0x28(%edi)
          if (pcb->rcv_ann_wnd < TCP_TCPLEN(cseg)) {
  80d0c4:	0f b7 47 2a          	movzwl 0x2a(%edi),%eax
  80d0c8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80d0cb:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  80d0cf:	83 ec 0c             	sub    $0xc,%esp
  80d0d2:	8b 43 10             	mov    0x10(%ebx),%eax
  80d0d5:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d0d9:	50                   	push   %eax
  80d0da:	e8 8b a8 ff ff       	call   80796a <ntohs>
  80d0df:	89 c2                	mov    %eax,%edx
  80d0e1:	83 c4 10             	add    $0x10,%esp
  80d0e4:	b8 01 00 00 00       	mov    $0x1,%eax
  80d0e9:	f6 c2 01             	test   $0x1,%dl
  80d0ec:	0f 84 9f fe ff ff    	je     80cf91 <tcp_receive+0x84c>
  80d0f2:	01 c6                	add    %eax,%esi
  80d0f4:	39 75 e4             	cmp    %esi,-0x1c(%ebp)
  80d0f7:	0f 8d b2 fe ff ff    	jge    80cfaf <tcp_receive+0x86a>
            pcb->rcv_ann_wnd = 0;
  80d0fd:	66 c7 47 2a 00 00    	movw   $0x0,0x2a(%edi)
          if (cseg->p->tot_len > 0) {
  80d103:	8b 43 04             	mov    0x4(%ebx),%eax
  80d106:	66 83 78 08 00       	cmpw   $0x0,0x8(%eax)
  80d10b:	0f 84 f3 fe ff ff    	je     80d004 <tcp_receive+0x8bf>
            if (recv_data) {
  80d111:	8b 15 98 b1 b3 00    	mov    0xb3b198,%edx
  80d117:	85 d2                	test   %edx,%edx
  80d119:	0f 84 d9 fe ff ff    	je     80cff8 <tcp_receive+0x8b3>
              pbuf_cat(recv_data, cseg->p);
  80d11f:	83 ec 08             	sub    $0x8,%esp
  80d122:	50                   	push   %eax
  80d123:	52                   	push   %edx
  80d124:	e8 6a 7d ff ff       	call   804e93 <pbuf_cat>
  80d129:	83 c4 10             	add    $0x10,%esp
  80d12c:	e9 cc fe ff ff       	jmp    80cffd <tcp_receive+0x8b8>
              pcb->state = CLOSE_WAIT;
  80d131:	c7 47 10 07 00 00 00 	movl   $0x7,0x10(%edi)
  80d138:	e9 ef fe ff ff       	jmp    80d02c <tcp_receive+0x8e7>
        tcp_ack(pcb);
  80d13d:	0f b6 47 20          	movzbl 0x20(%edi),%eax
  80d141:	89 c1                	mov    %eax,%ecx
  80d143:	83 e1 01             	and    $0x1,%ecx
  80d146:	88 4d e4             	mov    %cl,-0x1c(%ebp)
  80d149:	75 0f                	jne    80d15a <tcp_receive+0xa15>
  80d14b:	83 c8 01             	or     $0x1,%eax
  80d14e:	88 47 20             	mov    %al,0x20(%edi)
        accepted_inseq = 1; 
  80d151:	c6 45 e4 01          	movb   $0x1,-0x1c(%ebp)
  80d155:	e9 c1 02 00 00       	jmp    80d41b <tcp_receive+0xcd6>
        tcp_ack(pcb);
  80d15a:	83 e0 fe             	and    $0xfffffffe,%eax
  80d15d:	83 c8 02             	or     $0x2,%eax
  80d160:	88 47 20             	mov    %al,0x20(%edi)
  80d163:	83 ec 0c             	sub    $0xc,%esp
  80d166:	57                   	push   %edi
  80d167:	e8 73 b1 ff ff       	call   8082df <tcp_output>
  80d16c:	83 c4 10             	add    $0x10,%esp
  80d16f:	e9 a7 02 00 00       	jmp    80d41b <tcp_receive+0xcd6>
        tcp_ack_now(pcb);
  80d174:	80 4f 20 02          	orb    $0x2,0x20(%edi)
  80d178:	83 ec 0c             	sub    $0xc,%esp
  80d17b:	57                   	push   %edi
  80d17c:	e8 5e b1 ff ff       	call   8082df <tcp_output>
        if (pcb->ooseq == NULL) {
  80d181:	8b 5f 7c             	mov    0x7c(%edi),%ebx
  80d184:	83 c4 10             	add    $0x10,%esp
  80d187:	85 db                	test   %ebx,%ebx
  80d189:	74 1e                	je     80d1a9 <tcp_receive+0xa64>
            if (seqno == next->tcphdr->seqno) {
  80d18b:	8b 0d a8 b1 b3 00    	mov    0xb3b1a8,%ecx
  80d191:	8d 41 ff             	lea    -0x1(%ecx),%eax
  80d194:	8d 51 01             	lea    0x1(%ecx),%edx
  80d197:	89 55 e4             	mov    %edx,-0x1c(%ebp)
          prev = NULL;
  80d19a:	be 00 00 00 00       	mov    $0x0,%esi
  80d19f:	89 7d e0             	mov    %edi,-0x20(%ebp)
  80d1a2:	89 c7                	mov    %eax,%edi
  80d1a4:	e9 d7 00 00 00       	jmp    80d280 <tcp_receive+0xb3b>
          pcb->ooseq = tcp_seg_copy(&inseg);
  80d1a9:	83 ec 0c             	sub    $0xc,%esp
  80d1ac:	68 b4 b1 b3 00       	push   $0xb3b1b4
  80d1b1:	e8 46 88 ff ff       	call   8059fc <tcp_seg_copy>
  80d1b6:	89 47 7c             	mov    %eax,0x7c(%edi)
  80d1b9:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80d1bc:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  80d1c0:	e9 56 02 00 00       	jmp    80d41b <tcp_receive+0xcd6>
  80d1c5:	8b 7d e0             	mov    -0x20(%ebp),%edi
  80d1c8:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
              if (inseg.len > next->len) {
  80d1cc:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80d1d0:	66 39 05 c0 b1 b3 00 	cmp    %ax,0xb3b1c0
  80d1d7:	0f 86 3e 02 00 00    	jbe    80d41b <tcp_receive+0xcd6>
                cseg = tcp_seg_copy(&inseg);
  80d1dd:	83 ec 0c             	sub    $0xc,%esp
  80d1e0:	68 b4 b1 b3 00       	push   $0xb3b1b4
  80d1e5:	e8 12 88 ff ff       	call   8059fc <tcp_seg_copy>
  80d1ea:	89 c1                	mov    %eax,%ecx
  80d1ec:	89 45 e0             	mov    %eax,-0x20(%ebp)
                if (cseg != NULL) {
  80d1ef:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80d1f2:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
                if (cseg != NULL) {
  80d1f6:	85 c0                	test   %eax,%eax
  80d1f8:	0f 84 1d 02 00 00    	je     80d41b <tcp_receive+0xcd6>
                  cseg->next = next->next;
  80d1fe:	8b 03                	mov    (%ebx),%eax
  80d200:	89 01                	mov    %eax,(%ecx)
                  if (prev != NULL) {
  80d202:	85 f6                	test   %esi,%esi
  80d204:	74 5c                	je     80d262 <tcp_receive+0xb1d>
                    prev->next = cseg;
  80d206:	89 0e                	mov    %ecx,(%esi)
                  tcp_seg_free(next);
  80d208:	83 ec 0c             	sub    $0xc,%esp
  80d20b:	53                   	push   %ebx
  80d20c:	e8 66 87 ff ff       	call   805977 <tcp_seg_free>
                  if (cseg->next != NULL) {
  80d211:	8b 75 e0             	mov    -0x20(%ebp),%esi
  80d214:	8b 06                	mov    (%esi),%eax
  80d216:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80d219:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
                  if (cseg->next != NULL) {
  80d21d:	85 c0                	test   %eax,%eax
  80d21f:	0f 84 f6 01 00 00    	je     80d41b <tcp_receive+0xcd6>
                    if (TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
  80d225:	8b 0d a8 b1 b3 00    	mov    0xb3b1a8,%ecx
  80d22b:	8b 40 10             	mov    0x10(%eax),%eax
  80d22e:	8b 40 04             	mov    0x4(%eax),%eax
  80d231:	0f b7 56 0c          	movzwl 0xc(%esi),%edx
  80d235:	01 ca                	add    %ecx,%edx
  80d237:	29 c2                	sub    %eax,%edx
  80d239:	85 d2                	test   %edx,%edx
  80d23b:	0f 8e da 01 00 00    	jle    80d41b <tcp_receive+0xcd6>
                      cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
  80d241:	29 c8                	sub    %ecx,%eax
  80d243:	66 89 46 0c          	mov    %ax,0xc(%esi)
                      pbuf_realloc(cseg->p, cseg->len);
  80d247:	83 ec 08             	sub    $0x8,%esp
  80d24a:	0f b7 c0             	movzwl %ax,%eax
  80d24d:	50                   	push   %eax
  80d24e:	ff 76 04             	pushl  0x4(%esi)
  80d251:	e8 f4 7a ff ff       	call   804d4a <pbuf_realloc>
  80d256:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80d259:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  80d25d:	e9 b9 01 00 00       	jmp    80d41b <tcp_receive+0xcd6>
                    pcb->ooseq = cseg;
  80d262:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80d265:	89 47 7c             	mov    %eax,0x7c(%edi)
  80d268:	eb 9e                	jmp    80d208 <tcp_receive+0xac3>
                if (TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {
  80d26a:	39 c1                	cmp    %eax,%ecx
  80d26c:	0f 88 a0 00 00 00    	js     80d312 <tcp_receive+0xbcd>
              if (next->next == NULL &&
  80d272:	8b 13                	mov    (%ebx),%edx
  80d274:	89 de                	mov    %ebx,%esi
  80d276:	85 d2                	test   %edx,%edx
  80d278:	0f 84 0d 01 00 00    	je     80d38b <tcp_receive+0xc46>
  80d27e:	89 d3                	mov    %edx,%ebx
            if (seqno == next->tcphdr->seqno) {
  80d280:	8b 43 10             	mov    0x10(%ebx),%eax
  80d283:	8b 40 04             	mov    0x4(%eax),%eax
  80d286:	39 c8                	cmp    %ecx,%eax
  80d288:	0f 84 37 ff ff ff    	je     80d1c5 <tcp_receive+0xa80>
              if (prev == NULL) {
  80d28e:	85 f6                	test   %esi,%esi
  80d290:	74 d8                	je     80d26a <tcp_receive+0xb25>
                if(TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno+1, next->tcphdr->seqno-1)){
  80d292:	8b 56 10             	mov    0x10(%esi),%edx
  80d295:	3b 7a 04             	cmp    0x4(%edx),%edi
  80d298:	78 d8                	js     80d272 <tcp_receive+0xb2d>
  80d29a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80d29d:	29 c2                	sub    %eax,%edx
  80d29f:	85 d2                	test   %edx,%edx
  80d2a1:	7f cf                	jg     80d272 <tcp_receive+0xb2d>
                if (TCP_SEQ_GT(seqno + inseg.len, next->tcphdr->seqno)) {
  80d2a3:	0f b7 15 c0 b1 b3 00 	movzwl 0xb3b1c0,%edx
  80d2aa:	01 ca                	add    %ecx,%edx
  80d2ac:	29 c2                	sub    %eax,%edx
  80d2ae:	85 d2                	test   %edx,%edx
  80d2b0:	0f 8f b3 00 00 00    	jg     80d369 <tcp_receive+0xc24>
                cseg = tcp_seg_copy(&inseg);
  80d2b6:	83 ec 0c             	sub    $0xc,%esp
  80d2b9:	68 b4 b1 b3 00       	push   $0xb3b1b4
  80d2be:	e8 39 87 ff ff       	call   8059fc <tcp_seg_copy>
                if (cseg != NULL) {
  80d2c3:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80d2c6:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
                if (cseg != NULL) {
  80d2ca:	85 c0                	test   %eax,%eax
  80d2cc:	0f 84 49 01 00 00    	je     80d41b <tcp_receive+0xcd6>
                  cseg->next = next;
  80d2d2:	89 18                	mov    %ebx,(%eax)
                  prev->next = cseg;
  80d2d4:	89 06                	mov    %eax,(%esi)
                  if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
  80d2d6:	8b 46 10             	mov    0x10(%esi),%eax
  80d2d9:	8b 48 04             	mov    0x4(%eax),%ecx
  80d2dc:	a1 a8 b1 b3 00       	mov    0xb3b1a8,%eax
  80d2e1:	0f b7 56 0c          	movzwl 0xc(%esi),%edx
  80d2e5:	01 ca                	add    %ecx,%edx
  80d2e7:	29 c2                	sub    %eax,%edx
  80d2e9:	85 d2                	test   %edx,%edx
  80d2eb:	0f 8e 2a 01 00 00    	jle    80d41b <tcp_receive+0xcd6>
                    prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
  80d2f1:	29 c8                	sub    %ecx,%eax
  80d2f3:	66 89 46 0c          	mov    %ax,0xc(%esi)
                    pbuf_realloc(prev->p, prev->len);
  80d2f7:	83 ec 08             	sub    $0x8,%esp
  80d2fa:	0f b7 c0             	movzwl %ax,%eax
  80d2fd:	50                   	push   %eax
  80d2fe:	ff 76 04             	pushl  0x4(%esi)
  80d301:	e8 44 7a ff ff       	call   804d4a <pbuf_realloc>
  80d306:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80d309:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  80d30d:	e9 09 01 00 00       	jmp    80d41b <tcp_receive+0xcd6>
  80d312:	8b 7d e0             	mov    -0x20(%ebp),%edi
                  if (TCP_SEQ_GT(seqno + inseg.len, next->tcphdr->seqno)) {
  80d315:	0f b7 15 c0 b1 b3 00 	movzwl 0xb3b1c0,%edx
  80d31c:	01 ca                	add    %ecx,%edx
  80d31e:	29 c2                	sub    %eax,%edx
  80d320:	85 d2                	test   %edx,%edx
  80d322:	7f 26                	jg     80d34a <tcp_receive+0xc05>
                  cseg = tcp_seg_copy(&inseg);
  80d324:	83 ec 0c             	sub    $0xc,%esp
  80d327:	68 b4 b1 b3 00       	push   $0xb3b1b4
  80d32c:	e8 cb 86 ff ff       	call   8059fc <tcp_seg_copy>
                  if (cseg != NULL) {
  80d331:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80d334:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
                  if (cseg != NULL) {
  80d338:	85 c0                	test   %eax,%eax
  80d33a:	0f 84 db 00 00 00    	je     80d41b <tcp_receive+0xcd6>
                    cseg->next = next;
  80d340:	89 18                	mov    %ebx,(%eax)
                    pcb->ooseq = cseg;
  80d342:	89 47 7c             	mov    %eax,0x7c(%edi)
  80d345:	e9 d1 00 00 00       	jmp    80d41b <tcp_receive+0xcd6>
                    inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
  80d34a:	29 c8                	sub    %ecx,%eax
  80d34c:	66 a3 c0 b1 b3 00    	mov    %ax,0xb3b1c0
                    pbuf_realloc(inseg.p, inseg.len);
  80d352:	83 ec 08             	sub    $0x8,%esp
  80d355:	0f b7 c0             	movzwl %ax,%eax
  80d358:	50                   	push   %eax
  80d359:	ff 35 b8 b1 b3 00    	pushl  0xb3b1b8
  80d35f:	e8 e6 79 ff ff       	call   804d4a <pbuf_realloc>
  80d364:	83 c4 10             	add    $0x10,%esp
  80d367:	eb bb                	jmp    80d324 <tcp_receive+0xbdf>
                  inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
  80d369:	29 c8                	sub    %ecx,%eax
  80d36b:	66 a3 c0 b1 b3 00    	mov    %ax,0xb3b1c0
                  pbuf_realloc(inseg.p, inseg.len);
  80d371:	83 ec 08             	sub    $0x8,%esp
  80d374:	0f b7 c0             	movzwl %ax,%eax
  80d377:	50                   	push   %eax
  80d378:	ff 35 b8 b1 b3 00    	pushl  0xb3b1b8
  80d37e:	e8 c7 79 ff ff       	call   804d4a <pbuf_realloc>
  80d383:	83 c4 10             	add    $0x10,%esp
  80d386:	e9 2b ff ff ff       	jmp    80d2b6 <tcp_receive+0xb71>
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
  80d38b:	29 c1                	sub    %eax,%ecx
  u8_t accepted_inseq = 0;
  80d38d:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
              if (next->next == NULL &&
  80d391:	85 c9                	test   %ecx,%ecx
  80d393:	0f 8e 82 00 00 00    	jle    80d41b <tcp_receive+0xcd6>
                next->next = tcp_seg_copy(&inseg);
  80d399:	83 ec 0c             	sub    $0xc,%esp
  80d39c:	68 b4 b1 b3 00       	push   $0xb3b1b4
  80d3a1:	e8 56 86 ff ff       	call   8059fc <tcp_seg_copy>
  80d3a6:	89 03                	mov    %eax,(%ebx)
                if (next->next != NULL) {
  80d3a8:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80d3ab:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
                if (next->next != NULL) {
  80d3af:	85 c0                	test   %eax,%eax
  80d3b1:	74 68                	je     80d41b <tcp_receive+0xcd6>
                  if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
  80d3b3:	8b 43 10             	mov    0x10(%ebx),%eax
  80d3b6:	8b 48 04             	mov    0x4(%eax),%ecx
  80d3b9:	a1 a8 b1 b3 00       	mov    0xb3b1a8,%eax
  80d3be:	0f b7 53 0c          	movzwl 0xc(%ebx),%edx
  80d3c2:	01 ca                	add    %ecx,%edx
  80d3c4:	29 c2                	sub    %eax,%edx
  80d3c6:	85 d2                	test   %edx,%edx
  80d3c8:	7e 51                	jle    80d41b <tcp_receive+0xcd6>
                    next->len = (u16_t)(seqno - next->tcphdr->seqno);
  80d3ca:	29 c8                	sub    %ecx,%eax
  80d3cc:	66 89 43 0c          	mov    %ax,0xc(%ebx)
                    pbuf_realloc(next->p, next->len);
  80d3d0:	83 ec 08             	sub    $0x8,%esp
  80d3d3:	0f b7 c0             	movzwl %ax,%eax
  80d3d6:	50                   	push   %eax
  80d3d7:	ff 73 04             	pushl  0x4(%ebx)
  80d3da:	e8 6b 79 ff ff       	call   804d4a <pbuf_realloc>
  80d3df:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80d3e2:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  80d3e6:	eb 33                	jmp    80d41b <tcp_receive+0xcd6>
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
  80d3e8:	a1 a8 b1 b3 00       	mov    0xb3b1a8,%eax
  80d3ed:	8b 57 24             	mov    0x24(%edi),%edx
  80d3f0:	39 d0                	cmp    %edx,%eax
  80d3f2:	78 13                	js     80d407 <tcp_receive+0xcc2>
  80d3f4:	83 c0 01             	add    $0x1,%eax
  80d3f7:	29 d0                	sub    %edx,%eax
  80d3f9:	0f b7 57 28          	movzwl 0x28(%edi),%edx
  80d3fd:	29 d0                	sub    %edx,%eax
  u8_t accepted_inseq = 0;
  80d3ff:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
  80d403:	85 c0                	test   %eax,%eax
  80d405:	7e 14                	jle    80d41b <tcp_receive+0xcd6>
      tcp_ack_now(pcb);
  80d407:	80 4f 20 02          	orb    $0x2,0x20(%edi)
  80d40b:	83 ec 0c             	sub    $0xc,%esp
  80d40e:	57                   	push   %edi
  80d40f:	e8 cb ae ff ff       	call   8082df <tcp_output>
  80d414:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80d417:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
}
  80d41b:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  80d41f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80d422:	5b                   	pop    %ebx
  80d423:	5e                   	pop    %esi
  80d424:	5f                   	pop    %edi
  80d425:	5d                   	pop    %ebp
  80d426:	c3                   	ret    

0080d427 <tcp_input>:
{
  80d427:	f3 0f 1e fb          	endbr32 
  80d42b:	55                   	push   %ebp
  80d42c:	89 e5                	mov    %esp,%ebp
  80d42e:	57                   	push   %edi
  80d42f:	56                   	push   %esi
  80d430:	53                   	push   %ebx
  80d431:	83 ec 38             	sub    $0x38,%esp
  80d434:	8b 75 08             	mov    0x8(%ebp),%esi
  iphdr = p->payload;
  80d437:	8b 5e 04             	mov    0x4(%esi),%ebx
  80d43a:	89 1d ac b1 b3 00    	mov    %ebx,0xb3b1ac
  tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
  80d440:	0f b7 03             	movzwl (%ebx),%eax
  80d443:	50                   	push   %eax
  80d444:	e8 21 a5 ff ff       	call   80796a <ntohs>
  80d449:	66 c1 e8 08          	shr    $0x8,%ax
  80d44d:	83 e0 0f             	and    $0xf,%eax
  80d450:	8d 04 83             	lea    (%ebx,%eax,4),%eax
  80d453:	a3 b0 b1 b3 00       	mov    %eax,0xb3b1b0
  if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
  80d458:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
  80d45d:	0f b7 00             	movzwl (%eax),%eax
  80d460:	89 04 24             	mov    %eax,(%esp)
  80d463:	e8 02 a5 ff ff       	call   80796a <ntohs>
  80d468:	83 c4 08             	add    $0x8,%esp
  80d46b:	66 c1 e8 06          	shr    $0x6,%ax
  80d46f:	83 e0 3c             	and    $0x3c,%eax
  80d472:	f7 d8                	neg    %eax
  80d474:	98                   	cwtl   
  80d475:	50                   	push   %eax
  80d476:	56                   	push   %esi
  80d477:	e8 d2 74 ff ff       	call   80494e <pbuf_header>
  80d47c:	83 c4 10             	add    $0x10,%esp
  80d47f:	84 c0                	test   %al,%al
  80d481:	75 07                	jne    80d48a <tcp_input+0x63>
  80d483:	66 83 7e 08 13       	cmpw   $0x13,0x8(%esi)
  80d488:	77 14                	ja     80d49e <tcp_input+0x77>
    pbuf_free(p);
  80d48a:	83 ec 0c             	sub    $0xc,%esp
  80d48d:	56                   	push   %esi
  80d48e:	e8 8e 75 ff ff       	call   804a21 <pbuf_free>
    return;
  80d493:	83 c4 10             	add    $0x10,%esp
}
  80d496:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80d499:	5b                   	pop    %ebx
  80d49a:	5e                   	pop    %esi
  80d49b:	5f                   	pop    %edi
  80d49c:	5d                   	pop    %ebp
  80d49d:	c3                   	ret    
  if (ip_addr_isbroadcast(&(iphdr->dest), inp) ||
  80d49e:	83 ec 08             	sub    $0x8,%esp
  80d4a1:	ff 75 0c             	pushl  0xc(%ebp)
  80d4a4:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
  80d4a9:	83 c0 10             	add    $0x10,%eax
  80d4ac:	50                   	push   %eax
  80d4ad:	e8 2b 92 ff ff       	call   8066dd <ip_addr_isbroadcast>
  80d4b2:	83 c4 10             	add    $0x10,%esp
  80d4b5:	84 c0                	test   %al,%al
  80d4b7:	0f 85 54 01 00 00    	jne    80d611 <tcp_input+0x1ea>
      ip_addr_ismulticast(&(iphdr->dest))) {
  80d4bd:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
  80d4c2:	8b 58 10             	mov    0x10(%eax),%ebx
  80d4c5:	83 ec 0c             	sub    $0xc,%esp
  80d4c8:	68 00 00 00 f0       	push   $0xf0000000
  80d4cd:	e8 d6 a6 ff ff       	call   807ba8 <ntohl>
  80d4d2:	21 c3                	and    %eax,%ebx
  80d4d4:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80d4db:	e8 c8 a6 ff ff       	call   807ba8 <ntohl>
  if (ip_addr_isbroadcast(&(iphdr->dest), inp) ||
  80d4e0:	83 c4 10             	add    $0x10,%esp
  80d4e3:	39 c3                	cmp    %eax,%ebx
  80d4e5:	0f 84 26 01 00 00    	je     80d611 <tcp_input+0x1ea>
      (struct ip_addr *)&(iphdr->dest),
  80d4eb:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
  if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
  80d4f0:	83 ec 0c             	sub    $0xc,%esp
  80d4f3:	0f b7 56 08          	movzwl 0x8(%esi),%edx
  80d4f7:	52                   	push   %edx
  80d4f8:	6a 06                	push   $0x6
  80d4fa:	8d 50 10             	lea    0x10(%eax),%edx
  80d4fd:	52                   	push   %edx
  80d4fe:	83 c0 0c             	add    $0xc,%eax
  80d501:	50                   	push   %eax
  80d502:	56                   	push   %esi
  80d503:	e8 19 a1 ff ff       	call   807621 <inet_chksum_pseudo>
  80d508:	83 c4 20             	add    $0x20,%esp
  80d50b:	66 85 c0             	test   %ax,%ax
  80d50e:	0f 85 0e 01 00 00    	jne    80d622 <tcp_input+0x1fb>
  hdrlen = TCPH_HDRLEN(tcphdr);
  80d514:	83 ec 0c             	sub    $0xc,%esp
  80d517:	a1 b0 b1 b3 00       	mov    0xb3b1b0,%eax
  80d51c:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d520:	50                   	push   %eax
  80d521:	e8 44 a4 ff ff       	call   80796a <ntohs>
  if(pbuf_header(p, -(hdrlen * 4))){
  80d526:	83 c4 08             	add    $0x8,%esp
  hdrlen = TCPH_HDRLEN(tcphdr);
  80d529:	66 c1 e8 0c          	shr    $0xc,%ax
  if(pbuf_header(p, -(hdrlen * 4))){
  80d52d:	f7 d8                	neg    %eax
  80d52f:	c1 e0 02             	shl    $0x2,%eax
  80d532:	98                   	cwtl   
  80d533:	50                   	push   %eax
  80d534:	56                   	push   %esi
  80d535:	e8 14 74 ff ff       	call   80494e <pbuf_header>
  80d53a:	83 c4 10             	add    $0x10,%esp
  80d53d:	84 c0                	test   %al,%al
  80d53f:	0f 85 ee 00 00 00    	jne    80d633 <tcp_input+0x20c>
  tcphdr->src = ntohs(tcphdr->src);
  80d545:	8b 1d b0 b1 b3 00    	mov    0xb3b1b0,%ebx
  80d54b:	83 ec 0c             	sub    $0xc,%esp
  80d54e:	0f b7 03             	movzwl (%ebx),%eax
  80d551:	50                   	push   %eax
  80d552:	e8 13 a4 ff ff       	call   80796a <ntohs>
  80d557:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = ntohs(tcphdr->dest);
  80d55a:	8b 1d b0 b1 b3 00    	mov    0xb3b1b0,%ebx
  80d560:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  80d564:	89 04 24             	mov    %eax,(%esp)
  80d567:	e8 fe a3 ff ff       	call   80796a <ntohs>
  80d56c:	66 89 43 02          	mov    %ax,0x2(%ebx)
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
  80d570:	8b 1d b0 b1 b3 00    	mov    0xb3b1b0,%ebx
  80d576:	83 c4 04             	add    $0x4,%esp
  80d579:	ff 73 04             	pushl  0x4(%ebx)
  80d57c:	e8 27 a6 ff ff       	call   807ba8 <ntohl>
  80d581:	89 43 04             	mov    %eax,0x4(%ebx)
  80d584:	a3 a8 b1 b3 00       	mov    %eax,0xb3b1a8
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
  80d589:	8b 1d b0 b1 b3 00    	mov    0xb3b1b0,%ebx
  80d58f:	83 c4 04             	add    $0x4,%esp
  80d592:	ff 73 08             	pushl  0x8(%ebx)
  80d595:	e8 0e a6 ff ff       	call   807ba8 <ntohl>
  80d59a:	89 43 08             	mov    %eax,0x8(%ebx)
  80d59d:	a3 a4 b1 b3 00       	mov    %eax,0xb3b1a4
  tcphdr->wnd = ntohs(tcphdr->wnd);
  80d5a2:	8b 1d b0 b1 b3 00    	mov    0xb3b1b0,%ebx
  80d5a8:	0f b7 43 0e          	movzwl 0xe(%ebx),%eax
  80d5ac:	89 04 24             	mov    %eax,(%esp)
  80d5af:	e8 b6 a3 ff ff       	call   80796a <ntohs>
  80d5b4:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  flags = TCPH_FLAGS(tcphdr) & TCP_FLAGS;
  80d5b8:	a1 b0 b1 b3 00       	mov    0xb3b1b0,%eax
  80d5bd:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d5c1:	89 04 24             	mov    %eax,(%esp)
  80d5c4:	e8 a1 a3 ff ff       	call   80796a <ntohs>
  80d5c9:	89 c1                	mov    %eax,%ecx
  80d5cb:	66 89 45 d6          	mov    %ax,-0x2a(%ebp)
  80d5cf:	83 e0 3f             	and    $0x3f,%eax
  80d5d2:	a2 a0 b1 b3 00       	mov    %al,0xb3b1a0
  tcplen = p->tot_len + ((flags & TCP_FIN || flags & TCP_SYN)? 1: 0);
  80d5d7:	83 c4 10             	add    $0x10,%esp
  80d5da:	f6 c1 03             	test   $0x3,%cl
  80d5dd:	0f 95 c0             	setne  %al
  80d5e0:	0f b6 c0             	movzbl %al,%eax
  80d5e3:	66 03 46 08          	add    0x8(%esi),%ax
  80d5e7:	66 89 45 d4          	mov    %ax,-0x2c(%ebp)
  80d5eb:	66 a3 9e b1 b3 00    	mov    %ax,0xb3b19e
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80d5f1:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
  80d5f6:	89 45 d0             	mov    %eax,-0x30(%ebp)
    if (pcb->remote_port == tcphdr->src &&
  80d5f9:	8b 15 b0 b1 b3 00    	mov    0xb3b1b0,%edx
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  80d5ff:	8b 0d ac b1 b3 00    	mov    0xb3b1ac,%ecx
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80d605:	89 c3                	mov    %eax,%ebx
  prev = NULL;
  80d607:	bf 00 00 00 00       	mov    $0x0,%edi
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80d60c:	e9 ab 00 00 00       	jmp    80d6bc <tcp_input+0x295>
    pbuf_free(p);
  80d611:	83 ec 0c             	sub    $0xc,%esp
  80d614:	56                   	push   %esi
  80d615:	e8 07 74 ff ff       	call   804a21 <pbuf_free>
    return;
  80d61a:	83 c4 10             	add    $0x10,%esp
  80d61d:	e9 74 fe ff ff       	jmp    80d496 <tcp_input+0x6f>
    pbuf_free(p);
  80d622:	83 ec 0c             	sub    $0xc,%esp
  80d625:	56                   	push   %esi
  80d626:	e8 f6 73 ff ff       	call   804a21 <pbuf_free>
    return;
  80d62b:	83 c4 10             	add    $0x10,%esp
  80d62e:	e9 63 fe ff ff       	jmp    80d496 <tcp_input+0x6f>
    pbuf_free(p);
  80d633:	83 ec 0c             	sub    $0xc,%esp
  80d636:	56                   	push   %esi
  80d637:	e8 e5 73 ff ff       	call   804a21 <pbuf_free>
    return;
  80d63c:	83 c4 10             	add    $0x10,%esp
  80d63f:	e9 52 fe ff ff       	jmp    80d496 <tcp_input+0x6f>
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
  80d644:	83 ec 04             	sub    $0x4,%esp
  80d647:	68 d0 35 81 00       	push   $0x8135d0
  80d64c:	68 b5 00 00 00       	push   $0xb5
  80d651:	68 f4 36 81 00       	push   $0x8136f4
  80d656:	e8 ec 12 00 00       	call   80e947 <_panic>
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
  80d65b:	83 ec 04             	sub    $0x4,%esp
  80d65e:	68 f8 35 81 00       	push   $0x8135f8
  80d663:	68 b6 00 00 00       	push   $0xb6
  80d668:	68 f4 36 81 00       	push   $0x8136f4
  80d66d:	e8 d5 12 00 00       	call   80e947 <_panic>
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
  80d672:	83 ec 04             	sub    $0x4,%esp
  80d675:	68 24 36 81 00       	push   $0x813624
  80d67a:	68 b7 00 00 00       	push   $0xb7
  80d67f:	68 f4 36 81 00       	push   $0x8136f4
  80d684:	e8 be 12 00 00       	call   80e947 <_panic>
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
  80d689:	83 ec 04             	sub    $0x4,%esp
  80d68c:	68 4c 36 81 00       	push   $0x81364c
  80d691:	68 c0 00 00 00       	push   $0xc0
  80d696:	68 f4 36 81 00       	push   $0x8136f4
  80d69b:	e8 a7 12 00 00       	call   80e947 <_panic>
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
  80d6a0:	83 ec 04             	sub    $0x4,%esp
  80d6a3:	68 78 36 81 00       	push   $0x813678
  80d6a8:	68 c6 00 00 00       	push   $0xc6
  80d6ad:	68 f4 36 81 00       	push   $0x8136f4
  80d6b2:	e8 90 12 00 00       	call   80e947 <_panic>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80d6b7:	89 df                	mov    %ebx,%edi
  80d6b9:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  80d6bc:	85 db                	test   %ebx,%ebx
  80d6be:	0f 84 5b 0a 00 00    	je     80e11f <tcp_input+0xcf8>
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
  80d6c4:	8b 43 10             	mov    0x10(%ebx),%eax
  80d6c7:	85 c0                	test   %eax,%eax
  80d6c9:	0f 84 75 ff ff ff    	je     80d644 <tcp_input+0x21d>
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
  80d6cf:	83 f8 0a             	cmp    $0xa,%eax
  80d6d2:	74 87                	je     80d65b <tcp_input+0x234>
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
  80d6d4:	83 f8 01             	cmp    $0x1,%eax
  80d6d7:	74 99                	je     80d672 <tcp_input+0x24b>
    if (pcb->remote_port == tcphdr->src &&
  80d6d9:	0f b7 02             	movzwl (%edx),%eax
  80d6dc:	66 39 43 1e          	cmp    %ax,0x1e(%ebx)
  80d6e0:	75 d5                	jne    80d6b7 <tcp_input+0x290>
  80d6e2:	0f b7 42 02          	movzwl 0x2(%edx),%eax
  80d6e6:	66 39 43 1c          	cmp    %ax,0x1c(%ebx)
  80d6ea:	75 cb                	jne    80d6b7 <tcp_input+0x290>
       pcb->local_port == tcphdr->dest &&
  80d6ec:	8b 41 0c             	mov    0xc(%ecx),%eax
  80d6ef:	39 43 04             	cmp    %eax,0x4(%ebx)
  80d6f2:	75 c3                	jne    80d6b7 <tcp_input+0x290>
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  80d6f4:	8b 41 10             	mov    0x10(%ecx),%eax
  80d6f7:	39 03                	cmp    %eax,(%ebx)
  80d6f9:	75 bc                	jne    80d6b7 <tcp_input+0x290>
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
  80d6fb:	8b 43 0c             	mov    0xc(%ebx),%eax
  80d6fe:	39 c3                	cmp    %eax,%ebx
  80d700:	74 87                	je     80d689 <tcp_input+0x262>
      if (prev != NULL) {
  80d702:	85 ff                	test   %edi,%edi
  80d704:	74 13                	je     80d719 <tcp_input+0x2f2>
        prev->next = pcb->next;
  80d706:	89 47 0c             	mov    %eax,0xc(%edi)
        pcb->next = tcp_active_pcbs;
  80d709:	8b 45 d0             	mov    -0x30(%ebp),%eax
  80d70c:	89 43 0c             	mov    %eax,0xc(%ebx)
        tcp_active_pcbs = pcb;
  80d70f:	89 1d 3c b2 b3 00    	mov    %ebx,0xb3b23c
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
  80d715:	39 c3                	cmp    %eax,%ebx
  80d717:	74 87                	je     80d6a0 <tcp_input+0x279>
    inseg.next = NULL;
  80d719:	c7 05 b4 b1 b3 00 00 	movl   $0x0,0xb3b1b4
  80d720:	00 00 00 
    inseg.len = p->tot_len;
  80d723:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80d727:	66 a3 c0 b1 b3 00    	mov    %ax,0xb3b1c0
    inseg.dataptr = p->payload;
  80d72d:	8b 46 04             	mov    0x4(%esi),%eax
  80d730:	a3 bc b1 b3 00       	mov    %eax,0xb3b1bc
    inseg.p = p;
  80d735:	89 35 b8 b1 b3 00    	mov    %esi,0xb3b1b8
    inseg.tcphdr = tcphdr;
  80d73b:	89 15 c4 b1 b3 00    	mov    %edx,0xb3b1c4
    recv_data = NULL;
  80d741:	c7 05 98 b1 b3 00 00 	movl   $0x0,0xb3b198
  80d748:	00 00 00 
    recv_flags = 0;
  80d74b:	c6 05 9c b1 b3 00 00 	movb   $0x0,0xb3b19c
    if (pcb->refused_data != NULL) {
  80d752:	8b 83 80 00 00 00    	mov    0x80(%ebx),%eax
  80d758:	85 c0                	test   %eax,%eax
  80d75a:	74 2c                	je     80d788 <tcp_input+0x361>
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  80d75c:	8b 93 88 00 00 00    	mov    0x88(%ebx),%edx
  80d762:	85 d2                	test   %edx,%edx
  80d764:	0f 84 dd 02 00 00    	je     80da47 <tcp_input+0x620>
  80d76a:	6a 00                	push   $0x0
  80d76c:	50                   	push   %eax
  80d76d:	53                   	push   %ebx
  80d76e:	ff 73 18             	pushl  0x18(%ebx)
  80d771:	ff d2                	call   *%edx
      if (err == ERR_OK) {
  80d773:	83 c4 10             	add    $0x10,%esp
  80d776:	84 c0                	test   %al,%al
  80d778:	0f 85 da 02 00 00    	jne    80da58 <tcp_input+0x631>
        pcb->refused_data = NULL;
  80d77e:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  80d785:	00 00 00 
    tcp_input_pcb = pcb;
  80d788:	89 1d 58 b2 b3 00    	mov    %ebx,0xb3b258
  if (flags & TCP_RST) {
  80d78e:	0f b6 05 a0 b1 b3 00 	movzbl 0xb3b1a0,%eax
  80d795:	a8 04                	test   $0x4,%al
  80d797:	0f 84 f6 02 00 00    	je     80da93 <tcp_input+0x66c>
    if (pcb->state == SYN_SENT) {
  80d79d:	8b 53 10             	mov    0x10(%ebx),%edx
  80d7a0:	83 fa 02             	cmp    $0x2,%edx
  80d7a3:	0f 84 c0 02 00 00    	je     80da69 <tcp_input+0x642>
      if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
  80d7a9:	a1 a8 b1 b3 00       	mov    0xb3b1a8,%eax
  80d7ae:	2b 43 24             	sub    0x24(%ebx),%eax
  80d7b1:	78 1d                	js     80d7d0 <tcp_input+0x3a9>
  80d7b3:	0f b7 4b 28          	movzwl 0x28(%ebx),%ecx
  80d7b7:	29 c8                	sub    %ecx,%eax
  80d7b9:	85 c0                	test   %eax,%eax
  80d7bb:	7f 13                	jg     80d7d0 <tcp_input+0x3a9>
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
  80d7bd:	85 d2                	test   %edx,%edx
  80d7bf:	0f 84 b7 02 00 00    	je     80da7c <tcp_input+0x655>
      recv_flags = TF_RESET;
  80d7c5:	c6 05 9c b1 b3 00 08 	movb   $0x8,0xb3b19c
      pcb->flags &= ~TF_ACK_DELAY;
  80d7cc:	80 63 20 fe          	andb   $0xfe,0x20(%ebx)
    tcp_input_pcb = NULL;
  80d7d0:	c7 05 58 b2 b3 00 00 	movl   $0x0,0xb3b258
  80d7d7:	00 00 00 
      if (recv_flags & TF_RESET) {
  80d7da:	0f b6 05 9c b1 b3 00 	movzbl 0xb3b19c,%eax
  80d7e1:	a8 08                	test   $0x8,%al
  80d7e3:	0f 84 df 07 00 00    	je     80dfc8 <tcp_input+0xba1>
        TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_RST);
  80d7e9:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
  80d7ef:	85 c0                	test   %eax,%eax
  80d7f1:	74 0d                	je     80d800 <tcp_input+0x3d9>
  80d7f3:	83 ec 08             	sub    $0x8,%esp
  80d7f6:	6a fa                	push   $0xfffffffa
  80d7f8:	ff 73 18             	pushl  0x18(%ebx)
  80d7fb:	ff d0                	call   *%eax
  80d7fd:	83 c4 10             	add    $0x10,%esp
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
  80d800:	83 ec 08             	sub    $0x8,%esp
  80d803:	53                   	push   %ebx
  80d804:	68 3c b2 b3 00       	push   $0xb3b23c
  80d809:	e8 2b 83 ff ff       	call   805b39 <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
  80d80e:	83 c4 08             	add    $0x8,%esp
  80d811:	53                   	push   %ebx
  80d812:	6a 02                	push   $0x2
  80d814:	e8 85 6e ff ff       	call   80469e <memp_free>
  80d819:	83 c4 10             	add    $0x10,%esp
    if (inseg.p != NULL)
  80d81c:	a1 b8 b1 b3 00       	mov    0xb3b1b8,%eax
  80d821:	85 c0                	test   %eax,%eax
  80d823:	0f 84 6d fc ff ff    	je     80d496 <tcp_input+0x6f>
      pbuf_free(inseg.p);
  80d829:	83 ec 0c             	sub    $0xc,%esp
  80d82c:	50                   	push   %eax
  80d82d:	e8 ef 71 ff ff       	call   804a21 <pbuf_free>
      inseg.p = NULL;
  80d832:	c7 05 b8 b1 b3 00 00 	movl   $0x0,0xb3b1b8
  80d839:	00 00 00 
  80d83c:	83 c4 10             	add    $0x10,%esp
  80d83f:	e9 52 fc ff ff       	jmp    80d496 <tcp_input+0x6f>
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  80d844:	83 ec 04             	sub    $0x4,%esp
  80d847:	68 a4 36 81 00       	push   $0x8136a4
  80d84c:	68 d0 00 00 00       	push   $0xd0
  80d851:	68 f4 36 81 00       	push   $0x8136f4
  80d856:	e8 ec 10 00 00       	call   80e947 <_panic>
    tcp_ack_now(pcb);
  80d85b:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80d85f:	83 ec 0c             	sub    $0xc,%esp
  80d862:	53                   	push   %ebx
  80d863:	e8 77 aa ff ff       	call   8082df <tcp_output>
  80d868:	83 c4 10             	add    $0x10,%esp
  80d86b:	eb 4c                	jmp    80d8b9 <tcp_input+0x492>
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  80d86d:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  80d870:	85 db                	test   %ebx,%ebx
  80d872:	74 5e                	je     80d8d2 <tcp_input+0x4ab>
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  80d874:	83 7b 10 0a          	cmpl   $0xa,0x10(%ebx)
  80d878:	75 ca                	jne    80d844 <tcp_input+0x41d>
      if (pcb->remote_port == tcphdr->src &&
  80d87a:	0f b7 02             	movzwl (%edx),%eax
  80d87d:	66 39 43 1e          	cmp    %ax,0x1e(%ebx)
  80d881:	75 ea                	jne    80d86d <tcp_input+0x446>
  80d883:	0f b7 42 02          	movzwl 0x2(%edx),%eax
  80d887:	66 39 43 1c          	cmp    %ax,0x1c(%ebx)
  80d88b:	75 e0                	jne    80d86d <tcp_input+0x446>
         pcb->local_port == tcphdr->dest &&
  80d88d:	8b 41 0c             	mov    0xc(%ecx),%eax
  80d890:	39 43 04             	cmp    %eax,0x4(%ebx)
  80d893:	75 d8                	jne    80d86d <tcp_input+0x446>
         ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  80d895:	8b 41 10             	mov    0x10(%ecx),%eax
  80d898:	39 03                	cmp    %eax,(%ebx)
  80d89a:	75 d1                	jne    80d86d <tcp_input+0x446>
  if (TCP_SEQ_GT(seqno + tcplen, pcb->rcv_nxt)) {
  80d89c:	0f b7 45 d4          	movzwl -0x2c(%ebp),%eax
  80d8a0:	03 05 a8 b1 b3 00    	add    0xb3b1a8,%eax
  80d8a6:	89 c2                	mov    %eax,%edx
  80d8a8:	2b 53 24             	sub    0x24(%ebx),%edx
  80d8ab:	85 d2                	test   %edx,%edx
  80d8ad:	7e 03                	jle    80d8b2 <tcp_input+0x48b>
    pcb->rcv_nxt = seqno + tcplen;
  80d8af:	89 43 24             	mov    %eax,0x24(%ebx)
  if (tcplen > 0) {
  80d8b2:	66 83 7d d4 00       	cmpw   $0x0,-0x2c(%ebp)
  80d8b7:	75 a2                	jne    80d85b <tcp_input+0x434>
  return tcp_output(pcb);
  80d8b9:	83 ec 0c             	sub    $0xc,%esp
  80d8bc:	53                   	push   %ebx
  80d8bd:	e8 1d aa ff ff       	call   8082df <tcp_output>
        pbuf_free(p);
  80d8c2:	89 34 24             	mov    %esi,(%esp)
  80d8c5:	e8 57 71 ff ff       	call   804a21 <pbuf_free>
        return;
  80d8ca:	83 c4 10             	add    $0x10,%esp
  80d8cd:	e9 c4 fb ff ff       	jmp    80d496 <tcp_input+0x6f>
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  80d8d2:	a1 44 b2 b3 00       	mov    0xb3b244,%eax
  80d8d7:	89 45 d0             	mov    %eax,-0x30(%ebp)
  80d8da:	89 c7                	mov    %eax,%edi
  80d8dc:	eb 0f                	jmp    80d8ed <tcp_input+0x4c6>
        ip_addr_cmp(&(lpcb->local_ip), &(iphdr->dest))) &&
  80d8de:	0f b7 42 02          	movzwl 0x2(%edx),%eax
  80d8e2:	66 39 47 1c          	cmp    %ax,0x1c(%edi)
  80d8e6:	74 1a                	je     80d902 <tcp_input+0x4db>
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  80d8e8:	89 fb                	mov    %edi,%ebx
  80d8ea:	8b 7f 0c             	mov    0xc(%edi),%edi
  80d8ed:	85 ff                	test   %edi,%edi
  80d8ef:	0f 84 05 08 00 00    	je     80e0fa <tcp_input+0xcd3>
      if ((ip_addr_isany(&(lpcb->local_ip)) ||
  80d8f5:	8b 07                	mov    (%edi),%eax
  80d8f7:	85 c0                	test   %eax,%eax
  80d8f9:	74 e3                	je     80d8de <tcp_input+0x4b7>
  80d8fb:	3b 41 10             	cmp    0x10(%ecx),%eax
  80d8fe:	75 e8                	jne    80d8e8 <tcp_input+0x4c1>
  80d900:	eb dc                	jmp    80d8de <tcp_input+0x4b7>
        if (prev != NULL) {
  80d902:	85 db                	test   %ebx,%ebx
  80d904:	74 12                	je     80d918 <tcp_input+0x4f1>
          ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
  80d906:	8b 47 0c             	mov    0xc(%edi),%eax
  80d909:	89 43 0c             	mov    %eax,0xc(%ebx)
          lpcb->next = tcp_listen_pcbs.listen_pcbs;
  80d90c:	8b 45 d0             	mov    -0x30(%ebp),%eax
  80d90f:	89 47 0c             	mov    %eax,0xc(%edi)
          tcp_listen_pcbs.listen_pcbs = lpcb;
  80d912:	89 3d 44 b2 b3 00    	mov    %edi,0xb3b244
  if (flags & TCP_ACK) {
  80d918:	f6 45 d6 10          	testb  $0x10,-0x2a(%ebp)
  80d91c:	75 17                	jne    80d935 <tcp_input+0x50e>
  } else if (flags & TCP_SYN) {
  80d91e:	f6 45 d6 02          	testb  $0x2,-0x2a(%ebp)
  80d922:	75 43                	jne    80d967 <tcp_input+0x540>
        pbuf_free(p);
  80d924:	83 ec 0c             	sub    $0xc,%esp
  80d927:	56                   	push   %esi
  80d928:	e8 f4 70 ff ff       	call   804a21 <pbuf_free>
        return;
  80d92d:	83 c4 10             	add    $0x10,%esp
  80d930:	e9 61 fb ff ff       	jmp    80d496 <tcp_input+0x6f>
    tcp_rst(ackno + 1, seqno + tcplen,
  80d935:	83 ec 08             	sub    $0x8,%esp
  80d938:	0f b7 02             	movzwl (%edx),%eax
  80d93b:	50                   	push   %eax
  80d93c:	0f b7 42 02          	movzwl 0x2(%edx),%eax
  80d940:	50                   	push   %eax
  80d941:	8d 41 0c             	lea    0xc(%ecx),%eax
  80d944:	50                   	push   %eax
  80d945:	83 c1 10             	add    $0x10,%ecx
  80d948:	51                   	push   %ecx
  80d949:	0f b7 45 d4          	movzwl -0x2c(%ebp),%eax
  80d94d:	03 05 a8 b1 b3 00    	add    0xb3b1a8,%eax
  80d953:	50                   	push   %eax
  80d954:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80d959:	83 c0 01             	add    $0x1,%eax
  80d95c:	50                   	push   %eax
  80d95d:	e8 23 ae ff ff       	call   808785 <tcp_rst>
  80d962:	83 c4 20             	add    $0x20,%esp
  80d965:	eb bd                	jmp    80d924 <tcp_input+0x4fd>
    npcb = tcp_alloc(pcb->prio);
  80d967:	83 ec 0c             	sub    $0xc,%esp
  80d96a:	0f b6 47 14          	movzbl 0x14(%edi),%eax
  80d96e:	50                   	push   %eax
  80d96f:	e8 07 8a ff ff       	call   80637b <tcp_alloc>
  80d974:	89 c3                	mov    %eax,%ebx
    if (npcb == NULL) {
  80d976:	83 c4 10             	add    $0x10,%esp
  80d979:	85 c0                	test   %eax,%eax
  80d97b:	74 a7                	je     80d924 <tcp_input+0x4fd>
    ip_addr_set(&(npcb->local_ip), &(iphdr->dest));
  80d97d:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
  80d982:	8b 50 10             	mov    0x10(%eax),%edx
  80d985:	89 13                	mov    %edx,(%ebx)
    npcb->local_port = pcb->local_port;
  80d987:	0f b7 57 1c          	movzwl 0x1c(%edi),%edx
  80d98b:	66 89 53 1c          	mov    %dx,0x1c(%ebx)
    ip_addr_set(&(npcb->remote_ip), &(iphdr->src));
  80d98f:	8b 40 0c             	mov    0xc(%eax),%eax
  80d992:	89 43 04             	mov    %eax,0x4(%ebx)
    npcb->remote_port = tcphdr->src;
  80d995:	8b 15 b0 b1 b3 00    	mov    0xb3b1b0,%edx
  80d99b:	0f b7 02             	movzwl (%edx),%eax
  80d99e:	66 89 43 1e          	mov    %ax,0x1e(%ebx)
    npcb->state = SYN_RCVD;
  80d9a2:	c7 43 10 03 00 00 00 	movl   $0x3,0x10(%ebx)
    npcb->rcv_nxt = seqno + 1;
  80d9a9:	a1 a8 b1 b3 00       	mov    0xb3b1a8,%eax
  80d9ae:	8d 48 01             	lea    0x1(%eax),%ecx
  80d9b1:	89 4b 24             	mov    %ecx,0x24(%ebx)
    npcb->snd_wnd = tcphdr->wnd;
  80d9b4:	0f b7 52 0e          	movzwl 0xe(%edx),%edx
  80d9b8:	66 89 53 5c          	mov    %dx,0x5c(%ebx)
    npcb->ssthresh = npcb->snd_wnd;
  80d9bc:	66 89 53 50          	mov    %dx,0x50(%ebx)
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
  80d9c0:	83 e8 01             	sub    $0x1,%eax
  80d9c3:	89 43 60             	mov    %eax,0x60(%ebx)
    npcb->callback_arg = pcb->callback_arg;
  80d9c6:	8b 47 18             	mov    0x18(%edi),%eax
  80d9c9:	89 43 18             	mov    %eax,0x18(%ebx)
    npcb->accept = pcb->accept;
  80d9cc:	8b 47 20             	mov    0x20(%edi),%eax
  80d9cf:	89 83 90 00 00 00    	mov    %eax,0x90(%ebx)
    npcb->so_options = pcb->so_options & (SOF_DEBUG|SOF_DONTROUTE|SOF_KEEPALIVE|SOF_OOBINLINE|SOF_LINGER);
  80d9d5:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80d9d9:	66 25 99 01          	and    $0x199,%ax
  80d9dd:	66 89 43 08          	mov    %ax,0x8(%ebx)
    TCP_REG(&tcp_active_pcbs, npcb);
  80d9e1:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
  80d9e6:	89 43 0c             	mov    %eax,0xc(%ebx)
  80d9e9:	89 1d 3c b2 b3 00    	mov    %ebx,0xb3b23c
  80d9ef:	e8 58 49 ff ff       	call   80234c <tcp_timer_needed>
    tcp_parseopt(npcb);
  80d9f4:	89 d8                	mov    %ebx,%eax
  80d9f6:	e8 96 ec ff ff       	call   80c691 <tcp_parseopt>
    npcb->mss = tcp_eff_send_mss(npcb->mss, &(npcb->remote_ip));
  80d9fb:	83 ec 08             	sub    $0x8,%esp
  80d9fe:	8d 43 04             	lea    0x4(%ebx),%eax
  80da01:	50                   	push   %eax
  80da02:	0f b7 43 34          	movzwl 0x34(%ebx),%eax
  80da06:	50                   	push   %eax
  80da07:	e8 15 8b ff ff       	call   806521 <tcp_eff_send_mss>
  80da0c:	66 89 43 34          	mov    %ax,0x34(%ebx)
    optdata = TCP_BUILD_MSS_OPTION();
  80da10:	c7 04 24 b4 05 04 02 	movl   $0x20405b4,(%esp)
  80da17:	e8 5f 9f ff ff       	call   80797b <htonl>
  80da1c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    tcp_enqueue(npcb, NULL, 0, TCP_SYN | TCP_ACK, 0, (u8_t *)&optdata, 4);
  80da1f:	83 c4 0c             	add    $0xc,%esp
  80da22:	6a 04                	push   $0x4
  80da24:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80da27:	50                   	push   %eax
  80da28:	6a 00                	push   $0x0
  80da2a:	6a 12                	push   $0x12
  80da2c:	6a 00                	push   $0x0
  80da2e:	6a 00                	push   $0x0
  80da30:	53                   	push   %ebx
  80da31:	e8 89 a1 ff ff       	call   807bbf <tcp_enqueue>
    return tcp_output(npcb);
  80da36:	83 c4 14             	add    $0x14,%esp
  80da39:	53                   	push   %ebx
  80da3a:	e8 a0 a8 ff ff       	call   8082df <tcp_output>
  80da3f:	83 c4 10             	add    $0x10,%esp
  80da42:	e9 dd fe ff ff       	jmp    80d924 <tcp_input+0x4fd>
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  80da47:	83 ec 0c             	sub    $0xc,%esp
  80da4a:	50                   	push   %eax
  80da4b:	e8 d1 6f ff ff       	call   804a21 <pbuf_free>
  80da50:	83 c4 10             	add    $0x10,%esp
  80da53:	e9 26 fd ff ff       	jmp    80d77e <tcp_input+0x357>
        pbuf_free(p);
  80da58:	83 ec 0c             	sub    $0xc,%esp
  80da5b:	56                   	push   %esi
  80da5c:	e8 c0 6f ff ff       	call   804a21 <pbuf_free>
        return;
  80da61:	83 c4 10             	add    $0x10,%esp
  80da64:	e9 2d fa ff ff       	jmp    80d496 <tcp_input+0x6f>
      if (ackno == pcb->snd_nxt) {
  80da69:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80da6e:	39 43 54             	cmp    %eax,0x54(%ebx)
  80da71:	0f 84 4e fd ff ff    	je     80d7c5 <tcp_input+0x39e>
  80da77:	e9 54 fd ff ff       	jmp    80d7d0 <tcp_input+0x3a9>
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
  80da7c:	83 ec 04             	sub    $0x4,%esp
  80da7f:	68 d4 36 81 00       	push   $0x8136d4
  80da84:	68 09 02 00 00       	push   $0x209
  80da89:	68 f4 36 81 00       	push   $0x8136f4
  80da8e:	e8 b4 0e 00 00       	call   80e947 <_panic>
  pcb->tmr = tcp_ticks;
  80da93:	8b 15 40 b2 b3 00    	mov    0xb3b240,%edx
  80da99:	89 53 2c             	mov    %edx,0x2c(%ebx)
  pcb->keep_cnt_sent = 0;
  80da9c:	c6 83 a5 00 00 00 00 	movb   $0x0,0xa5(%ebx)
  80daa3:	83 7b 10 09          	cmpl   $0x9,0x10(%ebx)
  80daa7:	0f 87 0c 05 00 00    	ja     80dfb9 <tcp_input+0xb92>
  80daad:	8b 53 10             	mov    0x10(%ebx),%edx
  80dab0:	3e ff 24 95 78 37 81 	notrack jmp *0x813778(,%edx,4)
  80dab7:	00 
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
  80dab8:	83 e0 12             	and    $0x12,%eax
  80dabb:	3c 12                	cmp    $0x12,%al
  80dabd:	74 4d                	je     80db0c <tcp_input+0x6e5>
    else if (flags & TCP_ACK) {
  80dabf:	f6 05 a0 b1 b3 00 10 	testb  $0x10,0xb3b1a0
  80dac6:	0f 84 04 fd ff ff    	je     80d7d0 <tcp_input+0x3a9>
        tcphdr->dest, tcphdr->src);
  80dacc:	8b 15 b0 b1 b3 00    	mov    0xb3b1b0,%edx
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
  80dad2:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
  80dad7:	83 ec 08             	sub    $0x8,%esp
  80dada:	0f b7 0a             	movzwl (%edx),%ecx
  80dadd:	51                   	push   %ecx
  80dade:	0f b7 52 02          	movzwl 0x2(%edx),%edx
  80dae2:	52                   	push   %edx
  80dae3:	8d 50 0c             	lea    0xc(%eax),%edx
  80dae6:	52                   	push   %edx
  80dae7:	83 c0 10             	add    $0x10,%eax
  80daea:	50                   	push   %eax
  80daeb:	0f b7 05 9e b1 b3 00 	movzwl 0xb3b19e,%eax
  80daf2:	03 05 a8 b1 b3 00    	add    0xb3b1a8,%eax
  80daf8:	50                   	push   %eax
  80daf9:	ff 35 a4 b1 b3 00    	pushl  0xb3b1a4
  80daff:	e8 81 ac ff ff       	call   808785 <tcp_rst>
  80db04:	83 c4 20             	add    $0x20,%esp
  80db07:	e9 c4 fc ff ff       	jmp    80d7d0 <tcp_input+0x3a9>
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
  80db0c:	83 ec 0c             	sub    $0xc,%esp
  80db0f:	8b 43 78             	mov    0x78(%ebx),%eax
  80db12:	8b 40 10             	mov    0x10(%eax),%eax
  80db15:	ff 70 04             	pushl  0x4(%eax)
  80db18:	e8 8b a0 ff ff       	call   807ba8 <ntohl>
  80db1d:	8b 15 a4 b1 b3 00    	mov    0xb3b1a4,%edx
  80db23:	83 c0 01             	add    $0x1,%eax
  80db26:	83 c4 10             	add    $0x10,%esp
  80db29:	39 d0                	cmp    %edx,%eax
  80db2b:	75 92                	jne    80dabf <tcp_input+0x698>
      pcb->snd_buf++;
  80db2d:	66 83 43 6e 01       	addw   $0x1,0x6e(%ebx)
      pcb->rcv_nxt = seqno + 1;
  80db32:	a1 a8 b1 b3 00       	mov    0xb3b1a8,%eax
  80db37:	8d 48 01             	lea    0x1(%eax),%ecx
  80db3a:	89 4b 24             	mov    %ecx,0x24(%ebx)
      pcb->lastack = ackno;
  80db3d:	89 53 48             	mov    %edx,0x48(%ebx)
      pcb->snd_wnd = tcphdr->wnd;
  80db40:	8b 15 b0 b1 b3 00    	mov    0xb3b1b0,%edx
  80db46:	0f b7 52 0e          	movzwl 0xe(%edx),%edx
  80db4a:	66 89 53 5c          	mov    %dx,0x5c(%ebx)
      pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
  80db4e:	83 e8 01             	sub    $0x1,%eax
  80db51:	89 43 60             	mov    %eax,0x60(%ebx)
      pcb->state = ESTABLISHED;
  80db54:	c7 43 10 04 00 00 00 	movl   $0x4,0x10(%ebx)
      tcp_parseopt(pcb);
  80db5b:	89 d8                	mov    %ebx,%eax
  80db5d:	e8 2f eb ff ff       	call   80c691 <tcp_parseopt>
      pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->remote_ip));
  80db62:	83 ec 08             	sub    $0x8,%esp
  80db65:	8d 43 04             	lea    0x4(%ebx),%eax
  80db68:	50                   	push   %eax
  80db69:	0f b7 43 34          	movzwl 0x34(%ebx),%eax
  80db6d:	50                   	push   %eax
  80db6e:	e8 ae 89 ff ff       	call   806521 <tcp_eff_send_mss>
  80db73:	66 89 43 34          	mov    %ax,0x34(%ebx)
      pcb->ssthresh = pcb->mss * 10;
  80db77:	6b d0 0a             	imul   $0xa,%eax,%edx
  80db7a:	66 89 53 50          	mov    %dx,0x50(%ebx)
      pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  80db7e:	83 c4 10             	add    $0x10,%esp
  80db81:	66 83 7b 4e 01       	cmpw   $0x1,0x4e(%ebx)
  80db86:	74 63                	je     80dbeb <tcp_input+0x7c4>
  80db88:	66 89 43 4e          	mov    %ax,0x4e(%ebx)
      LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
  80db8c:	0f b7 43 70          	movzwl 0x70(%ebx),%eax
  80db90:	66 85 c0             	test   %ax,%ax
  80db93:	74 5a                	je     80dbef <tcp_input+0x7c8>
      --pcb->snd_queuelen;
  80db95:	83 e8 01             	sub    $0x1,%eax
  80db98:	66 89 43 70          	mov    %ax,0x70(%ebx)
      rseg = pcb->unacked;
  80db9c:	8b 43 78             	mov    0x78(%ebx),%eax
      pcb->unacked = rseg->next;
  80db9f:	8b 10                	mov    (%eax),%edx
  80dba1:	89 53 78             	mov    %edx,0x78(%ebx)
      if(pcb->unacked == NULL)
  80dba4:	85 d2                	test   %edx,%edx
  80dba6:	74 5e                	je     80dc06 <tcp_input+0x7df>
        pcb->rtime = 0;
  80dba8:	66 c7 43 32 00 00    	movw   $0x0,0x32(%ebx)
        pcb->nrtx = 0;
  80dbae:	c6 43 46 00          	movb   $0x0,0x46(%ebx)
      tcp_seg_free(rseg);
  80dbb2:	83 ec 0c             	sub    $0xc,%esp
  80dbb5:	50                   	push   %eax
  80dbb6:	e8 bc 7d ff ff       	call   805977 <tcp_seg_free>
      TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
  80dbbb:	8b 83 8c 00 00 00    	mov    0x8c(%ebx),%eax
  80dbc1:	83 c4 10             	add    $0x10,%esp
  80dbc4:	85 c0                	test   %eax,%eax
  80dbc6:	74 0e                	je     80dbd6 <tcp_input+0x7af>
  80dbc8:	83 ec 04             	sub    $0x4,%esp
  80dbcb:	6a 00                	push   $0x0
  80dbcd:	53                   	push   %ebx
  80dbce:	ff 73 18             	pushl  0x18(%ebx)
  80dbd1:	ff d0                	call   *%eax
  80dbd3:	83 c4 10             	add    $0x10,%esp
      tcp_ack_now(pcb);
  80dbd6:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80dbda:	83 ec 0c             	sub    $0xc,%esp
  80dbdd:	53                   	push   %ebx
  80dbde:	e8 fc a6 ff ff       	call   8082df <tcp_output>
  80dbe3:	83 c4 10             	add    $0x10,%esp
  80dbe6:	e9 e5 fb ff ff       	jmp    80d7d0 <tcp_input+0x3a9>
      pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  80dbeb:	01 c0                	add    %eax,%eax
  80dbed:	eb 99                	jmp    80db88 <tcp_input+0x761>
      LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
  80dbef:	83 ec 04             	sub    $0x4,%esp
  80dbf2:	68 4d 37 81 00       	push   $0x81374d
  80dbf7:	68 35 02 00 00       	push   $0x235
  80dbfc:	68 f4 36 81 00       	push   $0x8136f4
  80dc01:	e8 41 0d 00 00       	call   80e947 <_panic>
        pcb->rtime = -1;
  80dc06:	66 c7 43 32 ff ff    	movw   $0xffff,0x32(%ebx)
  80dc0c:	eb a4                	jmp    80dbb2 <tcp_input+0x78b>
    if (flags & TCP_ACK &&
  80dc0e:	83 e0 14             	and    $0x14,%eax
  80dc11:	3c 10                	cmp    $0x10,%al
  80dc13:	0f 85 b7 fb ff ff    	jne    80d7d0 <tcp_input+0x3a9>
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
  80dc19:	8b 15 a4 b1 b3 00    	mov    0xb3b1a4,%edx
  80dc1f:	8d 42 ff             	lea    -0x1(%edx),%eax
  80dc22:	3b 43 48             	cmp    0x48(%ebx),%eax
  80dc25:	78 09                	js     80dc30 <tcp_input+0x809>
  80dc27:	89 d0                	mov    %edx,%eax
  80dc29:	2b 43 54             	sub    0x54(%ebx),%eax
  80dc2c:	85 c0                	test   %eax,%eax
  80dc2e:	7e 3b                	jle    80dc6b <tcp_input+0x844>
                tcphdr->dest, tcphdr->src);
  80dc30:	8b 0d b0 b1 b3 00    	mov    0xb3b1b0,%ecx
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
  80dc36:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
  80dc3b:	83 ec 08             	sub    $0x8,%esp
  80dc3e:	0f b7 31             	movzwl (%ecx),%esi
  80dc41:	56                   	push   %esi
  80dc42:	0f b7 49 02          	movzwl 0x2(%ecx),%ecx
  80dc46:	51                   	push   %ecx
  80dc47:	8d 48 0c             	lea    0xc(%eax),%ecx
  80dc4a:	51                   	push   %ecx
  80dc4b:	83 c0 10             	add    $0x10,%eax
  80dc4e:	50                   	push   %eax
  80dc4f:	0f b7 05 9e b1 b3 00 	movzwl 0xb3b19e,%eax
  80dc56:	03 05 a8 b1 b3 00    	add    0xb3b1a8,%eax
  80dc5c:	50                   	push   %eax
  80dc5d:	52                   	push   %edx
  80dc5e:	e8 22 ab ff ff       	call   808785 <tcp_rst>
  80dc63:	83 c4 20             	add    $0x20,%esp
  80dc66:	e9 65 fb ff ff       	jmp    80d7d0 <tcp_input+0x3a9>
        pcb->state = ESTABLISHED;
  80dc6b:	c7 43 10 04 00 00 00 	movl   $0x4,0x10(%ebx)
        LWIP_ASSERT("pcb->accept != NULL", pcb->accept != NULL);
  80dc72:	8b 83 90 00 00 00    	mov    0x90(%ebx),%eax
  80dc78:	85 c0                	test   %eax,%eax
  80dc7a:	74 5e                	je     80dcda <tcp_input+0x8b3>
        TCP_EVENT_ACCEPT(pcb, ERR_OK, err);
  80dc7c:	83 ec 04             	sub    $0x4,%esp
  80dc7f:	6a 00                	push   $0x0
  80dc81:	53                   	push   %ebx
  80dc82:	ff 73 18             	pushl  0x18(%ebx)
  80dc85:	ff d0                	call   *%eax
        if (err != ERR_OK) {
  80dc87:	83 c4 10             	add    $0x10,%esp
  80dc8a:	84 c0                	test   %al,%al
  80dc8c:	75 63                	jne    80dcf1 <tcp_input+0x8ca>
        old_cwnd = pcb->cwnd;
  80dc8e:	0f b7 73 4e          	movzwl 0x4e(%ebx),%esi
        accepted_inseq = tcp_receive(pcb);
  80dc92:	89 d8                	mov    %ebx,%eax
  80dc94:	e8 ac ea ff ff       	call   80c745 <tcp_receive>
  80dc99:	89 c2                	mov    %eax,%edx
        pcb->cwnd = ((old_cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  80dc9b:	66 83 fe 01          	cmp    $0x1,%si
  80dc9f:	74 6b                	je     80dd0c <tcp_input+0x8e5>
  80dca1:	0f b7 43 34          	movzwl 0x34(%ebx),%eax
  80dca5:	66 89 43 4e          	mov    %ax,0x4e(%ebx)
        if ((flags & TCP_FIN) && accepted_inseq) {
  80dca9:	f6 05 a0 b1 b3 00 01 	testb  $0x1,0xb3b1a0
  80dcb0:	0f 84 1a fb ff ff    	je     80d7d0 <tcp_input+0x3a9>
  80dcb6:	84 d2                	test   %dl,%dl
  80dcb8:	0f 84 12 fb ff ff    	je     80d7d0 <tcp_input+0x3a9>
          tcp_ack_now(pcb);
  80dcbe:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80dcc2:	83 ec 0c             	sub    $0xc,%esp
  80dcc5:	53                   	push   %ebx
  80dcc6:	e8 14 a6 ff ff       	call   8082df <tcp_output>
          pcb->state = CLOSE_WAIT;
  80dccb:	c7 43 10 07 00 00 00 	movl   $0x7,0x10(%ebx)
  80dcd2:	83 c4 10             	add    $0x10,%esp
  80dcd5:	e9 f6 fa ff ff       	jmp    80d7d0 <tcp_input+0x3a9>
        LWIP_ASSERT("pcb->accept != NULL", pcb->accept != NULL);
  80dcda:	83 ec 04             	sub    $0x4,%esp
  80dcdd:	68 63 37 81 00       	push   $0x813763
  80dce2:	68 5b 02 00 00       	push   $0x25b
  80dce7:	68 f4 36 81 00       	push   $0x8136f4
  80dcec:	e8 56 0c 00 00       	call   80e947 <_panic>
          tcp_abort(pcb);
  80dcf1:	83 ec 0c             	sub    $0xc,%esp
  80dcf4:	53                   	push   %ebx
  80dcf5:	e8 df 80 ff ff       	call   805dd9 <tcp_abort>
    tcp_input_pcb = NULL;
  80dcfa:	c7 05 58 b2 b3 00 00 	movl   $0x0,0xb3b258
  80dd01:	00 00 00 
  80dd04:	83 c4 10             	add    $0x10,%esp
  80dd07:	e9 10 fb ff ff       	jmp    80d81c <tcp_input+0x3f5>
        pcb->cwnd = ((old_cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  80dd0c:	0f b7 43 34          	movzwl 0x34(%ebx),%eax
  80dd10:	01 c0                	add    %eax,%eax
  80dd12:	eb 91                	jmp    80dca5 <tcp_input+0x87e>
    accepted_inseq = tcp_receive(pcb);
  80dd14:	89 d8                	mov    %ebx,%eax
  80dd16:	e8 2a ea ff ff       	call   80c745 <tcp_receive>
    if ((flags & TCP_FIN) && accepted_inseq) { /* passive close */
  80dd1b:	f6 05 a0 b1 b3 00 01 	testb  $0x1,0xb3b1a0
  80dd22:	0f 84 a8 fa ff ff    	je     80d7d0 <tcp_input+0x3a9>
  80dd28:	84 c0                	test   %al,%al
  80dd2a:	0f 84 a0 fa ff ff    	je     80d7d0 <tcp_input+0x3a9>
      tcp_ack_now(pcb);
  80dd30:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80dd34:	83 ec 0c             	sub    $0xc,%esp
  80dd37:	53                   	push   %ebx
  80dd38:	e8 a2 a5 ff ff       	call   8082df <tcp_output>
      pcb->state = CLOSE_WAIT;
  80dd3d:	c7 43 10 07 00 00 00 	movl   $0x7,0x10(%ebx)
  80dd44:	83 c4 10             	add    $0x10,%esp
  80dd47:	e9 84 fa ff ff       	jmp    80d7d0 <tcp_input+0x3a9>
    tcp_receive(pcb);
  80dd4c:	89 d8                	mov    %ebx,%eax
  80dd4e:	e8 f2 e9 ff ff       	call   80c745 <tcp_receive>
    if (flags & TCP_FIN) {
  80dd53:	0f b6 05 a0 b1 b3 00 	movzbl 0xb3b1a0,%eax
  80dd5a:	a8 01                	test   $0x1,%al
  80dd5c:	0f 84 b7 00 00 00    	je     80de19 <tcp_input+0x9f2>
      if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  80dd62:	a8 10                	test   $0x10,%al
  80dd64:	74 0a                	je     80dd70 <tcp_input+0x949>
  80dd66:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80dd6b:	39 43 54             	cmp    %eax,0x54(%ebx)
  80dd6e:	74 1c                	je     80dd8c <tcp_input+0x965>
        tcp_ack_now(pcb);
  80dd70:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80dd74:	83 ec 0c             	sub    $0xc,%esp
  80dd77:	53                   	push   %ebx
  80dd78:	e8 62 a5 ff ff       	call   8082df <tcp_output>
        pcb->state = CLOSING;
  80dd7d:	c7 43 10 08 00 00 00 	movl   $0x8,0x10(%ebx)
  80dd84:	83 c4 10             	add    $0x10,%esp
  80dd87:	e9 44 fa ff ff       	jmp    80d7d0 <tcp_input+0x3a9>
        tcp_ack_now(pcb);
  80dd8c:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80dd90:	83 ec 0c             	sub    $0xc,%esp
  80dd93:	53                   	push   %ebx
  80dd94:	e8 46 a5 ff ff       	call   8082df <tcp_output>
        tcp_pcb_purge(pcb);
  80dd99:	89 1c 24             	mov    %ebx,(%esp)
  80dd9c:	e8 17 7d ff ff       	call   805ab8 <tcp_pcb_purge>
        TCP_RMV(&tcp_active_pcbs, pcb);
  80dda1:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
  80dda6:	83 c4 10             	add    $0x10,%esp
  80dda9:	39 c3                	cmp    %eax,%ebx
  80ddab:	74 11                	je     80ddbe <tcp_input+0x997>
  80ddad:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
  80ddb2:	ba 00 00 00 00       	mov    $0x0,%edx
  80ddb7:	be 01 00 00 00       	mov    $0x1,%esi
  80ddbc:	eb 2b                	jmp    80dde9 <tcp_input+0x9c2>
  80ddbe:	8b 40 0c             	mov    0xc(%eax),%eax
  80ddc1:	a3 3c b2 b3 00       	mov    %eax,0xb3b23c
        pcb->state = TIME_WAIT;
  80ddc6:	c7 43 10 0a 00 00 00 	movl   $0xa,0x10(%ebx)
        TCP_REG(&tcp_tw_pcbs, pcb);
  80ddcd:	a1 50 b2 b3 00       	mov    0xb3b250,%eax
  80ddd2:	89 43 0c             	mov    %eax,0xc(%ebx)
  80ddd5:	89 1d 50 b2 b3 00    	mov    %ebx,0xb3b250
  80dddb:	e8 6c 45 ff ff       	call   80234c <tcp_timer_needed>
  80dde0:	e9 eb f9 ff ff       	jmp    80d7d0 <tcp_input+0x3a9>
  80dde5:	89 f2                	mov    %esi,%edx
        TCP_RMV(&tcp_active_pcbs, pcb);
  80dde7:	89 c8                	mov    %ecx,%eax
  80dde9:	85 c0                	test   %eax,%eax
  80ddeb:	74 1c                	je     80de09 <tcp_input+0x9e2>
  80dded:	8b 48 0c             	mov    0xc(%eax),%ecx
  80ddf0:	39 cb                	cmp    %ecx,%ebx
  80ddf2:	75 f1                	jne    80dde5 <tcp_input+0x9be>
  80ddf4:	85 c9                	test   %ecx,%ecx
  80ddf6:	74 ed                	je     80dde5 <tcp_input+0x9be>
  80ddf8:	84 d2                	test   %dl,%dl
  80ddfa:	74 05                	je     80de01 <tcp_input+0x9da>
  80ddfc:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
  80de01:	8b 53 0c             	mov    0xc(%ebx),%edx
  80de04:	89 50 0c             	mov    %edx,0xc(%eax)
  80de07:	eb bd                	jmp    80ddc6 <tcp_input+0x99f>
  80de09:	84 d2                	test   %dl,%dl
  80de0b:	74 b9                	je     80ddc6 <tcp_input+0x99f>
  80de0d:	c7 05 48 b2 b3 00 00 	movl   $0x0,0xb3b248
  80de14:	00 00 00 
  80de17:	eb ad                	jmp    80ddc6 <tcp_input+0x99f>
    } else if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  80de19:	a8 10                	test   $0x10,%al
  80de1b:	0f 84 af f9 ff ff    	je     80d7d0 <tcp_input+0x3a9>
  80de21:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80de26:	39 43 54             	cmp    %eax,0x54(%ebx)
  80de29:	0f 85 a1 f9 ff ff    	jne    80d7d0 <tcp_input+0x3a9>
      pcb->state = FIN_WAIT_2;
  80de2f:	c7 43 10 06 00 00 00 	movl   $0x6,0x10(%ebx)
  80de36:	e9 95 f9 ff ff       	jmp    80d7d0 <tcp_input+0x3a9>
    tcp_receive(pcb);
  80de3b:	89 d8                	mov    %ebx,%eax
  80de3d:	e8 03 e9 ff ff       	call   80c745 <tcp_receive>
    if (flags & TCP_FIN) {
  80de42:	f6 05 a0 b1 b3 00 01 	testb  $0x1,0xb3b1a0
  80de49:	0f 84 81 f9 ff ff    	je     80d7d0 <tcp_input+0x3a9>
      tcp_ack_now(pcb);
  80de4f:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80de53:	83 ec 0c             	sub    $0xc,%esp
  80de56:	53                   	push   %ebx
  80de57:	e8 83 a4 ff ff       	call   8082df <tcp_output>
      tcp_pcb_purge(pcb);
  80de5c:	89 1c 24             	mov    %ebx,(%esp)
  80de5f:	e8 54 7c ff ff       	call   805ab8 <tcp_pcb_purge>
      TCP_RMV(&tcp_active_pcbs, pcb);
  80de64:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
  80de69:	83 c4 10             	add    $0x10,%esp
  80de6c:	39 c3                	cmp    %eax,%ebx
  80de6e:	74 11                	je     80de81 <tcp_input+0xa5a>
  80de70:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
  80de75:	b9 00 00 00 00       	mov    $0x0,%ecx
  80de7a:	be 01 00 00 00       	mov    $0x1,%esi
  80de7f:	eb 2b                	jmp    80deac <tcp_input+0xa85>
  80de81:	8b 40 0c             	mov    0xc(%eax),%eax
  80de84:	a3 3c b2 b3 00       	mov    %eax,0xb3b23c
      pcb->state = TIME_WAIT;
  80de89:	c7 43 10 0a 00 00 00 	movl   $0xa,0x10(%ebx)
      TCP_REG(&tcp_tw_pcbs, pcb);
  80de90:	a1 50 b2 b3 00       	mov    0xb3b250,%eax
  80de95:	89 43 0c             	mov    %eax,0xc(%ebx)
  80de98:	89 1d 50 b2 b3 00    	mov    %ebx,0xb3b250
  80de9e:	e8 a9 44 ff ff       	call   80234c <tcp_timer_needed>
  80dea3:	e9 28 f9 ff ff       	jmp    80d7d0 <tcp_input+0x3a9>
  80dea8:	89 f1                	mov    %esi,%ecx
      TCP_RMV(&tcp_active_pcbs, pcb);
  80deaa:	89 d0                	mov    %edx,%eax
  80deac:	85 c0                	test   %eax,%eax
  80deae:	74 1c                	je     80decc <tcp_input+0xaa5>
  80deb0:	8b 50 0c             	mov    0xc(%eax),%edx
  80deb3:	39 d3                	cmp    %edx,%ebx
  80deb5:	75 f1                	jne    80dea8 <tcp_input+0xa81>
  80deb7:	85 d2                	test   %edx,%edx
  80deb9:	74 ed                	je     80dea8 <tcp_input+0xa81>
  80debb:	84 c9                	test   %cl,%cl
  80debd:	74 05                	je     80dec4 <tcp_input+0xa9d>
  80debf:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
  80dec4:	8b 53 0c             	mov    0xc(%ebx),%edx
  80dec7:	89 50 0c             	mov    %edx,0xc(%eax)
  80deca:	eb bd                	jmp    80de89 <tcp_input+0xa62>
  80decc:	84 c9                	test   %cl,%cl
  80dece:	74 b9                	je     80de89 <tcp_input+0xa62>
  80ded0:	c7 05 48 b2 b3 00 00 	movl   $0x0,0xb3b248
  80ded7:	00 00 00 
  80deda:	eb ad                	jmp    80de89 <tcp_input+0xa62>
    tcp_receive(pcb);
  80dedc:	89 d8                	mov    %ebx,%eax
  80dede:	e8 62 e8 ff ff       	call   80c745 <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  80dee3:	f6 05 a0 b1 b3 00 10 	testb  $0x10,0xb3b1a0
  80deea:	0f 84 e0 f8 ff ff    	je     80d7d0 <tcp_input+0x3a9>
  80def0:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80def5:	39 43 54             	cmp    %eax,0x54(%ebx)
  80def8:	0f 85 d2 f8 ff ff    	jne    80d7d0 <tcp_input+0x3a9>
      tcp_ack_now(pcb);
  80defe:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80df02:	83 ec 0c             	sub    $0xc,%esp
  80df05:	53                   	push   %ebx
  80df06:	e8 d4 a3 ff ff       	call   8082df <tcp_output>
      tcp_pcb_purge(pcb);
  80df0b:	89 1c 24             	mov    %ebx,(%esp)
  80df0e:	e8 a5 7b ff ff       	call   805ab8 <tcp_pcb_purge>
      TCP_RMV(&tcp_active_pcbs, pcb);
  80df13:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
  80df18:	83 c4 10             	add    $0x10,%esp
  80df1b:	39 c3                	cmp    %eax,%ebx
  80df1d:	74 11                	je     80df30 <tcp_input+0xb09>
  80df1f:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
  80df24:	ba 00 00 00 00       	mov    $0x0,%edx
  80df29:	be 01 00 00 00       	mov    $0x1,%esi
  80df2e:	eb 2b                	jmp    80df5b <tcp_input+0xb34>
  80df30:	8b 40 0c             	mov    0xc(%eax),%eax
  80df33:	a3 3c b2 b3 00       	mov    %eax,0xb3b23c
      pcb->state = TIME_WAIT;
  80df38:	c7 43 10 0a 00 00 00 	movl   $0xa,0x10(%ebx)
      TCP_REG(&tcp_tw_pcbs, pcb);
  80df3f:	a1 50 b2 b3 00       	mov    0xb3b250,%eax
  80df44:	89 43 0c             	mov    %eax,0xc(%ebx)
  80df47:	89 1d 50 b2 b3 00    	mov    %ebx,0xb3b250
  80df4d:	e8 fa 43 ff ff       	call   80234c <tcp_timer_needed>
  80df52:	e9 79 f8 ff ff       	jmp    80d7d0 <tcp_input+0x3a9>
  80df57:	89 f2                	mov    %esi,%edx
      TCP_RMV(&tcp_active_pcbs, pcb);
  80df59:	89 c8                	mov    %ecx,%eax
  80df5b:	85 c0                	test   %eax,%eax
  80df5d:	74 1c                	je     80df7b <tcp_input+0xb54>
  80df5f:	8b 48 0c             	mov    0xc(%eax),%ecx
  80df62:	39 cb                	cmp    %ecx,%ebx
  80df64:	75 f1                	jne    80df57 <tcp_input+0xb30>
  80df66:	85 c9                	test   %ecx,%ecx
  80df68:	74 ed                	je     80df57 <tcp_input+0xb30>
  80df6a:	84 d2                	test   %dl,%dl
  80df6c:	74 05                	je     80df73 <tcp_input+0xb4c>
  80df6e:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
  80df73:	8b 53 0c             	mov    0xc(%ebx),%edx
  80df76:	89 50 0c             	mov    %edx,0xc(%eax)
  80df79:	eb bd                	jmp    80df38 <tcp_input+0xb11>
  80df7b:	84 d2                	test   %dl,%dl
  80df7d:	74 b9                	je     80df38 <tcp_input+0xb11>
  80df7f:	c7 05 48 b2 b3 00 00 	movl   $0x0,0xb3b248
  80df86:	00 00 00 
  80df89:	eb ad                	jmp    80df38 <tcp_input+0xb11>
    tcp_receive(pcb);
  80df8b:	89 d8                	mov    %ebx,%eax
  80df8d:	e8 b3 e7 ff ff       	call   80c745 <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  80df92:	f6 05 a0 b1 b3 00 10 	testb  $0x10,0xb3b1a0
  80df99:	0f 84 31 f8 ff ff    	je     80d7d0 <tcp_input+0x3a9>
  80df9f:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80dfa4:	39 43 54             	cmp    %eax,0x54(%ebx)
  80dfa7:	0f 85 23 f8 ff ff    	jne    80d7d0 <tcp_input+0x3a9>
      recv_flags = TF_CLOSED;
  80dfad:	c6 05 9c b1 b3 00 10 	movb   $0x10,0xb3b19c
  80dfb4:	e9 17 f8 ff ff       	jmp    80d7d0 <tcp_input+0x3a9>
    tcp_input_pcb = NULL;
  80dfb9:	c7 05 58 b2 b3 00 00 	movl   $0x0,0xb3b258
  80dfc0:	00 00 00 
  80dfc3:	e9 12 f8 ff ff       	jmp    80d7da <tcp_input+0x3b3>
      } else if (recv_flags & TF_CLOSED) {
  80dfc8:	a8 10                	test   $0x10,%al
  80dfca:	0f 85 96 00 00 00    	jne    80e066 <tcp_input+0xc3f>
        if (pcb->acked > 0) {
  80dfd0:	0f b7 53 6c          	movzwl 0x6c(%ebx),%edx
        err = ERR_OK;
  80dfd4:	b8 00 00 00 00       	mov    $0x0,%eax
        if (pcb->acked > 0) {
  80dfd9:	66 85 d2             	test   %dx,%dx
  80dfdc:	74 1a                	je     80dff8 <tcp_input+0xbd1>
          TCP_EVENT_SENT(pcb, pcb->acked, err);
  80dfde:	8b 8b 84 00 00 00    	mov    0x84(%ebx),%ecx
  80dfe4:	85 c9                	test   %ecx,%ecx
  80dfe6:	74 10                	je     80dff8 <tcp_input+0xbd1>
  80dfe8:	83 ec 04             	sub    $0x4,%esp
  80dfeb:	0f b7 d2             	movzwl %dx,%edx
  80dfee:	52                   	push   %edx
  80dfef:	53                   	push   %ebx
  80dff0:	ff 73 18             	pushl  0x18(%ebx)
  80dff3:	ff d1                	call   *%ecx
  80dff5:	83 c4 10             	add    $0x10,%esp
        if (recv_data != NULL) {
  80dff8:	8b 15 98 b1 b3 00    	mov    0xb3b198,%edx
  80dffe:	85 d2                	test   %edx,%edx
  80e000:	0f 84 a9 00 00 00    	je     80e0af <tcp_input+0xc88>
          if(flags & TCP_PSH) {
  80e006:	f6 05 a0 b1 b3 00 08 	testb  $0x8,0xb3b1a0
  80e00d:	74 04                	je     80e013 <tcp_input+0xbec>
            recv_data->flags |= PBUF_FLAG_PUSH;
  80e00f:	80 4a 0d 01          	orb    $0x1,0xd(%edx)
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
  80e013:	8b 83 88 00 00 00    	mov    0x88(%ebx),%eax
  80e019:	85 c0                	test   %eax,%eax
  80e01b:	74 6a                	je     80e087 <tcp_input+0xc60>
  80e01d:	6a 00                	push   $0x0
  80e01f:	52                   	push   %edx
  80e020:	53                   	push   %ebx
  80e021:	ff 73 18             	pushl  0x18(%ebx)
  80e024:	ff d0                	call   *%eax
          if (err != ERR_OK) {
  80e026:	83 c4 10             	add    $0x10,%esp
  80e029:	84 c0                	test   %al,%al
  80e02b:	75 68                	jne    80e095 <tcp_input+0xc6e>
        if (recv_flags & TF_GOT_FIN) {
  80e02d:	f6 05 9c b1 b3 00 20 	testb  $0x20,0xb3b19c
  80e034:	74 1f                	je     80e055 <tcp_input+0xc2e>
          TCP_EVENT_RECV(pcb, NULL, ERR_OK, err);
  80e036:	8b 83 88 00 00 00    	mov    0x88(%ebx),%eax
  80e03c:	85 c0                	test   %eax,%eax
  80e03e:	74 15                	je     80e055 <tcp_input+0xc2e>
  80e040:	6a 00                	push   $0x0
  80e042:	6a 00                	push   $0x0
  80e044:	53                   	push   %ebx
  80e045:	ff 73 18             	pushl  0x18(%ebx)
  80e048:	ff d0                	call   *%eax
  80e04a:	83 c4 10             	add    $0x10,%esp
        if (err == ERR_OK) {
  80e04d:	84 c0                	test   %al,%al
  80e04f:	0f 85 c7 f7 ff ff    	jne    80d81c <tcp_input+0x3f5>
          tcp_output(pcb);
  80e055:	83 ec 0c             	sub    $0xc,%esp
  80e058:	53                   	push   %ebx
  80e059:	e8 81 a2 ff ff       	call   8082df <tcp_output>
  80e05e:	83 c4 10             	add    $0x10,%esp
  80e061:	e9 b6 f7 ff ff       	jmp    80d81c <tcp_input+0x3f5>
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
  80e066:	83 ec 08             	sub    $0x8,%esp
  80e069:	53                   	push   %ebx
  80e06a:	68 3c b2 b3 00       	push   $0xb3b23c
  80e06f:	e8 c5 7a ff ff       	call   805b39 <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
  80e074:	83 c4 08             	add    $0x8,%esp
  80e077:	53                   	push   %ebx
  80e078:	6a 02                	push   $0x2
  80e07a:	e8 1f 66 ff ff       	call   80469e <memp_free>
  80e07f:	83 c4 10             	add    $0x10,%esp
  80e082:	e9 95 f7 ff ff       	jmp    80d81c <tcp_input+0x3f5>
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
  80e087:	83 ec 0c             	sub    $0xc,%esp
  80e08a:	52                   	push   %edx
  80e08b:	e8 91 69 ff ff       	call   804a21 <pbuf_free>
  80e090:	83 c4 10             	add    $0x10,%esp
  80e093:	eb 98                	jmp    80e02d <tcp_input+0xc06>
            pcb->refused_data = recv_data;
  80e095:	a1 98 b1 b3 00       	mov    0xb3b198,%eax
  80e09a:	89 83 80 00 00 00    	mov    %eax,0x80(%ebx)
        if (recv_flags & TF_GOT_FIN) {
  80e0a0:	f6 05 9c b1 b3 00 20 	testb  $0x20,0xb3b19c
  80e0a7:	0f 84 6f f7 ff ff    	je     80d81c <tcp_input+0x3f5>
  80e0ad:	eb 87                	jmp    80e036 <tcp_input+0xc0f>
  80e0af:	f6 05 9c b1 b3 00 20 	testb  $0x20,0xb3b19c
  80e0b6:	74 95                	je     80e04d <tcp_input+0xc26>
  80e0b8:	e9 79 ff ff ff       	jmp    80e036 <tcp_input+0xc0f>
        tcphdr->dest, tcphdr->src);
  80e0bd:	8b 15 b0 b1 b3 00    	mov    0xb3b1b0,%edx
        &(iphdr->dest), &(iphdr->src),
  80e0c3:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
      tcp_rst(ackno, seqno + tcplen,
  80e0c8:	83 ec 08             	sub    $0x8,%esp
  80e0cb:	0f b7 0a             	movzwl (%edx),%ecx
  80e0ce:	51                   	push   %ecx
  80e0cf:	0f b7 52 02          	movzwl 0x2(%edx),%edx
  80e0d3:	52                   	push   %edx
  80e0d4:	8d 50 0c             	lea    0xc(%eax),%edx
  80e0d7:	52                   	push   %edx
  80e0d8:	83 c0 10             	add    $0x10,%eax
  80e0db:	50                   	push   %eax
  80e0dc:	0f b7 05 9e b1 b3 00 	movzwl 0xb3b19e,%eax
  80e0e3:	03 05 a8 b1 b3 00    	add    0xb3b1a8,%eax
  80e0e9:	50                   	push   %eax
  80e0ea:	ff 35 a4 b1 b3 00    	pushl  0xb3b1a4
  80e0f0:	e8 90 a6 ff ff       	call   808785 <tcp_rst>
  80e0f5:	83 c4 20             	add    $0x20,%esp
  80e0f8:	eb 14                	jmp    80e10e <tcp_input+0xce7>
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
  80e0fa:	83 ec 0c             	sub    $0xc,%esp
  80e0fd:	0f b7 42 0c          	movzwl 0xc(%edx),%eax
  80e101:	50                   	push   %eax
  80e102:	e8 63 98 ff ff       	call   80796a <ntohs>
  80e107:	83 c4 10             	add    $0x10,%esp
  80e10a:	a8 04                	test   $0x4,%al
  80e10c:	74 af                	je     80e0bd <tcp_input+0xc96>
    pbuf_free(p);
  80e10e:	83 ec 0c             	sub    $0xc,%esp
  80e111:	56                   	push   %esi
  80e112:	e8 0a 69 ff ff       	call   804a21 <pbuf_free>
  80e117:	83 c4 10             	add    $0x10,%esp
  80e11a:	e9 77 f3 ff ff       	jmp    80d496 <tcp_input+0x6f>
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  80e11f:	8b 1d 50 b2 b3 00    	mov    0xb3b250,%ebx
  80e125:	e9 46 f7 ff ff       	jmp    80d870 <tcp_input+0x449>

0080e12a <raw_input>:
 *           caller).
 *
 */
u8_t
raw_input(struct pbuf *p, struct netif *inp)
{
  80e12a:	f3 0f 1e fb          	endbr32 
  80e12e:	55                   	push   %ebp
  80e12f:	89 e5                	mov    %esp,%ebp
  80e131:	57                   	push   %edi
  80e132:	56                   	push   %esi
  80e133:	53                   	push   %ebx
  80e134:	83 ec 28             	sub    $0x28,%esp
  s16_t proto;
  u8_t eaten = 0;

  LWIP_UNUSED_ARG(inp);

  iphdr = p->payload;
  80e137:	8b 45 08             	mov    0x8(%ebp),%eax
  80e13a:	8b 78 04             	mov    0x4(%eax),%edi
  proto = IPH_PROTO(iphdr);
  80e13d:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80e141:	50                   	push   %eax
  80e142:	e8 23 98 ff ff       	call   80796a <ntohs>
  80e147:	89 c2                	mov    %eax,%edx

  prev = NULL;
  pcb = raw_pcbs;
  80e149:	8b 1d c8 b1 b3 00    	mov    0xb3b1c8,%ebx
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
  80e14f:	83 c4 10             	add    $0x10,%esp
  u8_t eaten = 0;
  80e152:	b8 00 00 00 00       	mov    $0x0,%eax
  prev = NULL;
  80e157:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    if (pcb->protocol == proto) {
  80e15e:	0f b6 f2             	movzbl %dl,%esi
  while ((eaten == 0) && (pcb != NULL)) {
  80e161:	eb 11                	jmp    80e174 <raw_input+0x4a>
      if (pcb->recv != NULL) {
        /* the receive callback function did not eat the packet? */
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
        {
          /* receive function ate the packet */
          p = NULL;
  80e163:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80e166:	89 45 08             	mov    %eax,0x8(%ebp)
          eaten = 1;
  80e169:	b8 01 00 00 00       	mov    $0x1,%eax
        }
      }
      /* no receive callback function was set for this raw PCB */
      /* drop the packet */
    }
    prev = pcb;
  80e16e:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
    pcb = pcb->next;
  80e171:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  while ((eaten == 0) && (pcb != NULL)) {
  80e174:	84 c0                	test   %al,%al
  80e176:	75 55                	jne    80e1cd <raw_input+0xa3>
  80e178:	85 db                	test   %ebx,%ebx
  80e17a:	74 51                	je     80e1cd <raw_input+0xa3>
    if (pcb->protocol == proto) {
  80e17c:	0f b6 53 10          	movzbl 0x10(%ebx),%edx
  80e180:	b8 00 00 00 00       	mov    $0x0,%eax
  80e185:	39 f2                	cmp    %esi,%edx
  80e187:	75 e5                	jne    80e16e <raw_input+0x44>
      if (pcb->recv != NULL) {
  80e189:	8b 53 14             	mov    0x14(%ebx),%edx
  80e18c:	85 d2                	test   %edx,%edx
  80e18e:	74 de                	je     80e16e <raw_input+0x44>
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
  80e190:	8d 47 0c             	lea    0xc(%edi),%eax
  80e193:	50                   	push   %eax
  80e194:	ff 75 08             	pushl  0x8(%ebp)
  80e197:	53                   	push   %ebx
  80e198:	ff 73 18             	pushl  0x18(%ebx)
  80e19b:	ff d2                	call   *%edx
  80e19d:	83 c4 10             	add    $0x10,%esp
  80e1a0:	84 c0                	test   %al,%al
  80e1a2:	74 ca                	je     80e16e <raw_input+0x44>
          if (prev != NULL) {
  80e1a4:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80e1a7:	85 c9                	test   %ecx,%ecx
  80e1a9:	74 b8                	je     80e163 <raw_input+0x39>
            prev->next = pcb->next;
  80e1ab:	8b 43 0c             	mov    0xc(%ebx),%eax
  80e1ae:	89 41 0c             	mov    %eax,0xc(%ecx)
            pcb->next = raw_pcbs;
  80e1b1:	a1 c8 b1 b3 00       	mov    0xb3b1c8,%eax
  80e1b6:	89 43 0c             	mov    %eax,0xc(%ebx)
            raw_pcbs = pcb;
  80e1b9:	89 1d c8 b1 b3 00    	mov    %ebx,0xb3b1c8
          eaten = 1;
  80e1bf:	b8 01 00 00 00       	mov    $0x1,%eax
          p = NULL;
  80e1c4:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
  80e1cb:	eb a1                	jmp    80e16e <raw_input+0x44>
  }
  return eaten;
}
  80e1cd:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80e1d0:	5b                   	pop    %ebx
  80e1d1:	5e                   	pop    %esi
  80e1d2:	5f                   	pop    %edi
  80e1d3:	5d                   	pop    %ebp
  80e1d4:	c3                   	ret    

0080e1d5 <raw_bind>:
 *
 * @see raw_disconnect()
 */
err_t
raw_bind(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
  80e1d5:	f3 0f 1e fb          	endbr32 
  80e1d9:	55                   	push   %ebp
  80e1da:	89 e5                	mov    %esp,%ebp
  80e1dc:	8b 55 0c             	mov    0xc(%ebp),%edx
  ip_addr_set(&pcb->local_ip, ipaddr);
  80e1df:	b8 00 00 00 00       	mov    $0x0,%eax
  80e1e4:	85 d2                	test   %edx,%edx
  80e1e6:	74 02                	je     80e1ea <raw_bind+0x15>
  80e1e8:	8b 02                	mov    (%edx),%eax
  80e1ea:	8b 55 08             	mov    0x8(%ebp),%edx
  80e1ed:	89 02                	mov    %eax,(%edx)
  return ERR_OK;
}
  80e1ef:	b8 00 00 00 00       	mov    $0x0,%eax
  80e1f4:	5d                   	pop    %ebp
  80e1f5:	c3                   	ret    

0080e1f6 <raw_connect>:
 *
 * @see raw_disconnect() and raw_sendto()
 */
err_t
raw_connect(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
  80e1f6:	f3 0f 1e fb          	endbr32 
  80e1fa:	55                   	push   %ebp
  80e1fb:	89 e5                	mov    %esp,%ebp
  80e1fd:	8b 55 0c             	mov    0xc(%ebp),%edx
  ip_addr_set(&pcb->remote_ip, ipaddr);
  80e200:	b8 00 00 00 00       	mov    $0x0,%eax
  80e205:	85 d2                	test   %edx,%edx
  80e207:	74 02                	je     80e20b <raw_connect+0x15>
  80e209:	8b 02                	mov    (%edx),%eax
  80e20b:	8b 55 08             	mov    0x8(%ebp),%edx
  80e20e:	89 42 04             	mov    %eax,0x4(%edx)
  return ERR_OK;
}
  80e211:	b8 00 00 00 00       	mov    $0x0,%eax
  80e216:	5d                   	pop    %ebp
  80e217:	c3                   	ret    

0080e218 <raw_recv>:
void
raw_recv(struct raw_pcb *pcb,
         u8_t (* recv)(void *arg, struct raw_pcb *upcb, struct pbuf *p,
                      struct ip_addr *addr),
         void *recv_arg)
{
  80e218:	f3 0f 1e fb          	endbr32 
  80e21c:	55                   	push   %ebp
  80e21d:	89 e5                	mov    %esp,%ebp
  80e21f:	8b 45 08             	mov    0x8(%ebp),%eax
  /* remember recv() callback and user data */
  pcb->recv = recv;
  80e222:	8b 55 0c             	mov    0xc(%ebp),%edx
  80e225:	89 50 14             	mov    %edx,0x14(%eax)
  pcb->recv_arg = recv_arg;
  80e228:	8b 55 10             	mov    0x10(%ebp),%edx
  80e22b:	89 50 18             	mov    %edx,0x18(%eax)
}
  80e22e:	5d                   	pop    %ebp
  80e22f:	c3                   	ret    

0080e230 <raw_sendto>:
 * @param ipaddr the destination address of the IP packet
 *
 */
err_t
raw_sendto(struct raw_pcb *pcb, struct pbuf *p, struct ip_addr *ipaddr)
{
  80e230:	f3 0f 1e fb          	endbr32 
  80e234:	55                   	push   %ebp
  80e235:	89 e5                	mov    %esp,%ebp
  80e237:	57                   	push   %edi
  80e238:	56                   	push   %esi
  80e239:	53                   	push   %ebx
  80e23a:	83 ec 14             	sub    $0x14,%esp
  80e23d:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80e240:	8b 7d 0c             	mov    0xc(%ebp),%edi
  struct pbuf *q; /* q will be sent down the stack */
  
  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 3, ("raw_sendto\n"));
  
  /* not enough space to add an IP header to first pbuf in given p chain? */
  if (pbuf_header(p, IP_HLEN)) {
  80e243:	6a 14                	push   $0x14
  80e245:	57                   	push   %edi
  80e246:	e8 03 67 ff ff       	call   80494e <pbuf_header>
  80e24b:	83 c4 10             	add    $0x10,%esp
  80e24e:	84 c0                	test   %al,%al
  80e250:	74 52                	je     80e2a4 <raw_sendto+0x74>
    /* allocate header in new pbuf */
    q = pbuf_alloc(PBUF_IP, 0, PBUF_RAM);
  80e252:	83 ec 04             	sub    $0x4,%esp
  80e255:	6a 00                	push   $0x0
  80e257:	6a 00                	push   $0x0
  80e259:	6a 01                	push   $0x1
  80e25b:	e8 8b 68 ff ff       	call   804aeb <pbuf_alloc>
  80e260:	89 c6                	mov    %eax,%esi
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
  80e262:	83 c4 10             	add    $0x10,%esp
  80e265:	85 c0                	test   %eax,%eax
  80e267:	0f 84 be 00 00 00    	je     80e32b <raw_sendto+0xfb>
      LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 2, ("raw_sendto: could not allocate header\n"));
      return ERR_MEM;
    }
    /* chain header q in front of given pbuf p */
    pbuf_chain(q, p);
  80e26d:	83 ec 08             	sub    $0x8,%esp
  80e270:	57                   	push   %edi
  80e271:	50                   	push   %eax
  80e272:	e8 8c 6c ff ff       	call   804f03 <pbuf_chain>
      LWIP_ASSERT("Can't restore header we just removed!", 0);
      return ERR_MEM;
    }
  }
  
  if ((netif = ip_route(ipaddr)) == NULL) {
  80e277:	83 c4 04             	add    $0x4,%esp
  80e27a:	ff 75 10             	pushl  0x10(%ebp)
  80e27d:	e8 a2 84 ff ff       	call   806724 <ip_route>
  80e282:	83 c4 10             	add    $0x10,%esp
  80e285:	85 c0                	test   %eax,%eax
  80e287:	75 41                	jne    80e2ca <raw_sendto+0x9a>
    LWIP_DEBUGF(RAW_DEBUG | 1, ("raw_sendto: No route to 0x%"X32_F"\n", ipaddr->addr));
    /* free any temporary header pbuf allocated by pbuf_header() */
    if (q != p) {
  80e289:	39 f7                	cmp    %esi,%edi
  80e28b:	0f 84 a1 00 00 00    	je     80e332 <raw_sendto+0x102>
      pbuf_free(q);
  80e291:	83 ec 0c             	sub    $0xc,%esp
  80e294:	56                   	push   %esi
  80e295:	e8 87 67 ff ff       	call   804a21 <pbuf_free>
  80e29a:	83 c4 10             	add    $0x10,%esp
    }
    return ERR_RTE;
  80e29d:	bb fc ff ff ff       	mov    $0xfffffffc,%ebx
  80e2a2:	eb 66                	jmp    80e30a <raw_sendto+0xda>
    if(pbuf_header(q, -IP_HLEN)) {
  80e2a4:	83 ec 08             	sub    $0x8,%esp
  80e2a7:	6a ec                	push   $0xffffffec
  80e2a9:	57                   	push   %edi
  80e2aa:	e8 9f 66 ff ff       	call   80494e <pbuf_header>
  80e2af:	83 c4 10             	add    $0x10,%esp
  80e2b2:	84 c0                	test   %al,%al
  80e2b4:	75 5e                	jne    80e314 <raw_sendto+0xe4>
  if ((netif = ip_route(ipaddr)) == NULL) {
  80e2b6:	83 ec 0c             	sub    $0xc,%esp
  80e2b9:	ff 75 10             	pushl  0x10(%ebp)
  80e2bc:	e8 63 84 ff ff       	call   806724 <ip_route>
  80e2c1:	83 c4 10             	add    $0x10,%esp
  80e2c4:	85 c0                	test   %eax,%eax
  80e2c6:	74 71                	je     80e339 <raw_sendto+0x109>
    q = p;
  80e2c8:	89 fe                	mov    %edi,%esi
  }

  if (ip_addr_isany(&pcb->local_ip)) {
  80e2ca:	89 da                	mov    %ebx,%edx
  80e2cc:	85 db                	test   %ebx,%ebx
  80e2ce:	74 05                	je     80e2d5 <raw_sendto+0xa5>
  80e2d0:	83 3b 00             	cmpl   $0x0,(%ebx)
  80e2d3:	75 03                	jne    80e2d8 <raw_sendto+0xa8>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
  80e2d5:	8d 50 04             	lea    0x4(%eax),%edx
  }

#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = &(pcb->addr_hint);
#endif /* LWIP_NETIF_HWADDRHINT*/
  err = ip_output_if (q, src_ip, ipaddr, pcb->ttl, pcb->tos, pcb->protocol, netif);
  80e2d8:	83 ec 04             	sub    $0x4,%esp
  80e2db:	50                   	push   %eax
  80e2dc:	0f b6 43 10          	movzbl 0x10(%ebx),%eax
  80e2e0:	50                   	push   %eax
  80e2e1:	0f b6 43 0a          	movzbl 0xa(%ebx),%eax
  80e2e5:	50                   	push   %eax
  80e2e6:	0f b6 43 0b          	movzbl 0xb(%ebx),%eax
  80e2ea:	50                   	push   %eax
  80e2eb:	ff 75 10             	pushl  0x10(%ebp)
  80e2ee:	52                   	push   %edx
  80e2ef:	56                   	push   %esi
  80e2f0:	e8 b6 87 ff ff       	call   806aab <ip_output_if>
  80e2f5:	89 c3                	mov    %eax,%ebx
#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = NULL;
#endif /* LWIP_NETIF_HWADDRHINT*/

  /* did we chain a header earlier? */
  if (q != p) {
  80e2f7:	83 c4 20             	add    $0x20,%esp
  80e2fa:	39 f7                	cmp    %esi,%edi
  80e2fc:	74 0c                	je     80e30a <raw_sendto+0xda>
    /* free the header */
    pbuf_free(q);
  80e2fe:	83 ec 0c             	sub    $0xc,%esp
  80e301:	56                   	push   %esi
  80e302:	e8 1a 67 ff ff       	call   804a21 <pbuf_free>
  80e307:	83 c4 10             	add    $0x10,%esp
  }
  return err;
}
  80e30a:	89 d8                	mov    %ebx,%eax
  80e30c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80e30f:	5b                   	pop    %ebx
  80e310:	5e                   	pop    %esi
  80e311:	5f                   	pop    %edi
  80e312:	5d                   	pop    %ebp
  80e313:	c3                   	ret    
      LWIP_ASSERT("Can't restore header we just removed!", 0);
  80e314:	83 ec 04             	sub    $0x4,%esp
  80e317:	68 a0 37 81 00       	push   $0x8137a0
  80e31c:	68 e3 00 00 00       	push   $0xe3
  80e321:	68 c6 37 81 00       	push   $0x8137c6
  80e326:	e8 1c 06 00 00       	call   80e947 <_panic>
      return ERR_MEM;
  80e32b:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  80e330:	eb d8                	jmp    80e30a <raw_sendto+0xda>
    return ERR_RTE;
  80e332:	bb fc ff ff ff       	mov    $0xfffffffc,%ebx
  80e337:	eb d1                	jmp    80e30a <raw_sendto+0xda>
  80e339:	bb fc ff ff ff       	mov    $0xfffffffc,%ebx
  80e33e:	eb ca                	jmp    80e30a <raw_sendto+0xda>

0080e340 <raw_send>:
 * @param p the IP payload to send
 *
 */
err_t
raw_send(struct raw_pcb *pcb, struct pbuf *p)
{
  80e340:	f3 0f 1e fb          	endbr32 
  80e344:	55                   	push   %ebp
  80e345:	89 e5                	mov    %esp,%ebp
  80e347:	83 ec 0c             	sub    $0xc,%esp
  80e34a:	8b 45 08             	mov    0x8(%ebp),%eax
  return raw_sendto(pcb, p, &pcb->remote_ip);
  80e34d:	8d 50 04             	lea    0x4(%eax),%edx
  80e350:	52                   	push   %edx
  80e351:	ff 75 0c             	pushl  0xc(%ebp)
  80e354:	50                   	push   %eax
  80e355:	e8 d6 fe ff ff       	call   80e230 <raw_sendto>
}
  80e35a:	c9                   	leave  
  80e35b:	c3                   	ret    

0080e35c <raw_remove>:
 *
 * @see raw_new()
 */
void
raw_remove(struct raw_pcb *pcb)
{
  80e35c:	f3 0f 1e fb          	endbr32 
  80e360:	55                   	push   %ebp
  80e361:	89 e5                	mov    %esp,%ebp
  80e363:	83 ec 08             	sub    $0x8,%esp
  80e366:	8b 4d 08             	mov    0x8(%ebp),%ecx
  struct raw_pcb *pcb2;
  /* pcb to be removed is first in list? */
  if (raw_pcbs == pcb) {
  80e369:	a1 c8 b1 b3 00       	mov    0xb3b1c8,%eax
  80e36e:	39 c8                	cmp    %ecx,%eax
  80e370:	75 1b                	jne    80e38d <raw_remove+0x31>
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
  80e372:	8b 41 0c             	mov    0xc(%ecx),%eax
  80e375:	a3 c8 b1 b3 00       	mov    %eax,0xb3b1c8
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  }
  memp_free(MEMP_RAW_PCB, pcb);
  80e37a:	83 ec 08             	sub    $0x8,%esp
  80e37d:	51                   	push   %ecx
  80e37e:	6a 00                	push   $0x0
  80e380:	e8 19 63 ff ff       	call   80469e <memp_free>
}
  80e385:	83 c4 10             	add    $0x10,%esp
  80e388:	c9                   	leave  
  80e389:	c3                   	ret    
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  80e38a:	8b 40 0c             	mov    0xc(%eax),%eax
  80e38d:	85 c0                	test   %eax,%eax
  80e38f:	74 e9                	je     80e37a <raw_remove+0x1e>
      if (pcb2->next != NULL && pcb2->next == pcb) {
  80e391:	8b 50 0c             	mov    0xc(%eax),%edx
  80e394:	39 ca                	cmp    %ecx,%edx
  80e396:	75 f2                	jne    80e38a <raw_remove+0x2e>
  80e398:	85 d2                	test   %edx,%edx
  80e39a:	74 ee                	je     80e38a <raw_remove+0x2e>
        pcb2->next = pcb->next;
  80e39c:	8b 51 0c             	mov    0xc(%ecx),%edx
  80e39f:	89 50 0c             	mov    %edx,0xc(%eax)
  80e3a2:	eb e6                	jmp    80e38a <raw_remove+0x2e>

0080e3a4 <raw_new>:
 * @param proto the protocol number of the IPs payload (e.g. IP_PROTO_ICMP)
 *
 * @see raw_remove()
 */
struct raw_pcb *
raw_new(u8_t proto) {
  80e3a4:	f3 0f 1e fb          	endbr32 
  80e3a8:	55                   	push   %ebp
  80e3a9:	89 e5                	mov    %esp,%ebp
  80e3ab:	56                   	push   %esi
  80e3ac:	53                   	push   %ebx
  80e3ad:	8b 75 08             	mov    0x8(%ebp),%esi
  struct raw_pcb *pcb;

  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 3, ("raw_new\n"));

  pcb = memp_malloc(MEMP_RAW_PCB);
  80e3b0:	83 ec 0c             	sub    $0xc,%esp
  80e3b3:	6a 00                	push   $0x0
  80e3b5:	e8 8a 62 ff ff       	call   804644 <memp_malloc>
  80e3ba:	89 c3                	mov    %eax,%ebx
  /* could allocate RAW PCB? */
  if (pcb != NULL) {
  80e3bc:	83 c4 10             	add    $0x10,%esp
  80e3bf:	85 c0                	test   %eax,%eax
  80e3c1:	74 27                	je     80e3ea <raw_new+0x46>
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct raw_pcb));
  80e3c3:	83 ec 04             	sub    $0x4,%esp
  80e3c6:	6a 1c                	push   $0x1c
  80e3c8:	6a 00                	push   $0x0
  80e3ca:	50                   	push   %eax
  80e3cb:	e8 d2 0d 00 00       	call   80f1a2 <memset>
    pcb->protocol = proto;
  80e3d0:	89 f0                	mov    %esi,%eax
  80e3d2:	88 43 10             	mov    %al,0x10(%ebx)
    pcb->ttl = RAW_TTL;
  80e3d5:	c6 43 0b ff          	movb   $0xff,0xb(%ebx)
    pcb->next = raw_pcbs;
  80e3d9:	a1 c8 b1 b3 00       	mov    0xb3b1c8,%eax
  80e3de:	89 43 0c             	mov    %eax,0xc(%ebx)
    raw_pcbs = pcb;
  80e3e1:	89 1d c8 b1 b3 00    	mov    %ebx,0xb3b1c8
  80e3e7:	83 c4 10             	add    $0x10,%esp
  }
  return pcb;
}
  80e3ea:	89 d8                	mov    %ebx,%eax
  80e3ec:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80e3ef:	5b                   	pop    %ebx
  80e3f0:	5e                   	pop    %esi
  80e3f1:	5d                   	pop    %ebp
  80e3f2:	c3                   	ret    

0080e3f3 <icmp_input>:
 * @param p the icmp echo request packet, p->payload pointing to the ip header
 * @param inp the netif on which this packet was received
 */
void
icmp_input(struct pbuf *p, struct netif *inp)
{
  80e3f3:	f3 0f 1e fb          	endbr32 
  80e3f7:	55                   	push   %ebp
  80e3f8:	89 e5                	mov    %esp,%ebp
  80e3fa:	57                   	push   %edi
  80e3fb:	56                   	push   %esi
  80e3fc:	53                   	push   %ebx
  80e3fd:	83 ec 28             	sub    $0x28,%esp
  80e400:	8b 5d 08             	mov    0x8(%ebp),%ebx

  ICMP_STATS_INC(icmp.recv);
  snmp_inc_icmpinmsgs();


  iphdr = p->payload;
  80e403:	8b 7b 04             	mov    0x4(%ebx),%edi
  hlen = IPH_HL(iphdr) * 4;
  80e406:	0f b7 07             	movzwl (%edi),%eax
  80e409:	50                   	push   %eax
  80e40a:	e8 5b 95 ff ff       	call   80796a <ntohs>
  80e40f:	66 c1 e8 06          	shr    $0x6,%ax
  80e413:	83 e0 3c             	and    $0x3c,%eax
  80e416:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
  if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t)*2)) {
  80e41a:	89 c6                	mov    %eax,%esi
  80e41c:	f7 de                	neg    %esi
  80e41e:	0f bf f6             	movswl %si,%esi
  80e421:	83 c4 08             	add    $0x8,%esp
  80e424:	56                   	push   %esi
  80e425:	53                   	push   %ebx
  80e426:	e8 23 65 ff ff       	call   80494e <pbuf_header>
  80e42b:	83 c4 10             	add    $0x10,%esp
  80e42e:	84 c0                	test   %al,%al
  80e430:	75 67                	jne    80e499 <icmp_input+0xa6>
  80e432:	66 83 7b 08 03       	cmpw   $0x3,0x8(%ebx)
  80e437:	76 60                	jbe    80e499 <icmp_input+0xa6>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: short ICMP (%"U16_F" bytes) received\n", p->tot_len));
    goto lenerr;
  }

  type = *((u8_t *)p->payload);
  80e439:	8b 43 04             	mov    0x4(%ebx),%eax
#ifdef LWIP_DEBUG
  code = *(((u8_t *)p->payload)+1);
#endif /* LWIP_DEBUG */
  switch (type) {
  80e43c:	80 38 08             	cmpb   $0x8,(%eax)
  80e43f:	74 0e                	je     80e44f <icmp_input+0x5c>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %"S16_F" code %"S16_F" not supported.\n", 
                (s16_t)type, (s16_t)code));
    ICMP_STATS_INC(icmp.proterr);
    ICMP_STATS_INC(icmp.drop);
  }
  pbuf_free(p);
  80e441:	83 ec 0c             	sub    $0xc,%esp
  80e444:	53                   	push   %ebx
  80e445:	e8 d7 65 ff ff       	call   804a21 <pbuf_free>
  return;
  80e44a:	83 c4 10             	add    $0x10,%esp
  80e44d:	eb 56                	jmp    80e4a5 <icmp_input+0xb2>
    if (ip_addr_isbroadcast(&iphdr->dest, inp) || ip_addr_ismulticast(&iphdr->dest)) {
  80e44f:	83 ec 08             	sub    $0x8,%esp
  80e452:	ff 75 0c             	pushl  0xc(%ebp)
  80e455:	8d 47 10             	lea    0x10(%edi),%eax
  80e458:	50                   	push   %eax
  80e459:	e8 7f 82 ff ff       	call   8066dd <ip_addr_isbroadcast>
  80e45e:	83 c4 10             	add    $0x10,%esp
  80e461:	84 c0                	test   %al,%al
  80e463:	75 48                	jne    80e4ad <icmp_input+0xba>
  80e465:	8b 47 10             	mov    0x10(%edi),%eax
  80e468:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80e46b:	83 ec 0c             	sub    $0xc,%esp
  80e46e:	68 00 00 00 f0       	push   $0xf0000000
  80e473:	e8 30 97 ff ff       	call   807ba8 <ntohl>
  80e478:	23 45 e0             	and    -0x20(%ebp),%eax
  80e47b:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80e47e:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80e485:	e8 1e 97 ff ff       	call   807ba8 <ntohl>
  80e48a:	83 c4 10             	add    $0x10,%esp
  80e48d:	39 45 e0             	cmp    %eax,-0x20(%ebp)
  80e490:	74 1b                	je     80e4ad <icmp_input+0xba>
    if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
  80e492:	66 83 7b 08 07       	cmpw   $0x7,0x8(%ebx)
  80e497:	77 22                	ja     80e4bb <icmp_input+0xc8>
lenerr:
  pbuf_free(p);
  80e499:	83 ec 0c             	sub    $0xc,%esp
  80e49c:	53                   	push   %ebx
  80e49d:	e8 7f 65 ff ff       	call   804a21 <pbuf_free>
  ICMP_STATS_INC(icmp.lenerr);
  snmp_inc_icmpinerrors();
  return;
  80e4a2:	83 c4 10             	add    $0x10,%esp
memerr:
  pbuf_free(p);
  ICMP_STATS_INC(icmp.err);
  snmp_inc_icmpinerrors();
  return;
}
  80e4a5:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80e4a8:	5b                   	pop    %ebx
  80e4a9:	5e                   	pop    %esi
  80e4aa:	5f                   	pop    %edi
  80e4ab:	5d                   	pop    %ebp
  80e4ac:	c3                   	ret    
      pbuf_free(p);
  80e4ad:	83 ec 0c             	sub    $0xc,%esp
  80e4b0:	53                   	push   %ebx
  80e4b1:	e8 6b 65 ff ff       	call   804a21 <pbuf_free>
      return;
  80e4b6:	83 c4 10             	add    $0x10,%esp
  80e4b9:	eb ea                	jmp    80e4a5 <icmp_input+0xb2>
    if (inet_chksum_pbuf(p) != 0) {
  80e4bb:	83 ec 0c             	sub    $0xc,%esp
  80e4be:	53                   	push   %ebx
  80e4bf:	e8 75 93 ff ff       	call   807839 <inet_chksum_pbuf>
  80e4c4:	83 c4 10             	add    $0x10,%esp
  80e4c7:	66 85 c0             	test   %ax,%ax
  80e4ca:	0f 85 96 00 00 00    	jne    80e566 <icmp_input+0x173>
    if (pbuf_header(p, (PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
  80e4d0:	83 ec 08             	sub    $0x8,%esp
  80e4d3:	6a 22                	push   $0x22
  80e4d5:	53                   	push   %ebx
  80e4d6:	e8 73 64 ff ff       	call   80494e <pbuf_header>
  80e4db:	83 c4 10             	add    $0x10,%esp
  80e4de:	84 c0                	test   %al,%al
  80e4e0:	0f 84 fb 00 00 00    	je     80e5e1 <icmp_input+0x1ee>
      if (pbuf_header(p, hlen)) {
  80e4e6:	83 ec 08             	sub    $0x8,%esp
  80e4e9:	0f bf 45 e6          	movswl -0x1a(%ebp),%eax
  80e4ed:	50                   	push   %eax
  80e4ee:	53                   	push   %ebx
  80e4ef:	e8 5a 64 ff ff       	call   80494e <pbuf_header>
  80e4f4:	83 c4 10             	add    $0x10,%esp
  80e4f7:	84 c0                	test   %al,%al
  80e4f9:	75 7c                	jne    80e577 <icmp_input+0x184>
      r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
  80e4fb:	83 ec 04             	sub    $0x4,%esp
  80e4fe:	6a 00                	push   $0x0
  80e500:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80e504:	50                   	push   %eax
  80e505:	6a 02                	push   $0x2
  80e507:	e8 df 65 ff ff       	call   804aeb <pbuf_alloc>
  80e50c:	89 45 e0             	mov    %eax,-0x20(%ebp)
      if (r == NULL) {
  80e50f:	83 c4 10             	add    $0x10,%esp
  80e512:	85 c0                	test   %eax,%eax
  80e514:	74 75                	je     80e58b <icmp_input+0x198>
      LWIP_ASSERT("check that first pbuf can hold struct the ICMP header",
  80e516:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80e519:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
  80e51d:	0f bf 45 e6          	movswl -0x1a(%ebp),%eax
  80e521:	83 c0 08             	add    $0x8,%eax
  80e524:	39 c2                	cmp    %eax,%edx
  80e526:	72 74                	jb     80e59c <icmp_input+0x1a9>
      if (pbuf_copy(r, p) != ERR_OK) {
  80e528:	83 ec 08             	sub    $0x8,%esp
  80e52b:	53                   	push   %ebx
  80e52c:	ff 75 e0             	pushl  -0x20(%ebp)
  80e52f:	e8 9e 6a ff ff       	call   804fd2 <pbuf_copy>
  80e534:	83 c4 10             	add    $0x10,%esp
  80e537:	84 c0                	test   %al,%al
  80e539:	75 78                	jne    80e5b3 <icmp_input+0x1c0>
      iphdr = r->payload;
  80e53b:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80e53e:	8b 78 04             	mov    0x4(%eax),%edi
      if (pbuf_header(r, -hlen)) {
  80e541:	83 ec 08             	sub    $0x8,%esp
  80e544:	56                   	push   %esi
  80e545:	50                   	push   %eax
  80e546:	e8 03 64 ff ff       	call   80494e <pbuf_header>
  80e54b:	83 c4 10             	add    $0x10,%esp
  80e54e:	84 c0                	test   %al,%al
  80e550:	75 78                	jne    80e5ca <icmp_input+0x1d7>
      pbuf_free(p);
  80e552:	83 ec 0c             	sub    $0xc,%esp
  80e555:	53                   	push   %ebx
  80e556:	e8 c6 64 ff ff       	call   804a21 <pbuf_free>
  80e55b:	83 c4 10             	add    $0x10,%esp
      p = r;
  80e55e:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  80e561:	e9 91 00 00 00       	jmp    80e5f7 <icmp_input+0x204>
      pbuf_free(p);
  80e566:	83 ec 0c             	sub    $0xc,%esp
  80e569:	53                   	push   %ebx
  80e56a:	e8 b2 64 ff ff       	call   804a21 <pbuf_free>
      return;
  80e56f:	83 c4 10             	add    $0x10,%esp
  80e572:	e9 2e ff ff ff       	jmp    80e4a5 <icmp_input+0xb2>
        LWIP_ASSERT("icmp_input: moving p->payload to ip header failed\n", 0);
  80e577:	83 ec 04             	sub    $0x4,%esp
  80e57a:	68 dc 37 81 00       	push   $0x8137dc
  80e57f:	6a 7b                	push   $0x7b
  80e581:	68 d0 38 81 00       	push   $0x8138d0
  80e586:	e8 bc 03 00 00       	call   80e947 <_panic>
  pbuf_free(p);
  80e58b:	83 ec 0c             	sub    $0xc,%esp
  80e58e:	53                   	push   %ebx
  80e58f:	e8 8d 64 ff ff       	call   804a21 <pbuf_free>
  return;
  80e594:	83 c4 10             	add    $0x10,%esp
  80e597:	e9 09 ff ff ff       	jmp    80e4a5 <icmp_input+0xb2>
      LWIP_ASSERT("check that first pbuf can hold struct the ICMP header",
  80e59c:	83 ec 04             	sub    $0x4,%esp
  80e59f:	68 10 38 81 00       	push   $0x813810
  80e5a4:	68 84 00 00 00       	push   $0x84
  80e5a9:	68 d0 38 81 00       	push   $0x8138d0
  80e5ae:	e8 94 03 00 00       	call   80e947 <_panic>
        LWIP_ASSERT("icmp_input: copying to new pbuf failed\n", 0);
  80e5b3:	83 ec 04             	sub    $0x4,%esp
  80e5b6:	68 48 38 81 00       	push   $0x813848
  80e5bb:	68 88 00 00 00       	push   $0x88
  80e5c0:	68 d0 38 81 00       	push   $0x8138d0
  80e5c5:	e8 7d 03 00 00       	call   80e947 <_panic>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
  80e5ca:	83 ec 04             	sub    $0x4,%esp
  80e5cd:	68 70 38 81 00       	push   $0x813870
  80e5d2:	68 8e 00 00 00       	push   $0x8e
  80e5d7:	68 d0 38 81 00       	push   $0x8138d0
  80e5dc:	e8 66 03 00 00       	call   80e947 <_panic>
      if (pbuf_header(p, -(s16_t)(PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
  80e5e1:	83 ec 08             	sub    $0x8,%esp
  80e5e4:	6a de                	push   $0xffffffde
  80e5e6:	53                   	push   %ebx
  80e5e7:	e8 62 63 ff ff       	call   80494e <pbuf_header>
  80e5ec:	83 c4 10             	add    $0x10,%esp
  80e5ef:	84 c0                	test   %al,%al
  80e5f1:	0f 85 d3 00 00 00    	jne    80e6ca <icmp_input+0x2d7>
    iecho = p->payload;
  80e5f7:	8b 73 04             	mov    0x4(%ebx),%esi
    tmpaddr.addr = iphdr->src.addr;
  80e5fa:	8b 47 0c             	mov    0xc(%edi),%eax
    iphdr->src.addr = iphdr->dest.addr;
  80e5fd:	8b 57 10             	mov    0x10(%edi),%edx
  80e600:	89 57 0c             	mov    %edx,0xc(%edi)
    iphdr->dest.addr = tmpaddr.addr;
  80e603:	89 47 10             	mov    %eax,0x10(%edi)
    ICMPH_TYPE_SET(iecho, ICMP_ER);
  80e606:	83 ec 0c             	sub    $0xc,%esp
  80e609:	0f b7 06             	movzwl (%esi),%eax
  80e60c:	50                   	push   %eax
  80e60d:	e8 58 93 ff ff       	call   80796a <ntohs>
  80e612:	0f b6 c0             	movzbl %al,%eax
  80e615:	89 04 24             	mov    %eax,(%esp)
  80e618:	e8 3c 93 ff ff       	call   807959 <htons>
  80e61d:	66 89 06             	mov    %ax,(%esi)
    if (iecho->chksum >= htons(0xffff - (ICMP_ECHO << 8))) {
  80e620:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  80e624:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
  80e628:	c7 04 24 ff f7 00 00 	movl   $0xf7ff,(%esp)
  80e62f:	e8 25 93 ff ff       	call   807959 <htons>
  80e634:	83 c4 10             	add    $0x10,%esp
  80e637:	66 39 45 e0          	cmp    %ax,-0x20(%ebp)
  80e63b:	0f 82 a0 00 00 00    	jb     80e6e1 <icmp_input+0x2ee>
      iecho->chksum += htons(ICMP_ECHO << 8) + 1;
  80e641:	83 ec 0c             	sub    $0xc,%esp
  80e644:	68 00 08 00 00       	push   $0x800
  80e649:	e8 0b 93 ff ff       	call   807959 <htons>
  80e64e:	0f b7 56 02          	movzwl 0x2(%esi),%edx
  80e652:	8d 44 02 01          	lea    0x1(%edx,%eax,1),%eax
  80e656:	66 89 46 02          	mov    %ax,0x2(%esi)
  80e65a:	83 c4 10             	add    $0x10,%esp
    IPH_TTL_SET(iphdr, ICMP_TTL);
  80e65d:	83 ec 0c             	sub    $0xc,%esp
  80e660:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80e664:	50                   	push   %eax
  80e665:	e8 00 93 ff ff       	call   80796a <ntohs>
  80e66a:	66 0d 00 ff          	or     $0xff00,%ax
  80e66e:	0f b7 c0             	movzwl %ax,%eax
  80e671:	89 04 24             	mov    %eax,(%esp)
  80e674:	e8 e0 92 ff ff       	call   807959 <htons>
  80e679:	66 89 47 08          	mov    %ax,0x8(%edi)
    IPH_CHKSUM_SET(iphdr, 0);
  80e67d:	66 c7 47 0a 00 00    	movw   $0x0,0xa(%edi)
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  80e683:	83 c4 08             	add    $0x8,%esp
  80e686:	6a 14                	push   $0x14
  80e688:	57                   	push   %edi
  80e689:	e8 91 91 ff ff       	call   80781f <inet_chksum>
  80e68e:	66 89 47 0a          	mov    %ax,0xa(%edi)
    if(pbuf_header(p, hlen)) {
  80e692:	83 c4 08             	add    $0x8,%esp
  80e695:	0f bf 45 e6          	movswl -0x1a(%ebp),%eax
  80e699:	50                   	push   %eax
  80e69a:	53                   	push   %ebx
  80e69b:	e8 ae 62 ff ff       	call   80494e <pbuf_header>
  80e6a0:	83 c4 10             	add    $0x10,%esp
  80e6a3:	84 c0                	test   %al,%al
  80e6a5:	75 53                	jne    80e6fa <icmp_input+0x307>
      ret = ip_output_if(p, &(iphdr->src), IP_HDRINCL,
  80e6a7:	83 ec 04             	sub    $0x4,%esp
  80e6aa:	ff 75 0c             	pushl  0xc(%ebp)
  80e6ad:	6a 01                	push   $0x1
  80e6af:	6a 00                	push   $0x0
  80e6b1:	68 ff 00 00 00       	push   $0xff
  80e6b6:	6a 00                	push   $0x0
  80e6b8:	83 c7 0c             	add    $0xc,%edi
  80e6bb:	57                   	push   %edi
  80e6bc:	53                   	push   %ebx
  80e6bd:	e8 e9 83 ff ff       	call   806aab <ip_output_if>
  80e6c2:	83 c4 20             	add    $0x20,%esp
  80e6c5:	e9 77 fd ff ff       	jmp    80e441 <icmp_input+0x4e>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
  80e6ca:	83 ec 04             	sub    $0x4,%esp
  80e6cd:	68 70 38 81 00       	push   $0x813870
  80e6d2:	68 98 00 00 00       	push   $0x98
  80e6d7:	68 d0 38 81 00       	push   $0x8138d0
  80e6dc:	e8 66 02 00 00       	call   80e947 <_panic>
      iecho->chksum += htons(ICMP_ECHO << 8);
  80e6e1:	83 ec 0c             	sub    $0xc,%esp
  80e6e4:	68 00 08 00 00       	push   $0x800
  80e6e9:	e8 6b 92 ff ff       	call   807959 <htons>
  80e6ee:	66 01 46 02          	add    %ax,0x2(%esi)
  80e6f2:	83 c4 10             	add    $0x10,%esp
  80e6f5:	e9 63 ff ff ff       	jmp    80e65d <icmp_input+0x26a>
      LWIP_ASSERT("Can't move over header in packet", 0);
  80e6fa:	83 ec 04             	sub    $0x4,%esp
  80e6fd:	68 38 29 81 00       	push   $0x812938
  80e702:	68 b9 00 00 00       	push   $0xb9
  80e707:	68 d0 38 81 00       	push   $0x8138d0
  80e70c:	e8 36 02 00 00       	call   80e947 <_panic>

0080e711 <icmp_dest_unreach>:
 *          p->payload pointing to the IP header
 * @param t type of the 'unreachable' packet
 */
void
icmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t)
{
  80e711:	f3 0f 1e fb          	endbr32 
  80e715:	55                   	push   %ebp
  80e716:	89 e5                	mov    %esp,%ebp
  80e718:	57                   	push   %edi
  80e719:	56                   	push   %esi
  80e71a:	53                   	push   %ebx
  80e71b:	83 ec 10             	sub    $0x10,%esp
  struct pbuf *q;
  struct ip_hdr *iphdr;
  struct icmp_dur_hdr *idur;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
  80e71e:	6a 00                	push   $0x0
  80e720:	6a 24                	push   $0x24
  80e722:	6a 01                	push   $0x1
  80e724:	e8 c2 63 ff ff       	call   804aeb <pbuf_alloc>
                 PBUF_RAM);
  if (q == NULL) {
  80e729:	83 c4 10             	add    $0x10,%esp
  80e72c:	85 c0                	test   %eax,%eax
  80e72e:	0f 84 a5 00 00 00    	je     80e7d9 <icmp_dest_unreach+0xc8>
  80e734:	89 c3                	mov    %eax,%ebx
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_dest_unreach: failed to allocate pbuf for ICMP packet.\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  80e736:	66 83 78 0a 23       	cmpw   $0x23,0xa(%eax)
  80e73b:	0f 86 a0 00 00 00    	jbe    80e7e1 <icmp_dest_unreach+0xd0>
             (q->len >= (sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = p->payload;
  80e741:	8b 45 08             	mov    0x8(%ebp),%eax
  80e744:	8b 78 04             	mov    0x4(%eax),%edi

  idur = q->payload;
  80e747:	8b 73 04             	mov    0x4(%ebx),%esi
  ICMPH_TYPE_SET(idur, ICMP_DUR);
  80e74a:	83 ec 0c             	sub    $0xc,%esp
  80e74d:	0f b7 06             	movzwl (%esi),%eax
  80e750:	50                   	push   %eax
  80e751:	e8 14 92 ff ff       	call   80796a <ntohs>
  80e756:	0f b6 c0             	movzbl %al,%eax
  80e759:	80 cc 03             	or     $0x3,%ah
  80e75c:	89 04 24             	mov    %eax,(%esp)
  80e75f:	e8 f5 91 ff ff       	call   807959 <htons>
  80e764:	66 89 06             	mov    %ax,(%esi)
  ICMPH_CODE_SET(idur, t);
  80e767:	0f b7 c0             	movzwl %ax,%eax
  80e76a:	89 04 24             	mov    %eax,(%esp)
  80e76d:	e8 f8 91 ff ff       	call   80796a <ntohs>
  80e772:	b0 00                	mov    $0x0,%al
  80e774:	66 0b 45 0c          	or     0xc(%ebp),%ax
  80e778:	0f b7 c0             	movzwl %ax,%eax
  80e77b:	89 04 24             	mov    %eax,(%esp)
  80e77e:	e8 d6 91 ff ff       	call   807959 <htons>
  80e783:	66 89 06             	mov    %ax,(%esi)

  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_dur_hdr), p->payload,
  80e786:	83 c4 0c             	add    $0xc,%esp
  80e789:	6a 1c                	push   $0x1c
  80e78b:	8b 45 08             	mov    0x8(%ebp),%eax
  80e78e:	ff 70 04             	pushl  0x4(%eax)
  80e791:	8b 43 04             	mov    0x4(%ebx),%eax
  80e794:	83 c0 08             	add    $0x8,%eax
  80e797:	50                   	push   %eax
  80e798:	e8 b7 0a 00 00       	call   80f254 <memcpy>
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  idur->chksum = 0;
  80e79d:	66 c7 46 02 00 00    	movw   $0x0,0x2(%esi)
  idur->chksum = inet_chksum(idur, q->len);
  80e7a3:	83 c4 08             	add    $0x8,%esp
  80e7a6:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80e7aa:	50                   	push   %eax
  80e7ab:	56                   	push   %esi
  80e7ac:	e8 6e 90 ff ff       	call   80781f <inet_chksum>
  80e7b1:	66 89 46 02          	mov    %ax,0x2(%esi)
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpoutdestunreachs();

  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
  80e7b5:	83 c4 08             	add    $0x8,%esp
  80e7b8:	6a 01                	push   $0x1
  80e7ba:	6a 00                	push   $0x0
  80e7bc:	68 ff 00 00 00       	push   $0xff
  80e7c1:	83 c7 0c             	add    $0xc,%edi
  80e7c4:	57                   	push   %edi
  80e7c5:	6a 00                	push   $0x0
  80e7c7:	53                   	push   %ebx
  80e7c8:	e8 64 84 ff ff       	call   806c31 <ip_output>
  pbuf_free(q);
  80e7cd:	83 c4 14             	add    $0x14,%esp
  80e7d0:	53                   	push   %ebx
  80e7d1:	e8 4b 62 ff ff       	call   804a21 <pbuf_free>
  80e7d6:	83 c4 10             	add    $0x10,%esp
}
  80e7d9:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80e7dc:	5b                   	pop    %ebx
  80e7dd:	5e                   	pop    %esi
  80e7de:	5f                   	pop    %edi
  80e7df:	5d                   	pop    %ebp
  80e7e0:	c3                   	ret    
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  80e7e1:	83 ec 04             	sub    $0x4,%esp
  80e7e4:	68 a4 38 81 00       	push   $0x8138a4
  80e7e9:	68 ee 00 00 00       	push   $0xee
  80e7ee:	68 d0 38 81 00       	push   $0x8138d0
  80e7f3:	e8 4f 01 00 00       	call   80e947 <_panic>

0080e7f8 <icmp_time_exceeded>:
 *          p->payload pointing to the IP header
 * @param t type of the 'time exceeded' packet
 */
void
icmp_time_exceeded(struct pbuf *p, enum icmp_te_type t)
{
  80e7f8:	f3 0f 1e fb          	endbr32 
  80e7fc:	55                   	push   %ebp
  80e7fd:	89 e5                	mov    %esp,%ebp
  80e7ff:	57                   	push   %edi
  80e800:	56                   	push   %esi
  80e801:	53                   	push   %ebx
  80e802:	83 ec 10             	sub    $0x10,%esp
  struct pbuf *q;
  struct ip_hdr *iphdr;
  struct icmp_te_hdr *tehdr;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
  80e805:	6a 00                	push   $0x0
  80e807:	6a 24                	push   $0x24
  80e809:	6a 01                	push   $0x1
  80e80b:	e8 db 62 ff ff       	call   804aeb <pbuf_alloc>
                 PBUF_RAM);
  if (q == NULL) {
  80e810:	83 c4 10             	add    $0x10,%esp
  80e813:	85 c0                	test   %eax,%eax
  80e815:	0f 84 a5 00 00 00    	je     80e8c0 <icmp_time_exceeded+0xc8>
  80e81b:	89 c3                	mov    %eax,%ebx
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded: failed to allocate pbuf for ICMP packet.\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  80e81d:	66 83 78 0a 23       	cmpw   $0x23,0xa(%eax)
  80e822:	0f 86 a0 00 00 00    	jbe    80e8c8 <icmp_time_exceeded+0xd0>
             (q->len >= (sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = p->payload;
  80e828:	8b 45 08             	mov    0x8(%ebp),%eax
  80e82b:	8b 78 04             	mov    0x4(%eax),%edi
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->src));
  LWIP_DEBUGF(ICMP_DEBUG, (" to "));
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->dest));
  LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

  tehdr = q->payload;
  80e82e:	8b 73 04             	mov    0x4(%ebx),%esi
  ICMPH_TYPE_SET(tehdr, ICMP_TE);
  80e831:	83 ec 0c             	sub    $0xc,%esp
  80e834:	0f b7 06             	movzwl (%esi),%eax
  80e837:	50                   	push   %eax
  80e838:	e8 2d 91 ff ff       	call   80796a <ntohs>
  80e83d:	0f b6 c0             	movzbl %al,%eax
  80e840:	80 cc 0b             	or     $0xb,%ah
  80e843:	89 04 24             	mov    %eax,(%esp)
  80e846:	e8 0e 91 ff ff       	call   807959 <htons>
  80e84b:	66 89 06             	mov    %ax,(%esi)
  ICMPH_CODE_SET(tehdr, t);
  80e84e:	0f b7 c0             	movzwl %ax,%eax
  80e851:	89 04 24             	mov    %eax,(%esp)
  80e854:	e8 11 91 ff ff       	call   80796a <ntohs>
  80e859:	b0 00                	mov    $0x0,%al
  80e85b:	66 0b 45 0c          	or     0xc(%ebp),%ax
  80e85f:	0f b7 c0             	movzwl %ax,%eax
  80e862:	89 04 24             	mov    %eax,(%esp)
  80e865:	e8 ef 90 ff ff       	call   807959 <htons>
  80e86a:	66 89 06             	mov    %ax,(%esi)

  /* copy fields from original packet */
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_dur_hdr), (u8_t *)p->payload,
  80e86d:	83 c4 0c             	add    $0xc,%esp
  80e870:	6a 1c                	push   $0x1c
  80e872:	8b 45 08             	mov    0x8(%ebp),%eax
  80e875:	ff 70 04             	pushl  0x4(%eax)
  80e878:	8b 43 04             	mov    0x4(%ebx),%eax
  80e87b:	83 c0 08             	add    $0x8,%eax
  80e87e:	50                   	push   %eax
  80e87f:	e8 d0 09 00 00       	call   80f254 <memcpy>
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  tehdr->chksum = 0;
  80e884:	66 c7 46 02 00 00    	movw   $0x0,0x2(%esi)
  tehdr->chksum = inet_chksum(tehdr, q->len);
  80e88a:	83 c4 08             	add    $0x8,%esp
  80e88d:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80e891:	50                   	push   %eax
  80e892:	56                   	push   %esi
  80e893:	e8 87 8f ff ff       	call   80781f <inet_chksum>
  80e898:	66 89 46 02          	mov    %ax,0x2(%esi)
  ICMP_STATS_INC(icmp.xmit);
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpouttimeexcds();
  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
  80e89c:	83 c4 08             	add    $0x8,%esp
  80e89f:	6a 01                	push   $0x1
  80e8a1:	6a 00                	push   $0x0
  80e8a3:	68 ff 00 00 00       	push   $0xff
  80e8a8:	83 c7 0c             	add    $0xc,%edi
  80e8ab:	57                   	push   %edi
  80e8ac:	6a 00                	push   $0x0
  80e8ae:	53                   	push   %ebx
  80e8af:	e8 7d 83 ff ff       	call   806c31 <ip_output>
  pbuf_free(q);
  80e8b4:	83 c4 14             	add    $0x14,%esp
  80e8b7:	53                   	push   %ebx
  80e8b8:	e8 64 61 ff ff       	call   804a21 <pbuf_free>
  80e8bd:	83 c4 10             	add    $0x10,%esp
}
  80e8c0:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80e8c3:	5b                   	pop    %ebx
  80e8c4:	5e                   	pop    %esi
  80e8c5:	5f                   	pop    %edi
  80e8c6:	5d                   	pop    %ebp
  80e8c7:	c3                   	ret    
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  80e8c8:	83 ec 04             	sub    $0x4,%esp
  80e8cb:	68 a4 38 81 00       	push   $0x8138a4
  80e8d0:	68 1d 01 00 00       	push   $0x11d
  80e8d5:	68 d0 38 81 00       	push   $0x8138d0
  80e8da:	e8 68 00 00 00       	call   80e947 <_panic>

0080e8df <libmain>:
const volatile struct Env *thisenv;
const char *binaryname = "<unknown>";

void
libmain(int argc, char **argv)
{
  80e8df:	f3 0f 1e fb          	endbr32 
  80e8e3:	55                   	push   %ebp
  80e8e4:	89 e5                	mov    %esp,%ebp
  80e8e6:	56                   	push   %esi
  80e8e7:	53                   	push   %ebx
  80e8e8:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80e8eb:	8b 75 0c             	mov    0xc(%ebp),%esi
	// set thisenv to point at our Env structure in envs[].
	// LAB 3: Your code here.
	thisenv = &envs[ENVX(sys_getenvid())];
  80e8ee:	e8 41 0b 00 00       	call   80f434 <sys_getenvid>
  80e8f3:	25 ff 03 00 00       	and    $0x3ff,%eax
  80e8f8:	6b c0 7c             	imul   $0x7c,%eax,%eax
  80e8fb:	05 00 00 c0 ee       	add    $0xeec00000,%eax
  80e900:	a3 5c b2 b3 00       	mov    %eax,0xb3b25c

	// save the name of the program so that panic() can use it
	if (argc > 0)
  80e905:	85 db                	test   %ebx,%ebx
  80e907:	7e 07                	jle    80e910 <libmain+0x31>
		binaryname = argv[0];
  80e909:	8b 06                	mov    (%esi),%eax
  80e90b:	a3 e8 42 81 00       	mov    %eax,0x8142e8

	// call user main routine
	umain(argc, argv);
  80e910:	83 ec 08             	sub    $0x8,%esp
  80e913:	56                   	push   %esi
  80e914:	53                   	push   %ebx
  80e915:	e8 7c 1c ff ff       	call   800596 <umain>

	// exit gracefully
	exit();
  80e91a:	e8 0a 00 00 00       	call   80e929 <exit>
}
  80e91f:	83 c4 10             	add    $0x10,%esp
  80e922:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80e925:	5b                   	pop    %ebx
  80e926:	5e                   	pop    %esi
  80e927:	5d                   	pop    %ebp
  80e928:	c3                   	ret    

0080e929 <exit>:

#include <inc/lib.h>

void
exit(void)
{
  80e929:	f3 0f 1e fb          	endbr32 
  80e92d:	55                   	push   %ebp
  80e92e:	89 e5                	mov    %esp,%ebp
  80e930:	83 ec 08             	sub    $0x8,%esp
	close_all();
  80e933:	e8 09 14 00 00       	call   80fd41 <close_all>
	sys_env_destroy(0);
  80e938:	83 ec 0c             	sub    $0xc,%esp
  80e93b:	6a 00                	push   $0x0
  80e93d:	e8 ad 0a 00 00       	call   80f3ef <sys_env_destroy>
}
  80e942:	83 c4 10             	add    $0x10,%esp
  80e945:	c9                   	leave  
  80e946:	c3                   	ret    

0080e947 <_panic>:
 * It prints "panic: <message>", then causes a breakpoint exception,
 * which causes JOS to enter the JOS kernel monitor.
 */
void
_panic(const char *file, int line, const char *fmt, ...)
{
  80e947:	f3 0f 1e fb          	endbr32 
  80e94b:	55                   	push   %ebp
  80e94c:	89 e5                	mov    %esp,%ebp
  80e94e:	56                   	push   %esi
  80e94f:	53                   	push   %ebx
	va_list ap;

	va_start(ap, fmt);
  80e950:	8d 5d 14             	lea    0x14(%ebp),%ebx

	// Print the panic message
	cprintf("[%08x] user panic in %s at %s:%d: ",
  80e953:	8b 35 e8 42 81 00    	mov    0x8142e8,%esi
  80e959:	e8 d6 0a 00 00       	call   80f434 <sys_getenvid>
  80e95e:	83 ec 0c             	sub    $0xc,%esp
  80e961:	ff 75 0c             	pushl  0xc(%ebp)
  80e964:	ff 75 08             	pushl  0x8(%ebp)
  80e967:	56                   	push   %esi
  80e968:	50                   	push   %eax
  80e969:	68 f4 38 81 00       	push   $0x8138f4
  80e96e:	e8 bb 00 00 00       	call   80ea2e <cprintf>
		sys_getenvid(), binaryname, file, line);
	vcprintf(fmt, ap);
  80e973:	83 c4 18             	add    $0x18,%esp
  80e976:	53                   	push   %ebx
  80e977:	ff 75 10             	pushl  0x10(%ebp)
  80e97a:	e8 5a 00 00 00       	call   80e9d9 <vcprintf>
	cprintf("\n");
  80e97f:	c7 04 24 c8 14 81 00 	movl   $0x8114c8,(%esp)
  80e986:	e8 a3 00 00 00       	call   80ea2e <cprintf>
  80e98b:	83 c4 10             	add    $0x10,%esp

	// Cause a breakpoint exception
	while (1)
		asm volatile("int3");
  80e98e:	cc                   	int3   
  80e98f:	eb fd                	jmp    80e98e <_panic+0x47>

0080e991 <putch>:
};


static void
putch(int ch, struct printbuf *b)
{
  80e991:	f3 0f 1e fb          	endbr32 
  80e995:	55                   	push   %ebp
  80e996:	89 e5                	mov    %esp,%ebp
  80e998:	53                   	push   %ebx
  80e999:	83 ec 04             	sub    $0x4,%esp
  80e99c:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	b->buf[b->idx++] = ch;
  80e99f:	8b 13                	mov    (%ebx),%edx
  80e9a1:	8d 42 01             	lea    0x1(%edx),%eax
  80e9a4:	89 03                	mov    %eax,(%ebx)
  80e9a6:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80e9a9:	88 4c 13 08          	mov    %cl,0x8(%ebx,%edx,1)
	if (b->idx == 256-1) {
  80e9ad:	3d ff 00 00 00       	cmp    $0xff,%eax
  80e9b2:	74 09                	je     80e9bd <putch+0x2c>
		sys_cputs(b->buf, b->idx);
		b->idx = 0;
	}
	b->cnt++;
  80e9b4:	83 43 04 01          	addl   $0x1,0x4(%ebx)
}
  80e9b8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80e9bb:	c9                   	leave  
  80e9bc:	c3                   	ret    
		sys_cputs(b->buf, b->idx);
  80e9bd:	83 ec 08             	sub    $0x8,%esp
  80e9c0:	68 ff 00 00 00       	push   $0xff
  80e9c5:	8d 43 08             	lea    0x8(%ebx),%eax
  80e9c8:	50                   	push   %eax
  80e9c9:	e8 dc 09 00 00       	call   80f3aa <sys_cputs>
		b->idx = 0;
  80e9ce:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  80e9d4:	83 c4 10             	add    $0x10,%esp
  80e9d7:	eb db                	jmp    80e9b4 <putch+0x23>

0080e9d9 <vcprintf>:

int
vcprintf(const char *fmt, va_list ap)
{
  80e9d9:	f3 0f 1e fb          	endbr32 
  80e9dd:	55                   	push   %ebp
  80e9de:	89 e5                	mov    %esp,%ebp
  80e9e0:	81 ec 18 01 00 00    	sub    $0x118,%esp
	struct printbuf b;

	b.idx = 0;
  80e9e6:	c7 85 f0 fe ff ff 00 	movl   $0x0,-0x110(%ebp)
  80e9ed:	00 00 00 
	b.cnt = 0;
  80e9f0:	c7 85 f4 fe ff ff 00 	movl   $0x0,-0x10c(%ebp)
  80e9f7:	00 00 00 
	vprintfmt((void*)putch, &b, fmt, ap);
  80e9fa:	ff 75 0c             	pushl  0xc(%ebp)
  80e9fd:	ff 75 08             	pushl  0x8(%ebp)
  80ea00:	8d 85 f0 fe ff ff    	lea    -0x110(%ebp),%eax
  80ea06:	50                   	push   %eax
  80ea07:	68 91 e9 80 00       	push   $0x80e991
  80ea0c:	e8 20 01 00 00       	call   80eb31 <vprintfmt>
	sys_cputs(b.buf, b.idx);
  80ea11:	83 c4 08             	add    $0x8,%esp
  80ea14:	ff b5 f0 fe ff ff    	pushl  -0x110(%ebp)
  80ea1a:	8d 85 f8 fe ff ff    	lea    -0x108(%ebp),%eax
  80ea20:	50                   	push   %eax
  80ea21:	e8 84 09 00 00       	call   80f3aa <sys_cputs>

	return b.cnt;
}
  80ea26:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
  80ea2c:	c9                   	leave  
  80ea2d:	c3                   	ret    

0080ea2e <cprintf>:

int
cprintf(const char *fmt, ...)
{
  80ea2e:	f3 0f 1e fb          	endbr32 
  80ea32:	55                   	push   %ebp
  80ea33:	89 e5                	mov    %esp,%ebp
  80ea35:	83 ec 10             	sub    $0x10,%esp
	va_list ap;
	int cnt;

	va_start(ap, fmt);
  80ea38:	8d 45 0c             	lea    0xc(%ebp),%eax
	cnt = vcprintf(fmt, ap);
  80ea3b:	50                   	push   %eax
  80ea3c:	ff 75 08             	pushl  0x8(%ebp)
  80ea3f:	e8 95 ff ff ff       	call   80e9d9 <vcprintf>
	va_end(ap);

	return cnt;
}
  80ea44:	c9                   	leave  
  80ea45:	c3                   	ret    

0080ea46 <printnum>:
 * using specified putch function and associated pointer putdat.
 */
static void
printnum(void (*putch)(int, void*), void *putdat,
	 unsigned long long num, unsigned base, int width, int padc)
{
  80ea46:	55                   	push   %ebp
  80ea47:	89 e5                	mov    %esp,%ebp
  80ea49:	57                   	push   %edi
  80ea4a:	56                   	push   %esi
  80ea4b:	53                   	push   %ebx
  80ea4c:	83 ec 1c             	sub    $0x1c,%esp
  80ea4f:	89 c7                	mov    %eax,%edi
  80ea51:	89 d6                	mov    %edx,%esi
  80ea53:	8b 45 08             	mov    0x8(%ebp),%eax
  80ea56:	8b 55 0c             	mov    0xc(%ebp),%edx
  80ea59:	89 d1                	mov    %edx,%ecx
  80ea5b:	89 c2                	mov    %eax,%edx
  80ea5d:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80ea60:	89 4d dc             	mov    %ecx,-0x24(%ebp)
  80ea63:	8b 45 10             	mov    0x10(%ebp),%eax
  80ea66:	8b 5d 14             	mov    0x14(%ebp),%ebx
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
  80ea69:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80ea6c:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  80ea73:	39 c2                	cmp    %eax,%edx
  80ea75:	1b 4d e4             	sbb    -0x1c(%ebp),%ecx
  80ea78:	72 3e                	jb     80eab8 <printnum+0x72>
		printnum(putch, putdat, num / base, base, width - 1, padc);
  80ea7a:	83 ec 0c             	sub    $0xc,%esp
  80ea7d:	ff 75 18             	pushl  0x18(%ebp)
  80ea80:	83 eb 01             	sub    $0x1,%ebx
  80ea83:	53                   	push   %ebx
  80ea84:	50                   	push   %eax
  80ea85:	83 ec 08             	sub    $0x8,%esp
  80ea88:	ff 75 e4             	pushl  -0x1c(%ebp)
  80ea8b:	ff 75 e0             	pushl  -0x20(%ebp)
  80ea8e:	ff 75 dc             	pushl  -0x24(%ebp)
  80ea91:	ff 75 d8             	pushl  -0x28(%ebp)
  80ea94:	e8 37 26 00 00       	call   8110d0 <__udivdi3>
  80ea99:	83 c4 18             	add    $0x18,%esp
  80ea9c:	52                   	push   %edx
  80ea9d:	50                   	push   %eax
  80ea9e:	89 f2                	mov    %esi,%edx
  80eaa0:	89 f8                	mov    %edi,%eax
  80eaa2:	e8 9f ff ff ff       	call   80ea46 <printnum>
  80eaa7:	83 c4 20             	add    $0x20,%esp
  80eaaa:	eb 13                	jmp    80eabf <printnum+0x79>
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
			putch(padc, putdat);
  80eaac:	83 ec 08             	sub    $0x8,%esp
  80eaaf:	56                   	push   %esi
  80eab0:	ff 75 18             	pushl  0x18(%ebp)
  80eab3:	ff d7                	call   *%edi
  80eab5:	83 c4 10             	add    $0x10,%esp
		while (--width > 0)
  80eab8:	83 eb 01             	sub    $0x1,%ebx
  80eabb:	85 db                	test   %ebx,%ebx
  80eabd:	7f ed                	jg     80eaac <printnum+0x66>
	}

	// then print this (the least significant) digit
	putch("0123456789abcdef"[num % base], putdat);
  80eabf:	83 ec 08             	sub    $0x8,%esp
  80eac2:	56                   	push   %esi
  80eac3:	83 ec 04             	sub    $0x4,%esp
  80eac6:	ff 75 e4             	pushl  -0x1c(%ebp)
  80eac9:	ff 75 e0             	pushl  -0x20(%ebp)
  80eacc:	ff 75 dc             	pushl  -0x24(%ebp)
  80eacf:	ff 75 d8             	pushl  -0x28(%ebp)
  80ead2:	e8 09 27 00 00       	call   8111e0 <__umoddi3>
  80ead7:	83 c4 14             	add    $0x14,%esp
  80eada:	0f be 80 17 39 81 00 	movsbl 0x813917(%eax),%eax
  80eae1:	50                   	push   %eax
  80eae2:	ff d7                	call   *%edi
}
  80eae4:	83 c4 10             	add    $0x10,%esp
  80eae7:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80eaea:	5b                   	pop    %ebx
  80eaeb:	5e                   	pop    %esi
  80eaec:	5f                   	pop    %edi
  80eaed:	5d                   	pop    %ebp
  80eaee:	c3                   	ret    

0080eaef <sprintputch>:
	int cnt;
};

static void
sprintputch(int ch, struct sprintbuf *b)
{
  80eaef:	f3 0f 1e fb          	endbr32 
  80eaf3:	55                   	push   %ebp
  80eaf4:	89 e5                	mov    %esp,%ebp
  80eaf6:	8b 45 0c             	mov    0xc(%ebp),%eax
	b->cnt++;
  80eaf9:	83 40 08 01          	addl   $0x1,0x8(%eax)
	if (b->buf < b->ebuf)
  80eafd:	8b 10                	mov    (%eax),%edx
  80eaff:	3b 50 04             	cmp    0x4(%eax),%edx
  80eb02:	73 0a                	jae    80eb0e <sprintputch+0x1f>
		*b->buf++ = ch;
  80eb04:	8d 4a 01             	lea    0x1(%edx),%ecx
  80eb07:	89 08                	mov    %ecx,(%eax)
  80eb09:	8b 45 08             	mov    0x8(%ebp),%eax
  80eb0c:	88 02                	mov    %al,(%edx)
}
  80eb0e:	5d                   	pop    %ebp
  80eb0f:	c3                   	ret    

0080eb10 <printfmt>:
{
  80eb10:	f3 0f 1e fb          	endbr32 
  80eb14:	55                   	push   %ebp
  80eb15:	89 e5                	mov    %esp,%ebp
  80eb17:	83 ec 08             	sub    $0x8,%esp
	va_start(ap, fmt);
  80eb1a:	8d 45 14             	lea    0x14(%ebp),%eax
	vprintfmt(putch, putdat, fmt, ap);
  80eb1d:	50                   	push   %eax
  80eb1e:	ff 75 10             	pushl  0x10(%ebp)
  80eb21:	ff 75 0c             	pushl  0xc(%ebp)
  80eb24:	ff 75 08             	pushl  0x8(%ebp)
  80eb27:	e8 05 00 00 00       	call   80eb31 <vprintfmt>
}
  80eb2c:	83 c4 10             	add    $0x10,%esp
  80eb2f:	c9                   	leave  
  80eb30:	c3                   	ret    

0080eb31 <vprintfmt>:
{
  80eb31:	f3 0f 1e fb          	endbr32 
  80eb35:	55                   	push   %ebp
  80eb36:	89 e5                	mov    %esp,%ebp
  80eb38:	57                   	push   %edi
  80eb39:	56                   	push   %esi
  80eb3a:	53                   	push   %ebx
  80eb3b:	83 ec 3c             	sub    $0x3c,%esp
  80eb3e:	8b 75 08             	mov    0x8(%ebp),%esi
  80eb41:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  80eb44:	8b 7d 10             	mov    0x10(%ebp),%edi
  80eb47:	e9 8e 03 00 00       	jmp    80eeda <vprintfmt+0x3a9>
		padc = ' ';
  80eb4c:	c6 45 d3 20          	movb   $0x20,-0x2d(%ebp)
		altflag = 0;
  80eb50:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
		precision = -1;
  80eb57:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%ebp)
		width = -1;
  80eb5e:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
		lflag = 0;
  80eb65:	b9 00 00 00 00       	mov    $0x0,%ecx
		switch (ch = *(unsigned char *) fmt++) {
  80eb6a:	8d 47 01             	lea    0x1(%edi),%eax
  80eb6d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80eb70:	0f b6 17             	movzbl (%edi),%edx
  80eb73:	8d 42 dd             	lea    -0x23(%edx),%eax
  80eb76:	3c 55                	cmp    $0x55,%al
  80eb78:	0f 87 df 03 00 00    	ja     80ef5d <vprintfmt+0x42c>
  80eb7e:	0f b6 c0             	movzbl %al,%eax
  80eb81:	3e ff 24 85 60 3a 81 	notrack jmp *0x813a60(,%eax,4)
  80eb88:	00 
  80eb89:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			padc = '-';
  80eb8c:	c6 45 d3 2d          	movb   $0x2d,-0x2d(%ebp)
  80eb90:	eb d8                	jmp    80eb6a <vprintfmt+0x39>
		switch (ch = *(unsigned char *) fmt++) {
  80eb92:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  80eb95:	c6 45 d3 30          	movb   $0x30,-0x2d(%ebp)
  80eb99:	eb cf                	jmp    80eb6a <vprintfmt+0x39>
  80eb9b:	0f b6 d2             	movzbl %dl,%edx
  80eb9e:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			for (precision = 0; ; ++fmt) {
  80eba1:	b8 00 00 00 00       	mov    $0x0,%eax
  80eba6:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
				precision = precision * 10 + ch - '0';
  80eba9:	8d 04 80             	lea    (%eax,%eax,4),%eax
  80ebac:	8d 44 42 d0          	lea    -0x30(%edx,%eax,2),%eax
				ch = *fmt;
  80ebb0:	0f be 17             	movsbl (%edi),%edx
				if (ch < '0' || ch > '9')
  80ebb3:	8d 4a d0             	lea    -0x30(%edx),%ecx
  80ebb6:	83 f9 09             	cmp    $0x9,%ecx
  80ebb9:	77 55                	ja     80ec10 <vprintfmt+0xdf>
			for (precision = 0; ; ++fmt) {
  80ebbb:	83 c7 01             	add    $0x1,%edi
				precision = precision * 10 + ch - '0';
  80ebbe:	eb e9                	jmp    80eba9 <vprintfmt+0x78>
			precision = va_arg(ap, int);
  80ebc0:	8b 45 14             	mov    0x14(%ebp),%eax
  80ebc3:	8b 00                	mov    (%eax),%eax
  80ebc5:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80ebc8:	8b 45 14             	mov    0x14(%ebp),%eax
  80ebcb:	8d 40 04             	lea    0x4(%eax),%eax
  80ebce:	89 45 14             	mov    %eax,0x14(%ebp)
		switch (ch = *(unsigned char *) fmt++) {
  80ebd1:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			if (width < 0)
  80ebd4:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  80ebd8:	79 90                	jns    80eb6a <vprintfmt+0x39>
				width = precision, precision = -1;
  80ebda:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80ebdd:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80ebe0:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%ebp)
  80ebe7:	eb 81                	jmp    80eb6a <vprintfmt+0x39>
  80ebe9:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80ebec:	85 c0                	test   %eax,%eax
  80ebee:	ba 00 00 00 00       	mov    $0x0,%edx
  80ebf3:	0f 49 d0             	cmovns %eax,%edx
  80ebf6:	89 55 e0             	mov    %edx,-0x20(%ebp)
		switch (ch = *(unsigned char *) fmt++) {
  80ebf9:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			goto reswitch;
  80ebfc:	e9 69 ff ff ff       	jmp    80eb6a <vprintfmt+0x39>
		switch (ch = *(unsigned char *) fmt++) {
  80ec01:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			altflag = 1;
  80ec04:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
			goto reswitch;
  80ec0b:	e9 5a ff ff ff       	jmp    80eb6a <vprintfmt+0x39>
  80ec10:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80ec13:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80ec16:	eb bc                	jmp    80ebd4 <vprintfmt+0xa3>
			lflag++;
  80ec18:	83 c1 01             	add    $0x1,%ecx
		switch (ch = *(unsigned char *) fmt++) {
  80ec1b:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			goto reswitch;
  80ec1e:	e9 47 ff ff ff       	jmp    80eb6a <vprintfmt+0x39>
			putch(va_arg(ap, int), putdat);
  80ec23:	8b 45 14             	mov    0x14(%ebp),%eax
  80ec26:	8d 78 04             	lea    0x4(%eax),%edi
  80ec29:	83 ec 08             	sub    $0x8,%esp
  80ec2c:	53                   	push   %ebx
  80ec2d:	ff 30                	pushl  (%eax)
  80ec2f:	ff d6                	call   *%esi
			break;
  80ec31:	83 c4 10             	add    $0x10,%esp
			putch(va_arg(ap, int), putdat);
  80ec34:	89 7d 14             	mov    %edi,0x14(%ebp)
			break;
  80ec37:	e9 9b 02 00 00       	jmp    80eed7 <vprintfmt+0x3a6>
			err = va_arg(ap, int);
  80ec3c:	8b 45 14             	mov    0x14(%ebp),%eax
  80ec3f:	8d 78 04             	lea    0x4(%eax),%edi
  80ec42:	8b 00                	mov    (%eax),%eax
  80ec44:	99                   	cltd   
  80ec45:	31 d0                	xor    %edx,%eax
  80ec47:	29 d0                	sub    %edx,%eax
			if (err >= MAXERROR || (p = error_string[err]) == NULL)
  80ec49:	83 f8 0f             	cmp    $0xf,%eax
  80ec4c:	7f 23                	jg     80ec71 <vprintfmt+0x140>
  80ec4e:	8b 14 85 c0 3b 81 00 	mov    0x813bc0(,%eax,4),%edx
  80ec55:	85 d2                	test   %edx,%edx
  80ec57:	74 18                	je     80ec71 <vprintfmt+0x140>
				printfmt(putch, putdat, "%s", p);
  80ec59:	52                   	push   %edx
  80ec5a:	68 fd 2a 81 00       	push   $0x812afd
  80ec5f:	53                   	push   %ebx
  80ec60:	56                   	push   %esi
  80ec61:	e8 aa fe ff ff       	call   80eb10 <printfmt>
  80ec66:	83 c4 10             	add    $0x10,%esp
			err = va_arg(ap, int);
  80ec69:	89 7d 14             	mov    %edi,0x14(%ebp)
  80ec6c:	e9 66 02 00 00       	jmp    80eed7 <vprintfmt+0x3a6>
				printfmt(putch, putdat, "error %d", err);
  80ec71:	50                   	push   %eax
  80ec72:	68 2f 39 81 00       	push   $0x81392f
  80ec77:	53                   	push   %ebx
  80ec78:	56                   	push   %esi
  80ec79:	e8 92 fe ff ff       	call   80eb10 <printfmt>
  80ec7e:	83 c4 10             	add    $0x10,%esp
			err = va_arg(ap, int);
  80ec81:	89 7d 14             	mov    %edi,0x14(%ebp)
				printfmt(putch, putdat, "error %d", err);
  80ec84:	e9 4e 02 00 00       	jmp    80eed7 <vprintfmt+0x3a6>
			if ((p = va_arg(ap, char *)) == NULL)
  80ec89:	8b 45 14             	mov    0x14(%ebp),%eax
  80ec8c:	83 c0 04             	add    $0x4,%eax
  80ec8f:	89 45 c8             	mov    %eax,-0x38(%ebp)
  80ec92:	8b 45 14             	mov    0x14(%ebp),%eax
  80ec95:	8b 10                	mov    (%eax),%edx
				p = "(null)";
  80ec97:	85 d2                	test   %edx,%edx
  80ec99:	b8 28 39 81 00       	mov    $0x813928,%eax
  80ec9e:	0f 45 c2             	cmovne %edx,%eax
  80eca1:	89 45 cc             	mov    %eax,-0x34(%ebp)
			if (width > 0 && padc != '-')
  80eca4:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  80eca8:	7e 06                	jle    80ecb0 <vprintfmt+0x17f>
  80ecaa:	80 7d d3 2d          	cmpb   $0x2d,-0x2d(%ebp)
  80ecae:	75 0d                	jne    80ecbd <vprintfmt+0x18c>
				for (width -= strnlen(p, precision); width > 0; width--)
  80ecb0:	8b 45 cc             	mov    -0x34(%ebp),%eax
  80ecb3:	89 c7                	mov    %eax,%edi
  80ecb5:	03 45 e0             	add    -0x20(%ebp),%eax
  80ecb8:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80ecbb:	eb 55                	jmp    80ed12 <vprintfmt+0x1e1>
  80ecbd:	83 ec 08             	sub    $0x8,%esp
  80ecc0:	ff 75 d8             	pushl  -0x28(%ebp)
  80ecc3:	ff 75 cc             	pushl  -0x34(%ebp)
  80ecc6:	e8 46 03 00 00       	call   80f011 <strnlen>
  80eccb:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80ecce:	29 c2                	sub    %eax,%edx
  80ecd0:	89 55 c4             	mov    %edx,-0x3c(%ebp)
  80ecd3:	83 c4 10             	add    $0x10,%esp
  80ecd6:	89 d7                	mov    %edx,%edi
					putch(padc, putdat);
  80ecd8:	0f be 45 d3          	movsbl -0x2d(%ebp),%eax
  80ecdc:	89 45 e0             	mov    %eax,-0x20(%ebp)
				for (width -= strnlen(p, precision); width > 0; width--)
  80ecdf:	85 ff                	test   %edi,%edi
  80ece1:	7e 11                	jle    80ecf4 <vprintfmt+0x1c3>
					putch(padc, putdat);
  80ece3:	83 ec 08             	sub    $0x8,%esp
  80ece6:	53                   	push   %ebx
  80ece7:	ff 75 e0             	pushl  -0x20(%ebp)
  80ecea:	ff d6                	call   *%esi
				for (width -= strnlen(p, precision); width > 0; width--)
  80ecec:	83 ef 01             	sub    $0x1,%edi
  80ecef:	83 c4 10             	add    $0x10,%esp
  80ecf2:	eb eb                	jmp    80ecdf <vprintfmt+0x1ae>
  80ecf4:	8b 55 c4             	mov    -0x3c(%ebp),%edx
  80ecf7:	85 d2                	test   %edx,%edx
  80ecf9:	b8 00 00 00 00       	mov    $0x0,%eax
  80ecfe:	0f 49 c2             	cmovns %edx,%eax
  80ed01:	29 c2                	sub    %eax,%edx
  80ed03:	89 55 e0             	mov    %edx,-0x20(%ebp)
  80ed06:	eb a8                	jmp    80ecb0 <vprintfmt+0x17f>
					putch(ch, putdat);
  80ed08:	83 ec 08             	sub    $0x8,%esp
  80ed0b:	53                   	push   %ebx
  80ed0c:	52                   	push   %edx
  80ed0d:	ff d6                	call   *%esi
  80ed0f:	83 c4 10             	add    $0x10,%esp
  80ed12:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  80ed15:	29 f9                	sub    %edi,%ecx
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  80ed17:	83 c7 01             	add    $0x1,%edi
  80ed1a:	0f b6 47 ff          	movzbl -0x1(%edi),%eax
  80ed1e:	0f be d0             	movsbl %al,%edx
  80ed21:	85 d2                	test   %edx,%edx
  80ed23:	74 4b                	je     80ed70 <vprintfmt+0x23f>
  80ed25:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
  80ed29:	78 06                	js     80ed31 <vprintfmt+0x200>
  80ed2b:	83 6d d8 01          	subl   $0x1,-0x28(%ebp)
  80ed2f:	78 1e                	js     80ed4f <vprintfmt+0x21e>
				if (altflag && (ch < ' ' || ch > '~'))
  80ed31:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
  80ed35:	74 d1                	je     80ed08 <vprintfmt+0x1d7>
  80ed37:	0f be c0             	movsbl %al,%eax
  80ed3a:	83 e8 20             	sub    $0x20,%eax
  80ed3d:	83 f8 5e             	cmp    $0x5e,%eax
  80ed40:	76 c6                	jbe    80ed08 <vprintfmt+0x1d7>
					putch('?', putdat);
  80ed42:	83 ec 08             	sub    $0x8,%esp
  80ed45:	53                   	push   %ebx
  80ed46:	6a 3f                	push   $0x3f
  80ed48:	ff d6                	call   *%esi
  80ed4a:	83 c4 10             	add    $0x10,%esp
  80ed4d:	eb c3                	jmp    80ed12 <vprintfmt+0x1e1>
  80ed4f:	89 cf                	mov    %ecx,%edi
  80ed51:	eb 0e                	jmp    80ed61 <vprintfmt+0x230>
				putch(' ', putdat);
  80ed53:	83 ec 08             	sub    $0x8,%esp
  80ed56:	53                   	push   %ebx
  80ed57:	6a 20                	push   $0x20
  80ed59:	ff d6                	call   *%esi
			for (; width > 0; width--)
  80ed5b:	83 ef 01             	sub    $0x1,%edi
  80ed5e:	83 c4 10             	add    $0x10,%esp
  80ed61:	85 ff                	test   %edi,%edi
  80ed63:	7f ee                	jg     80ed53 <vprintfmt+0x222>
			if ((p = va_arg(ap, char *)) == NULL)
  80ed65:	8b 45 c8             	mov    -0x38(%ebp),%eax
  80ed68:	89 45 14             	mov    %eax,0x14(%ebp)
  80ed6b:	e9 67 01 00 00       	jmp    80eed7 <vprintfmt+0x3a6>
  80ed70:	89 cf                	mov    %ecx,%edi
  80ed72:	eb ed                	jmp    80ed61 <vprintfmt+0x230>
	if (lflag >= 2)
  80ed74:	83 f9 01             	cmp    $0x1,%ecx
  80ed77:	7f 1b                	jg     80ed94 <vprintfmt+0x263>
	else if (lflag)
  80ed79:	85 c9                	test   %ecx,%ecx
  80ed7b:	74 63                	je     80ede0 <vprintfmt+0x2af>
		return va_arg(*ap, long);
  80ed7d:	8b 45 14             	mov    0x14(%ebp),%eax
  80ed80:	8b 00                	mov    (%eax),%eax
  80ed82:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80ed85:	99                   	cltd   
  80ed86:	89 55 dc             	mov    %edx,-0x24(%ebp)
  80ed89:	8b 45 14             	mov    0x14(%ebp),%eax
  80ed8c:	8d 40 04             	lea    0x4(%eax),%eax
  80ed8f:	89 45 14             	mov    %eax,0x14(%ebp)
  80ed92:	eb 17                	jmp    80edab <vprintfmt+0x27a>
		return va_arg(*ap, long long);
  80ed94:	8b 45 14             	mov    0x14(%ebp),%eax
  80ed97:	8b 50 04             	mov    0x4(%eax),%edx
  80ed9a:	8b 00                	mov    (%eax),%eax
  80ed9c:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80ed9f:	89 55 dc             	mov    %edx,-0x24(%ebp)
  80eda2:	8b 45 14             	mov    0x14(%ebp),%eax
  80eda5:	8d 40 08             	lea    0x8(%eax),%eax
  80eda8:	89 45 14             	mov    %eax,0x14(%ebp)
			if ((long long) num < 0) {
  80edab:	8b 55 d8             	mov    -0x28(%ebp),%edx
  80edae:	8b 4d dc             	mov    -0x24(%ebp),%ecx
			base = 10;
  80edb1:	b8 0a 00 00 00       	mov    $0xa,%eax
			if ((long long) num < 0) {
  80edb6:	85 c9                	test   %ecx,%ecx
  80edb8:	0f 89 ff 00 00 00    	jns    80eebd <vprintfmt+0x38c>
				putch('-', putdat);
  80edbe:	83 ec 08             	sub    $0x8,%esp
  80edc1:	53                   	push   %ebx
  80edc2:	6a 2d                	push   $0x2d
  80edc4:	ff d6                	call   *%esi
				num = -(long long) num;
  80edc6:	8b 55 d8             	mov    -0x28(%ebp),%edx
  80edc9:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  80edcc:	f7 da                	neg    %edx
  80edce:	83 d1 00             	adc    $0x0,%ecx
  80edd1:	f7 d9                	neg    %ecx
  80edd3:	83 c4 10             	add    $0x10,%esp
			base = 10;
  80edd6:	b8 0a 00 00 00       	mov    $0xa,%eax
  80eddb:	e9 dd 00 00 00       	jmp    80eebd <vprintfmt+0x38c>
		return va_arg(*ap, int);
  80ede0:	8b 45 14             	mov    0x14(%ebp),%eax
  80ede3:	8b 00                	mov    (%eax),%eax
  80ede5:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80ede8:	99                   	cltd   
  80ede9:	89 55 dc             	mov    %edx,-0x24(%ebp)
  80edec:	8b 45 14             	mov    0x14(%ebp),%eax
  80edef:	8d 40 04             	lea    0x4(%eax),%eax
  80edf2:	89 45 14             	mov    %eax,0x14(%ebp)
  80edf5:	eb b4                	jmp    80edab <vprintfmt+0x27a>
	if (lflag >= 2)
  80edf7:	83 f9 01             	cmp    $0x1,%ecx
  80edfa:	7f 1e                	jg     80ee1a <vprintfmt+0x2e9>
	else if (lflag)
  80edfc:	85 c9                	test   %ecx,%ecx
  80edfe:	74 32                	je     80ee32 <vprintfmt+0x301>
		return va_arg(*ap, unsigned long);
  80ee00:	8b 45 14             	mov    0x14(%ebp),%eax
  80ee03:	8b 10                	mov    (%eax),%edx
  80ee05:	b9 00 00 00 00       	mov    $0x0,%ecx
  80ee0a:	8d 40 04             	lea    0x4(%eax),%eax
  80ee0d:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 10;
  80ee10:	b8 0a 00 00 00       	mov    $0xa,%eax
		return va_arg(*ap, unsigned long);
  80ee15:	e9 a3 00 00 00       	jmp    80eebd <vprintfmt+0x38c>
		return va_arg(*ap, unsigned long long);
  80ee1a:	8b 45 14             	mov    0x14(%ebp),%eax
  80ee1d:	8b 10                	mov    (%eax),%edx
  80ee1f:	8b 48 04             	mov    0x4(%eax),%ecx
  80ee22:	8d 40 08             	lea    0x8(%eax),%eax
  80ee25:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 10;
  80ee28:	b8 0a 00 00 00       	mov    $0xa,%eax
		return va_arg(*ap, unsigned long long);
  80ee2d:	e9 8b 00 00 00       	jmp    80eebd <vprintfmt+0x38c>
		return va_arg(*ap, unsigned int);
  80ee32:	8b 45 14             	mov    0x14(%ebp),%eax
  80ee35:	8b 10                	mov    (%eax),%edx
  80ee37:	b9 00 00 00 00       	mov    $0x0,%ecx
  80ee3c:	8d 40 04             	lea    0x4(%eax),%eax
  80ee3f:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 10;
  80ee42:	b8 0a 00 00 00       	mov    $0xa,%eax
		return va_arg(*ap, unsigned int);
  80ee47:	eb 74                	jmp    80eebd <vprintfmt+0x38c>
	if (lflag >= 2)
  80ee49:	83 f9 01             	cmp    $0x1,%ecx
  80ee4c:	7f 1b                	jg     80ee69 <vprintfmt+0x338>
	else if (lflag)
  80ee4e:	85 c9                	test   %ecx,%ecx
  80ee50:	74 2c                	je     80ee7e <vprintfmt+0x34d>
		return va_arg(*ap, unsigned long);
  80ee52:	8b 45 14             	mov    0x14(%ebp),%eax
  80ee55:	8b 10                	mov    (%eax),%edx
  80ee57:	b9 00 00 00 00       	mov    $0x0,%ecx
  80ee5c:	8d 40 04             	lea    0x4(%eax),%eax
  80ee5f:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 8;
  80ee62:	b8 08 00 00 00       	mov    $0x8,%eax
		return va_arg(*ap, unsigned long);
  80ee67:	eb 54                	jmp    80eebd <vprintfmt+0x38c>
		return va_arg(*ap, unsigned long long);
  80ee69:	8b 45 14             	mov    0x14(%ebp),%eax
  80ee6c:	8b 10                	mov    (%eax),%edx
  80ee6e:	8b 48 04             	mov    0x4(%eax),%ecx
  80ee71:	8d 40 08             	lea    0x8(%eax),%eax
  80ee74:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 8;
  80ee77:	b8 08 00 00 00       	mov    $0x8,%eax
		return va_arg(*ap, unsigned long long);
  80ee7c:	eb 3f                	jmp    80eebd <vprintfmt+0x38c>
		return va_arg(*ap, unsigned int);
  80ee7e:	8b 45 14             	mov    0x14(%ebp),%eax
  80ee81:	8b 10                	mov    (%eax),%edx
  80ee83:	b9 00 00 00 00       	mov    $0x0,%ecx
  80ee88:	8d 40 04             	lea    0x4(%eax),%eax
  80ee8b:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 8;
  80ee8e:	b8 08 00 00 00       	mov    $0x8,%eax
		return va_arg(*ap, unsigned int);
  80ee93:	eb 28                	jmp    80eebd <vprintfmt+0x38c>
			putch('0', putdat);
  80ee95:	83 ec 08             	sub    $0x8,%esp
  80ee98:	53                   	push   %ebx
  80ee99:	6a 30                	push   $0x30
  80ee9b:	ff d6                	call   *%esi
			putch('x', putdat);
  80ee9d:	83 c4 08             	add    $0x8,%esp
  80eea0:	53                   	push   %ebx
  80eea1:	6a 78                	push   $0x78
  80eea3:	ff d6                	call   *%esi
			num = (unsigned long long)
  80eea5:	8b 45 14             	mov    0x14(%ebp),%eax
  80eea8:	8b 10                	mov    (%eax),%edx
  80eeaa:	b9 00 00 00 00       	mov    $0x0,%ecx
			goto number;
  80eeaf:	83 c4 10             	add    $0x10,%esp
				(uintptr_t) va_arg(ap, void *);
  80eeb2:	8d 40 04             	lea    0x4(%eax),%eax
  80eeb5:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 16;
  80eeb8:	b8 10 00 00 00       	mov    $0x10,%eax
			printnum(putch, putdat, num, base, width, padc);
  80eebd:	83 ec 0c             	sub    $0xc,%esp
  80eec0:	0f be 7d d3          	movsbl -0x2d(%ebp),%edi
  80eec4:	57                   	push   %edi
  80eec5:	ff 75 e0             	pushl  -0x20(%ebp)
  80eec8:	50                   	push   %eax
  80eec9:	51                   	push   %ecx
  80eeca:	52                   	push   %edx
  80eecb:	89 da                	mov    %ebx,%edx
  80eecd:	89 f0                	mov    %esi,%eax
  80eecf:	e8 72 fb ff ff       	call   80ea46 <printnum>
			break;
  80eed4:	83 c4 20             	add    $0x20,%esp
			if ((p = va_arg(ap, char *)) == NULL)
  80eed7:	8b 7d e4             	mov    -0x1c(%ebp),%edi
		while ((ch = *(unsigned char *) fmt++) != '%') {
  80eeda:	83 c7 01             	add    $0x1,%edi
  80eedd:	0f b6 47 ff          	movzbl -0x1(%edi),%eax
  80eee1:	83 f8 25             	cmp    $0x25,%eax
  80eee4:	0f 84 62 fc ff ff    	je     80eb4c <vprintfmt+0x1b>
			if (ch == '\0')
  80eeea:	85 c0                	test   %eax,%eax
  80eeec:	0f 84 8b 00 00 00    	je     80ef7d <vprintfmt+0x44c>
			putch(ch, putdat);
  80eef2:	83 ec 08             	sub    $0x8,%esp
  80eef5:	53                   	push   %ebx
  80eef6:	50                   	push   %eax
  80eef7:	ff d6                	call   *%esi
  80eef9:	83 c4 10             	add    $0x10,%esp
  80eefc:	eb dc                	jmp    80eeda <vprintfmt+0x3a9>
	if (lflag >= 2)
  80eefe:	83 f9 01             	cmp    $0x1,%ecx
  80ef01:	7f 1b                	jg     80ef1e <vprintfmt+0x3ed>
	else if (lflag)
  80ef03:	85 c9                	test   %ecx,%ecx
  80ef05:	74 2c                	je     80ef33 <vprintfmt+0x402>
		return va_arg(*ap, unsigned long);
  80ef07:	8b 45 14             	mov    0x14(%ebp),%eax
  80ef0a:	8b 10                	mov    (%eax),%edx
  80ef0c:	b9 00 00 00 00       	mov    $0x0,%ecx
  80ef11:	8d 40 04             	lea    0x4(%eax),%eax
  80ef14:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 16;
  80ef17:	b8 10 00 00 00       	mov    $0x10,%eax
		return va_arg(*ap, unsigned long);
  80ef1c:	eb 9f                	jmp    80eebd <vprintfmt+0x38c>
		return va_arg(*ap, unsigned long long);
  80ef1e:	8b 45 14             	mov    0x14(%ebp),%eax
  80ef21:	8b 10                	mov    (%eax),%edx
  80ef23:	8b 48 04             	mov    0x4(%eax),%ecx
  80ef26:	8d 40 08             	lea    0x8(%eax),%eax
  80ef29:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 16;
  80ef2c:	b8 10 00 00 00       	mov    $0x10,%eax
		return va_arg(*ap, unsigned long long);
  80ef31:	eb 8a                	jmp    80eebd <vprintfmt+0x38c>
		return va_arg(*ap, unsigned int);
  80ef33:	8b 45 14             	mov    0x14(%ebp),%eax
  80ef36:	8b 10                	mov    (%eax),%edx
  80ef38:	b9 00 00 00 00       	mov    $0x0,%ecx
  80ef3d:	8d 40 04             	lea    0x4(%eax),%eax
  80ef40:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 16;
  80ef43:	b8 10 00 00 00       	mov    $0x10,%eax
		return va_arg(*ap, unsigned int);
  80ef48:	e9 70 ff ff ff       	jmp    80eebd <vprintfmt+0x38c>
			putch(ch, putdat);
  80ef4d:	83 ec 08             	sub    $0x8,%esp
  80ef50:	53                   	push   %ebx
  80ef51:	6a 25                	push   $0x25
  80ef53:	ff d6                	call   *%esi
			break;
  80ef55:	83 c4 10             	add    $0x10,%esp
  80ef58:	e9 7a ff ff ff       	jmp    80eed7 <vprintfmt+0x3a6>
			putch('%', putdat);
  80ef5d:	83 ec 08             	sub    $0x8,%esp
  80ef60:	53                   	push   %ebx
  80ef61:	6a 25                	push   $0x25
  80ef63:	ff d6                	call   *%esi
			for (fmt--; fmt[-1] != '%'; fmt--)
  80ef65:	83 c4 10             	add    $0x10,%esp
  80ef68:	89 f8                	mov    %edi,%eax
  80ef6a:	80 78 ff 25          	cmpb   $0x25,-0x1(%eax)
  80ef6e:	74 05                	je     80ef75 <vprintfmt+0x444>
  80ef70:	83 e8 01             	sub    $0x1,%eax
  80ef73:	eb f5                	jmp    80ef6a <vprintfmt+0x439>
  80ef75:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80ef78:	e9 5a ff ff ff       	jmp    80eed7 <vprintfmt+0x3a6>
}
  80ef7d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80ef80:	5b                   	pop    %ebx
  80ef81:	5e                   	pop    %esi
  80ef82:	5f                   	pop    %edi
  80ef83:	5d                   	pop    %ebp
  80ef84:	c3                   	ret    

0080ef85 <vsnprintf>:

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
  80ef85:	f3 0f 1e fb          	endbr32 
  80ef89:	55                   	push   %ebp
  80ef8a:	89 e5                	mov    %esp,%ebp
  80ef8c:	83 ec 18             	sub    $0x18,%esp
  80ef8f:	8b 45 08             	mov    0x8(%ebp),%eax
  80ef92:	8b 55 0c             	mov    0xc(%ebp),%edx
	struct sprintbuf b = {buf, buf+n-1, 0};
  80ef95:	89 45 ec             	mov    %eax,-0x14(%ebp)
  80ef98:	8d 4c 10 ff          	lea    -0x1(%eax,%edx,1),%ecx
  80ef9c:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  80ef9f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	if (buf == NULL || n < 1)
  80efa6:	85 c0                	test   %eax,%eax
  80efa8:	74 26                	je     80efd0 <vsnprintf+0x4b>
  80efaa:	85 d2                	test   %edx,%edx
  80efac:	7e 22                	jle    80efd0 <vsnprintf+0x4b>
		return -E_INVAL;

	// print the string to the buffer
	vprintfmt((void*)sprintputch, &b, fmt, ap);
  80efae:	ff 75 14             	pushl  0x14(%ebp)
  80efb1:	ff 75 10             	pushl  0x10(%ebp)
  80efb4:	8d 45 ec             	lea    -0x14(%ebp),%eax
  80efb7:	50                   	push   %eax
  80efb8:	68 ef ea 80 00       	push   $0x80eaef
  80efbd:	e8 6f fb ff ff       	call   80eb31 <vprintfmt>

	// null terminate the buffer
	*b.buf = '\0';
  80efc2:	8b 45 ec             	mov    -0x14(%ebp),%eax
  80efc5:	c6 00 00             	movb   $0x0,(%eax)

	return b.cnt;
  80efc8:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80efcb:	83 c4 10             	add    $0x10,%esp
}
  80efce:	c9                   	leave  
  80efcf:	c3                   	ret    
		return -E_INVAL;
  80efd0:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80efd5:	eb f7                	jmp    80efce <vsnprintf+0x49>

0080efd7 <snprintf>:

int
snprintf(char *buf, int n, const char *fmt, ...)
{
  80efd7:	f3 0f 1e fb          	endbr32 
  80efdb:	55                   	push   %ebp
  80efdc:	89 e5                	mov    %esp,%ebp
  80efde:	83 ec 08             	sub    $0x8,%esp
	va_list ap;
	int rc;

	va_start(ap, fmt);
  80efe1:	8d 45 14             	lea    0x14(%ebp),%eax
	rc = vsnprintf(buf, n, fmt, ap);
  80efe4:	50                   	push   %eax
  80efe5:	ff 75 10             	pushl  0x10(%ebp)
  80efe8:	ff 75 0c             	pushl  0xc(%ebp)
  80efeb:	ff 75 08             	pushl  0x8(%ebp)
  80efee:	e8 92 ff ff ff       	call   80ef85 <vsnprintf>
	va_end(ap);

	return rc;
}
  80eff3:	c9                   	leave  
  80eff4:	c3                   	ret    

0080eff5 <strlen>:
// Primespipe runs 3x faster this way.
#define ASM 1

int
strlen(const char *s)
{
  80eff5:	f3 0f 1e fb          	endbr32 
  80eff9:	55                   	push   %ebp
  80effa:	89 e5                	mov    %esp,%ebp
  80effc:	8b 55 08             	mov    0x8(%ebp),%edx
	int n;

	for (n = 0; *s != '\0'; s++)
  80efff:	b8 00 00 00 00       	mov    $0x0,%eax
  80f004:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
  80f008:	74 05                	je     80f00f <strlen+0x1a>
		n++;
  80f00a:	83 c0 01             	add    $0x1,%eax
  80f00d:	eb f5                	jmp    80f004 <strlen+0xf>
	return n;
}
  80f00f:	5d                   	pop    %ebp
  80f010:	c3                   	ret    

0080f011 <strnlen>:

int
strnlen(const char *s, size_t size)
{
  80f011:	f3 0f 1e fb          	endbr32 
  80f015:	55                   	push   %ebp
  80f016:	89 e5                	mov    %esp,%ebp
  80f018:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80f01b:	8b 55 0c             	mov    0xc(%ebp),%edx
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  80f01e:	b8 00 00 00 00       	mov    $0x0,%eax
  80f023:	39 d0                	cmp    %edx,%eax
  80f025:	74 0d                	je     80f034 <strnlen+0x23>
  80f027:	80 3c 01 00          	cmpb   $0x0,(%ecx,%eax,1)
  80f02b:	74 05                	je     80f032 <strnlen+0x21>
		n++;
  80f02d:	83 c0 01             	add    $0x1,%eax
  80f030:	eb f1                	jmp    80f023 <strnlen+0x12>
  80f032:	89 c2                	mov    %eax,%edx
	return n;
}
  80f034:	89 d0                	mov    %edx,%eax
  80f036:	5d                   	pop    %ebp
  80f037:	c3                   	ret    

0080f038 <strcpy>:

char *
strcpy(char *dst, const char *src)
{
  80f038:	f3 0f 1e fb          	endbr32 
  80f03c:	55                   	push   %ebp
  80f03d:	89 e5                	mov    %esp,%ebp
  80f03f:	53                   	push   %ebx
  80f040:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80f043:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	char *ret;

	ret = dst;
	while ((*dst++ = *src++) != '\0')
  80f046:	b8 00 00 00 00       	mov    $0x0,%eax
  80f04b:	0f b6 14 03          	movzbl (%ebx,%eax,1),%edx
  80f04f:	88 14 01             	mov    %dl,(%ecx,%eax,1)
  80f052:	83 c0 01             	add    $0x1,%eax
  80f055:	84 d2                	test   %dl,%dl
  80f057:	75 f2                	jne    80f04b <strcpy+0x13>
		/* do nothing */;
	return ret;
}
  80f059:	89 c8                	mov    %ecx,%eax
  80f05b:	5b                   	pop    %ebx
  80f05c:	5d                   	pop    %ebp
  80f05d:	c3                   	ret    

0080f05e <strcat>:

char *
strcat(char *dst, const char *src)
{
  80f05e:	f3 0f 1e fb          	endbr32 
  80f062:	55                   	push   %ebp
  80f063:	89 e5                	mov    %esp,%ebp
  80f065:	53                   	push   %ebx
  80f066:	83 ec 10             	sub    $0x10,%esp
  80f069:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int len = strlen(dst);
  80f06c:	53                   	push   %ebx
  80f06d:	e8 83 ff ff ff       	call   80eff5 <strlen>
  80f072:	83 c4 08             	add    $0x8,%esp
	strcpy(dst + len, src);
  80f075:	ff 75 0c             	pushl  0xc(%ebp)
  80f078:	01 d8                	add    %ebx,%eax
  80f07a:	50                   	push   %eax
  80f07b:	e8 b8 ff ff ff       	call   80f038 <strcpy>
	return dst;
}
  80f080:	89 d8                	mov    %ebx,%eax
  80f082:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80f085:	c9                   	leave  
  80f086:	c3                   	ret    

0080f087 <strncpy>:

char *
strncpy(char *dst, const char *src, size_t size) {
  80f087:	f3 0f 1e fb          	endbr32 
  80f08b:	55                   	push   %ebp
  80f08c:	89 e5                	mov    %esp,%ebp
  80f08e:	56                   	push   %esi
  80f08f:	53                   	push   %ebx
  80f090:	8b 75 08             	mov    0x8(%ebp),%esi
  80f093:	8b 55 0c             	mov    0xc(%ebp),%edx
  80f096:	89 f3                	mov    %esi,%ebx
  80f098:	03 5d 10             	add    0x10(%ebp),%ebx
	size_t i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
  80f09b:	89 f0                	mov    %esi,%eax
  80f09d:	39 d8                	cmp    %ebx,%eax
  80f09f:	74 11                	je     80f0b2 <strncpy+0x2b>
		*dst++ = *src;
  80f0a1:	83 c0 01             	add    $0x1,%eax
  80f0a4:	0f b6 0a             	movzbl (%edx),%ecx
  80f0a7:	88 48 ff             	mov    %cl,-0x1(%eax)
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
  80f0aa:	80 f9 01             	cmp    $0x1,%cl
  80f0ad:	83 da ff             	sbb    $0xffffffff,%edx
  80f0b0:	eb eb                	jmp    80f09d <strncpy+0x16>
	}
	return ret;
}
  80f0b2:	89 f0                	mov    %esi,%eax
  80f0b4:	5b                   	pop    %ebx
  80f0b5:	5e                   	pop    %esi
  80f0b6:	5d                   	pop    %ebp
  80f0b7:	c3                   	ret    

0080f0b8 <strlcpy>:

size_t
strlcpy(char *dst, const char *src, size_t size)
{
  80f0b8:	f3 0f 1e fb          	endbr32 
  80f0bc:	55                   	push   %ebp
  80f0bd:	89 e5                	mov    %esp,%ebp
  80f0bf:	56                   	push   %esi
  80f0c0:	53                   	push   %ebx
  80f0c1:	8b 75 08             	mov    0x8(%ebp),%esi
  80f0c4:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f0c7:	8b 55 10             	mov    0x10(%ebp),%edx
  80f0ca:	89 f0                	mov    %esi,%eax
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
  80f0cc:	85 d2                	test   %edx,%edx
  80f0ce:	74 21                	je     80f0f1 <strlcpy+0x39>
  80f0d0:	8d 44 16 ff          	lea    -0x1(%esi,%edx,1),%eax
  80f0d4:	89 f2                	mov    %esi,%edx
		while (--size > 0 && *src != '\0')
  80f0d6:	39 c2                	cmp    %eax,%edx
  80f0d8:	74 14                	je     80f0ee <strlcpy+0x36>
  80f0da:	0f b6 19             	movzbl (%ecx),%ebx
  80f0dd:	84 db                	test   %bl,%bl
  80f0df:	74 0b                	je     80f0ec <strlcpy+0x34>
			*dst++ = *src++;
  80f0e1:	83 c1 01             	add    $0x1,%ecx
  80f0e4:	83 c2 01             	add    $0x1,%edx
  80f0e7:	88 5a ff             	mov    %bl,-0x1(%edx)
  80f0ea:	eb ea                	jmp    80f0d6 <strlcpy+0x1e>
  80f0ec:	89 d0                	mov    %edx,%eax
		*dst = '\0';
  80f0ee:	c6 00 00             	movb   $0x0,(%eax)
	}
	return dst - dst_in;
  80f0f1:	29 f0                	sub    %esi,%eax
}
  80f0f3:	5b                   	pop    %ebx
  80f0f4:	5e                   	pop    %esi
  80f0f5:	5d                   	pop    %ebp
  80f0f6:	c3                   	ret    

0080f0f7 <strcmp>:

int
strcmp(const char *p, const char *q)
{
  80f0f7:	f3 0f 1e fb          	endbr32 
  80f0fb:	55                   	push   %ebp
  80f0fc:	89 e5                	mov    %esp,%ebp
  80f0fe:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80f101:	8b 55 0c             	mov    0xc(%ebp),%edx
	while (*p && *p == *q)
  80f104:	0f b6 01             	movzbl (%ecx),%eax
  80f107:	84 c0                	test   %al,%al
  80f109:	74 0c                	je     80f117 <strcmp+0x20>
  80f10b:	3a 02                	cmp    (%edx),%al
  80f10d:	75 08                	jne    80f117 <strcmp+0x20>
		p++, q++;
  80f10f:	83 c1 01             	add    $0x1,%ecx
  80f112:	83 c2 01             	add    $0x1,%edx
  80f115:	eb ed                	jmp    80f104 <strcmp+0xd>
	return (int) ((unsigned char) *p - (unsigned char) *q);
  80f117:	0f b6 c0             	movzbl %al,%eax
  80f11a:	0f b6 12             	movzbl (%edx),%edx
  80f11d:	29 d0                	sub    %edx,%eax
}
  80f11f:	5d                   	pop    %ebp
  80f120:	c3                   	ret    

0080f121 <strncmp>:

int
strncmp(const char *p, const char *q, size_t n)
{
  80f121:	f3 0f 1e fb          	endbr32 
  80f125:	55                   	push   %ebp
  80f126:	89 e5                	mov    %esp,%ebp
  80f128:	53                   	push   %ebx
  80f129:	8b 45 08             	mov    0x8(%ebp),%eax
  80f12c:	8b 55 0c             	mov    0xc(%ebp),%edx
  80f12f:	89 c3                	mov    %eax,%ebx
  80f131:	03 5d 10             	add    0x10(%ebp),%ebx
	while (n > 0 && *p && *p == *q)
  80f134:	eb 06                	jmp    80f13c <strncmp+0x1b>
		n--, p++, q++;
  80f136:	83 c0 01             	add    $0x1,%eax
  80f139:	83 c2 01             	add    $0x1,%edx
	while (n > 0 && *p && *p == *q)
  80f13c:	39 d8                	cmp    %ebx,%eax
  80f13e:	74 16                	je     80f156 <strncmp+0x35>
  80f140:	0f b6 08             	movzbl (%eax),%ecx
  80f143:	84 c9                	test   %cl,%cl
  80f145:	74 04                	je     80f14b <strncmp+0x2a>
  80f147:	3a 0a                	cmp    (%edx),%cl
  80f149:	74 eb                	je     80f136 <strncmp+0x15>
	if (n == 0)
		return 0;
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
  80f14b:	0f b6 00             	movzbl (%eax),%eax
  80f14e:	0f b6 12             	movzbl (%edx),%edx
  80f151:	29 d0                	sub    %edx,%eax
}
  80f153:	5b                   	pop    %ebx
  80f154:	5d                   	pop    %ebp
  80f155:	c3                   	ret    
		return 0;
  80f156:	b8 00 00 00 00       	mov    $0x0,%eax
  80f15b:	eb f6                	jmp    80f153 <strncmp+0x32>

0080f15d <strchr>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
  80f15d:	f3 0f 1e fb          	endbr32 
  80f161:	55                   	push   %ebp
  80f162:	89 e5                	mov    %esp,%ebp
  80f164:	8b 45 08             	mov    0x8(%ebp),%eax
  80f167:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
	for (; *s; s++)
  80f16b:	0f b6 10             	movzbl (%eax),%edx
  80f16e:	84 d2                	test   %dl,%dl
  80f170:	74 09                	je     80f17b <strchr+0x1e>
		if (*s == c)
  80f172:	38 ca                	cmp    %cl,%dl
  80f174:	74 0a                	je     80f180 <strchr+0x23>
	for (; *s; s++)
  80f176:	83 c0 01             	add    $0x1,%eax
  80f179:	eb f0                	jmp    80f16b <strchr+0xe>
			return (char *) s;
	return 0;
  80f17b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80f180:	5d                   	pop    %ebp
  80f181:	c3                   	ret    

0080f182 <strfind>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
  80f182:	f3 0f 1e fb          	endbr32 
  80f186:	55                   	push   %ebp
  80f187:	89 e5                	mov    %esp,%ebp
  80f189:	8b 45 08             	mov    0x8(%ebp),%eax
  80f18c:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
	for (; *s; s++)
  80f190:	0f b6 10             	movzbl (%eax),%edx
		if (*s == c)
  80f193:	38 ca                	cmp    %cl,%dl
  80f195:	74 09                	je     80f1a0 <strfind+0x1e>
  80f197:	84 d2                	test   %dl,%dl
  80f199:	74 05                	je     80f1a0 <strfind+0x1e>
	for (; *s; s++)
  80f19b:	83 c0 01             	add    $0x1,%eax
  80f19e:	eb f0                	jmp    80f190 <strfind+0xe>
			break;
	return (char *) s;
}
  80f1a0:	5d                   	pop    %ebp
  80f1a1:	c3                   	ret    

0080f1a2 <memset>:

#if ASM
void *
memset(void *v, int c, size_t n)
{
  80f1a2:	f3 0f 1e fb          	endbr32 
  80f1a6:	55                   	push   %ebp
  80f1a7:	89 e5                	mov    %esp,%ebp
  80f1a9:	57                   	push   %edi
  80f1aa:	56                   	push   %esi
  80f1ab:	53                   	push   %ebx
  80f1ac:	8b 7d 08             	mov    0x8(%ebp),%edi
  80f1af:	8b 4d 10             	mov    0x10(%ebp),%ecx
	char *p;

	if (n == 0)
  80f1b2:	85 c9                	test   %ecx,%ecx
  80f1b4:	74 31                	je     80f1e7 <memset+0x45>
		return v;
	if ((int)v%4 == 0 && n%4 == 0) {
  80f1b6:	89 f8                	mov    %edi,%eax
  80f1b8:	09 c8                	or     %ecx,%eax
  80f1ba:	a8 03                	test   $0x3,%al
  80f1bc:	75 23                	jne    80f1e1 <memset+0x3f>
		c &= 0xFF;
  80f1be:	0f b6 55 0c          	movzbl 0xc(%ebp),%edx
		c = (c<<24)|(c<<16)|(c<<8)|c;
  80f1c2:	89 d3                	mov    %edx,%ebx
  80f1c4:	c1 e3 08             	shl    $0x8,%ebx
  80f1c7:	89 d0                	mov    %edx,%eax
  80f1c9:	c1 e0 18             	shl    $0x18,%eax
  80f1cc:	89 d6                	mov    %edx,%esi
  80f1ce:	c1 e6 10             	shl    $0x10,%esi
  80f1d1:	09 f0                	or     %esi,%eax
  80f1d3:	09 c2                	or     %eax,%edx
  80f1d5:	09 da                	or     %ebx,%edx
		asm volatile("cld; rep stosl\n"
			:: "D" (v), "a" (c), "c" (n/4)
  80f1d7:	c1 e9 02             	shr    $0x2,%ecx
		asm volatile("cld; rep stosl\n"
  80f1da:	89 d0                	mov    %edx,%eax
  80f1dc:	fc                   	cld    
  80f1dd:	f3 ab                	rep stos %eax,%es:(%edi)
  80f1df:	eb 06                	jmp    80f1e7 <memset+0x45>
			: "cc", "memory");
	} else
		asm volatile("cld; rep stosb\n"
  80f1e1:	8b 45 0c             	mov    0xc(%ebp),%eax
  80f1e4:	fc                   	cld    
  80f1e5:	f3 aa                	rep stos %al,%es:(%edi)
			:: "D" (v), "a" (c), "c" (n)
			: "cc", "memory");
	return v;
}
  80f1e7:	89 f8                	mov    %edi,%eax
  80f1e9:	5b                   	pop    %ebx
  80f1ea:	5e                   	pop    %esi
  80f1eb:	5f                   	pop    %edi
  80f1ec:	5d                   	pop    %ebp
  80f1ed:	c3                   	ret    

0080f1ee <memmove>:

void *
memmove(void *dst, const void *src, size_t n)
{
  80f1ee:	f3 0f 1e fb          	endbr32 
  80f1f2:	55                   	push   %ebp
  80f1f3:	89 e5                	mov    %esp,%ebp
  80f1f5:	57                   	push   %edi
  80f1f6:	56                   	push   %esi
  80f1f7:	8b 45 08             	mov    0x8(%ebp),%eax
  80f1fa:	8b 75 0c             	mov    0xc(%ebp),%esi
  80f1fd:	8b 4d 10             	mov    0x10(%ebp),%ecx
	const char *s;
	char *d;

	s = src;
	d = dst;
	if (s < d && s + n > d) {
  80f200:	39 c6                	cmp    %eax,%esi
  80f202:	73 32                	jae    80f236 <memmove+0x48>
  80f204:	8d 14 0e             	lea    (%esi,%ecx,1),%edx
  80f207:	39 c2                	cmp    %eax,%edx
  80f209:	76 2b                	jbe    80f236 <memmove+0x48>
		s += n;
		d += n;
  80f20b:	8d 3c 08             	lea    (%eax,%ecx,1),%edi
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
  80f20e:	89 fe                	mov    %edi,%esi
  80f210:	09 ce                	or     %ecx,%esi
  80f212:	09 d6                	or     %edx,%esi
  80f214:	f7 c6 03 00 00 00    	test   $0x3,%esi
  80f21a:	75 0e                	jne    80f22a <memmove+0x3c>
			asm volatile("std; rep movsl\n"
				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
  80f21c:	83 ef 04             	sub    $0x4,%edi
  80f21f:	8d 72 fc             	lea    -0x4(%edx),%esi
  80f222:	c1 e9 02             	shr    $0x2,%ecx
			asm volatile("std; rep movsl\n"
  80f225:	fd                   	std    
  80f226:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
  80f228:	eb 09                	jmp    80f233 <memmove+0x45>
		else
			asm volatile("std; rep movsb\n"
				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
  80f22a:	83 ef 01             	sub    $0x1,%edi
  80f22d:	8d 72 ff             	lea    -0x1(%edx),%esi
			asm volatile("std; rep movsb\n"
  80f230:	fd                   	std    
  80f231:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
  80f233:	fc                   	cld    
  80f234:	eb 1a                	jmp    80f250 <memmove+0x62>
	} else {
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
  80f236:	89 c2                	mov    %eax,%edx
  80f238:	09 ca                	or     %ecx,%edx
  80f23a:	09 f2                	or     %esi,%edx
  80f23c:	f6 c2 03             	test   $0x3,%dl
  80f23f:	75 0a                	jne    80f24b <memmove+0x5d>
			asm volatile("cld; rep movsl\n"
				:: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
  80f241:	c1 e9 02             	shr    $0x2,%ecx
			asm volatile("cld; rep movsl\n"
  80f244:	89 c7                	mov    %eax,%edi
  80f246:	fc                   	cld    
  80f247:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
  80f249:	eb 05                	jmp    80f250 <memmove+0x62>
		else
			asm volatile("cld; rep movsb\n"
  80f24b:	89 c7                	mov    %eax,%edi
  80f24d:	fc                   	cld    
  80f24e:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
				:: "D" (d), "S" (s), "c" (n) : "cc", "memory");
	}
	return dst;
}
  80f250:	5e                   	pop    %esi
  80f251:	5f                   	pop    %edi
  80f252:	5d                   	pop    %ebp
  80f253:	c3                   	ret    

0080f254 <memcpy>:
}
#endif

void *
memcpy(void *dst, const void *src, size_t n)
{
  80f254:	f3 0f 1e fb          	endbr32 
  80f258:	55                   	push   %ebp
  80f259:	89 e5                	mov    %esp,%ebp
  80f25b:	83 ec 0c             	sub    $0xc,%esp
	return memmove(dst, src, n);
  80f25e:	ff 75 10             	pushl  0x10(%ebp)
  80f261:	ff 75 0c             	pushl  0xc(%ebp)
  80f264:	ff 75 08             	pushl  0x8(%ebp)
  80f267:	e8 82 ff ff ff       	call   80f1ee <memmove>
}
  80f26c:	c9                   	leave  
  80f26d:	c3                   	ret    

0080f26e <memcmp>:

int
memcmp(const void *v1, const void *v2, size_t n)
{
  80f26e:	f3 0f 1e fb          	endbr32 
  80f272:	55                   	push   %ebp
  80f273:	89 e5                	mov    %esp,%ebp
  80f275:	56                   	push   %esi
  80f276:	53                   	push   %ebx
  80f277:	8b 45 08             	mov    0x8(%ebp),%eax
  80f27a:	8b 55 0c             	mov    0xc(%ebp),%edx
  80f27d:	89 c6                	mov    %eax,%esi
  80f27f:	03 75 10             	add    0x10(%ebp),%esi
	const uint8_t *s1 = (const uint8_t *) v1;
	const uint8_t *s2 = (const uint8_t *) v2;

	while (n-- > 0) {
  80f282:	39 f0                	cmp    %esi,%eax
  80f284:	74 1c                	je     80f2a2 <memcmp+0x34>
		if (*s1 != *s2)
  80f286:	0f b6 08             	movzbl (%eax),%ecx
  80f289:	0f b6 1a             	movzbl (%edx),%ebx
  80f28c:	38 d9                	cmp    %bl,%cl
  80f28e:	75 08                	jne    80f298 <memcmp+0x2a>
			return (int) *s1 - (int) *s2;
		s1++, s2++;
  80f290:	83 c0 01             	add    $0x1,%eax
  80f293:	83 c2 01             	add    $0x1,%edx
  80f296:	eb ea                	jmp    80f282 <memcmp+0x14>
			return (int) *s1 - (int) *s2;
  80f298:	0f b6 c1             	movzbl %cl,%eax
  80f29b:	0f b6 db             	movzbl %bl,%ebx
  80f29e:	29 d8                	sub    %ebx,%eax
  80f2a0:	eb 05                	jmp    80f2a7 <memcmp+0x39>
	}

	return 0;
  80f2a2:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80f2a7:	5b                   	pop    %ebx
  80f2a8:	5e                   	pop    %esi
  80f2a9:	5d                   	pop    %ebp
  80f2aa:	c3                   	ret    

0080f2ab <memfind>:

void *
memfind(const void *s, int c, size_t n)
{
  80f2ab:	f3 0f 1e fb          	endbr32 
  80f2af:	55                   	push   %ebp
  80f2b0:	89 e5                	mov    %esp,%ebp
  80f2b2:	8b 45 08             	mov    0x8(%ebp),%eax
  80f2b5:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	const void *ends = (const char *) s + n;
  80f2b8:	89 c2                	mov    %eax,%edx
  80f2ba:	03 55 10             	add    0x10(%ebp),%edx
	for (; s < ends; s++)
  80f2bd:	39 d0                	cmp    %edx,%eax
  80f2bf:	73 09                	jae    80f2ca <memfind+0x1f>
		if (*(const unsigned char *) s == (unsigned char) c)
  80f2c1:	38 08                	cmp    %cl,(%eax)
  80f2c3:	74 05                	je     80f2ca <memfind+0x1f>
	for (; s < ends; s++)
  80f2c5:	83 c0 01             	add    $0x1,%eax
  80f2c8:	eb f3                	jmp    80f2bd <memfind+0x12>
			break;
	return (void *) s;
}
  80f2ca:	5d                   	pop    %ebp
  80f2cb:	c3                   	ret    

0080f2cc <strtol>:

long
strtol(const char *s, char **endptr, int base)
{
  80f2cc:	f3 0f 1e fb          	endbr32 
  80f2d0:	55                   	push   %ebp
  80f2d1:	89 e5                	mov    %esp,%ebp
  80f2d3:	57                   	push   %edi
  80f2d4:	56                   	push   %esi
  80f2d5:	53                   	push   %ebx
  80f2d6:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80f2d9:	8b 5d 10             	mov    0x10(%ebp),%ebx
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  80f2dc:	eb 03                	jmp    80f2e1 <strtol+0x15>
		s++;
  80f2de:	83 c1 01             	add    $0x1,%ecx
	while (*s == ' ' || *s == '\t')
  80f2e1:	0f b6 01             	movzbl (%ecx),%eax
  80f2e4:	3c 20                	cmp    $0x20,%al
  80f2e6:	74 f6                	je     80f2de <strtol+0x12>
  80f2e8:	3c 09                	cmp    $0x9,%al
  80f2ea:	74 f2                	je     80f2de <strtol+0x12>

	// plus/minus sign
	if (*s == '+')
  80f2ec:	3c 2b                	cmp    $0x2b,%al
  80f2ee:	74 2a                	je     80f31a <strtol+0x4e>
	int neg = 0;
  80f2f0:	bf 00 00 00 00       	mov    $0x0,%edi
		s++;
	else if (*s == '-')
  80f2f5:	3c 2d                	cmp    $0x2d,%al
  80f2f7:	74 2b                	je     80f324 <strtol+0x58>
		s++, neg = 1;

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
  80f2f9:	f7 c3 ef ff ff ff    	test   $0xffffffef,%ebx
  80f2ff:	75 0f                	jne    80f310 <strtol+0x44>
  80f301:	80 39 30             	cmpb   $0x30,(%ecx)
  80f304:	74 28                	je     80f32e <strtol+0x62>
		s += 2, base = 16;
	else if (base == 0 && s[0] == '0')
		s++, base = 8;
	else if (base == 0)
		base = 10;
  80f306:	85 db                	test   %ebx,%ebx
  80f308:	b8 0a 00 00 00       	mov    $0xa,%eax
  80f30d:	0f 44 d8             	cmove  %eax,%ebx
  80f310:	b8 00 00 00 00       	mov    $0x0,%eax
  80f315:	89 5d 10             	mov    %ebx,0x10(%ebp)
  80f318:	eb 46                	jmp    80f360 <strtol+0x94>
		s++;
  80f31a:	83 c1 01             	add    $0x1,%ecx
	int neg = 0;
  80f31d:	bf 00 00 00 00       	mov    $0x0,%edi
  80f322:	eb d5                	jmp    80f2f9 <strtol+0x2d>
		s++, neg = 1;
  80f324:	83 c1 01             	add    $0x1,%ecx
  80f327:	bf 01 00 00 00       	mov    $0x1,%edi
  80f32c:	eb cb                	jmp    80f2f9 <strtol+0x2d>
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
  80f32e:	80 79 01 78          	cmpb   $0x78,0x1(%ecx)
  80f332:	74 0e                	je     80f342 <strtol+0x76>
	else if (base == 0 && s[0] == '0')
  80f334:	85 db                	test   %ebx,%ebx
  80f336:	75 d8                	jne    80f310 <strtol+0x44>
		s++, base = 8;
  80f338:	83 c1 01             	add    $0x1,%ecx
  80f33b:	bb 08 00 00 00       	mov    $0x8,%ebx
  80f340:	eb ce                	jmp    80f310 <strtol+0x44>
		s += 2, base = 16;
  80f342:	83 c1 02             	add    $0x2,%ecx
  80f345:	bb 10 00 00 00       	mov    $0x10,%ebx
  80f34a:	eb c4                	jmp    80f310 <strtol+0x44>
	// digits
	while (1) {
		int dig;

		if (*s >= '0' && *s <= '9')
			dig = *s - '0';
  80f34c:	0f be d2             	movsbl %dl,%edx
  80f34f:	83 ea 30             	sub    $0x30,%edx
			dig = *s - 'a' + 10;
		else if (*s >= 'A' && *s <= 'Z')
			dig = *s - 'A' + 10;
		else
			break;
		if (dig >= base)
  80f352:	3b 55 10             	cmp    0x10(%ebp),%edx
  80f355:	7d 3a                	jge    80f391 <strtol+0xc5>
			break;
		s++, val = (val * base) + dig;
  80f357:	83 c1 01             	add    $0x1,%ecx
  80f35a:	0f af 45 10          	imul   0x10(%ebp),%eax
  80f35e:	01 d0                	add    %edx,%eax
		if (*s >= '0' && *s <= '9')
  80f360:	0f b6 11             	movzbl (%ecx),%edx
  80f363:	8d 72 d0             	lea    -0x30(%edx),%esi
  80f366:	89 f3                	mov    %esi,%ebx
  80f368:	80 fb 09             	cmp    $0x9,%bl
  80f36b:	76 df                	jbe    80f34c <strtol+0x80>
		else if (*s >= 'a' && *s <= 'z')
  80f36d:	8d 72 9f             	lea    -0x61(%edx),%esi
  80f370:	89 f3                	mov    %esi,%ebx
  80f372:	80 fb 19             	cmp    $0x19,%bl
  80f375:	77 08                	ja     80f37f <strtol+0xb3>
			dig = *s - 'a' + 10;
  80f377:	0f be d2             	movsbl %dl,%edx
  80f37a:	83 ea 57             	sub    $0x57,%edx
  80f37d:	eb d3                	jmp    80f352 <strtol+0x86>
		else if (*s >= 'A' && *s <= 'Z')
  80f37f:	8d 72 bf             	lea    -0x41(%edx),%esi
  80f382:	89 f3                	mov    %esi,%ebx
  80f384:	80 fb 19             	cmp    $0x19,%bl
  80f387:	77 08                	ja     80f391 <strtol+0xc5>
			dig = *s - 'A' + 10;
  80f389:	0f be d2             	movsbl %dl,%edx
  80f38c:	83 ea 37             	sub    $0x37,%edx
  80f38f:	eb c1                	jmp    80f352 <strtol+0x86>
		// we don't properly detect overflow!
	}

	if (endptr)
  80f391:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  80f395:	74 05                	je     80f39c <strtol+0xd0>
		*endptr = (char *) s;
  80f397:	8b 75 0c             	mov    0xc(%ebp),%esi
  80f39a:	89 0e                	mov    %ecx,(%esi)
	return (neg ? -val : val);
  80f39c:	89 c2                	mov    %eax,%edx
  80f39e:	f7 da                	neg    %edx
  80f3a0:	85 ff                	test   %edi,%edi
  80f3a2:	0f 45 c2             	cmovne %edx,%eax
}
  80f3a5:	5b                   	pop    %ebx
  80f3a6:	5e                   	pop    %esi
  80f3a7:	5f                   	pop    %edi
  80f3a8:	5d                   	pop    %ebp
  80f3a9:	c3                   	ret    

0080f3aa <sys_cputs>:
	return ret;
}

void
sys_cputs(const char *s, size_t len)
{
  80f3aa:	f3 0f 1e fb          	endbr32 
  80f3ae:	55                   	push   %ebp
  80f3af:	89 e5                	mov    %esp,%ebp
  80f3b1:	57                   	push   %edi
  80f3b2:	56                   	push   %esi
  80f3b3:	53                   	push   %ebx
	asm volatile("int %1\n"
  80f3b4:	b8 00 00 00 00       	mov    $0x0,%eax
  80f3b9:	8b 55 08             	mov    0x8(%ebp),%edx
  80f3bc:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f3bf:	89 c3                	mov    %eax,%ebx
  80f3c1:	89 c7                	mov    %eax,%edi
  80f3c3:	89 c6                	mov    %eax,%esi
  80f3c5:	cd 30                	int    $0x30
	syscall(SYS_cputs, 0, (uint32_t)s, len, 0, 0, 0);
}
  80f3c7:	5b                   	pop    %ebx
  80f3c8:	5e                   	pop    %esi
  80f3c9:	5f                   	pop    %edi
  80f3ca:	5d                   	pop    %ebp
  80f3cb:	c3                   	ret    

0080f3cc <sys_cgetc>:

int
sys_cgetc(void)
{
  80f3cc:	f3 0f 1e fb          	endbr32 
  80f3d0:	55                   	push   %ebp
  80f3d1:	89 e5                	mov    %esp,%ebp
  80f3d3:	57                   	push   %edi
  80f3d4:	56                   	push   %esi
  80f3d5:	53                   	push   %ebx
	asm volatile("int %1\n"
  80f3d6:	ba 00 00 00 00       	mov    $0x0,%edx
  80f3db:	b8 01 00 00 00       	mov    $0x1,%eax
  80f3e0:	89 d1                	mov    %edx,%ecx
  80f3e2:	89 d3                	mov    %edx,%ebx
  80f3e4:	89 d7                	mov    %edx,%edi
  80f3e6:	89 d6                	mov    %edx,%esi
  80f3e8:	cd 30                	int    $0x30
	return syscall(SYS_cgetc, 0, 0, 0, 0, 0, 0);
}
  80f3ea:	5b                   	pop    %ebx
  80f3eb:	5e                   	pop    %esi
  80f3ec:	5f                   	pop    %edi
  80f3ed:	5d                   	pop    %ebp
  80f3ee:	c3                   	ret    

0080f3ef <sys_env_destroy>:

int
sys_env_destroy(envid_t envid)
{
  80f3ef:	f3 0f 1e fb          	endbr32 
  80f3f3:	55                   	push   %ebp
  80f3f4:	89 e5                	mov    %esp,%ebp
  80f3f6:	57                   	push   %edi
  80f3f7:	56                   	push   %esi
  80f3f8:	53                   	push   %ebx
  80f3f9:	83 ec 0c             	sub    $0xc,%esp
	asm volatile("int %1\n"
  80f3fc:	b9 00 00 00 00       	mov    $0x0,%ecx
  80f401:	8b 55 08             	mov    0x8(%ebp),%edx
  80f404:	b8 03 00 00 00       	mov    $0x3,%eax
  80f409:	89 cb                	mov    %ecx,%ebx
  80f40b:	89 cf                	mov    %ecx,%edi
  80f40d:	89 ce                	mov    %ecx,%esi
  80f40f:	cd 30                	int    $0x30
	if(check && ret > 0)
  80f411:	85 c0                	test   %eax,%eax
  80f413:	7f 08                	jg     80f41d <sys_env_destroy+0x2e>
	return syscall(SYS_env_destroy, 1, envid, 0, 0, 0, 0);
}
  80f415:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f418:	5b                   	pop    %ebx
  80f419:	5e                   	pop    %esi
  80f41a:	5f                   	pop    %edi
  80f41b:	5d                   	pop    %ebp
  80f41c:	c3                   	ret    
		panic("syscall %d returned %d (> 0)", num, ret);
  80f41d:	83 ec 0c             	sub    $0xc,%esp
  80f420:	50                   	push   %eax
  80f421:	6a 03                	push   $0x3
  80f423:	68 1f 3c 81 00       	push   $0x813c1f
  80f428:	6a 23                	push   $0x23
  80f42a:	68 3c 3c 81 00       	push   $0x813c3c
  80f42f:	e8 13 f5 ff ff       	call   80e947 <_panic>

0080f434 <sys_getenvid>:

envid_t
sys_getenvid(void)
{
  80f434:	f3 0f 1e fb          	endbr32 
  80f438:	55                   	push   %ebp
  80f439:	89 e5                	mov    %esp,%ebp
  80f43b:	57                   	push   %edi
  80f43c:	56                   	push   %esi
  80f43d:	53                   	push   %ebx
	asm volatile("int %1\n"
  80f43e:	ba 00 00 00 00       	mov    $0x0,%edx
  80f443:	b8 02 00 00 00       	mov    $0x2,%eax
  80f448:	89 d1                	mov    %edx,%ecx
  80f44a:	89 d3                	mov    %edx,%ebx
  80f44c:	89 d7                	mov    %edx,%edi
  80f44e:	89 d6                	mov    %edx,%esi
  80f450:	cd 30                	int    $0x30
	 return syscall(SYS_getenvid, 0, 0, 0, 0, 0, 0);
}
  80f452:	5b                   	pop    %ebx
  80f453:	5e                   	pop    %esi
  80f454:	5f                   	pop    %edi
  80f455:	5d                   	pop    %ebp
  80f456:	c3                   	ret    

0080f457 <sys_yield>:

void
sys_yield(void)
{
  80f457:	f3 0f 1e fb          	endbr32 
  80f45b:	55                   	push   %ebp
  80f45c:	89 e5                	mov    %esp,%ebp
  80f45e:	57                   	push   %edi
  80f45f:	56                   	push   %esi
  80f460:	53                   	push   %ebx
	asm volatile("int %1\n"
  80f461:	ba 00 00 00 00       	mov    $0x0,%edx
  80f466:	b8 0b 00 00 00       	mov    $0xb,%eax
  80f46b:	89 d1                	mov    %edx,%ecx
  80f46d:	89 d3                	mov    %edx,%ebx
  80f46f:	89 d7                	mov    %edx,%edi
  80f471:	89 d6                	mov    %edx,%esi
  80f473:	cd 30                	int    $0x30
	syscall(SYS_yield, 0, 0, 0, 0, 0, 0);
}
  80f475:	5b                   	pop    %ebx
  80f476:	5e                   	pop    %esi
  80f477:	5f                   	pop    %edi
  80f478:	5d                   	pop    %ebp
  80f479:	c3                   	ret    

0080f47a <sys_page_alloc>:

int
sys_page_alloc(envid_t envid, void *va, int perm)
{
  80f47a:	f3 0f 1e fb          	endbr32 
  80f47e:	55                   	push   %ebp
  80f47f:	89 e5                	mov    %esp,%ebp
  80f481:	57                   	push   %edi
  80f482:	56                   	push   %esi
  80f483:	53                   	push   %ebx
  80f484:	83 ec 0c             	sub    $0xc,%esp
	asm volatile("int %1\n"
  80f487:	be 00 00 00 00       	mov    $0x0,%esi
  80f48c:	8b 55 08             	mov    0x8(%ebp),%edx
  80f48f:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f492:	b8 04 00 00 00       	mov    $0x4,%eax
  80f497:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80f49a:	89 f7                	mov    %esi,%edi
  80f49c:	cd 30                	int    $0x30
	if(check && ret > 0)
  80f49e:	85 c0                	test   %eax,%eax
  80f4a0:	7f 08                	jg     80f4aa <sys_page_alloc+0x30>
	return syscall(SYS_page_alloc, 1, envid, (uint32_t) va, perm, 0, 0);
}
  80f4a2:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f4a5:	5b                   	pop    %ebx
  80f4a6:	5e                   	pop    %esi
  80f4a7:	5f                   	pop    %edi
  80f4a8:	5d                   	pop    %ebp
  80f4a9:	c3                   	ret    
		panic("syscall %d returned %d (> 0)", num, ret);
  80f4aa:	83 ec 0c             	sub    $0xc,%esp
  80f4ad:	50                   	push   %eax
  80f4ae:	6a 04                	push   $0x4
  80f4b0:	68 1f 3c 81 00       	push   $0x813c1f
  80f4b5:	6a 23                	push   $0x23
  80f4b7:	68 3c 3c 81 00       	push   $0x813c3c
  80f4bc:	e8 86 f4 ff ff       	call   80e947 <_panic>

0080f4c1 <sys_page_map>:

int
sys_page_map(envid_t srcenv, void *srcva, envid_t dstenv, void *dstva, int perm)
{
  80f4c1:	f3 0f 1e fb          	endbr32 
  80f4c5:	55                   	push   %ebp
  80f4c6:	89 e5                	mov    %esp,%ebp
  80f4c8:	57                   	push   %edi
  80f4c9:	56                   	push   %esi
  80f4ca:	53                   	push   %ebx
  80f4cb:	83 ec 0c             	sub    $0xc,%esp
	asm volatile("int %1\n"
  80f4ce:	8b 55 08             	mov    0x8(%ebp),%edx
  80f4d1:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f4d4:	b8 05 00 00 00       	mov    $0x5,%eax
  80f4d9:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80f4dc:	8b 7d 14             	mov    0x14(%ebp),%edi
  80f4df:	8b 75 18             	mov    0x18(%ebp),%esi
  80f4e2:	cd 30                	int    $0x30
	if(check && ret > 0)
  80f4e4:	85 c0                	test   %eax,%eax
  80f4e6:	7f 08                	jg     80f4f0 <sys_page_map+0x2f>
	return syscall(SYS_page_map, 1, srcenv, (uint32_t) srcva, dstenv, (uint32_t) dstva, perm);
}
  80f4e8:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f4eb:	5b                   	pop    %ebx
  80f4ec:	5e                   	pop    %esi
  80f4ed:	5f                   	pop    %edi
  80f4ee:	5d                   	pop    %ebp
  80f4ef:	c3                   	ret    
		panic("syscall %d returned %d (> 0)", num, ret);
  80f4f0:	83 ec 0c             	sub    $0xc,%esp
  80f4f3:	50                   	push   %eax
  80f4f4:	6a 05                	push   $0x5
  80f4f6:	68 1f 3c 81 00       	push   $0x813c1f
  80f4fb:	6a 23                	push   $0x23
  80f4fd:	68 3c 3c 81 00       	push   $0x813c3c
  80f502:	e8 40 f4 ff ff       	call   80e947 <_panic>

0080f507 <sys_page_unmap>:

int
sys_page_unmap(envid_t envid, void *va)
{
  80f507:	f3 0f 1e fb          	endbr32 
  80f50b:	55                   	push   %ebp
  80f50c:	89 e5                	mov    %esp,%ebp
  80f50e:	57                   	push   %edi
  80f50f:	56                   	push   %esi
  80f510:	53                   	push   %ebx
  80f511:	83 ec 0c             	sub    $0xc,%esp
	asm volatile("int %1\n"
  80f514:	bb 00 00 00 00       	mov    $0x0,%ebx
  80f519:	8b 55 08             	mov    0x8(%ebp),%edx
  80f51c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f51f:	b8 06 00 00 00       	mov    $0x6,%eax
  80f524:	89 df                	mov    %ebx,%edi
  80f526:	89 de                	mov    %ebx,%esi
  80f528:	cd 30                	int    $0x30
	if(check && ret > 0)
  80f52a:	85 c0                	test   %eax,%eax
  80f52c:	7f 08                	jg     80f536 <sys_page_unmap+0x2f>
	return syscall(SYS_page_unmap, 1, envid, (uint32_t) va, 0, 0, 0);
}
  80f52e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f531:	5b                   	pop    %ebx
  80f532:	5e                   	pop    %esi
  80f533:	5f                   	pop    %edi
  80f534:	5d                   	pop    %ebp
  80f535:	c3                   	ret    
		panic("syscall %d returned %d (> 0)", num, ret);
  80f536:	83 ec 0c             	sub    $0xc,%esp
  80f539:	50                   	push   %eax
  80f53a:	6a 06                	push   $0x6
  80f53c:	68 1f 3c 81 00       	push   $0x813c1f
  80f541:	6a 23                	push   $0x23
  80f543:	68 3c 3c 81 00       	push   $0x813c3c
  80f548:	e8 fa f3 ff ff       	call   80e947 <_panic>

0080f54d <sys_env_set_status>:

// sys_exofork is inlined in lib.h

int
sys_env_set_status(envid_t envid, int status)
{
  80f54d:	f3 0f 1e fb          	endbr32 
  80f551:	55                   	push   %ebp
  80f552:	89 e5                	mov    %esp,%ebp
  80f554:	57                   	push   %edi
  80f555:	56                   	push   %esi
  80f556:	53                   	push   %ebx
  80f557:	83 ec 0c             	sub    $0xc,%esp
	asm volatile("int %1\n"
  80f55a:	bb 00 00 00 00       	mov    $0x0,%ebx
  80f55f:	8b 55 08             	mov    0x8(%ebp),%edx
  80f562:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f565:	b8 08 00 00 00       	mov    $0x8,%eax
  80f56a:	89 df                	mov    %ebx,%edi
  80f56c:	89 de                	mov    %ebx,%esi
  80f56e:	cd 30                	int    $0x30
	if(check && ret > 0)
  80f570:	85 c0                	test   %eax,%eax
  80f572:	7f 08                	jg     80f57c <sys_env_set_status+0x2f>
	return syscall(SYS_env_set_status, 1, envid, status, 0, 0, 0);
}
  80f574:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f577:	5b                   	pop    %ebx
  80f578:	5e                   	pop    %esi
  80f579:	5f                   	pop    %edi
  80f57a:	5d                   	pop    %ebp
  80f57b:	c3                   	ret    
		panic("syscall %d returned %d (> 0)", num, ret);
  80f57c:	83 ec 0c             	sub    $0xc,%esp
  80f57f:	50                   	push   %eax
  80f580:	6a 08                	push   $0x8
  80f582:	68 1f 3c 81 00       	push   $0x813c1f
  80f587:	6a 23                	push   $0x23
  80f589:	68 3c 3c 81 00       	push   $0x813c3c
  80f58e:	e8 b4 f3 ff ff       	call   80e947 <_panic>

0080f593 <sys_env_set_trapframe>:

int
sys_env_set_trapframe(envid_t envid, struct Trapframe *tf)
{
  80f593:	f3 0f 1e fb          	endbr32 
  80f597:	55                   	push   %ebp
  80f598:	89 e5                	mov    %esp,%ebp
  80f59a:	57                   	push   %edi
  80f59b:	56                   	push   %esi
  80f59c:	53                   	push   %ebx
  80f59d:	83 ec 0c             	sub    $0xc,%esp
	asm volatile("int %1\n"
  80f5a0:	bb 00 00 00 00       	mov    $0x0,%ebx
  80f5a5:	8b 55 08             	mov    0x8(%ebp),%edx
  80f5a8:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f5ab:	b8 09 00 00 00       	mov    $0x9,%eax
  80f5b0:	89 df                	mov    %ebx,%edi
  80f5b2:	89 de                	mov    %ebx,%esi
  80f5b4:	cd 30                	int    $0x30
	if(check && ret > 0)
  80f5b6:	85 c0                	test   %eax,%eax
  80f5b8:	7f 08                	jg     80f5c2 <sys_env_set_trapframe+0x2f>
	return syscall(SYS_env_set_trapframe, 1, envid, (uint32_t) tf, 0, 0, 0);
}
  80f5ba:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f5bd:	5b                   	pop    %ebx
  80f5be:	5e                   	pop    %esi
  80f5bf:	5f                   	pop    %edi
  80f5c0:	5d                   	pop    %ebp
  80f5c1:	c3                   	ret    
		panic("syscall %d returned %d (> 0)", num, ret);
  80f5c2:	83 ec 0c             	sub    $0xc,%esp
  80f5c5:	50                   	push   %eax
  80f5c6:	6a 09                	push   $0x9
  80f5c8:	68 1f 3c 81 00       	push   $0x813c1f
  80f5cd:	6a 23                	push   $0x23
  80f5cf:	68 3c 3c 81 00       	push   $0x813c3c
  80f5d4:	e8 6e f3 ff ff       	call   80e947 <_panic>

0080f5d9 <sys_env_set_pgfault_upcall>:

int
sys_env_set_pgfault_upcall(envid_t envid, void *upcall)
{
  80f5d9:	f3 0f 1e fb          	endbr32 
  80f5dd:	55                   	push   %ebp
  80f5de:	89 e5                	mov    %esp,%ebp
  80f5e0:	57                   	push   %edi
  80f5e1:	56                   	push   %esi
  80f5e2:	53                   	push   %ebx
  80f5e3:	83 ec 0c             	sub    $0xc,%esp
	asm volatile("int %1\n"
  80f5e6:	bb 00 00 00 00       	mov    $0x0,%ebx
  80f5eb:	8b 55 08             	mov    0x8(%ebp),%edx
  80f5ee:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f5f1:	b8 0a 00 00 00       	mov    $0xa,%eax
  80f5f6:	89 df                	mov    %ebx,%edi
  80f5f8:	89 de                	mov    %ebx,%esi
  80f5fa:	cd 30                	int    $0x30
	if(check && ret > 0)
  80f5fc:	85 c0                	test   %eax,%eax
  80f5fe:	7f 08                	jg     80f608 <sys_env_set_pgfault_upcall+0x2f>
	return syscall(SYS_env_set_pgfault_upcall, 1, envid, (uint32_t) upcall, 0, 0, 0);
}
  80f600:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f603:	5b                   	pop    %ebx
  80f604:	5e                   	pop    %esi
  80f605:	5f                   	pop    %edi
  80f606:	5d                   	pop    %ebp
  80f607:	c3                   	ret    
		panic("syscall %d returned %d (> 0)", num, ret);
  80f608:	83 ec 0c             	sub    $0xc,%esp
  80f60b:	50                   	push   %eax
  80f60c:	6a 0a                	push   $0xa
  80f60e:	68 1f 3c 81 00       	push   $0x813c1f
  80f613:	6a 23                	push   $0x23
  80f615:	68 3c 3c 81 00       	push   $0x813c3c
  80f61a:	e8 28 f3 ff ff       	call   80e947 <_panic>

0080f61f <sys_ipc_try_send>:

int
sys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, int perm)
{
  80f61f:	f3 0f 1e fb          	endbr32 
  80f623:	55                   	push   %ebp
  80f624:	89 e5                	mov    %esp,%ebp
  80f626:	57                   	push   %edi
  80f627:	56                   	push   %esi
  80f628:	53                   	push   %ebx
	asm volatile("int %1\n"
  80f629:	8b 55 08             	mov    0x8(%ebp),%edx
  80f62c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f62f:	b8 0c 00 00 00       	mov    $0xc,%eax
  80f634:	be 00 00 00 00       	mov    $0x0,%esi
  80f639:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80f63c:	8b 7d 14             	mov    0x14(%ebp),%edi
  80f63f:	cd 30                	int    $0x30
	return syscall(SYS_ipc_try_send, 0, envid, value, (uint32_t) srcva, perm, 0);
}
  80f641:	5b                   	pop    %ebx
  80f642:	5e                   	pop    %esi
  80f643:	5f                   	pop    %edi
  80f644:	5d                   	pop    %ebp
  80f645:	c3                   	ret    

0080f646 <sys_ipc_recv>:

int
sys_ipc_recv(void *dstva)
{
  80f646:	f3 0f 1e fb          	endbr32 
  80f64a:	55                   	push   %ebp
  80f64b:	89 e5                	mov    %esp,%ebp
  80f64d:	57                   	push   %edi
  80f64e:	56                   	push   %esi
  80f64f:	53                   	push   %ebx
  80f650:	83 ec 0c             	sub    $0xc,%esp
	asm volatile("int %1\n"
  80f653:	b9 00 00 00 00       	mov    $0x0,%ecx
  80f658:	8b 55 08             	mov    0x8(%ebp),%edx
  80f65b:	b8 0d 00 00 00       	mov    $0xd,%eax
  80f660:	89 cb                	mov    %ecx,%ebx
  80f662:	89 cf                	mov    %ecx,%edi
  80f664:	89 ce                	mov    %ecx,%esi
  80f666:	cd 30                	int    $0x30
	if(check && ret > 0)
  80f668:	85 c0                	test   %eax,%eax
  80f66a:	7f 08                	jg     80f674 <sys_ipc_recv+0x2e>
	return syscall(SYS_ipc_recv, 1, (uint32_t)dstva, 0, 0, 0, 0);
}
  80f66c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f66f:	5b                   	pop    %ebx
  80f670:	5e                   	pop    %esi
  80f671:	5f                   	pop    %edi
  80f672:	5d                   	pop    %ebp
  80f673:	c3                   	ret    
		panic("syscall %d returned %d (> 0)", num, ret);
  80f674:	83 ec 0c             	sub    $0xc,%esp
  80f677:	50                   	push   %eax
  80f678:	6a 0d                	push   $0xd
  80f67a:	68 1f 3c 81 00       	push   $0x813c1f
  80f67f:	6a 23                	push   $0x23
  80f681:	68 3c 3c 81 00       	push   $0x813c3c
  80f686:	e8 bc f2 ff ff       	call   80e947 <_panic>

0080f68b <sys_time_msec>:

unsigned int
sys_time_msec(void)
{
  80f68b:	f3 0f 1e fb          	endbr32 
  80f68f:	55                   	push   %ebp
  80f690:	89 e5                	mov    %esp,%ebp
  80f692:	57                   	push   %edi
  80f693:	56                   	push   %esi
  80f694:	53                   	push   %ebx
	asm volatile("int %1\n"
  80f695:	ba 00 00 00 00       	mov    $0x0,%edx
  80f69a:	b8 0e 00 00 00       	mov    $0xe,%eax
  80f69f:	89 d1                	mov    %edx,%ecx
  80f6a1:	89 d3                	mov    %edx,%ebx
  80f6a3:	89 d7                	mov    %edx,%edi
  80f6a5:	89 d6                	mov    %edx,%esi
  80f6a7:	cd 30                	int    $0x30
	return (unsigned int) syscall(SYS_time_msec, 0, 0, 0, 0, 0, 0);
}
  80f6a9:	5b                   	pop    %ebx
  80f6aa:	5e                   	pop    %esi
  80f6ab:	5f                   	pop    %edi
  80f6ac:	5d                   	pop    %ebp
  80f6ad:	c3                   	ret    

0080f6ae <sys_pkt_send>:

int
sys_pkt_send(void *data, size_t len)
{
  80f6ae:	f3 0f 1e fb          	endbr32 
  80f6b2:	55                   	push   %ebp
  80f6b3:	89 e5                	mov    %esp,%ebp
  80f6b5:	57                   	push   %edi
  80f6b6:	56                   	push   %esi
  80f6b7:	53                   	push   %ebx
  80f6b8:	83 ec 0c             	sub    $0xc,%esp
	asm volatile("int %1\n"
  80f6bb:	bb 00 00 00 00       	mov    $0x0,%ebx
  80f6c0:	8b 55 08             	mov    0x8(%ebp),%edx
  80f6c3:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f6c6:	b8 0f 00 00 00       	mov    $0xf,%eax
  80f6cb:	89 df                	mov    %ebx,%edi
  80f6cd:	89 de                	mov    %ebx,%esi
  80f6cf:	cd 30                	int    $0x30
	if(check && ret > 0)
  80f6d1:	85 c0                	test   %eax,%eax
  80f6d3:	7f 08                	jg     80f6dd <sys_pkt_send+0x2f>
	return syscall(SYS_pkt_send, 1, (uint32_t)data, len, 0, 0, 0);
}
  80f6d5:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f6d8:	5b                   	pop    %ebx
  80f6d9:	5e                   	pop    %esi
  80f6da:	5f                   	pop    %edi
  80f6db:	5d                   	pop    %ebp
  80f6dc:	c3                   	ret    
		panic("syscall %d returned %d (> 0)", num, ret);
  80f6dd:	83 ec 0c             	sub    $0xc,%esp
  80f6e0:	50                   	push   %eax
  80f6e1:	6a 0f                	push   $0xf
  80f6e3:	68 1f 3c 81 00       	push   $0x813c1f
  80f6e8:	6a 23                	push   $0x23
  80f6ea:	68 3c 3c 81 00       	push   $0x813c3c
  80f6ef:	e8 53 f2 ff ff       	call   80e947 <_panic>

0080f6f4 <sys_pkt_recv>:

int
sys_pkt_recv(void *addr, size_t *len)
{
  80f6f4:	f3 0f 1e fb          	endbr32 
  80f6f8:	55                   	push   %ebp
  80f6f9:	89 e5                	mov    %esp,%ebp
  80f6fb:	57                   	push   %edi
  80f6fc:	56                   	push   %esi
  80f6fd:	53                   	push   %ebx
  80f6fe:	83 ec 0c             	sub    $0xc,%esp
	asm volatile("int %1\n"
  80f701:	bb 00 00 00 00       	mov    $0x0,%ebx
  80f706:	8b 55 08             	mov    0x8(%ebp),%edx
  80f709:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f70c:	b8 10 00 00 00       	mov    $0x10,%eax
  80f711:	89 df                	mov    %ebx,%edi
  80f713:	89 de                	mov    %ebx,%esi
  80f715:	cd 30                	int    $0x30
	if(check && ret > 0)
  80f717:	85 c0                	test   %eax,%eax
  80f719:	7f 08                	jg     80f723 <sys_pkt_recv+0x2f>
	return syscall(SYS_pkt_recv, 1, (uint32_t)addr, (uint32_t)len, 0, 0, 0);
  80f71b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f71e:	5b                   	pop    %ebx
  80f71f:	5e                   	pop    %esi
  80f720:	5f                   	pop    %edi
  80f721:	5d                   	pop    %ebp
  80f722:	c3                   	ret    
		panic("syscall %d returned %d (> 0)", num, ret);
  80f723:	83 ec 0c             	sub    $0xc,%esp
  80f726:	50                   	push   %eax
  80f727:	6a 10                	push   $0x10
  80f729:	68 1f 3c 81 00       	push   $0x813c1f
  80f72e:	6a 23                	push   $0x23
  80f730:	68 3c 3c 81 00       	push   $0x813c3c
  80f735:	e8 0d f2 ff ff       	call   80e947 <_panic>

0080f73a <pgfault>:
// Custom page fault handler - if faulting page is copy-on-write,
// map in our own private writable copy.
//
static void
pgfault(struct UTrapframe *utf)
{
  80f73a:	f3 0f 1e fb          	endbr32 
  80f73e:	55                   	push   %ebp
  80f73f:	89 e5                	mov    %esp,%ebp
  80f741:	53                   	push   %ebx
  80f742:	83 ec 04             	sub    $0x4,%esp
  80f745:	8b 45 08             	mov    0x8(%ebp),%eax
	void *addr = (void *) utf->utf_fault_va;
  80f748:	8b 18                	mov    (%eax),%ebx
	// Hint:
	//   Use the read-only page table mappings at uvpt
	//   (see <inc/memlayout.h>).

	// LAB 4: Your code here.
	if (!((err & FEC_WR) && (uvpt[PGNUM(addr)] & PTE_COW))) {
  80f74a:	f6 40 04 02          	testb  $0x2,0x4(%eax)
  80f74e:	74 74                	je     80f7c4 <pgfault+0x8a>
  80f750:	89 d8                	mov    %ebx,%eax
  80f752:	c1 e8 0c             	shr    $0xc,%eax
  80f755:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
  80f75c:	f6 c4 08             	test   $0x8,%ah
  80f75f:	74 63                	je     80f7c4 <pgfault+0x8a>
	// page to the old page's address.
	// Hint:
	//   You should make three system calls.

	// LAB 4: Your code here.
	addr = ROUNDDOWN(addr, PGSIZE);
  80f761:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
	if ((r = sys_page_map(0, addr, 0, (void *) PFTEMP, PTE_U | PTE_P)) < 0) {
  80f767:	83 ec 0c             	sub    $0xc,%esp
  80f76a:	6a 05                	push   $0x5
  80f76c:	68 00 f0 7f 00       	push   $0x7ff000
  80f771:	6a 00                	push   $0x0
  80f773:	53                   	push   %ebx
  80f774:	6a 00                	push   $0x0
  80f776:	e8 46 fd ff ff       	call   80f4c1 <sys_page_map>
  80f77b:	83 c4 20             	add    $0x20,%esp
  80f77e:	85 c0                	test   %eax,%eax
  80f780:	78 59                	js     80f7db <pgfault+0xa1>
		panic("pgfault: %e\n", r);
	}

	if ((r = sys_page_alloc(0, addr, PTE_U | PTE_P | PTE_W)) < 0) {
  80f782:	83 ec 04             	sub    $0x4,%esp
  80f785:	6a 07                	push   $0x7
  80f787:	53                   	push   %ebx
  80f788:	6a 00                	push   $0x0
  80f78a:	e8 eb fc ff ff       	call   80f47a <sys_page_alloc>
  80f78f:	83 c4 10             	add    $0x10,%esp
  80f792:	85 c0                	test   %eax,%eax
  80f794:	78 5a                	js     80f7f0 <pgfault+0xb6>
		panic("pgfault: %e\n", r);
	}

	memmove(addr, PFTEMP, PGSIZE);								//将PFTEMP指向的物理页拷贝到addr指向的物理页
  80f796:	83 ec 04             	sub    $0x4,%esp
  80f799:	68 00 10 00 00       	push   $0x1000
  80f79e:	68 00 f0 7f 00       	push   $0x7ff000
  80f7a3:	53                   	push   %ebx
  80f7a4:	e8 45 fa ff ff       	call   80f1ee <memmove>

	if ((r = sys_page_unmap(0, (void *) PFTEMP)) < 0) {
  80f7a9:	83 c4 08             	add    $0x8,%esp
  80f7ac:	68 00 f0 7f 00       	push   $0x7ff000
  80f7b1:	6a 00                	push   $0x0
  80f7b3:	e8 4f fd ff ff       	call   80f507 <sys_page_unmap>
  80f7b8:	83 c4 10             	add    $0x10,%esp
  80f7bb:	85 c0                	test   %eax,%eax
  80f7bd:	78 46                	js     80f805 <pgfault+0xcb>
		panic("pgfault: %e\n", r);
	}
}
  80f7bf:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80f7c2:	c9                   	leave  
  80f7c3:	c3                   	ret    
        panic("pgfault: not copy-on-write\n");
  80f7c4:	83 ec 04             	sub    $0x4,%esp
  80f7c7:	68 4a 3c 81 00       	push   $0x813c4a
  80f7cc:	68 d3 00 00 00       	push   $0xd3
  80f7d1:	68 66 3c 81 00       	push   $0x813c66
  80f7d6:	e8 6c f1 ff ff       	call   80e947 <_panic>
		panic("pgfault: %e\n", r);
  80f7db:	50                   	push   %eax
  80f7dc:	68 71 3c 81 00       	push   $0x813c71
  80f7e1:	68 df 00 00 00       	push   $0xdf
  80f7e6:	68 66 3c 81 00       	push   $0x813c66
  80f7eb:	e8 57 f1 ff ff       	call   80e947 <_panic>
		panic("pgfault: %e\n", r);
  80f7f0:	50                   	push   %eax
  80f7f1:	68 71 3c 81 00       	push   $0x813c71
  80f7f6:	68 e3 00 00 00       	push   $0xe3
  80f7fb:	68 66 3c 81 00       	push   $0x813c66
  80f800:	e8 42 f1 ff ff       	call   80e947 <_panic>
		panic("pgfault: %e\n", r);
  80f805:	50                   	push   %eax
  80f806:	68 71 3c 81 00       	push   $0x813c71
  80f80b:	68 e9 00 00 00       	push   $0xe9
  80f810:	68 66 3c 81 00       	push   $0x813c66
  80f815:	e8 2d f1 ff ff       	call   80e947 <_panic>

0080f81a <fork>:
//   Neither user exception stack should ever be marked copy-on-write,
//   so you must allocate a new page for the child's user exception stack.
//
envid_t
fork(void)
{
  80f81a:	f3 0f 1e fb          	endbr32 
  80f81e:	55                   	push   %ebp
  80f81f:	89 e5                	mov    %esp,%ebp
  80f821:	57                   	push   %edi
  80f822:	56                   	push   %esi
  80f823:	53                   	push   %ebx
  80f824:	83 ec 28             	sub    $0x28,%esp
	// LAB 4: Your code here.
	extern void _pgfault_upcall(void);
	set_pgfault_handler(pgfault);
  80f827:	68 3a f7 80 00       	push   $0x80f73a
  80f82c:	e8 c3 17 00 00       	call   810ff4 <set_pgfault_handler>
// This must be inlined.  Exercise for reader: why?
static inline envid_t __attribute__((always_inline))
sys_exofork(void)
{
	envid_t ret;
	asm volatile("int %2"
  80f831:	b8 07 00 00 00       	mov    $0x7,%eax
  80f836:	cd 30                	int    $0x30
  80f838:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	envid_t envid = sys_exofork();
	if (envid < 0)
  80f83b:	83 c4 10             	add    $0x10,%esp
  80f83e:	85 c0                	test   %eax,%eax
  80f840:	78 2d                	js     80f86f <fork+0x55>
  80f842:	89 c7                	mov    %eax,%edi
		thisenv = &envs[ENVX(sys_getenvid())];
		return 0;
	}

	uint32_t addr;
	for (addr = 0; addr < USTACKTOP; addr += PGSIZE) {
  80f844:	bb 00 00 00 00       	mov    $0x0,%ebx
	if (envid == 0) {
  80f849:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
  80f84d:	0f 85 9b 00 00 00    	jne    80f8ee <fork+0xd4>
		thisenv = &envs[ENVX(sys_getenvid())];
  80f853:	e8 dc fb ff ff       	call   80f434 <sys_getenvid>
  80f858:	25 ff 03 00 00       	and    $0x3ff,%eax
  80f85d:	6b c0 7c             	imul   $0x7c,%eax,%eax
  80f860:	05 00 00 c0 ee       	add    $0xeec00000,%eax
  80f865:	a3 5c b2 b3 00       	mov    %eax,0xb3b25c
		return 0;
  80f86a:	e9 71 01 00 00       	jmp    80f9e0 <fork+0x1c6>
		panic("sys_exofork: %e", envid);
  80f86f:	50                   	push   %eax
  80f870:	68 7e 3c 81 00       	push   $0x813c7e
  80f875:	68 2a 01 00 00       	push   $0x12a
  80f87a:	68 66 3c 81 00       	push   $0x813c66
  80f87f:	e8 c3 f0 ff ff       	call   80e947 <_panic>
		sys_page_map(0, (void *) (pn * PGSIZE), envid, (void *) (pn * PGSIZE), PTE_SYSCALL);
  80f884:	c1 e6 0c             	shl    $0xc,%esi
  80f887:	83 ec 0c             	sub    $0xc,%esp
  80f88a:	68 07 0e 00 00       	push   $0xe07
  80f88f:	56                   	push   %esi
  80f890:	57                   	push   %edi
  80f891:	56                   	push   %esi
  80f892:	6a 00                	push   $0x0
  80f894:	e8 28 fc ff ff       	call   80f4c1 <sys_page_map>
  80f899:	83 c4 20             	add    $0x20,%esp
  80f89c:	eb 3e                	jmp    80f8dc <fork+0xc2>
		if ((r = sys_page_map(0, (void *) (pn * PGSIZE), envid, (void *) (pn * PGSIZE), perm)) < 0) {
  80f89e:	c1 e6 0c             	shl    $0xc,%esi
  80f8a1:	83 ec 0c             	sub    $0xc,%esp
  80f8a4:	68 05 08 00 00       	push   $0x805
  80f8a9:	56                   	push   %esi
  80f8aa:	57                   	push   %edi
  80f8ab:	56                   	push   %esi
  80f8ac:	6a 00                	push   $0x0
  80f8ae:	e8 0e fc ff ff       	call   80f4c1 <sys_page_map>
  80f8b3:	83 c4 20             	add    $0x20,%esp
  80f8b6:	85 c0                	test   %eax,%eax
  80f8b8:	0f 88 bc 00 00 00    	js     80f97a <fork+0x160>
		if ((r = sys_page_map(0, (void *) (pn * PGSIZE), 0, (void *) (pn * PGSIZE), perm)) < 0) {
  80f8be:	83 ec 0c             	sub    $0xc,%esp
  80f8c1:	68 05 08 00 00       	push   $0x805
  80f8c6:	56                   	push   %esi
  80f8c7:	6a 00                	push   $0x0
  80f8c9:	56                   	push   %esi
  80f8ca:	6a 00                	push   $0x0
  80f8cc:	e8 f0 fb ff ff       	call   80f4c1 <sys_page_map>
  80f8d1:	83 c4 20             	add    $0x20,%esp
  80f8d4:	85 c0                	test   %eax,%eax
  80f8d6:	0f 88 b3 00 00 00    	js     80f98f <fork+0x175>
	for (addr = 0; addr < USTACKTOP; addr += PGSIZE) {
  80f8dc:	81 c3 00 10 00 00    	add    $0x1000,%ebx
  80f8e2:	81 fb 00 e0 bf ee    	cmp    $0xeebfe000,%ebx
  80f8e8:	0f 84 b6 00 00 00    	je     80f9a4 <fork+0x18a>
		// uvpd是有1024个pde的一维数组，而uvpt是有2^20个pte的一维数组,与物理页号刚好一一对应
		if ((uvpd[PDX(addr)] & PTE_P) && (uvpt[PGNUM(addr)] & PTE_P) && (uvpt[PGNUM(addr)] & PTE_U)) {
  80f8ee:	89 d8                	mov    %ebx,%eax
  80f8f0:	c1 e8 16             	shr    $0x16,%eax
  80f8f3:	8b 04 85 00 d0 7b ef 	mov    -0x10843000(,%eax,4),%eax
  80f8fa:	a8 01                	test   $0x1,%al
  80f8fc:	74 de                	je     80f8dc <fork+0xc2>
  80f8fe:	89 de                	mov    %ebx,%esi
  80f900:	c1 ee 0c             	shr    $0xc,%esi
  80f903:	8b 04 b5 00 00 40 ef 	mov    -0x10c00000(,%esi,4),%eax
  80f90a:	a8 01                	test   $0x1,%al
  80f90c:	74 ce                	je     80f8dc <fork+0xc2>
  80f90e:	8b 04 b5 00 00 40 ef 	mov    -0x10c00000(,%esi,4),%eax
  80f915:	a8 04                	test   $0x4,%al
  80f917:	74 c3                	je     80f8dc <fork+0xc2>
	if ((uvpt[pn] & PTE_SHARE)){
  80f919:	8b 04 b5 00 00 40 ef 	mov    -0x10c00000(,%esi,4),%eax
  80f920:	f6 c4 04             	test   $0x4,%ah
  80f923:	0f 85 5b ff ff ff    	jne    80f884 <fork+0x6a>
	} else if ((uvpt[pn] & PTE_W) || (uvpt[pn] & PTE_COW)) {
  80f929:	8b 04 b5 00 00 40 ef 	mov    -0x10c00000(,%esi,4),%eax
  80f930:	a8 02                	test   $0x2,%al
  80f932:	0f 85 66 ff ff ff    	jne    80f89e <fork+0x84>
  80f938:	8b 04 b5 00 00 40 ef 	mov    -0x10c00000(,%esi,4),%eax
  80f93f:	f6 c4 08             	test   $0x8,%ah
  80f942:	0f 85 56 ff ff ff    	jne    80f89e <fork+0x84>
	} else if ((r = sys_page_map(0, (void *) (pn * PGSIZE), envid, (void *) (pn * PGSIZE), perm)) < 0) {
  80f948:	c1 e6 0c             	shl    $0xc,%esi
  80f94b:	83 ec 0c             	sub    $0xc,%esp
  80f94e:	6a 05                	push   $0x5
  80f950:	56                   	push   %esi
  80f951:	57                   	push   %edi
  80f952:	56                   	push   %esi
  80f953:	6a 00                	push   $0x0
  80f955:	e8 67 fb ff ff       	call   80f4c1 <sys_page_map>
  80f95a:	83 c4 20             	add    $0x20,%esp
  80f95d:	85 c0                	test   %eax,%eax
  80f95f:	0f 89 77 ff ff ff    	jns    80f8dc <fork+0xc2>
		panic("duppage: %e\n", r);
  80f965:	50                   	push   %eax
  80f966:	68 8e 3c 81 00       	push   $0x813c8e
  80f96b:	68 0c 01 00 00       	push   $0x10c
  80f970:	68 66 3c 81 00       	push   $0x813c66
  80f975:	e8 cd ef ff ff       	call   80e947 <_panic>
			panic("duppage: %e\n", r);
  80f97a:	50                   	push   %eax
  80f97b:	68 8e 3c 81 00       	push   $0x813c8e
  80f980:	68 05 01 00 00       	push   $0x105
  80f985:	68 66 3c 81 00       	push   $0x813c66
  80f98a:	e8 b8 ef ff ff       	call   80e947 <_panic>
			panic("duppage: %e\n", r);
  80f98f:	50                   	push   %eax
  80f990:	68 8e 3c 81 00       	push   $0x813c8e
  80f995:	68 09 01 00 00       	push   $0x109
  80f99a:	68 66 3c 81 00       	push   $0x813c66
  80f99f:	e8 a3 ef ff ff       	call   80e947 <_panic>
            duppage(envid, PGNUM(addr)); 
        }
	}

	int r;
	if ((r = sys_page_alloc(envid, (void *) (UXSTACKTOP - PGSIZE), PTE_U | PTE_W | PTE_P)) < 0)
  80f9a4:	83 ec 04             	sub    $0x4,%esp
  80f9a7:	6a 07                	push   $0x7
  80f9a9:	68 00 f0 bf ee       	push   $0xeebff000
  80f9ae:	ff 75 e4             	pushl  -0x1c(%ebp)
  80f9b1:	e8 c4 fa ff ff       	call   80f47a <sys_page_alloc>
  80f9b6:	83 c4 10             	add    $0x10,%esp
  80f9b9:	85 c0                	test   %eax,%eax
  80f9bb:	78 2e                	js     80f9eb <fork+0x1d1>
		panic("sys_page_alloc: %e", r);

	sys_env_set_pgfault_upcall(envid, _pgfault_upcall);
  80f9bd:	83 ec 08             	sub    $0x8,%esp
  80f9c0:	68 67 10 81 00       	push   $0x811067
  80f9c5:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  80f9c8:	57                   	push   %edi
  80f9c9:	e8 0b fc ff ff       	call   80f5d9 <sys_env_set_pgfault_upcall>
	// Start the child environment running
	if ((r = sys_env_set_status(envid, ENV_RUNNABLE)) < 0)
  80f9ce:	83 c4 08             	add    $0x8,%esp
  80f9d1:	6a 02                	push   $0x2
  80f9d3:	57                   	push   %edi
  80f9d4:	e8 74 fb ff ff       	call   80f54d <sys_env_set_status>
  80f9d9:	83 c4 10             	add    $0x10,%esp
  80f9dc:	85 c0                	test   %eax,%eax
  80f9de:	78 20                	js     80fa00 <fork+0x1e6>
		panic("sys_env_set_status: %e", r);

	return envid;
}
  80f9e0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80f9e3:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f9e6:	5b                   	pop    %ebx
  80f9e7:	5e                   	pop    %esi
  80f9e8:	5f                   	pop    %edi
  80f9e9:	5d                   	pop    %ebp
  80f9ea:	c3                   	ret    
		panic("sys_page_alloc: %e", r);
  80f9eb:	50                   	push   %eax
  80f9ec:	68 9b 3c 81 00       	push   $0x813c9b
  80f9f1:	68 3e 01 00 00       	push   $0x13e
  80f9f6:	68 66 3c 81 00       	push   $0x813c66
  80f9fb:	e8 47 ef ff ff       	call   80e947 <_panic>
		panic("sys_env_set_status: %e", r);
  80fa00:	50                   	push   %eax
  80fa01:	68 ae 3c 81 00       	push   $0x813cae
  80fa06:	68 43 01 00 00       	push   $0x143
  80fa0b:	68 66 3c 81 00       	push   $0x813c66
  80fa10:	e8 32 ef ff ff       	call   80e947 <_panic>

0080fa15 <sfork>:

// Challenge!
int
sfork(void)
{
  80fa15:	f3 0f 1e fb          	endbr32 
  80fa19:	55                   	push   %ebp
  80fa1a:	89 e5                	mov    %esp,%ebp
  80fa1c:	83 ec 0c             	sub    $0xc,%esp
	panic("sfork not implemented");
  80fa1f:	68 c5 3c 81 00       	push   $0x813cc5
  80fa24:	68 4c 01 00 00       	push   $0x14c
  80fa29:	68 66 3c 81 00       	push   $0x813c66
  80fa2e:	e8 14 ef ff ff       	call   80e947 <_panic>

0080fa33 <ipc_recv>:
//   If 'pg' is null, pass sys_ipc_recv a value that it will understand
//   as meaning "no page".  (Zero is not the right value, since that's
//   a perfectly valid place to map a page.)
int32_t
ipc_recv(envid_t *from_env_store, void *pg, int *perm_store)
{
  80fa33:	f3 0f 1e fb          	endbr32 
  80fa37:	55                   	push   %ebp
  80fa38:	89 e5                	mov    %esp,%ebp
  80fa3a:	56                   	push   %esi
  80fa3b:	53                   	push   %ebx
  80fa3c:	8b 75 08             	mov    0x8(%ebp),%esi
  80fa3f:	8b 45 0c             	mov    0xc(%ebp),%eax
  80fa42:	8b 5d 10             	mov    0x10(%ebp),%ebx
	//	that address.

	//   If 'pg' is null, pass sys_ipc_recv a value that it will understand
	//   as meaning "no page".  (Zero is not the right value, since that's
	//   a perfectly valid place to map a page.)
	if(pg){
  80fa45:	85 c0                	test   %eax,%eax
  80fa47:	74 3d                	je     80fa86 <ipc_recv+0x53>
		r = sys_ipc_recv(pg);
  80fa49:	83 ec 0c             	sub    $0xc,%esp
  80fa4c:	50                   	push   %eax
  80fa4d:	e8 f4 fb ff ff       	call   80f646 <sys_ipc_recv>
  80fa52:	83 c4 10             	add    $0x10,%esp
	}

	// If 'from_env_store' is nonnull, then store the IPC sender's envid in
	//	*from_env_store.
	//   Use 'thisenv' to discover the value and who sent it.
	if(from_env_store){
  80fa55:	85 f6                	test   %esi,%esi
  80fa57:	74 0b                	je     80fa64 <ipc_recv+0x31>
		*from_env_store = thisenv->env_ipc_from;
  80fa59:	8b 15 5c b2 b3 00    	mov    0xb3b25c,%edx
  80fa5f:	8b 52 74             	mov    0x74(%edx),%edx
  80fa62:	89 16                	mov    %edx,(%esi)
	}

	// If 'perm_store' is nonnull, then store the IPC sender's page permission
	//	in *perm_store (this is nonzero iff a page was successfully
	//	transferred to 'pg').
	if(perm_store){
  80fa64:	85 db                	test   %ebx,%ebx
  80fa66:	74 0b                	je     80fa73 <ipc_recv+0x40>
		*perm_store = thisenv->env_ipc_perm;
  80fa68:	8b 15 5c b2 b3 00    	mov    0xb3b25c,%edx
  80fa6e:	8b 52 78             	mov    0x78(%edx),%edx
  80fa71:	89 13                	mov    %edx,(%ebx)
	}

	// If the system call fails, then store 0 in *fromenv and *perm (if
	//	they're nonnull) and return the error.
	// Otherwise, return the value sent by the sender
	if(r < 0){
  80fa73:	85 c0                	test   %eax,%eax
  80fa75:	78 21                	js     80fa98 <ipc_recv+0x65>
		if(!from_env_store) *from_env_store = 0;
		if(!perm_store) *perm_store = 0;
		return r;
	}

	return thisenv->env_ipc_value;
  80fa77:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
  80fa7c:	8b 40 70             	mov    0x70(%eax),%eax
}
  80fa7f:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80fa82:	5b                   	pop    %ebx
  80fa83:	5e                   	pop    %esi
  80fa84:	5d                   	pop    %ebp
  80fa85:	c3                   	ret    
		r = sys_ipc_recv((void*)UTOP);
  80fa86:	83 ec 0c             	sub    $0xc,%esp
  80fa89:	68 00 00 c0 ee       	push   $0xeec00000
  80fa8e:	e8 b3 fb ff ff       	call   80f646 <sys_ipc_recv>
  80fa93:	83 c4 10             	add    $0x10,%esp
  80fa96:	eb bd                	jmp    80fa55 <ipc_recv+0x22>
		if(!from_env_store) *from_env_store = 0;
  80fa98:	85 f6                	test   %esi,%esi
  80fa9a:	74 10                	je     80faac <ipc_recv+0x79>
		if(!perm_store) *perm_store = 0;
  80fa9c:	85 db                	test   %ebx,%ebx
  80fa9e:	75 df                	jne    80fa7f <ipc_recv+0x4c>
  80faa0:	c7 05 00 00 00 00 00 	movl   $0x0,0x0
  80faa7:	00 00 00 
  80faaa:	eb d3                	jmp    80fa7f <ipc_recv+0x4c>
		if(!from_env_store) *from_env_store = 0;
  80faac:	c7 05 00 00 00 00 00 	movl   $0x0,0x0
  80fab3:	00 00 00 
  80fab6:	eb e4                	jmp    80fa9c <ipc_recv+0x69>

0080fab8 <ipc_send>:
//   Use sys_yield() to be CPU-friendly.
//   If 'pg' is null, pass sys_ipc_try_send a value that it will understand
//   as meaning "no page".  (Zero is not the right value.)
void
ipc_send(envid_t to_env, uint32_t val, void *pg, int perm)
{
  80fab8:	f3 0f 1e fb          	endbr32 
  80fabc:	55                   	push   %ebp
  80fabd:	89 e5                	mov    %esp,%ebp
  80fabf:	57                   	push   %edi
  80fac0:	56                   	push   %esi
  80fac1:	53                   	push   %ebx
  80fac2:	83 ec 0c             	sub    $0xc,%esp
  80fac5:	8b 7d 08             	mov    0x8(%ebp),%edi
  80fac8:	8b 75 0c             	mov    0xc(%ebp),%esi
  80facb:	8b 5d 10             	mov    0x10(%ebp),%ebx
	// LAB 4: Your code here.
	//panic("ipc_send not implemented");
	int r;

	if(!pg) pg = (void*)UTOP;
  80face:	85 db                	test   %ebx,%ebx
  80fad0:	b8 00 00 c0 ee       	mov    $0xeec00000,%eax
  80fad5:	0f 44 d8             	cmove  %eax,%ebx

	while((r = sys_ipc_try_send(to_env, val, pg, perm)) < 0){
  80fad8:	ff 75 14             	pushl  0x14(%ebp)
  80fadb:	53                   	push   %ebx
  80fadc:	56                   	push   %esi
  80fadd:	57                   	push   %edi
  80fade:	e8 3c fb ff ff       	call   80f61f <sys_ipc_try_send>
  80fae3:	83 c4 10             	add    $0x10,%esp
  80fae6:	85 c0                	test   %eax,%eax
  80fae8:	79 1e                	jns    80fb08 <ipc_send+0x50>
		if(r != -E_IPC_NOT_RECV){
  80faea:	83 f8 f9             	cmp    $0xfffffff9,%eax
  80faed:	75 07                	jne    80faf6 <ipc_send+0x3e>
			panic("sys_ipc_try_send error %d\n", r);
		}
		sys_yield();
  80faef:	e8 63 f9 ff ff       	call   80f457 <sys_yield>
  80faf4:	eb e2                	jmp    80fad8 <ipc_send+0x20>
			panic("sys_ipc_try_send error %d\n", r);
  80faf6:	50                   	push   %eax
  80faf7:	68 db 3c 81 00       	push   $0x813cdb
  80fafc:	6a 59                	push   $0x59
  80fafe:	68 f6 3c 81 00       	push   $0x813cf6
  80fb03:	e8 3f ee ff ff       	call   80e947 <_panic>
	}
}
  80fb08:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80fb0b:	5b                   	pop    %ebx
  80fb0c:	5e                   	pop    %esi
  80fb0d:	5f                   	pop    %edi
  80fb0e:	5d                   	pop    %ebp
  80fb0f:	c3                   	ret    

0080fb10 <ipc_find_env>:
// Find the first environment of the given type.  We'll use this to
// find special environments.
// Returns 0 if no such environment exists.
envid_t
ipc_find_env(enum EnvType type)
{
  80fb10:	f3 0f 1e fb          	endbr32 
  80fb14:	55                   	push   %ebp
  80fb15:	89 e5                	mov    %esp,%ebp
  80fb17:	8b 4d 08             	mov    0x8(%ebp),%ecx
	int i;
	for (i = 0; i < NENV; i++)
  80fb1a:	b8 00 00 00 00       	mov    $0x0,%eax
		if (envs[i].env_type == type)
  80fb1f:	6b d0 7c             	imul   $0x7c,%eax,%edx
  80fb22:	81 c2 00 00 c0 ee    	add    $0xeec00000,%edx
  80fb28:	8b 52 50             	mov    0x50(%edx),%edx
  80fb2b:	39 ca                	cmp    %ecx,%edx
  80fb2d:	74 11                	je     80fb40 <ipc_find_env+0x30>
	for (i = 0; i < NENV; i++)
  80fb2f:	83 c0 01             	add    $0x1,%eax
  80fb32:	3d 00 04 00 00       	cmp    $0x400,%eax
  80fb37:	75 e6                	jne    80fb1f <ipc_find_env+0xf>
			return envs[i].env_id;
	return 0;
  80fb39:	b8 00 00 00 00       	mov    $0x0,%eax
  80fb3e:	eb 0b                	jmp    80fb4b <ipc_find_env+0x3b>
			return envs[i].env_id;
  80fb40:	6b c0 7c             	imul   $0x7c,%eax,%eax
  80fb43:	05 00 00 c0 ee       	add    $0xeec00000,%eax
  80fb48:	8b 40 48             	mov    0x48(%eax),%eax
}
  80fb4b:	5d                   	pop    %ebp
  80fb4c:	c3                   	ret    

0080fb4d <fd2num>:
// File descriptor manipulators
// --------------------------------------------------------------

int
fd2num(struct Fd *fd)
{
  80fb4d:	f3 0f 1e fb          	endbr32 
  80fb51:	55                   	push   %ebp
  80fb52:	89 e5                	mov    %esp,%ebp
	return ((uintptr_t) fd - FDTABLE) / PGSIZE;
  80fb54:	8b 45 08             	mov    0x8(%ebp),%eax
  80fb57:	05 00 00 00 30       	add    $0x30000000,%eax
  80fb5c:	c1 e8 0c             	shr    $0xc,%eax
}
  80fb5f:	5d                   	pop    %ebp
  80fb60:	c3                   	ret    

0080fb61 <fd2data>:

char*
fd2data(struct Fd *fd)
{
  80fb61:	f3 0f 1e fb          	endbr32 
  80fb65:	55                   	push   %ebp
  80fb66:	89 e5                	mov    %esp,%ebp
	return ((uintptr_t) fd - FDTABLE) / PGSIZE;
  80fb68:	8b 45 08             	mov    0x8(%ebp),%eax
  80fb6b:	05 00 00 00 30       	add    $0x30000000,%eax
	return INDEX2DATA(fd2num(fd));
  80fb70:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  80fb75:	2d 00 00 fe 2f       	sub    $0x2ffe0000,%eax
}
  80fb7a:	5d                   	pop    %ebp
  80fb7b:	c3                   	ret    

0080fb7c <fd_alloc>:
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_MAX_FD: no more file descriptors
// On error, *fd_store is set to 0.
int
fd_alloc(struct Fd **fd_store)
{
  80fb7c:	f3 0f 1e fb          	endbr32 
  80fb80:	55                   	push   %ebp
  80fb81:	89 e5                	mov    %esp,%ebp
  80fb83:	b8 00 00 00 d0       	mov    $0xd0000000,%eax
	int i;
	struct Fd *fd;

	for (i = 0; i < MAXFD; i++) {
		fd = INDEX2FD(i);
		if ((uvpd[PDX(fd)] & PTE_P) == 0 || (uvpt[PGNUM(fd)] & PTE_P) == 0) {
  80fb88:	89 c2                	mov    %eax,%edx
  80fb8a:	c1 ea 16             	shr    $0x16,%edx
  80fb8d:	8b 14 95 00 d0 7b ef 	mov    -0x10843000(,%edx,4),%edx
  80fb94:	f6 c2 01             	test   $0x1,%dl
  80fb97:	74 2d                	je     80fbc6 <fd_alloc+0x4a>
  80fb99:	89 c2                	mov    %eax,%edx
  80fb9b:	c1 ea 0c             	shr    $0xc,%edx
  80fb9e:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx
  80fba5:	f6 c2 01             	test   $0x1,%dl
  80fba8:	74 1c                	je     80fbc6 <fd_alloc+0x4a>
  80fbaa:	05 00 10 00 00       	add    $0x1000,%eax
	for (i = 0; i < MAXFD; i++) {
  80fbaf:	3d 00 00 02 d0       	cmp    $0xd0020000,%eax
  80fbb4:	75 d2                	jne    80fb88 <fd_alloc+0xc>
			*fd_store = fd;
			return 0;
		}
	}
	*fd_store = 0;
  80fbb6:	8b 45 08             	mov    0x8(%ebp),%eax
  80fbb9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return -E_MAX_OPEN;
  80fbbf:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  80fbc4:	eb 0a                	jmp    80fbd0 <fd_alloc+0x54>
			*fd_store = fd;
  80fbc6:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80fbc9:	89 01                	mov    %eax,(%ecx)
			return 0;
  80fbcb:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80fbd0:	5d                   	pop    %ebp
  80fbd1:	c3                   	ret    

0080fbd2 <fd_lookup>:
// Returns 0 on success (the page is in range and mapped), < 0 on error.
// Errors are:
//	-E_INVAL: fdnum was either not in range or not mapped.
int
fd_lookup(int fdnum, struct Fd **fd_store)
{
  80fbd2:	f3 0f 1e fb          	endbr32 
  80fbd6:	55                   	push   %ebp
  80fbd7:	89 e5                	mov    %esp,%ebp
  80fbd9:	8b 45 08             	mov    0x8(%ebp),%eax
	struct Fd *fd;

	if (fdnum < 0 || fdnum >= MAXFD) {
  80fbdc:	83 f8 1f             	cmp    $0x1f,%eax
  80fbdf:	77 30                	ja     80fc11 <fd_lookup+0x3f>
		if (debug)
			cprintf("[%08x] bad fd %d\n", thisenv->env_id, fdnum);
		return -E_INVAL;
	}
	fd = INDEX2FD(fdnum);
  80fbe1:	c1 e0 0c             	shl    $0xc,%eax
  80fbe4:	2d 00 00 00 30       	sub    $0x30000000,%eax
	if (!(uvpd[PDX(fd)] & PTE_P) || !(uvpt[PGNUM(fd)] & PTE_P)) {
  80fbe9:	8b 15 00 dd 7b ef    	mov    0xef7bdd00,%edx
  80fbef:	f6 c2 01             	test   $0x1,%dl
  80fbf2:	74 24                	je     80fc18 <fd_lookup+0x46>
  80fbf4:	89 c2                	mov    %eax,%edx
  80fbf6:	c1 ea 0c             	shr    $0xc,%edx
  80fbf9:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx
  80fc00:	f6 c2 01             	test   $0x1,%dl
  80fc03:	74 1a                	je     80fc1f <fd_lookup+0x4d>
		if (debug)
			cprintf("[%08x] closed fd %d\n", thisenv->env_id, fdnum);
		return -E_INVAL;
	}
	*fd_store = fd;
  80fc05:	8b 55 0c             	mov    0xc(%ebp),%edx
  80fc08:	89 02                	mov    %eax,(%edx)
	return 0;
  80fc0a:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80fc0f:	5d                   	pop    %ebp
  80fc10:	c3                   	ret    
		return -E_INVAL;
  80fc11:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80fc16:	eb f7                	jmp    80fc0f <fd_lookup+0x3d>
		return -E_INVAL;
  80fc18:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80fc1d:	eb f0                	jmp    80fc0f <fd_lookup+0x3d>
  80fc1f:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80fc24:	eb e9                	jmp    80fc0f <fd_lookup+0x3d>

0080fc26 <dev_lookup>:
	0
};

int
dev_lookup(int dev_id, struct Dev **dev)
{
  80fc26:	f3 0f 1e fb          	endbr32 
  80fc2a:	55                   	push   %ebp
  80fc2b:	89 e5                	mov    %esp,%ebp
  80fc2d:	83 ec 08             	sub    $0x8,%esp
  80fc30:	8b 4d 08             	mov    0x8(%ebp),%ecx
	int i;
	for (i = 0; devtab[i]; i++)
  80fc33:	ba 00 00 00 00       	mov    $0x0,%edx
  80fc38:	b8 ec 42 81 00       	mov    $0x8142ec,%eax
		if (devtab[i]->dev_id == dev_id) {
  80fc3d:	39 08                	cmp    %ecx,(%eax)
  80fc3f:	74 38                	je     80fc79 <dev_lookup+0x53>
	for (i = 0; devtab[i]; i++)
  80fc41:	83 c2 01             	add    $0x1,%edx
  80fc44:	8b 04 95 7c 3d 81 00 	mov    0x813d7c(,%edx,4),%eax
  80fc4b:	85 c0                	test   %eax,%eax
  80fc4d:	75 ee                	jne    80fc3d <dev_lookup+0x17>
			*dev = devtab[i];
			return 0;
		}
	cprintf("[%08x] unknown device type %d\n", thisenv->env_id, dev_id);
  80fc4f:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
  80fc54:	8b 40 48             	mov    0x48(%eax),%eax
  80fc57:	83 ec 04             	sub    $0x4,%esp
  80fc5a:	51                   	push   %ecx
  80fc5b:	50                   	push   %eax
  80fc5c:	68 00 3d 81 00       	push   $0x813d00
  80fc61:	e8 c8 ed ff ff       	call   80ea2e <cprintf>
	*dev = 0;
  80fc66:	8b 45 0c             	mov    0xc(%ebp),%eax
  80fc69:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return -E_INVAL;
  80fc6f:	83 c4 10             	add    $0x10,%esp
  80fc72:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
}
  80fc77:	c9                   	leave  
  80fc78:	c3                   	ret    
			*dev = devtab[i];
  80fc79:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80fc7c:	89 01                	mov    %eax,(%ecx)
			return 0;
  80fc7e:	b8 00 00 00 00       	mov    $0x0,%eax
  80fc83:	eb f2                	jmp    80fc77 <dev_lookup+0x51>

0080fc85 <fd_close>:
{
  80fc85:	f3 0f 1e fb          	endbr32 
  80fc89:	55                   	push   %ebp
  80fc8a:	89 e5                	mov    %esp,%ebp
  80fc8c:	57                   	push   %edi
  80fc8d:	56                   	push   %esi
  80fc8e:	53                   	push   %ebx
  80fc8f:	83 ec 24             	sub    $0x24,%esp
  80fc92:	8b 75 08             	mov    0x8(%ebp),%esi
  80fc95:	8b 7d 0c             	mov    0xc(%ebp),%edi
	if ((r = fd_lookup(fd2num(fd), &fd2)) < 0
  80fc98:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80fc9b:	50                   	push   %eax
	return ((uintptr_t) fd - FDTABLE) / PGSIZE;
  80fc9c:	8d 86 00 00 00 30    	lea    0x30000000(%esi),%eax
  80fca2:	c1 e8 0c             	shr    $0xc,%eax
	if ((r = fd_lookup(fd2num(fd), &fd2)) < 0
  80fca5:	50                   	push   %eax
  80fca6:	e8 27 ff ff ff       	call   80fbd2 <fd_lookup>
  80fcab:	89 c3                	mov    %eax,%ebx
  80fcad:	83 c4 10             	add    $0x10,%esp
  80fcb0:	85 c0                	test   %eax,%eax
  80fcb2:	78 05                	js     80fcb9 <fd_close+0x34>
	    || fd != fd2)
  80fcb4:	39 75 e4             	cmp    %esi,-0x1c(%ebp)
  80fcb7:	74 16                	je     80fccf <fd_close+0x4a>
		return (must_exist ? r : 0);
  80fcb9:	89 f8                	mov    %edi,%eax
  80fcbb:	84 c0                	test   %al,%al
  80fcbd:	b8 00 00 00 00       	mov    $0x0,%eax
  80fcc2:	0f 44 d8             	cmove  %eax,%ebx
}
  80fcc5:	89 d8                	mov    %ebx,%eax
  80fcc7:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80fcca:	5b                   	pop    %ebx
  80fccb:	5e                   	pop    %esi
  80fccc:	5f                   	pop    %edi
  80fccd:	5d                   	pop    %ebp
  80fcce:	c3                   	ret    
	if ((r = dev_lookup(fd->fd_dev_id, &dev)) >= 0) {
  80fccf:	83 ec 08             	sub    $0x8,%esp
  80fcd2:	8d 45 e0             	lea    -0x20(%ebp),%eax
  80fcd5:	50                   	push   %eax
  80fcd6:	ff 36                	pushl  (%esi)
  80fcd8:	e8 49 ff ff ff       	call   80fc26 <dev_lookup>
  80fcdd:	89 c3                	mov    %eax,%ebx
  80fcdf:	83 c4 10             	add    $0x10,%esp
  80fce2:	85 c0                	test   %eax,%eax
  80fce4:	78 1a                	js     80fd00 <fd_close+0x7b>
		if (dev->dev_close)
  80fce6:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80fce9:	8b 40 10             	mov    0x10(%eax),%eax
			r = 0;
  80fcec:	bb 00 00 00 00       	mov    $0x0,%ebx
		if (dev->dev_close)
  80fcf1:	85 c0                	test   %eax,%eax
  80fcf3:	74 0b                	je     80fd00 <fd_close+0x7b>
			r = (*dev->dev_close)(fd);
  80fcf5:	83 ec 0c             	sub    $0xc,%esp
  80fcf8:	56                   	push   %esi
  80fcf9:	ff d0                	call   *%eax
  80fcfb:	89 c3                	mov    %eax,%ebx
  80fcfd:	83 c4 10             	add    $0x10,%esp
	(void) sys_page_unmap(0, fd);
  80fd00:	83 ec 08             	sub    $0x8,%esp
  80fd03:	56                   	push   %esi
  80fd04:	6a 00                	push   $0x0
  80fd06:	e8 fc f7 ff ff       	call   80f507 <sys_page_unmap>
	return r;
  80fd0b:	83 c4 10             	add    $0x10,%esp
  80fd0e:	eb b5                	jmp    80fcc5 <fd_close+0x40>

0080fd10 <close>:

int
close(int fdnum)
{
  80fd10:	f3 0f 1e fb          	endbr32 
  80fd14:	55                   	push   %ebp
  80fd15:	89 e5                	mov    %esp,%ebp
  80fd17:	83 ec 20             	sub    $0x20,%esp
	struct Fd *fd;
	int r;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  80fd1a:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80fd1d:	50                   	push   %eax
  80fd1e:	ff 75 08             	pushl  0x8(%ebp)
  80fd21:	e8 ac fe ff ff       	call   80fbd2 <fd_lookup>
  80fd26:	83 c4 10             	add    $0x10,%esp
  80fd29:	85 c0                	test   %eax,%eax
  80fd2b:	79 02                	jns    80fd2f <close+0x1f>
		return r;
	else
		return fd_close(fd, 1);
}
  80fd2d:	c9                   	leave  
  80fd2e:	c3                   	ret    
		return fd_close(fd, 1);
  80fd2f:	83 ec 08             	sub    $0x8,%esp
  80fd32:	6a 01                	push   $0x1
  80fd34:	ff 75 f4             	pushl  -0xc(%ebp)
  80fd37:	e8 49 ff ff ff       	call   80fc85 <fd_close>
  80fd3c:	83 c4 10             	add    $0x10,%esp
  80fd3f:	eb ec                	jmp    80fd2d <close+0x1d>

0080fd41 <close_all>:

void
close_all(void)
{
  80fd41:	f3 0f 1e fb          	endbr32 
  80fd45:	55                   	push   %ebp
  80fd46:	89 e5                	mov    %esp,%ebp
  80fd48:	53                   	push   %ebx
  80fd49:	83 ec 04             	sub    $0x4,%esp
	int i;
	for (i = 0; i < MAXFD; i++)
  80fd4c:	bb 00 00 00 00       	mov    $0x0,%ebx
		close(i);
  80fd51:	83 ec 0c             	sub    $0xc,%esp
  80fd54:	53                   	push   %ebx
  80fd55:	e8 b6 ff ff ff       	call   80fd10 <close>
	for (i = 0; i < MAXFD; i++)
  80fd5a:	83 c3 01             	add    $0x1,%ebx
  80fd5d:	83 c4 10             	add    $0x10,%esp
  80fd60:	83 fb 20             	cmp    $0x20,%ebx
  80fd63:	75 ec                	jne    80fd51 <close_all+0x10>
}
  80fd65:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80fd68:	c9                   	leave  
  80fd69:	c3                   	ret    

0080fd6a <dup>:
// file and the file offset of the other.
// Closes any previously open file descriptor at 'newfdnum'.
// This is implemented using virtual memory tricks (of course!).
int
dup(int oldfdnum, int newfdnum)
{
  80fd6a:	f3 0f 1e fb          	endbr32 
  80fd6e:	55                   	push   %ebp
  80fd6f:	89 e5                	mov    %esp,%ebp
  80fd71:	57                   	push   %edi
  80fd72:	56                   	push   %esi
  80fd73:	53                   	push   %ebx
  80fd74:	83 ec 24             	sub    $0x24,%esp
	int r;
	char *ova, *nva;
	pte_t pte;
	struct Fd *oldfd, *newfd;

	if ((r = fd_lookup(oldfdnum, &oldfd)) < 0)
  80fd77:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80fd7a:	50                   	push   %eax
  80fd7b:	ff 75 08             	pushl  0x8(%ebp)
  80fd7e:	e8 4f fe ff ff       	call   80fbd2 <fd_lookup>
  80fd83:	89 c3                	mov    %eax,%ebx
  80fd85:	83 c4 10             	add    $0x10,%esp
  80fd88:	85 c0                	test   %eax,%eax
  80fd8a:	0f 88 81 00 00 00    	js     80fe11 <dup+0xa7>
		return r;
	close(newfdnum);
  80fd90:	83 ec 0c             	sub    $0xc,%esp
  80fd93:	ff 75 0c             	pushl  0xc(%ebp)
  80fd96:	e8 75 ff ff ff       	call   80fd10 <close>

	newfd = INDEX2FD(newfdnum);
  80fd9b:	8b 75 0c             	mov    0xc(%ebp),%esi
  80fd9e:	c1 e6 0c             	shl    $0xc,%esi
  80fda1:	81 ee 00 00 00 30    	sub    $0x30000000,%esi
	ova = fd2data(oldfd);
  80fda7:	83 c4 04             	add    $0x4,%esp
  80fdaa:	ff 75 e4             	pushl  -0x1c(%ebp)
  80fdad:	e8 af fd ff ff       	call   80fb61 <fd2data>
  80fdb2:	89 c3                	mov    %eax,%ebx
	nva = fd2data(newfd);
  80fdb4:	89 34 24             	mov    %esi,(%esp)
  80fdb7:	e8 a5 fd ff ff       	call   80fb61 <fd2data>
  80fdbc:	83 c4 10             	add    $0x10,%esp
  80fdbf:	89 c7                	mov    %eax,%edi

	if ((uvpd[PDX(ova)] & PTE_P) && (uvpt[PGNUM(ova)] & PTE_P))
  80fdc1:	89 d8                	mov    %ebx,%eax
  80fdc3:	c1 e8 16             	shr    $0x16,%eax
  80fdc6:	8b 04 85 00 d0 7b ef 	mov    -0x10843000(,%eax,4),%eax
  80fdcd:	a8 01                	test   $0x1,%al
  80fdcf:	74 11                	je     80fde2 <dup+0x78>
  80fdd1:	89 d8                	mov    %ebx,%eax
  80fdd3:	c1 e8 0c             	shr    $0xc,%eax
  80fdd6:	8b 14 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%edx
  80fddd:	f6 c2 01             	test   $0x1,%dl
  80fde0:	75 39                	jne    80fe1b <dup+0xb1>
		if ((r = sys_page_map(0, ova, 0, nva, uvpt[PGNUM(ova)] & PTE_SYSCALL)) < 0)
			goto err;
	if ((r = sys_page_map(0, oldfd, 0, newfd, uvpt[PGNUM(oldfd)] & PTE_SYSCALL)) < 0)
  80fde2:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80fde5:	89 d0                	mov    %edx,%eax
  80fde7:	c1 e8 0c             	shr    $0xc,%eax
  80fdea:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
  80fdf1:	83 ec 0c             	sub    $0xc,%esp
  80fdf4:	25 07 0e 00 00       	and    $0xe07,%eax
  80fdf9:	50                   	push   %eax
  80fdfa:	56                   	push   %esi
  80fdfb:	6a 00                	push   $0x0
  80fdfd:	52                   	push   %edx
  80fdfe:	6a 00                	push   $0x0
  80fe00:	e8 bc f6 ff ff       	call   80f4c1 <sys_page_map>
  80fe05:	89 c3                	mov    %eax,%ebx
  80fe07:	83 c4 20             	add    $0x20,%esp
  80fe0a:	85 c0                	test   %eax,%eax
  80fe0c:	78 31                	js     80fe3f <dup+0xd5>
		goto err;

	return newfdnum;
  80fe0e:	8b 5d 0c             	mov    0xc(%ebp),%ebx

err:
	sys_page_unmap(0, newfd);
	sys_page_unmap(0, nva);
	return r;
}
  80fe11:	89 d8                	mov    %ebx,%eax
  80fe13:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80fe16:	5b                   	pop    %ebx
  80fe17:	5e                   	pop    %esi
  80fe18:	5f                   	pop    %edi
  80fe19:	5d                   	pop    %ebp
  80fe1a:	c3                   	ret    
		if ((r = sys_page_map(0, ova, 0, nva, uvpt[PGNUM(ova)] & PTE_SYSCALL)) < 0)
  80fe1b:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
  80fe22:	83 ec 0c             	sub    $0xc,%esp
  80fe25:	25 07 0e 00 00       	and    $0xe07,%eax
  80fe2a:	50                   	push   %eax
  80fe2b:	57                   	push   %edi
  80fe2c:	6a 00                	push   $0x0
  80fe2e:	53                   	push   %ebx
  80fe2f:	6a 00                	push   $0x0
  80fe31:	e8 8b f6 ff ff       	call   80f4c1 <sys_page_map>
  80fe36:	89 c3                	mov    %eax,%ebx
  80fe38:	83 c4 20             	add    $0x20,%esp
  80fe3b:	85 c0                	test   %eax,%eax
  80fe3d:	79 a3                	jns    80fde2 <dup+0x78>
	sys_page_unmap(0, newfd);
  80fe3f:	83 ec 08             	sub    $0x8,%esp
  80fe42:	56                   	push   %esi
  80fe43:	6a 00                	push   $0x0
  80fe45:	e8 bd f6 ff ff       	call   80f507 <sys_page_unmap>
	sys_page_unmap(0, nva);
  80fe4a:	83 c4 08             	add    $0x8,%esp
  80fe4d:	57                   	push   %edi
  80fe4e:	6a 00                	push   $0x0
  80fe50:	e8 b2 f6 ff ff       	call   80f507 <sys_page_unmap>
	return r;
  80fe55:	83 c4 10             	add    $0x10,%esp
  80fe58:	eb b7                	jmp    80fe11 <dup+0xa7>

0080fe5a <read>:

ssize_t
read(int fdnum, void *buf, size_t n)
{
  80fe5a:	f3 0f 1e fb          	endbr32 
  80fe5e:	55                   	push   %ebp
  80fe5f:	89 e5                	mov    %esp,%ebp
  80fe61:	53                   	push   %ebx
  80fe62:	83 ec 1c             	sub    $0x1c,%esp
  80fe65:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  80fe68:	8d 45 f0             	lea    -0x10(%ebp),%eax
  80fe6b:	50                   	push   %eax
  80fe6c:	53                   	push   %ebx
  80fe6d:	e8 60 fd ff ff       	call   80fbd2 <fd_lookup>
  80fe72:	83 c4 10             	add    $0x10,%esp
  80fe75:	85 c0                	test   %eax,%eax
  80fe77:	78 3f                	js     80feb8 <read+0x5e>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  80fe79:	83 ec 08             	sub    $0x8,%esp
  80fe7c:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80fe7f:	50                   	push   %eax
  80fe80:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80fe83:	ff 30                	pushl  (%eax)
  80fe85:	e8 9c fd ff ff       	call   80fc26 <dev_lookup>
  80fe8a:	83 c4 10             	add    $0x10,%esp
  80fe8d:	85 c0                	test   %eax,%eax
  80fe8f:	78 27                	js     80feb8 <read+0x5e>
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_WRONLY) {
  80fe91:	8b 55 f0             	mov    -0x10(%ebp),%edx
  80fe94:	8b 42 08             	mov    0x8(%edx),%eax
  80fe97:	83 e0 03             	and    $0x3,%eax
  80fe9a:	83 f8 01             	cmp    $0x1,%eax
  80fe9d:	74 1e                	je     80febd <read+0x63>
		cprintf("[%08x] read %d -- bad mode\n", thisenv->env_id, fdnum);
		return -E_INVAL;
	}
	if (!dev->dev_read)
  80fe9f:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80fea2:	8b 40 08             	mov    0x8(%eax),%eax
  80fea5:	85 c0                	test   %eax,%eax
  80fea7:	74 35                	je     80fede <read+0x84>
		return -E_NOT_SUPP;
	return (*dev->dev_read)(fd, buf, n);
  80fea9:	83 ec 04             	sub    $0x4,%esp
  80feac:	ff 75 10             	pushl  0x10(%ebp)
  80feaf:	ff 75 0c             	pushl  0xc(%ebp)
  80feb2:	52                   	push   %edx
  80feb3:	ff d0                	call   *%eax
  80feb5:	83 c4 10             	add    $0x10,%esp
}
  80feb8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80febb:	c9                   	leave  
  80febc:	c3                   	ret    
		cprintf("[%08x] read %d -- bad mode\n", thisenv->env_id, fdnum);
  80febd:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
  80fec2:	8b 40 48             	mov    0x48(%eax),%eax
  80fec5:	83 ec 04             	sub    $0x4,%esp
  80fec8:	53                   	push   %ebx
  80fec9:	50                   	push   %eax
  80feca:	68 41 3d 81 00       	push   $0x813d41
  80fecf:	e8 5a eb ff ff       	call   80ea2e <cprintf>
		return -E_INVAL;
  80fed4:	83 c4 10             	add    $0x10,%esp
  80fed7:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80fedc:	eb da                	jmp    80feb8 <read+0x5e>
		return -E_NOT_SUPP;
  80fede:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
  80fee3:	eb d3                	jmp    80feb8 <read+0x5e>

0080fee5 <readn>:

ssize_t
readn(int fdnum, void *buf, size_t n)
{
  80fee5:	f3 0f 1e fb          	endbr32 
  80fee9:	55                   	push   %ebp
  80feea:	89 e5                	mov    %esp,%ebp
  80feec:	57                   	push   %edi
  80feed:	56                   	push   %esi
  80feee:	53                   	push   %ebx
  80feef:	83 ec 0c             	sub    $0xc,%esp
  80fef2:	8b 7d 08             	mov    0x8(%ebp),%edi
  80fef5:	8b 75 10             	mov    0x10(%ebp),%esi
	int m, tot;

	for (tot = 0; tot < n; tot += m) {
  80fef8:	bb 00 00 00 00       	mov    $0x0,%ebx
  80fefd:	eb 02                	jmp    80ff01 <readn+0x1c>
  80feff:	01 c3                	add    %eax,%ebx
  80ff01:	39 f3                	cmp    %esi,%ebx
  80ff03:	73 21                	jae    80ff26 <readn+0x41>
		m = read(fdnum, (char*)buf + tot, n - tot);
  80ff05:	83 ec 04             	sub    $0x4,%esp
  80ff08:	89 f0                	mov    %esi,%eax
  80ff0a:	29 d8                	sub    %ebx,%eax
  80ff0c:	50                   	push   %eax
  80ff0d:	89 d8                	mov    %ebx,%eax
  80ff0f:	03 45 0c             	add    0xc(%ebp),%eax
  80ff12:	50                   	push   %eax
  80ff13:	57                   	push   %edi
  80ff14:	e8 41 ff ff ff       	call   80fe5a <read>
		if (m < 0)
  80ff19:	83 c4 10             	add    $0x10,%esp
  80ff1c:	85 c0                	test   %eax,%eax
  80ff1e:	78 04                	js     80ff24 <readn+0x3f>
			return m;
		if (m == 0)
  80ff20:	75 dd                	jne    80feff <readn+0x1a>
  80ff22:	eb 02                	jmp    80ff26 <readn+0x41>
		m = read(fdnum, (char*)buf + tot, n - tot);
  80ff24:	89 c3                	mov    %eax,%ebx
			break;
	}
	return tot;
}
  80ff26:	89 d8                	mov    %ebx,%eax
  80ff28:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80ff2b:	5b                   	pop    %ebx
  80ff2c:	5e                   	pop    %esi
  80ff2d:	5f                   	pop    %edi
  80ff2e:	5d                   	pop    %ebp
  80ff2f:	c3                   	ret    

0080ff30 <write>:

ssize_t
write(int fdnum, const void *buf, size_t n)
{
  80ff30:	f3 0f 1e fb          	endbr32 
  80ff34:	55                   	push   %ebp
  80ff35:	89 e5                	mov    %esp,%ebp
  80ff37:	53                   	push   %ebx
  80ff38:	83 ec 1c             	sub    $0x1c,%esp
  80ff3b:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  80ff3e:	8d 45 f0             	lea    -0x10(%ebp),%eax
  80ff41:	50                   	push   %eax
  80ff42:	53                   	push   %ebx
  80ff43:	e8 8a fc ff ff       	call   80fbd2 <fd_lookup>
  80ff48:	83 c4 10             	add    $0x10,%esp
  80ff4b:	85 c0                	test   %eax,%eax
  80ff4d:	78 3a                	js     80ff89 <write+0x59>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  80ff4f:	83 ec 08             	sub    $0x8,%esp
  80ff52:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80ff55:	50                   	push   %eax
  80ff56:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80ff59:	ff 30                	pushl  (%eax)
  80ff5b:	e8 c6 fc ff ff       	call   80fc26 <dev_lookup>
  80ff60:	83 c4 10             	add    $0x10,%esp
  80ff63:	85 c0                	test   %eax,%eax
  80ff65:	78 22                	js     80ff89 <write+0x59>
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
  80ff67:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80ff6a:	f6 40 08 03          	testb  $0x3,0x8(%eax)
  80ff6e:	74 1e                	je     80ff8e <write+0x5e>
		return -E_INVAL;
	}
	if (debug)
		cprintf("write %d %p %d via dev %s\n",
			fdnum, buf, n, dev->dev_name);
	if (!dev->dev_write)
  80ff70:	8b 55 f4             	mov    -0xc(%ebp),%edx
  80ff73:	8b 52 0c             	mov    0xc(%edx),%edx
  80ff76:	85 d2                	test   %edx,%edx
  80ff78:	74 35                	je     80ffaf <write+0x7f>
		return -E_NOT_SUPP;
	return (*dev->dev_write)(fd, buf, n);
  80ff7a:	83 ec 04             	sub    $0x4,%esp
  80ff7d:	ff 75 10             	pushl  0x10(%ebp)
  80ff80:	ff 75 0c             	pushl  0xc(%ebp)
  80ff83:	50                   	push   %eax
  80ff84:	ff d2                	call   *%edx
  80ff86:	83 c4 10             	add    $0x10,%esp
}
  80ff89:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80ff8c:	c9                   	leave  
  80ff8d:	c3                   	ret    
		cprintf("[%08x] write %d -- bad mode\n", thisenv->env_id, fdnum);
  80ff8e:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
  80ff93:	8b 40 48             	mov    0x48(%eax),%eax
  80ff96:	83 ec 04             	sub    $0x4,%esp
  80ff99:	53                   	push   %ebx
  80ff9a:	50                   	push   %eax
  80ff9b:	68 5d 3d 81 00       	push   $0x813d5d
  80ffa0:	e8 89 ea ff ff       	call   80ea2e <cprintf>
		return -E_INVAL;
  80ffa5:	83 c4 10             	add    $0x10,%esp
  80ffa8:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80ffad:	eb da                	jmp    80ff89 <write+0x59>
		return -E_NOT_SUPP;
  80ffaf:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
  80ffb4:	eb d3                	jmp    80ff89 <write+0x59>

0080ffb6 <seek>:

int
seek(int fdnum, off_t offset)
{
  80ffb6:	f3 0f 1e fb          	endbr32 
  80ffba:	55                   	push   %ebp
  80ffbb:	89 e5                	mov    %esp,%ebp
  80ffbd:	83 ec 20             	sub    $0x20,%esp
	int r;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  80ffc0:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80ffc3:	50                   	push   %eax
  80ffc4:	ff 75 08             	pushl  0x8(%ebp)
  80ffc7:	e8 06 fc ff ff       	call   80fbd2 <fd_lookup>
  80ffcc:	83 c4 10             	add    $0x10,%esp
  80ffcf:	85 c0                	test   %eax,%eax
  80ffd1:	78 0e                	js     80ffe1 <seek+0x2b>
		return r;
	fd->fd_offset = offset;
  80ffd3:	8b 55 0c             	mov    0xc(%ebp),%edx
  80ffd6:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80ffd9:	89 50 04             	mov    %edx,0x4(%eax)
	return 0;
  80ffdc:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80ffe1:	c9                   	leave  
  80ffe2:	c3                   	ret    

0080ffe3 <ftruncate>:

int
ftruncate(int fdnum, off_t newsize)
{
  80ffe3:	f3 0f 1e fb          	endbr32 
  80ffe7:	55                   	push   %ebp
  80ffe8:	89 e5                	mov    %esp,%ebp
  80ffea:	53                   	push   %ebx
  80ffeb:	83 ec 1c             	sub    $0x1c,%esp
  80ffee:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;
	if ((r = fd_lookup(fdnum, &fd)) < 0
  80fff1:	8d 45 f0             	lea    -0x10(%ebp),%eax
  80fff4:	50                   	push   %eax
  80fff5:	53                   	push   %ebx
  80fff6:	e8 d7 fb ff ff       	call   80fbd2 <fd_lookup>
  80fffb:	83 c4 10             	add    $0x10,%esp
  80fffe:	85 c0                	test   %eax,%eax
  810000:	78 37                	js     810039 <ftruncate+0x56>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  810002:	83 ec 08             	sub    $0x8,%esp
  810005:	8d 45 f4             	lea    -0xc(%ebp),%eax
  810008:	50                   	push   %eax
  810009:	8b 45 f0             	mov    -0x10(%ebp),%eax
  81000c:	ff 30                	pushl  (%eax)
  81000e:	e8 13 fc ff ff       	call   80fc26 <dev_lookup>
  810013:	83 c4 10             	add    $0x10,%esp
  810016:	85 c0                	test   %eax,%eax
  810018:	78 1f                	js     810039 <ftruncate+0x56>
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
  81001a:	8b 45 f0             	mov    -0x10(%ebp),%eax
  81001d:	f6 40 08 03          	testb  $0x3,0x8(%eax)
  810021:	74 1b                	je     81003e <ftruncate+0x5b>
		cprintf("[%08x] ftruncate %d -- bad mode\n",
			thisenv->env_id, fdnum);
		return -E_INVAL;
	}
	if (!dev->dev_trunc)
  810023:	8b 55 f4             	mov    -0xc(%ebp),%edx
  810026:	8b 52 18             	mov    0x18(%edx),%edx
  810029:	85 d2                	test   %edx,%edx
  81002b:	74 32                	je     81005f <ftruncate+0x7c>
		return -E_NOT_SUPP;
	return (*dev->dev_trunc)(fd, newsize);
  81002d:	83 ec 08             	sub    $0x8,%esp
  810030:	ff 75 0c             	pushl  0xc(%ebp)
  810033:	50                   	push   %eax
  810034:	ff d2                	call   *%edx
  810036:	83 c4 10             	add    $0x10,%esp
}
  810039:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  81003c:	c9                   	leave  
  81003d:	c3                   	ret    
			thisenv->env_id, fdnum);
  81003e:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
		cprintf("[%08x] ftruncate %d -- bad mode\n",
  810043:	8b 40 48             	mov    0x48(%eax),%eax
  810046:	83 ec 04             	sub    $0x4,%esp
  810049:	53                   	push   %ebx
  81004a:	50                   	push   %eax
  81004b:	68 20 3d 81 00       	push   $0x813d20
  810050:	e8 d9 e9 ff ff       	call   80ea2e <cprintf>
		return -E_INVAL;
  810055:	83 c4 10             	add    $0x10,%esp
  810058:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  81005d:	eb da                	jmp    810039 <ftruncate+0x56>
		return -E_NOT_SUPP;
  81005f:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
  810064:	eb d3                	jmp    810039 <ftruncate+0x56>

00810066 <fstat>:

int
fstat(int fdnum, struct Stat *stat)
{
  810066:	f3 0f 1e fb          	endbr32 
  81006a:	55                   	push   %ebp
  81006b:	89 e5                	mov    %esp,%ebp
  81006d:	53                   	push   %ebx
  81006e:	83 ec 1c             	sub    $0x1c,%esp
  810071:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  810074:	8d 45 f0             	lea    -0x10(%ebp),%eax
  810077:	50                   	push   %eax
  810078:	ff 75 08             	pushl  0x8(%ebp)
  81007b:	e8 52 fb ff ff       	call   80fbd2 <fd_lookup>
  810080:	83 c4 10             	add    $0x10,%esp
  810083:	85 c0                	test   %eax,%eax
  810085:	78 4b                	js     8100d2 <fstat+0x6c>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  810087:	83 ec 08             	sub    $0x8,%esp
  81008a:	8d 45 f4             	lea    -0xc(%ebp),%eax
  81008d:	50                   	push   %eax
  81008e:	8b 45 f0             	mov    -0x10(%ebp),%eax
  810091:	ff 30                	pushl  (%eax)
  810093:	e8 8e fb ff ff       	call   80fc26 <dev_lookup>
  810098:	83 c4 10             	add    $0x10,%esp
  81009b:	85 c0                	test   %eax,%eax
  81009d:	78 33                	js     8100d2 <fstat+0x6c>
		return r;
	if (!dev->dev_stat)
  81009f:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8100a2:	83 78 14 00          	cmpl   $0x0,0x14(%eax)
  8100a6:	74 2f                	je     8100d7 <fstat+0x71>
		return -E_NOT_SUPP;
	stat->st_name[0] = 0;
  8100a8:	c6 03 00             	movb   $0x0,(%ebx)
	stat->st_size = 0;
  8100ab:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  8100b2:	00 00 00 
	stat->st_isdir = 0;
  8100b5:	c7 83 84 00 00 00 00 	movl   $0x0,0x84(%ebx)
  8100bc:	00 00 00 
	stat->st_dev = dev;
  8100bf:	89 83 88 00 00 00    	mov    %eax,0x88(%ebx)
	return (*dev->dev_stat)(fd, stat);
  8100c5:	83 ec 08             	sub    $0x8,%esp
  8100c8:	53                   	push   %ebx
  8100c9:	ff 75 f0             	pushl  -0x10(%ebp)
  8100cc:	ff 50 14             	call   *0x14(%eax)
  8100cf:	83 c4 10             	add    $0x10,%esp
}
  8100d2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8100d5:	c9                   	leave  
  8100d6:	c3                   	ret    
		return -E_NOT_SUPP;
  8100d7:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
  8100dc:	eb f4                	jmp    8100d2 <fstat+0x6c>

008100de <stat>:

int
stat(const char *path, struct Stat *stat)
{
  8100de:	f3 0f 1e fb          	endbr32 
  8100e2:	55                   	push   %ebp
  8100e3:	89 e5                	mov    %esp,%ebp
  8100e5:	56                   	push   %esi
  8100e6:	53                   	push   %ebx
	int fd, r;

	if ((fd = open(path, O_RDONLY)) < 0)
  8100e7:	83 ec 08             	sub    $0x8,%esp
  8100ea:	6a 00                	push   $0x0
  8100ec:	ff 75 08             	pushl  0x8(%ebp)
  8100ef:	e8 fb 01 00 00       	call   8102ef <open>
  8100f4:	89 c3                	mov    %eax,%ebx
  8100f6:	83 c4 10             	add    $0x10,%esp
  8100f9:	85 c0                	test   %eax,%eax
  8100fb:	78 1b                	js     810118 <stat+0x3a>
		return fd;
	r = fstat(fd, stat);
  8100fd:	83 ec 08             	sub    $0x8,%esp
  810100:	ff 75 0c             	pushl  0xc(%ebp)
  810103:	50                   	push   %eax
  810104:	e8 5d ff ff ff       	call   810066 <fstat>
  810109:	89 c6                	mov    %eax,%esi
	close(fd);
  81010b:	89 1c 24             	mov    %ebx,(%esp)
  81010e:	e8 fd fb ff ff       	call   80fd10 <close>
	return r;
  810113:	83 c4 10             	add    $0x10,%esp
  810116:	89 f3                	mov    %esi,%ebx
}
  810118:	89 d8                	mov    %ebx,%eax
  81011a:	8d 65 f8             	lea    -0x8(%ebp),%esp
  81011d:	5b                   	pop    %ebx
  81011e:	5e                   	pop    %esi
  81011f:	5d                   	pop    %ebp
  810120:	c3                   	ret    

00810121 <fsipc>:
// type: request code, passed as the simple integer IPC value.
// dstva: virtual address at which to receive reply page, 0 if none.
// Returns result from the file server.
static int
fsipc(unsigned type, void *dstva)
{
  810121:	55                   	push   %ebp
  810122:	89 e5                	mov    %esp,%ebp
  810124:	56                   	push   %esi
  810125:	53                   	push   %ebx
  810126:	89 c6                	mov    %eax,%esi
  810128:	89 d3                	mov    %edx,%ebx
	static envid_t fsenv;
	if (fsenv == 0)
  81012a:	83 3d cc b1 b3 00 00 	cmpl   $0x0,0xb3b1cc
  810131:	74 27                	je     81015a <fsipc+0x39>
	static_assert(sizeof(fsipcbuf) == PGSIZE);

	if (debug)
		cprintf("[%08x] fsipc %d %08x\n", thisenv->env_id, type, *(uint32_t *)&fsipcbuf);

	ipc_send(fsenv, type, &fsipcbuf, PTE_P | PTE_W | PTE_U);
  810133:	6a 07                	push   $0x7
  810135:	68 00 c0 b3 00       	push   $0xb3c000
  81013a:	56                   	push   %esi
  81013b:	ff 35 cc b1 b3 00    	pushl  0xb3b1cc
  810141:	e8 72 f9 ff ff       	call   80fab8 <ipc_send>
	return ipc_recv(NULL, dstva, NULL);
  810146:	83 c4 0c             	add    $0xc,%esp
  810149:	6a 00                	push   $0x0
  81014b:	53                   	push   %ebx
  81014c:	6a 00                	push   $0x0
  81014e:	e8 e0 f8 ff ff       	call   80fa33 <ipc_recv>
}
  810153:	8d 65 f8             	lea    -0x8(%ebp),%esp
  810156:	5b                   	pop    %ebx
  810157:	5e                   	pop    %esi
  810158:	5d                   	pop    %ebp
  810159:	c3                   	ret    
		fsenv = ipc_find_env(ENV_TYPE_FS);
  81015a:	83 ec 0c             	sub    $0xc,%esp
  81015d:	6a 01                	push   $0x1
  81015f:	e8 ac f9 ff ff       	call   80fb10 <ipc_find_env>
  810164:	a3 cc b1 b3 00       	mov    %eax,0xb3b1cc
  810169:	83 c4 10             	add    $0x10,%esp
  81016c:	eb c5                	jmp    810133 <fsipc+0x12>

0081016e <devfile_trunc>:
}

// Truncate or extend an open file to 'size' bytes
static int
devfile_trunc(struct Fd *fd, off_t newsize)
{
  81016e:	f3 0f 1e fb          	endbr32 
  810172:	55                   	push   %ebp
  810173:	89 e5                	mov    %esp,%ebp
  810175:	83 ec 08             	sub    $0x8,%esp
	fsipcbuf.set_size.req_fileid = fd->fd_file.id;
  810178:	8b 45 08             	mov    0x8(%ebp),%eax
  81017b:	8b 40 0c             	mov    0xc(%eax),%eax
  81017e:	a3 00 c0 b3 00       	mov    %eax,0xb3c000
	fsipcbuf.set_size.req_size = newsize;
  810183:	8b 45 0c             	mov    0xc(%ebp),%eax
  810186:	a3 04 c0 b3 00       	mov    %eax,0xb3c004
	return fsipc(FSREQ_SET_SIZE, NULL);
  81018b:	ba 00 00 00 00       	mov    $0x0,%edx
  810190:	b8 02 00 00 00       	mov    $0x2,%eax
  810195:	e8 87 ff ff ff       	call   810121 <fsipc>
}
  81019a:	c9                   	leave  
  81019b:	c3                   	ret    

0081019c <devfile_flush>:
{
  81019c:	f3 0f 1e fb          	endbr32 
  8101a0:	55                   	push   %ebp
  8101a1:	89 e5                	mov    %esp,%ebp
  8101a3:	83 ec 08             	sub    $0x8,%esp
	fsipcbuf.flush.req_fileid = fd->fd_file.id;
  8101a6:	8b 45 08             	mov    0x8(%ebp),%eax
  8101a9:	8b 40 0c             	mov    0xc(%eax),%eax
  8101ac:	a3 00 c0 b3 00       	mov    %eax,0xb3c000
	return fsipc(FSREQ_FLUSH, NULL);
  8101b1:	ba 00 00 00 00       	mov    $0x0,%edx
  8101b6:	b8 06 00 00 00       	mov    $0x6,%eax
  8101bb:	e8 61 ff ff ff       	call   810121 <fsipc>
}
  8101c0:	c9                   	leave  
  8101c1:	c3                   	ret    

008101c2 <devfile_stat>:
{
  8101c2:	f3 0f 1e fb          	endbr32 
  8101c6:	55                   	push   %ebp
  8101c7:	89 e5                	mov    %esp,%ebp
  8101c9:	53                   	push   %ebx
  8101ca:	83 ec 04             	sub    $0x4,%esp
  8101cd:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	fsipcbuf.stat.req_fileid = fd->fd_file.id;
  8101d0:	8b 45 08             	mov    0x8(%ebp),%eax
  8101d3:	8b 40 0c             	mov    0xc(%eax),%eax
  8101d6:	a3 00 c0 b3 00       	mov    %eax,0xb3c000
	if ((r = fsipc(FSREQ_STAT, NULL)) < 0)
  8101db:	ba 00 00 00 00       	mov    $0x0,%edx
  8101e0:	b8 05 00 00 00       	mov    $0x5,%eax
  8101e5:	e8 37 ff ff ff       	call   810121 <fsipc>
  8101ea:	85 c0                	test   %eax,%eax
  8101ec:	78 2c                	js     81021a <devfile_stat+0x58>
	strcpy(st->st_name, fsipcbuf.statRet.ret_name);
  8101ee:	83 ec 08             	sub    $0x8,%esp
  8101f1:	68 00 c0 b3 00       	push   $0xb3c000
  8101f6:	53                   	push   %ebx
  8101f7:	e8 3c ee ff ff       	call   80f038 <strcpy>
	st->st_size = fsipcbuf.statRet.ret_size;
  8101fc:	a1 80 c0 b3 00       	mov    0xb3c080,%eax
  810201:	89 83 80 00 00 00    	mov    %eax,0x80(%ebx)
	st->st_isdir = fsipcbuf.statRet.ret_isdir;
  810207:	a1 84 c0 b3 00       	mov    0xb3c084,%eax
  81020c:	89 83 84 00 00 00    	mov    %eax,0x84(%ebx)
	return 0;
  810212:	83 c4 10             	add    $0x10,%esp
  810215:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81021a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  81021d:	c9                   	leave  
  81021e:	c3                   	ret    

0081021f <devfile_write>:
{
  81021f:	f3 0f 1e fb          	endbr32 
  810223:	55                   	push   %ebp
  810224:	89 e5                	mov    %esp,%ebp
  810226:	83 ec 0c             	sub    $0xc,%esp
  810229:	8b 45 10             	mov    0x10(%ebp),%eax
	fsipcbuf.write.req_fileid = fd->fd_file.id;
  81022c:	8b 55 08             	mov    0x8(%ebp),%edx
  81022f:	8b 52 0c             	mov    0xc(%edx),%edx
  810232:	89 15 00 c0 b3 00    	mov    %edx,0xb3c000
	n = n > sizeof(fsipcbuf.write.req_buf) ? sizeof(fsipcbuf.write.req_buf) : n;
  810238:	3d f8 0f 00 00       	cmp    $0xff8,%eax
  81023d:	ba f8 0f 00 00       	mov    $0xff8,%edx
  810242:	0f 47 c2             	cmova  %edx,%eax
	fsipcbuf.write.req_n = n;
  810245:	a3 04 c0 b3 00       	mov    %eax,0xb3c004
	memmove(fsipcbuf.write.req_buf, buf, n);
  81024a:	50                   	push   %eax
  81024b:	ff 75 0c             	pushl  0xc(%ebp)
  81024e:	68 08 c0 b3 00       	push   $0xb3c008
  810253:	e8 96 ef ff ff       	call   80f1ee <memmove>
	return fsipc(FSREQ_WRITE, NULL);
  810258:	ba 00 00 00 00       	mov    $0x0,%edx
  81025d:	b8 04 00 00 00       	mov    $0x4,%eax
  810262:	e8 ba fe ff ff       	call   810121 <fsipc>
}
  810267:	c9                   	leave  
  810268:	c3                   	ret    

00810269 <devfile_read>:
{
  810269:	f3 0f 1e fb          	endbr32 
  81026d:	55                   	push   %ebp
  81026e:	89 e5                	mov    %esp,%ebp
  810270:	56                   	push   %esi
  810271:	53                   	push   %ebx
  810272:	8b 75 10             	mov    0x10(%ebp),%esi
	fsipcbuf.read.req_fileid = fd->fd_file.id;
  810275:	8b 45 08             	mov    0x8(%ebp),%eax
  810278:	8b 40 0c             	mov    0xc(%eax),%eax
  81027b:	a3 00 c0 b3 00       	mov    %eax,0xb3c000
	fsipcbuf.read.req_n = n;
  810280:	89 35 04 c0 b3 00    	mov    %esi,0xb3c004
	if ((r = fsipc(FSREQ_READ, NULL)) < 0)
  810286:	ba 00 00 00 00       	mov    $0x0,%edx
  81028b:	b8 03 00 00 00       	mov    $0x3,%eax
  810290:	e8 8c fe ff ff       	call   810121 <fsipc>
  810295:	89 c3                	mov    %eax,%ebx
  810297:	85 c0                	test   %eax,%eax
  810299:	78 1f                	js     8102ba <devfile_read+0x51>
	assert(r <= n);
  81029b:	39 f0                	cmp    %esi,%eax
  81029d:	77 24                	ja     8102c3 <devfile_read+0x5a>
	assert(r <= PGSIZE);
  81029f:	3d 00 10 00 00       	cmp    $0x1000,%eax
  8102a4:	7f 33                	jg     8102d9 <devfile_read+0x70>
	memmove(buf, fsipcbuf.readRet.ret_buf, r);
  8102a6:	83 ec 04             	sub    $0x4,%esp
  8102a9:	50                   	push   %eax
  8102aa:	68 00 c0 b3 00       	push   $0xb3c000
  8102af:	ff 75 0c             	pushl  0xc(%ebp)
  8102b2:	e8 37 ef ff ff       	call   80f1ee <memmove>
	return r;
  8102b7:	83 c4 10             	add    $0x10,%esp
}
  8102ba:	89 d8                	mov    %ebx,%eax
  8102bc:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8102bf:	5b                   	pop    %ebx
  8102c0:	5e                   	pop    %esi
  8102c1:	5d                   	pop    %ebp
  8102c2:	c3                   	ret    
	assert(r <= n);
  8102c3:	68 90 3d 81 00       	push   $0x813d90
  8102c8:	68 eb 2a 81 00       	push   $0x812aeb
  8102cd:	6a 7c                	push   $0x7c
  8102cf:	68 97 3d 81 00       	push   $0x813d97
  8102d4:	e8 6e e6 ff ff       	call   80e947 <_panic>
	assert(r <= PGSIZE);
  8102d9:	68 a2 3d 81 00       	push   $0x813da2
  8102de:	68 eb 2a 81 00       	push   $0x812aeb
  8102e3:	6a 7d                	push   $0x7d
  8102e5:	68 97 3d 81 00       	push   $0x813d97
  8102ea:	e8 58 e6 ff ff       	call   80e947 <_panic>

008102ef <open>:
{
  8102ef:	f3 0f 1e fb          	endbr32 
  8102f3:	55                   	push   %ebp
  8102f4:	89 e5                	mov    %esp,%ebp
  8102f6:	56                   	push   %esi
  8102f7:	53                   	push   %ebx
  8102f8:	83 ec 1c             	sub    $0x1c,%esp
  8102fb:	8b 75 08             	mov    0x8(%ebp),%esi
	if (strlen(path) >= MAXPATHLEN)
  8102fe:	56                   	push   %esi
  8102ff:	e8 f1 ec ff ff       	call   80eff5 <strlen>
  810304:	83 c4 10             	add    $0x10,%esp
  810307:	3d ff 03 00 00       	cmp    $0x3ff,%eax
  81030c:	7f 6c                	jg     81037a <open+0x8b>
	if ((r = fd_alloc(&fd)) < 0)
  81030e:	83 ec 0c             	sub    $0xc,%esp
  810311:	8d 45 f4             	lea    -0xc(%ebp),%eax
  810314:	50                   	push   %eax
  810315:	e8 62 f8 ff ff       	call   80fb7c <fd_alloc>
  81031a:	89 c3                	mov    %eax,%ebx
  81031c:	83 c4 10             	add    $0x10,%esp
  81031f:	85 c0                	test   %eax,%eax
  810321:	78 3c                	js     81035f <open+0x70>
	strcpy(fsipcbuf.open.req_path, path);
  810323:	83 ec 08             	sub    $0x8,%esp
  810326:	56                   	push   %esi
  810327:	68 00 c0 b3 00       	push   $0xb3c000
  81032c:	e8 07 ed ff ff       	call   80f038 <strcpy>
	fsipcbuf.open.req_omode = mode;
  810331:	8b 45 0c             	mov    0xc(%ebp),%eax
  810334:	a3 00 c4 b3 00       	mov    %eax,0xb3c400
	if ((r = fsipc(FSREQ_OPEN, fd)) < 0) {
  810339:	8b 55 f4             	mov    -0xc(%ebp),%edx
  81033c:	b8 01 00 00 00       	mov    $0x1,%eax
  810341:	e8 db fd ff ff       	call   810121 <fsipc>
  810346:	89 c3                	mov    %eax,%ebx
  810348:	83 c4 10             	add    $0x10,%esp
  81034b:	85 c0                	test   %eax,%eax
  81034d:	78 19                	js     810368 <open+0x79>
	return fd2num(fd);
  81034f:	83 ec 0c             	sub    $0xc,%esp
  810352:	ff 75 f4             	pushl  -0xc(%ebp)
  810355:	e8 f3 f7 ff ff       	call   80fb4d <fd2num>
  81035a:	89 c3                	mov    %eax,%ebx
  81035c:	83 c4 10             	add    $0x10,%esp
}
  81035f:	89 d8                	mov    %ebx,%eax
  810361:	8d 65 f8             	lea    -0x8(%ebp),%esp
  810364:	5b                   	pop    %ebx
  810365:	5e                   	pop    %esi
  810366:	5d                   	pop    %ebp
  810367:	c3                   	ret    
		fd_close(fd, 0);
  810368:	83 ec 08             	sub    $0x8,%esp
  81036b:	6a 00                	push   $0x0
  81036d:	ff 75 f4             	pushl  -0xc(%ebp)
  810370:	e8 10 f9 ff ff       	call   80fc85 <fd_close>
		return r;
  810375:	83 c4 10             	add    $0x10,%esp
  810378:	eb e5                	jmp    81035f <open+0x70>
		return -E_BAD_PATH;
  81037a:	bb f4 ff ff ff       	mov    $0xfffffff4,%ebx
  81037f:	eb de                	jmp    81035f <open+0x70>

00810381 <sync>:


// Synchronize disk with buffer cache
int
sync(void)
{
  810381:	f3 0f 1e fb          	endbr32 
  810385:	55                   	push   %ebp
  810386:	89 e5                	mov    %esp,%ebp
  810388:	83 ec 08             	sub    $0x8,%esp
	// Ask the file server to update the disk
	// by writing any dirty blocks in the buffer cache.

	return fsipc(FSREQ_SYNC, NULL);
  81038b:	ba 00 00 00 00       	mov    $0x0,%edx
  810390:	b8 08 00 00 00       	mov    $0x8,%eax
  810395:	e8 87 fd ff ff       	call   810121 <fsipc>
}
  81039a:	c9                   	leave  
  81039b:	c3                   	ret    

0081039c <devsock_stat>:
	return nsipc_send(fd->fd_sock.sockid, buf, n, 0);
}

static int
devsock_stat(struct Fd *fd, struct Stat *stat)
{
  81039c:	f3 0f 1e fb          	endbr32 
  8103a0:	55                   	push   %ebp
  8103a1:	89 e5                	mov    %esp,%ebp
  8103a3:	83 ec 10             	sub    $0x10,%esp
	strcpy(stat->st_name, "<sock>");
  8103a6:	68 ae 3d 81 00       	push   $0x813dae
  8103ab:	ff 75 0c             	pushl  0xc(%ebp)
  8103ae:	e8 85 ec ff ff       	call   80f038 <strcpy>
	return 0;
}
  8103b3:	b8 00 00 00 00       	mov    $0x0,%eax
  8103b8:	c9                   	leave  
  8103b9:	c3                   	ret    

008103ba <devsock_close>:
{
  8103ba:	f3 0f 1e fb          	endbr32 
  8103be:	55                   	push   %ebp
  8103bf:	89 e5                	mov    %esp,%ebp
  8103c1:	53                   	push   %ebx
  8103c2:	83 ec 10             	sub    $0x10,%esp
  8103c5:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (pageref(fd) == 1)
  8103c8:	53                   	push   %ebx
  8103c9:	e8 bf 0c 00 00       	call   81108d <pageref>
  8103ce:	89 c2                	mov    %eax,%edx
  8103d0:	83 c4 10             	add    $0x10,%esp
		return 0;
  8103d3:	b8 00 00 00 00       	mov    $0x0,%eax
	if (pageref(fd) == 1)
  8103d8:	83 fa 01             	cmp    $0x1,%edx
  8103db:	74 05                	je     8103e2 <devsock_close+0x28>
}
  8103dd:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8103e0:	c9                   	leave  
  8103e1:	c3                   	ret    
		return nsipc_close(fd->fd_sock.sockid);
  8103e2:	83 ec 0c             	sub    $0xc,%esp
  8103e5:	ff 73 0c             	pushl  0xc(%ebx)
  8103e8:	e8 e3 02 00 00       	call   8106d0 <nsipc_close>
  8103ed:	83 c4 10             	add    $0x10,%esp
  8103f0:	eb eb                	jmp    8103dd <devsock_close+0x23>

008103f2 <devsock_write>:
{
  8103f2:	f3 0f 1e fb          	endbr32 
  8103f6:	55                   	push   %ebp
  8103f7:	89 e5                	mov    %esp,%ebp
  8103f9:	83 ec 08             	sub    $0x8,%esp
	return nsipc_send(fd->fd_sock.sockid, buf, n, 0);
  8103fc:	6a 00                	push   $0x0
  8103fe:	ff 75 10             	pushl  0x10(%ebp)
  810401:	ff 75 0c             	pushl  0xc(%ebp)
  810404:	8b 45 08             	mov    0x8(%ebp),%eax
  810407:	ff 70 0c             	pushl  0xc(%eax)
  81040a:	e8 b5 03 00 00       	call   8107c4 <nsipc_send>
}
  81040f:	c9                   	leave  
  810410:	c3                   	ret    

00810411 <devsock_read>:
{
  810411:	f3 0f 1e fb          	endbr32 
  810415:	55                   	push   %ebp
  810416:	89 e5                	mov    %esp,%ebp
  810418:	83 ec 08             	sub    $0x8,%esp
	return nsipc_recv(fd->fd_sock.sockid, buf, n, 0);
  81041b:	6a 00                	push   $0x0
  81041d:	ff 75 10             	pushl  0x10(%ebp)
  810420:	ff 75 0c             	pushl  0xc(%ebp)
  810423:	8b 45 08             	mov    0x8(%ebp),%eax
  810426:	ff 70 0c             	pushl  0xc(%eax)
  810429:	e8 1f 03 00 00       	call   81074d <nsipc_recv>
}
  81042e:	c9                   	leave  
  81042f:	c3                   	ret    

00810430 <fd2sockid>:
{
  810430:	55                   	push   %ebp
  810431:	89 e5                	mov    %esp,%ebp
  810433:	83 ec 20             	sub    $0x20,%esp
	if ((r = fd_lookup(fd, &sfd)) < 0)
  810436:	8d 55 f4             	lea    -0xc(%ebp),%edx
  810439:	52                   	push   %edx
  81043a:	50                   	push   %eax
  81043b:	e8 92 f7 ff ff       	call   80fbd2 <fd_lookup>
  810440:	83 c4 10             	add    $0x10,%esp
  810443:	85 c0                	test   %eax,%eax
  810445:	78 10                	js     810457 <fd2sockid+0x27>
	if (sfd->fd_dev_id != devsock.dev_id)
  810447:	8b 45 f4             	mov    -0xc(%ebp),%eax
  81044a:	8b 0d 08 43 81 00    	mov    0x814308,%ecx
  810450:	39 08                	cmp    %ecx,(%eax)
  810452:	75 05                	jne    810459 <fd2sockid+0x29>
	return sfd->fd_sock.sockid;
  810454:	8b 40 0c             	mov    0xc(%eax),%eax
}
  810457:	c9                   	leave  
  810458:	c3                   	ret    
		return -E_NOT_SUPP;
  810459:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
  81045e:	eb f7                	jmp    810457 <fd2sockid+0x27>

00810460 <alloc_sockfd>:
{
  810460:	55                   	push   %ebp
  810461:	89 e5                	mov    %esp,%ebp
  810463:	56                   	push   %esi
  810464:	53                   	push   %ebx
  810465:	83 ec 1c             	sub    $0x1c,%esp
  810468:	89 c6                	mov    %eax,%esi
	if ((r = fd_alloc(&sfd)) < 0
  81046a:	8d 45 f4             	lea    -0xc(%ebp),%eax
  81046d:	50                   	push   %eax
  81046e:	e8 09 f7 ff ff       	call   80fb7c <fd_alloc>
  810473:	89 c3                	mov    %eax,%ebx
  810475:	83 c4 10             	add    $0x10,%esp
  810478:	85 c0                	test   %eax,%eax
  81047a:	78 43                	js     8104bf <alloc_sockfd+0x5f>
	    || (r = sys_page_alloc(0, sfd, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0) {
  81047c:	83 ec 04             	sub    $0x4,%esp
  81047f:	68 07 04 00 00       	push   $0x407
  810484:	ff 75 f4             	pushl  -0xc(%ebp)
  810487:	6a 00                	push   $0x0
  810489:	e8 ec ef ff ff       	call   80f47a <sys_page_alloc>
  81048e:	89 c3                	mov    %eax,%ebx
  810490:	83 c4 10             	add    $0x10,%esp
  810493:	85 c0                	test   %eax,%eax
  810495:	78 28                	js     8104bf <alloc_sockfd+0x5f>
	sfd->fd_dev_id = devsock.dev_id;
  810497:	8b 45 f4             	mov    -0xc(%ebp),%eax
  81049a:	8b 15 08 43 81 00    	mov    0x814308,%edx
  8104a0:	89 10                	mov    %edx,(%eax)
	sfd->fd_omode = O_RDWR;
  8104a2:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8104a5:	c7 40 08 02 00 00 00 	movl   $0x2,0x8(%eax)
	sfd->fd_sock.sockid = sockid;
  8104ac:	89 70 0c             	mov    %esi,0xc(%eax)
	return fd2num(sfd);
  8104af:	83 ec 0c             	sub    $0xc,%esp
  8104b2:	50                   	push   %eax
  8104b3:	e8 95 f6 ff ff       	call   80fb4d <fd2num>
  8104b8:	89 c3                	mov    %eax,%ebx
  8104ba:	83 c4 10             	add    $0x10,%esp
  8104bd:	eb 0c                	jmp    8104cb <alloc_sockfd+0x6b>
		nsipc_close(sockid);
  8104bf:	83 ec 0c             	sub    $0xc,%esp
  8104c2:	56                   	push   %esi
  8104c3:	e8 08 02 00 00       	call   8106d0 <nsipc_close>
		return r;
  8104c8:	83 c4 10             	add    $0x10,%esp
}
  8104cb:	89 d8                	mov    %ebx,%eax
  8104cd:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8104d0:	5b                   	pop    %ebx
  8104d1:	5e                   	pop    %esi
  8104d2:	5d                   	pop    %ebp
  8104d3:	c3                   	ret    

008104d4 <accept>:
{
  8104d4:	f3 0f 1e fb          	endbr32 
  8104d8:	55                   	push   %ebp
  8104d9:	89 e5                	mov    %esp,%ebp
  8104db:	83 ec 08             	sub    $0x8,%esp
	if ((r = fd2sockid(s)) < 0)
  8104de:	8b 45 08             	mov    0x8(%ebp),%eax
  8104e1:	e8 4a ff ff ff       	call   810430 <fd2sockid>
  8104e6:	85 c0                	test   %eax,%eax
  8104e8:	78 1b                	js     810505 <accept+0x31>
	if ((r = nsipc_accept(r, addr, addrlen)) < 0)
  8104ea:	83 ec 04             	sub    $0x4,%esp
  8104ed:	ff 75 10             	pushl  0x10(%ebp)
  8104f0:	ff 75 0c             	pushl  0xc(%ebp)
  8104f3:	50                   	push   %eax
  8104f4:	e8 22 01 00 00       	call   81061b <nsipc_accept>
  8104f9:	83 c4 10             	add    $0x10,%esp
  8104fc:	85 c0                	test   %eax,%eax
  8104fe:	78 05                	js     810505 <accept+0x31>
	return alloc_sockfd(r);
  810500:	e8 5b ff ff ff       	call   810460 <alloc_sockfd>
}
  810505:	c9                   	leave  
  810506:	c3                   	ret    

00810507 <bind>:
{
  810507:	f3 0f 1e fb          	endbr32 
  81050b:	55                   	push   %ebp
  81050c:	89 e5                	mov    %esp,%ebp
  81050e:	83 ec 08             	sub    $0x8,%esp
	if ((r = fd2sockid(s)) < 0)
  810511:	8b 45 08             	mov    0x8(%ebp),%eax
  810514:	e8 17 ff ff ff       	call   810430 <fd2sockid>
  810519:	85 c0                	test   %eax,%eax
  81051b:	78 12                	js     81052f <bind+0x28>
	return nsipc_bind(r, name, namelen);
  81051d:	83 ec 04             	sub    $0x4,%esp
  810520:	ff 75 10             	pushl  0x10(%ebp)
  810523:	ff 75 0c             	pushl  0xc(%ebp)
  810526:	50                   	push   %eax
  810527:	e8 45 01 00 00       	call   810671 <nsipc_bind>
  81052c:	83 c4 10             	add    $0x10,%esp
}
  81052f:	c9                   	leave  
  810530:	c3                   	ret    

00810531 <shutdown>:
{
  810531:	f3 0f 1e fb          	endbr32 
  810535:	55                   	push   %ebp
  810536:	89 e5                	mov    %esp,%ebp
  810538:	83 ec 08             	sub    $0x8,%esp
	if ((r = fd2sockid(s)) < 0)
  81053b:	8b 45 08             	mov    0x8(%ebp),%eax
  81053e:	e8 ed fe ff ff       	call   810430 <fd2sockid>
  810543:	85 c0                	test   %eax,%eax
  810545:	78 0f                	js     810556 <shutdown+0x25>
	return nsipc_shutdown(r, how);
  810547:	83 ec 08             	sub    $0x8,%esp
  81054a:	ff 75 0c             	pushl  0xc(%ebp)
  81054d:	50                   	push   %eax
  81054e:	e8 57 01 00 00       	call   8106aa <nsipc_shutdown>
  810553:	83 c4 10             	add    $0x10,%esp
}
  810556:	c9                   	leave  
  810557:	c3                   	ret    

00810558 <connect>:
{
  810558:	f3 0f 1e fb          	endbr32 
  81055c:	55                   	push   %ebp
  81055d:	89 e5                	mov    %esp,%ebp
  81055f:	83 ec 08             	sub    $0x8,%esp
	if ((r = fd2sockid(s)) < 0)
  810562:	8b 45 08             	mov    0x8(%ebp),%eax
  810565:	e8 c6 fe ff ff       	call   810430 <fd2sockid>
  81056a:	85 c0                	test   %eax,%eax
  81056c:	78 12                	js     810580 <connect+0x28>
	return nsipc_connect(r, name, namelen);
  81056e:	83 ec 04             	sub    $0x4,%esp
  810571:	ff 75 10             	pushl  0x10(%ebp)
  810574:	ff 75 0c             	pushl  0xc(%ebp)
  810577:	50                   	push   %eax
  810578:	e8 71 01 00 00       	call   8106ee <nsipc_connect>
  81057d:	83 c4 10             	add    $0x10,%esp
}
  810580:	c9                   	leave  
  810581:	c3                   	ret    

00810582 <listen>:
{
  810582:	f3 0f 1e fb          	endbr32 
  810586:	55                   	push   %ebp
  810587:	89 e5                	mov    %esp,%ebp
  810589:	83 ec 08             	sub    $0x8,%esp
	if ((r = fd2sockid(s)) < 0)
  81058c:	8b 45 08             	mov    0x8(%ebp),%eax
  81058f:	e8 9c fe ff ff       	call   810430 <fd2sockid>
  810594:	85 c0                	test   %eax,%eax
  810596:	78 0f                	js     8105a7 <listen+0x25>
	return nsipc_listen(r, backlog);
  810598:	83 ec 08             	sub    $0x8,%esp
  81059b:	ff 75 0c             	pushl  0xc(%ebp)
  81059e:	50                   	push   %eax
  81059f:	e8 83 01 00 00       	call   810727 <nsipc_listen>
  8105a4:	83 c4 10             	add    $0x10,%esp
}
  8105a7:	c9                   	leave  
  8105a8:	c3                   	ret    

008105a9 <socket>:

int
socket(int domain, int type, int protocol)
{
  8105a9:	f3 0f 1e fb          	endbr32 
  8105ad:	55                   	push   %ebp
  8105ae:	89 e5                	mov    %esp,%ebp
  8105b0:	83 ec 0c             	sub    $0xc,%esp
	int r;
	if ((r = nsipc_socket(domain, type, protocol)) < 0)
  8105b3:	ff 75 10             	pushl  0x10(%ebp)
  8105b6:	ff 75 0c             	pushl  0xc(%ebp)
  8105b9:	ff 75 08             	pushl  0x8(%ebp)
  8105bc:	e8 65 02 00 00       	call   810826 <nsipc_socket>
  8105c1:	83 c4 10             	add    $0x10,%esp
  8105c4:	85 c0                	test   %eax,%eax
  8105c6:	78 05                	js     8105cd <socket+0x24>
		return r;
	return alloc_sockfd(r);
  8105c8:	e8 93 fe ff ff       	call   810460 <alloc_sockfd>
}
  8105cd:	c9                   	leave  
  8105ce:	c3                   	ret    

008105cf <nsipc>:
// may be written back to nsipcbuf.
// type: request code, passed as the simple integer IPC value.
// Returns 0 if successful, < 0 on failure.
static int
nsipc(unsigned type)
{
  8105cf:	55                   	push   %ebp
  8105d0:	89 e5                	mov    %esp,%ebp
  8105d2:	53                   	push   %ebx
  8105d3:	83 ec 04             	sub    $0x4,%esp
  8105d6:	89 c3                	mov    %eax,%ebx
	static envid_t nsenv;
	if (nsenv == 0)
  8105d8:	83 3d d0 b1 b3 00 00 	cmpl   $0x0,0xb3b1d0
  8105df:	74 26                	je     810607 <nsipc+0x38>
	static_assert(sizeof(nsipcbuf) == PGSIZE);

	if (debug)
		cprintf("[%08x] nsipc %d\n", thisenv->env_id, type);

	ipc_send(nsenv, type, &nsipcbuf, PTE_P|PTE_W|PTE_U);
  8105e1:	6a 07                	push   $0x7
  8105e3:	68 00 d0 b3 00       	push   $0xb3d000
  8105e8:	53                   	push   %ebx
  8105e9:	ff 35 d0 b1 b3 00    	pushl  0xb3b1d0
  8105ef:	e8 c4 f4 ff ff       	call   80fab8 <ipc_send>
	return ipc_recv(NULL, NULL, NULL);
  8105f4:	83 c4 0c             	add    $0xc,%esp
  8105f7:	6a 00                	push   $0x0
  8105f9:	6a 00                	push   $0x0
  8105fb:	6a 00                	push   $0x0
  8105fd:	e8 31 f4 ff ff       	call   80fa33 <ipc_recv>
}
  810602:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  810605:	c9                   	leave  
  810606:	c3                   	ret    
		nsenv = ipc_find_env(ENV_TYPE_NS);
  810607:	83 ec 0c             	sub    $0xc,%esp
  81060a:	6a 02                	push   $0x2
  81060c:	e8 ff f4 ff ff       	call   80fb10 <ipc_find_env>
  810611:	a3 d0 b1 b3 00       	mov    %eax,0xb3b1d0
  810616:	83 c4 10             	add    $0x10,%esp
  810619:	eb c6                	jmp    8105e1 <nsipc+0x12>

0081061b <nsipc_accept>:

int
nsipc_accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  81061b:	f3 0f 1e fb          	endbr32 
  81061f:	55                   	push   %ebp
  810620:	89 e5                	mov    %esp,%ebp
  810622:	56                   	push   %esi
  810623:	53                   	push   %ebx
  810624:	8b 75 10             	mov    0x10(%ebp),%esi
	int r;

	nsipcbuf.accept.req_s = s;
  810627:	8b 45 08             	mov    0x8(%ebp),%eax
  81062a:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	nsipcbuf.accept.req_addrlen = *addrlen;
  81062f:	8b 06                	mov    (%esi),%eax
  810631:	a3 04 d0 b3 00       	mov    %eax,0xb3d004
	if ((r = nsipc(NSREQ_ACCEPT)) >= 0) {
  810636:	b8 01 00 00 00       	mov    $0x1,%eax
  81063b:	e8 8f ff ff ff       	call   8105cf <nsipc>
  810640:	89 c3                	mov    %eax,%ebx
  810642:	85 c0                	test   %eax,%eax
  810644:	79 09                	jns    81064f <nsipc_accept+0x34>
		struct Nsret_accept *ret = &nsipcbuf.acceptRet;
		memmove(addr, &ret->ret_addr, ret->ret_addrlen);
		*addrlen = ret->ret_addrlen;
	}
	return r;
}
  810646:	89 d8                	mov    %ebx,%eax
  810648:	8d 65 f8             	lea    -0x8(%ebp),%esp
  81064b:	5b                   	pop    %ebx
  81064c:	5e                   	pop    %esi
  81064d:	5d                   	pop    %ebp
  81064e:	c3                   	ret    
		memmove(addr, &ret->ret_addr, ret->ret_addrlen);
  81064f:	83 ec 04             	sub    $0x4,%esp
  810652:	ff 35 10 d0 b3 00    	pushl  0xb3d010
  810658:	68 00 d0 b3 00       	push   $0xb3d000
  81065d:	ff 75 0c             	pushl  0xc(%ebp)
  810660:	e8 89 eb ff ff       	call   80f1ee <memmove>
		*addrlen = ret->ret_addrlen;
  810665:	a1 10 d0 b3 00       	mov    0xb3d010,%eax
  81066a:	89 06                	mov    %eax,(%esi)
  81066c:	83 c4 10             	add    $0x10,%esp
	return r;
  81066f:	eb d5                	jmp    810646 <nsipc_accept+0x2b>

00810671 <nsipc_bind>:

int
nsipc_bind(int s, struct sockaddr *name, socklen_t namelen)
{
  810671:	f3 0f 1e fb          	endbr32 
  810675:	55                   	push   %ebp
  810676:	89 e5                	mov    %esp,%ebp
  810678:	53                   	push   %ebx
  810679:	83 ec 08             	sub    $0x8,%esp
  81067c:	8b 5d 10             	mov    0x10(%ebp),%ebx
	nsipcbuf.bind.req_s = s;
  81067f:	8b 45 08             	mov    0x8(%ebp),%eax
  810682:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	memmove(&nsipcbuf.bind.req_name, name, namelen);
  810687:	53                   	push   %ebx
  810688:	ff 75 0c             	pushl  0xc(%ebp)
  81068b:	68 04 d0 b3 00       	push   $0xb3d004
  810690:	e8 59 eb ff ff       	call   80f1ee <memmove>
	nsipcbuf.bind.req_namelen = namelen;
  810695:	89 1d 14 d0 b3 00    	mov    %ebx,0xb3d014
	return nsipc(NSREQ_BIND);
  81069b:	b8 02 00 00 00       	mov    $0x2,%eax
  8106a0:	e8 2a ff ff ff       	call   8105cf <nsipc>
}
  8106a5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8106a8:	c9                   	leave  
  8106a9:	c3                   	ret    

008106aa <nsipc_shutdown>:

int
nsipc_shutdown(int s, int how)
{
  8106aa:	f3 0f 1e fb          	endbr32 
  8106ae:	55                   	push   %ebp
  8106af:	89 e5                	mov    %esp,%ebp
  8106b1:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.shutdown.req_s = s;
  8106b4:	8b 45 08             	mov    0x8(%ebp),%eax
  8106b7:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	nsipcbuf.shutdown.req_how = how;
  8106bc:	8b 45 0c             	mov    0xc(%ebp),%eax
  8106bf:	a3 04 d0 b3 00       	mov    %eax,0xb3d004
	return nsipc(NSREQ_SHUTDOWN);
  8106c4:	b8 03 00 00 00       	mov    $0x3,%eax
  8106c9:	e8 01 ff ff ff       	call   8105cf <nsipc>
}
  8106ce:	c9                   	leave  
  8106cf:	c3                   	ret    

008106d0 <nsipc_close>:

int
nsipc_close(int s)
{
  8106d0:	f3 0f 1e fb          	endbr32 
  8106d4:	55                   	push   %ebp
  8106d5:	89 e5                	mov    %esp,%ebp
  8106d7:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.close.req_s = s;
  8106da:	8b 45 08             	mov    0x8(%ebp),%eax
  8106dd:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	return nsipc(NSREQ_CLOSE);
  8106e2:	b8 04 00 00 00       	mov    $0x4,%eax
  8106e7:	e8 e3 fe ff ff       	call   8105cf <nsipc>
}
  8106ec:	c9                   	leave  
  8106ed:	c3                   	ret    

008106ee <nsipc_connect>:

int
nsipc_connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  8106ee:	f3 0f 1e fb          	endbr32 
  8106f2:	55                   	push   %ebp
  8106f3:	89 e5                	mov    %esp,%ebp
  8106f5:	53                   	push   %ebx
  8106f6:	83 ec 08             	sub    $0x8,%esp
  8106f9:	8b 5d 10             	mov    0x10(%ebp),%ebx
	nsipcbuf.connect.req_s = s;
  8106fc:	8b 45 08             	mov    0x8(%ebp),%eax
  8106ff:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	memmove(&nsipcbuf.connect.req_name, name, namelen);
  810704:	53                   	push   %ebx
  810705:	ff 75 0c             	pushl  0xc(%ebp)
  810708:	68 04 d0 b3 00       	push   $0xb3d004
  81070d:	e8 dc ea ff ff       	call   80f1ee <memmove>
	nsipcbuf.connect.req_namelen = namelen;
  810712:	89 1d 14 d0 b3 00    	mov    %ebx,0xb3d014
	return nsipc(NSREQ_CONNECT);
  810718:	b8 05 00 00 00       	mov    $0x5,%eax
  81071d:	e8 ad fe ff ff       	call   8105cf <nsipc>
}
  810722:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  810725:	c9                   	leave  
  810726:	c3                   	ret    

00810727 <nsipc_listen>:

int
nsipc_listen(int s, int backlog)
{
  810727:	f3 0f 1e fb          	endbr32 
  81072b:	55                   	push   %ebp
  81072c:	89 e5                	mov    %esp,%ebp
  81072e:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.listen.req_s = s;
  810731:	8b 45 08             	mov    0x8(%ebp),%eax
  810734:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	nsipcbuf.listen.req_backlog = backlog;
  810739:	8b 45 0c             	mov    0xc(%ebp),%eax
  81073c:	a3 04 d0 b3 00       	mov    %eax,0xb3d004
	return nsipc(NSREQ_LISTEN);
  810741:	b8 06 00 00 00       	mov    $0x6,%eax
  810746:	e8 84 fe ff ff       	call   8105cf <nsipc>
}
  81074b:	c9                   	leave  
  81074c:	c3                   	ret    

0081074d <nsipc_recv>:

int
nsipc_recv(int s, void *mem, int len, unsigned int flags)
{
  81074d:	f3 0f 1e fb          	endbr32 
  810751:	55                   	push   %ebp
  810752:	89 e5                	mov    %esp,%ebp
  810754:	56                   	push   %esi
  810755:	53                   	push   %ebx
  810756:	8b 75 10             	mov    0x10(%ebp),%esi
	int r;

	nsipcbuf.recv.req_s = s;
  810759:	8b 45 08             	mov    0x8(%ebp),%eax
  81075c:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	nsipcbuf.recv.req_len = len;
  810761:	89 35 04 d0 b3 00    	mov    %esi,0xb3d004
	nsipcbuf.recv.req_flags = flags;
  810767:	8b 45 14             	mov    0x14(%ebp),%eax
  81076a:	a3 08 d0 b3 00       	mov    %eax,0xb3d008

	if ((r = nsipc(NSREQ_RECV)) >= 0) {
  81076f:	b8 07 00 00 00       	mov    $0x7,%eax
  810774:	e8 56 fe ff ff       	call   8105cf <nsipc>
  810779:	89 c3                	mov    %eax,%ebx
  81077b:	85 c0                	test   %eax,%eax
  81077d:	78 26                	js     8107a5 <nsipc_recv+0x58>
		assert(r < 1600 && r <= len);
  81077f:	81 fe 3f 06 00 00    	cmp    $0x63f,%esi
  810785:	b8 3f 06 00 00       	mov    $0x63f,%eax
  81078a:	0f 4e c6             	cmovle %esi,%eax
  81078d:	39 c3                	cmp    %eax,%ebx
  81078f:	7f 1d                	jg     8107ae <nsipc_recv+0x61>
		memmove(mem, nsipcbuf.recvRet.ret_buf, r);
  810791:	83 ec 04             	sub    $0x4,%esp
  810794:	53                   	push   %ebx
  810795:	68 00 d0 b3 00       	push   $0xb3d000
  81079a:	ff 75 0c             	pushl  0xc(%ebp)
  81079d:	e8 4c ea ff ff       	call   80f1ee <memmove>
  8107a2:	83 c4 10             	add    $0x10,%esp
	}

	return r;
}
  8107a5:	89 d8                	mov    %ebx,%eax
  8107a7:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8107aa:	5b                   	pop    %ebx
  8107ab:	5e                   	pop    %esi
  8107ac:	5d                   	pop    %ebp
  8107ad:	c3                   	ret    
		assert(r < 1600 && r <= len);
  8107ae:	68 ba 3d 81 00       	push   $0x813dba
  8107b3:	68 eb 2a 81 00       	push   $0x812aeb
  8107b8:	6a 62                	push   $0x62
  8107ba:	68 cf 3d 81 00       	push   $0x813dcf
  8107bf:	e8 83 e1 ff ff       	call   80e947 <_panic>

008107c4 <nsipc_send>:

int
nsipc_send(int s, const void *buf, int size, unsigned int flags)
{
  8107c4:	f3 0f 1e fb          	endbr32 
  8107c8:	55                   	push   %ebp
  8107c9:	89 e5                	mov    %esp,%ebp
  8107cb:	53                   	push   %ebx
  8107cc:	83 ec 04             	sub    $0x4,%esp
  8107cf:	8b 5d 10             	mov    0x10(%ebp),%ebx
	nsipcbuf.send.req_s = s;
  8107d2:	8b 45 08             	mov    0x8(%ebp),%eax
  8107d5:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	assert(size < 1600);
  8107da:	81 fb 3f 06 00 00    	cmp    $0x63f,%ebx
  8107e0:	7f 2e                	jg     810810 <nsipc_send+0x4c>
	memmove(&nsipcbuf.send.req_buf, buf, size);
  8107e2:	83 ec 04             	sub    $0x4,%esp
  8107e5:	53                   	push   %ebx
  8107e6:	ff 75 0c             	pushl  0xc(%ebp)
  8107e9:	68 0c d0 b3 00       	push   $0xb3d00c
  8107ee:	e8 fb e9 ff ff       	call   80f1ee <memmove>
	nsipcbuf.send.req_size = size;
  8107f3:	89 1d 04 d0 b3 00    	mov    %ebx,0xb3d004
	nsipcbuf.send.req_flags = flags;
  8107f9:	8b 45 14             	mov    0x14(%ebp),%eax
  8107fc:	a3 08 d0 b3 00       	mov    %eax,0xb3d008
	return nsipc(NSREQ_SEND);
  810801:	b8 08 00 00 00       	mov    $0x8,%eax
  810806:	e8 c4 fd ff ff       	call   8105cf <nsipc>
}
  81080b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  81080e:	c9                   	leave  
  81080f:	c3                   	ret    
	assert(size < 1600);
  810810:	68 db 3d 81 00       	push   $0x813ddb
  810815:	68 eb 2a 81 00       	push   $0x812aeb
  81081a:	6a 6d                	push   $0x6d
  81081c:	68 cf 3d 81 00       	push   $0x813dcf
  810821:	e8 21 e1 ff ff       	call   80e947 <_panic>

00810826 <nsipc_socket>:

int
nsipc_socket(int domain, int type, int protocol)
{
  810826:	f3 0f 1e fb          	endbr32 
  81082a:	55                   	push   %ebp
  81082b:	89 e5                	mov    %esp,%ebp
  81082d:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.socket.req_domain = domain;
  810830:	8b 45 08             	mov    0x8(%ebp),%eax
  810833:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	nsipcbuf.socket.req_type = type;
  810838:	8b 45 0c             	mov    0xc(%ebp),%eax
  81083b:	a3 04 d0 b3 00       	mov    %eax,0xb3d004
	nsipcbuf.socket.req_protocol = protocol;
  810840:	8b 45 10             	mov    0x10(%ebp),%eax
  810843:	a3 08 d0 b3 00       	mov    %eax,0xb3d008
	return nsipc(NSREQ_SOCKET);
  810848:	b8 09 00 00 00       	mov    $0x9,%eax
  81084d:	e8 7d fd ff ff       	call   8105cf <nsipc>
}
  810852:	c9                   	leave  
  810853:	c3                   	ret    

00810854 <free>:
	return v;
}

void
free(void *v)
{
  810854:	f3 0f 1e fb          	endbr32 
  810858:	55                   	push   %ebp
  810859:	89 e5                	mov    %esp,%ebp
  81085b:	53                   	push   %ebx
  81085c:	83 ec 04             	sub    $0x4,%esp
  81085f:	8b 5d 08             	mov    0x8(%ebp),%ebx
	uint8_t *c;
	uint32_t *ref;

	if (v == 0)
  810862:	85 db                	test   %ebx,%ebx
  810864:	0f 84 85 00 00 00    	je     8108ef <free+0x9b>
		return;
	assert(mbegin <= (uint8_t*) v && (uint8_t*) v < mend);
  81086a:	8d 83 00 00 00 f8    	lea    -0x8000000(%ebx),%eax
  810870:	3d ff ff ff 07       	cmp    $0x7ffffff,%eax
  810875:	77 51                	ja     8108c8 <free+0x74>

	c = ROUNDDOWN(v, PGSIZE);
  810877:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx

	while (uvpt[PGNUM(c)] & PTE_CONTINUED) {
  81087d:	89 d8                	mov    %ebx,%eax
  81087f:	c1 e8 0c             	shr    $0xc,%eax
  810882:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
  810889:	f6 c4 02             	test   $0x2,%ah
  81088c:	74 50                	je     8108de <free+0x8a>
		sys_page_unmap(0, c);
  81088e:	83 ec 08             	sub    $0x8,%esp
  810891:	53                   	push   %ebx
  810892:	6a 00                	push   $0x0
  810894:	e8 6e ec ff ff       	call   80f507 <sys_page_unmap>
		c += PGSIZE;
  810899:	81 c3 00 10 00 00    	add    $0x1000,%ebx
		assert(mbegin <= c && c < mend);
  81089f:	8d 83 00 00 00 f8    	lea    -0x8000000(%ebx),%eax
  8108a5:	83 c4 10             	add    $0x10,%esp
  8108a8:	3d ff ff ff 07       	cmp    $0x7ffffff,%eax
  8108ad:	76 ce                	jbe    81087d <free+0x29>
  8108af:	68 23 3e 81 00       	push   $0x813e23
  8108b4:	68 eb 2a 81 00       	push   $0x812aeb
  8108b9:	68 81 00 00 00       	push   $0x81
  8108be:	68 16 3e 81 00       	push   $0x813e16
  8108c3:	e8 7f e0 ff ff       	call   80e947 <_panic>
	assert(mbegin <= (uint8_t*) v && (uint8_t*) v < mend);
  8108c8:	68 e8 3d 81 00       	push   $0x813de8
  8108cd:	68 eb 2a 81 00       	push   $0x812aeb
  8108d2:	6a 7a                	push   $0x7a
  8108d4:	68 16 3e 81 00       	push   $0x813e16
  8108d9:	e8 69 e0 ff ff       	call   80e947 <_panic>
	/*
	 * c is just a piece of this page, so dec the ref count
	 * and maybe free the page.
	 */
	ref = (uint32_t*) (c + PGSIZE - 4);
	if (--(*ref) == 0)
  8108de:	8b 83 fc 0f 00 00    	mov    0xffc(%ebx),%eax
  8108e4:	83 e8 01             	sub    $0x1,%eax
  8108e7:	89 83 fc 0f 00 00    	mov    %eax,0xffc(%ebx)
  8108ed:	74 05                	je     8108f4 <free+0xa0>
		sys_page_unmap(0, c);
}
  8108ef:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8108f2:	c9                   	leave  
  8108f3:	c3                   	ret    
		sys_page_unmap(0, c);
  8108f4:	83 ec 08             	sub    $0x8,%esp
  8108f7:	53                   	push   %ebx
  8108f8:	6a 00                	push   $0x0
  8108fa:	e8 08 ec ff ff       	call   80f507 <sys_page_unmap>
  8108ff:	83 c4 10             	add    $0x10,%esp
  810902:	eb eb                	jmp    8108ef <free+0x9b>

00810904 <malloc>:
{
  810904:	f3 0f 1e fb          	endbr32 
  810908:	55                   	push   %ebp
  810909:	89 e5                	mov    %esp,%ebp
  81090b:	57                   	push   %edi
  81090c:	56                   	push   %esi
  81090d:	53                   	push   %ebx
  81090e:	83 ec 1c             	sub    $0x1c,%esp
	if (mptr == 0)
  810911:	a1 d4 b1 b3 00       	mov    0xb3b1d4,%eax
  810916:	85 c0                	test   %eax,%eax
  810918:	74 74                	je     81098e <malloc+0x8a>
	n = ROUNDUP(n, 4);
  81091a:	8b 4d 08             	mov    0x8(%ebp),%ecx
  81091d:	8d 51 03             	lea    0x3(%ecx),%edx
  810920:	83 e2 fc             	and    $0xfffffffc,%edx
  810923:	89 d6                	mov    %edx,%esi
  810925:	89 55 dc             	mov    %edx,-0x24(%ebp)
	if (n >= MAXMALLOC)
  810928:	81 fa ff ff 0f 00    	cmp    $0xfffff,%edx
  81092e:	0f 87 12 01 00 00    	ja     810a46 <malloc+0x142>
	if ((uintptr_t) mptr % PGSIZE){
  810934:	89 c1                	mov    %eax,%ecx
  810936:	a9 ff 0f 00 00       	test   $0xfff,%eax
  81093b:	74 30                	je     81096d <malloc+0x69>
		if ((uintptr_t) mptr / PGSIZE == (uintptr_t) (mptr + n - 1 + 4) / PGSIZE) {
  81093d:	89 c3                	mov    %eax,%ebx
  81093f:	c1 eb 0c             	shr    $0xc,%ebx
  810942:	8d 54 10 03          	lea    0x3(%eax,%edx,1),%edx
  810946:	c1 ea 0c             	shr    $0xc,%edx
  810949:	39 d3                	cmp    %edx,%ebx
  81094b:	74 64                	je     8109b1 <malloc+0xad>
		free(mptr);	/* drop reference to this page */
  81094d:	83 ec 0c             	sub    $0xc,%esp
  810950:	50                   	push   %eax
  810951:	e8 fe fe ff ff       	call   810854 <free>
		mptr = ROUNDDOWN(mptr + PGSIZE, PGSIZE);
  810956:	a1 d4 b1 b3 00       	mov    0xb3b1d4,%eax
  81095b:	05 00 10 00 00       	add    $0x1000,%eax
  810960:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  810965:	a3 d4 b1 b3 00       	mov    %eax,0xb3b1d4
  81096a:	83 c4 10             	add    $0x10,%esp
  81096d:	8b 15 d4 b1 b3 00    	mov    0xb3b1d4,%edx
{
  810973:	c7 45 d8 02 00 00 00 	movl   $0x2,-0x28(%ebp)
  81097a:	be 00 00 00 00       	mov    $0x0,%esi
		if (isfree(mptr, n + 4))
  81097f:	8b 45 dc             	mov    -0x24(%ebp),%eax
  810982:	8d 78 04             	lea    0x4(%eax),%edi
  810985:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
  810989:	e9 86 00 00 00       	jmp    810a14 <malloc+0x110>
		mptr = mbegin;
  81098e:	c7 05 d4 b1 b3 00 00 	movl   $0x8000000,0xb3b1d4
  810995:	00 00 08 
	n = ROUNDUP(n, 4);
  810998:	8b 4d 08             	mov    0x8(%ebp),%ecx
  81099b:	8d 51 03             	lea    0x3(%ecx),%edx
  81099e:	83 e2 fc             	and    $0xfffffffc,%edx
  8109a1:	89 55 dc             	mov    %edx,-0x24(%ebp)
	if (n >= MAXMALLOC)
  8109a4:	81 fa ff ff 0f 00    	cmp    $0xfffff,%edx
  8109aa:	76 c1                	jbe    81096d <malloc+0x69>
  8109ac:	e9 fb 00 00 00       	jmp    810aac <malloc+0x1a8>
		ref = (uint32_t*) (ROUNDUP(mptr, PGSIZE) - 4);
  8109b1:	81 c1 ff 0f 00 00    	add    $0xfff,%ecx
  8109b7:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
			(*ref)++;
  8109bd:	83 41 fc 01          	addl   $0x1,-0x4(%ecx)
			mptr += n;
  8109c1:	89 f2                	mov    %esi,%edx
  8109c3:	01 c2                	add    %eax,%edx
  8109c5:	89 15 d4 b1 b3 00    	mov    %edx,0xb3b1d4
			return v;
  8109cb:	e9 dc 00 00 00       	jmp    810aac <malloc+0x1a8>
	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
  8109d0:	05 00 10 00 00       	add    $0x1000,%eax
  8109d5:	39 c1                	cmp    %eax,%ecx
  8109d7:	76 74                	jbe    810a4d <malloc+0x149>
		if (va >= (uintptr_t) mend
  8109d9:	3d ff ff ff 0f       	cmp    $0xfffffff,%eax
  8109de:	77 22                	ja     810a02 <malloc+0xfe>
		    || ((uvpd[PDX(va)] & PTE_P) && (uvpt[PGNUM(va)] & PTE_P)))
  8109e0:	89 c3                	mov    %eax,%ebx
  8109e2:	c1 eb 16             	shr    $0x16,%ebx
  8109e5:	8b 1c 9d 00 d0 7b ef 	mov    -0x10843000(,%ebx,4),%ebx
  8109ec:	f6 c3 01             	test   $0x1,%bl
  8109ef:	74 df                	je     8109d0 <malloc+0xcc>
  8109f1:	89 c3                	mov    %eax,%ebx
  8109f3:	c1 eb 0c             	shr    $0xc,%ebx
  8109f6:	8b 1c 9d 00 00 40 ef 	mov    -0x10c00000(,%ebx,4),%ebx
  8109fd:	f6 c3 01             	test   $0x1,%bl
  810a00:	74 ce                	je     8109d0 <malloc+0xcc>
  810a02:	81 c2 00 10 00 00    	add    $0x1000,%edx
  810a08:	0f b6 75 e3          	movzbl -0x1d(%ebp),%esi
		if (mptr == mend) {
  810a0c:	81 fa 00 00 00 10    	cmp    $0x10000000,%edx
  810a12:	74 0a                	je     810a1e <malloc+0x11a>
  810a14:	89 55 e4             	mov    %edx,-0x1c(%ebp)
	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
  810a17:	89 d0                	mov    %edx,%eax
  810a19:	8d 0c 17             	lea    (%edi,%edx,1),%ecx
  810a1c:	eb b7                	jmp    8109d5 <malloc+0xd1>
			mptr = mbegin;
  810a1e:	ba 00 00 00 08       	mov    $0x8000000,%edx
  810a23:	be 01 00 00 00       	mov    $0x1,%esi
			if (++nwrap == 2)
  810a28:	83 6d d8 01          	subl   $0x1,-0x28(%ebp)
  810a2c:	75 e6                	jne    810a14 <malloc+0x110>
  810a2e:	c7 05 d4 b1 b3 00 00 	movl   $0x8000000,0xb3b1d4
  810a35:	00 00 08 
				return 0;	/* out of address space */
  810a38:	b8 00 00 00 00       	mov    $0x0,%eax
  810a3d:	eb 6d                	jmp    810aac <malloc+0x1a8>
			return 0;	/* out of physical memory */
  810a3f:	b8 00 00 00 00       	mov    $0x0,%eax
  810a44:	eb 66                	jmp    810aac <malloc+0x1a8>
		return 0;
  810a46:	b8 00 00 00 00       	mov    $0x0,%eax
  810a4b:	eb 5f                	jmp    810aac <malloc+0x1a8>
  810a4d:	89 f0                	mov    %esi,%eax
  810a4f:	84 c0                	test   %al,%al
  810a51:	74 08                	je     810a5b <malloc+0x157>
  810a53:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  810a56:	a3 d4 b1 b3 00       	mov    %eax,0xb3b1d4
	for (i = 0; i < n + 4; i += PGSIZE){
  810a5b:	bb 00 00 00 00       	mov    $0x0,%ebx
  810a60:	89 de                	mov    %ebx,%esi
  810a62:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
		cont = (i + PGSIZE < n + 4) ? PTE_CONTINUED : 0;
  810a65:	81 c3 00 10 00 00    	add    $0x1000,%ebx
  810a6b:	39 df                	cmp    %ebx,%edi
  810a6d:	76 45                	jbe    810ab4 <malloc+0x1b0>
		if (sys_page_alloc(0, mptr + i, PTE_P|PTE_U|PTE_W|cont) < 0){
  810a6f:	83 ec 04             	sub    $0x4,%esp
  810a72:	68 07 02 00 00       	push   $0x207
  810a77:	03 35 d4 b1 b3 00    	add    0xb3b1d4,%esi
  810a7d:	56                   	push   %esi
  810a7e:	6a 00                	push   $0x0
  810a80:	e8 f5 e9 ff ff       	call   80f47a <sys_page_alloc>
  810a85:	83 c4 10             	add    $0x10,%esp
  810a88:	85 c0                	test   %eax,%eax
  810a8a:	79 d4                	jns    810a60 <malloc+0x15c>
  810a8c:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  810a8f:	eb 42                	jmp    810ad3 <malloc+0x1cf>
	ref = (uint32_t*) (mptr + i - 4);
  810a91:	a1 d4 b1 b3 00       	mov    0xb3b1d4,%eax
	*ref = 2;	/* reference for mptr, reference for returned block */
  810a96:	c7 84 30 fc 0f 00 00 	movl   $0x2,0xffc(%eax,%esi,1)
  810a9d:	02 00 00 00 
	mptr += n;
  810aa1:	8b 55 dc             	mov    -0x24(%ebp),%edx
  810aa4:	01 c2                	add    %eax,%edx
  810aa6:	89 15 d4 b1 b3 00    	mov    %edx,0xb3b1d4
}
  810aac:	8d 65 f4             	lea    -0xc(%ebp),%esp
  810aaf:	5b                   	pop    %ebx
  810ab0:	5e                   	pop    %esi
  810ab1:	5f                   	pop    %edi
  810ab2:	5d                   	pop    %ebp
  810ab3:	c3                   	ret    
		if (sys_page_alloc(0, mptr + i, PTE_P|PTE_U|PTE_W|cont) < 0){
  810ab4:	83 ec 04             	sub    $0x4,%esp
  810ab7:	6a 07                	push   $0x7
  810ab9:	89 f0                	mov    %esi,%eax
  810abb:	03 05 d4 b1 b3 00    	add    0xb3b1d4,%eax
  810ac1:	50                   	push   %eax
  810ac2:	6a 00                	push   $0x0
  810ac4:	e8 b1 e9 ff ff       	call   80f47a <sys_page_alloc>
  810ac9:	83 c4 10             	add    $0x10,%esp
  810acc:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  810acf:	85 c0                	test   %eax,%eax
  810ad1:	79 be                	jns    810a91 <malloc+0x18d>
			for (; i >= 0; i -= PGSIZE)
  810ad3:	85 db                	test   %ebx,%ebx
  810ad5:	0f 88 64 ff ff ff    	js     810a3f <malloc+0x13b>
				sys_page_unmap(0, mptr + i);
  810adb:	83 ec 08             	sub    $0x8,%esp
  810ade:	89 d8                	mov    %ebx,%eax
  810ae0:	03 05 d4 b1 b3 00    	add    0xb3b1d4,%eax
  810ae6:	50                   	push   %eax
  810ae7:	6a 00                	push   $0x0
  810ae9:	e8 19 ea ff ff       	call   80f507 <sys_page_unmap>
			for (; i >= 0; i -= PGSIZE)
  810aee:	81 eb 00 10 00 00    	sub    $0x1000,%ebx
  810af4:	83 c4 10             	add    $0x10,%esp
  810af7:	eb da                	jmp    810ad3 <malloc+0x1cf>

00810af9 <devpipe_stat>:
	return i;
}

static int
devpipe_stat(struct Fd *fd, struct Stat *stat)
{
  810af9:	f3 0f 1e fb          	endbr32 
  810afd:	55                   	push   %ebp
  810afe:	89 e5                	mov    %esp,%ebp
  810b00:	56                   	push   %esi
  810b01:	53                   	push   %ebx
  810b02:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	struct Pipe *p = (struct Pipe*) fd2data(fd);
  810b05:	83 ec 0c             	sub    $0xc,%esp
  810b08:	ff 75 08             	pushl  0x8(%ebp)
  810b0b:	e8 51 f0 ff ff       	call   80fb61 <fd2data>
  810b10:	89 c6                	mov    %eax,%esi
	strcpy(stat->st_name, "<pipe>");
  810b12:	83 c4 08             	add    $0x8,%esp
  810b15:	68 3b 3e 81 00       	push   $0x813e3b
  810b1a:	53                   	push   %ebx
  810b1b:	e8 18 e5 ff ff       	call   80f038 <strcpy>
	stat->st_size = p->p_wpos - p->p_rpos;
  810b20:	8b 46 04             	mov    0x4(%esi),%eax
  810b23:	2b 06                	sub    (%esi),%eax
  810b25:	89 83 80 00 00 00    	mov    %eax,0x80(%ebx)
	stat->st_isdir = 0;
  810b2b:	c7 83 84 00 00 00 00 	movl   $0x0,0x84(%ebx)
  810b32:	00 00 00 
	stat->st_dev = &devpipe;
  810b35:	c7 83 88 00 00 00 24 	movl   $0x814324,0x88(%ebx)
  810b3c:	43 81 00 
	return 0;
}
  810b3f:	b8 00 00 00 00       	mov    $0x0,%eax
  810b44:	8d 65 f8             	lea    -0x8(%ebp),%esp
  810b47:	5b                   	pop    %ebx
  810b48:	5e                   	pop    %esi
  810b49:	5d                   	pop    %ebp
  810b4a:	c3                   	ret    

00810b4b <devpipe_close>:

static int
devpipe_close(struct Fd *fd)
{
  810b4b:	f3 0f 1e fb          	endbr32 
  810b4f:	55                   	push   %ebp
  810b50:	89 e5                	mov    %esp,%ebp
  810b52:	53                   	push   %ebx
  810b53:	83 ec 0c             	sub    $0xc,%esp
  810b56:	8b 5d 08             	mov    0x8(%ebp),%ebx
	(void) sys_page_unmap(0, fd);
  810b59:	53                   	push   %ebx
  810b5a:	6a 00                	push   $0x0
  810b5c:	e8 a6 e9 ff ff       	call   80f507 <sys_page_unmap>
	return sys_page_unmap(0, fd2data(fd));
  810b61:	89 1c 24             	mov    %ebx,(%esp)
  810b64:	e8 f8 ef ff ff       	call   80fb61 <fd2data>
  810b69:	83 c4 08             	add    $0x8,%esp
  810b6c:	50                   	push   %eax
  810b6d:	6a 00                	push   $0x0
  810b6f:	e8 93 e9 ff ff       	call   80f507 <sys_page_unmap>
}
  810b74:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  810b77:	c9                   	leave  
  810b78:	c3                   	ret    

00810b79 <_pipeisclosed>:
{
  810b79:	55                   	push   %ebp
  810b7a:	89 e5                	mov    %esp,%ebp
  810b7c:	57                   	push   %edi
  810b7d:	56                   	push   %esi
  810b7e:	53                   	push   %ebx
  810b7f:	83 ec 1c             	sub    $0x1c,%esp
  810b82:	89 c7                	mov    %eax,%edi
  810b84:	89 d6                	mov    %edx,%esi
		n = thisenv->env_runs;
  810b86:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
  810b8b:	8b 58 58             	mov    0x58(%eax),%ebx
		ret = pageref(fd) == pageref(p);
  810b8e:	83 ec 0c             	sub    $0xc,%esp
  810b91:	57                   	push   %edi
  810b92:	e8 f6 04 00 00       	call   81108d <pageref>
  810b97:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  810b9a:	89 34 24             	mov    %esi,(%esp)
  810b9d:	e8 eb 04 00 00       	call   81108d <pageref>
		nn = thisenv->env_runs;
  810ba2:	8b 15 5c b2 b3 00    	mov    0xb3b25c,%edx
  810ba8:	8b 4a 58             	mov    0x58(%edx),%ecx
		if (n == nn)
  810bab:	83 c4 10             	add    $0x10,%esp
  810bae:	39 cb                	cmp    %ecx,%ebx
  810bb0:	74 1b                	je     810bcd <_pipeisclosed+0x54>
		if (n != nn && ret == 1)
  810bb2:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
  810bb5:	75 cf                	jne    810b86 <_pipeisclosed+0xd>
			cprintf("pipe race avoided\n", n, thisenv->env_runs, ret);
  810bb7:	8b 42 58             	mov    0x58(%edx),%eax
  810bba:	6a 01                	push   $0x1
  810bbc:	50                   	push   %eax
  810bbd:	53                   	push   %ebx
  810bbe:	68 42 3e 81 00       	push   $0x813e42
  810bc3:	e8 66 de ff ff       	call   80ea2e <cprintf>
  810bc8:	83 c4 10             	add    $0x10,%esp
  810bcb:	eb b9                	jmp    810b86 <_pipeisclosed+0xd>
		ret = pageref(fd) == pageref(p);
  810bcd:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
  810bd0:	0f 94 c0             	sete   %al
  810bd3:	0f b6 c0             	movzbl %al,%eax
}
  810bd6:	8d 65 f4             	lea    -0xc(%ebp),%esp
  810bd9:	5b                   	pop    %ebx
  810bda:	5e                   	pop    %esi
  810bdb:	5f                   	pop    %edi
  810bdc:	5d                   	pop    %ebp
  810bdd:	c3                   	ret    

00810bde <devpipe_write>:
{
  810bde:	f3 0f 1e fb          	endbr32 
  810be2:	55                   	push   %ebp
  810be3:	89 e5                	mov    %esp,%ebp
  810be5:	57                   	push   %edi
  810be6:	56                   	push   %esi
  810be7:	53                   	push   %ebx
  810be8:	83 ec 28             	sub    $0x28,%esp
  810beb:	8b 75 08             	mov    0x8(%ebp),%esi
	p = (struct Pipe*) fd2data(fd);
  810bee:	56                   	push   %esi
  810bef:	e8 6d ef ff ff       	call   80fb61 <fd2data>
  810bf4:	89 c3                	mov    %eax,%ebx
	for (i = 0; i < n; i++) {
  810bf6:	83 c4 10             	add    $0x10,%esp
  810bf9:	bf 00 00 00 00       	mov    $0x0,%edi
  810bfe:	3b 7d 10             	cmp    0x10(%ebp),%edi
  810c01:	74 4f                	je     810c52 <devpipe_write+0x74>
		while (p->p_wpos >= p->p_rpos + sizeof(p->p_buf)) {
  810c03:	8b 43 04             	mov    0x4(%ebx),%eax
  810c06:	8b 0b                	mov    (%ebx),%ecx
  810c08:	8d 51 20             	lea    0x20(%ecx),%edx
  810c0b:	39 d0                	cmp    %edx,%eax
  810c0d:	72 14                	jb     810c23 <devpipe_write+0x45>
			if (_pipeisclosed(fd, p))
  810c0f:	89 da                	mov    %ebx,%edx
  810c11:	89 f0                	mov    %esi,%eax
  810c13:	e8 61 ff ff ff       	call   810b79 <_pipeisclosed>
  810c18:	85 c0                	test   %eax,%eax
  810c1a:	75 3b                	jne    810c57 <devpipe_write+0x79>
			sys_yield();
  810c1c:	e8 36 e8 ff ff       	call   80f457 <sys_yield>
  810c21:	eb e0                	jmp    810c03 <devpipe_write+0x25>
		p->p_buf[p->p_wpos % PIPEBUFSIZ] = buf[i];
  810c23:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  810c26:	0f b6 0c 39          	movzbl (%ecx,%edi,1),%ecx
  810c2a:	88 4d e7             	mov    %cl,-0x19(%ebp)
  810c2d:	89 c2                	mov    %eax,%edx
  810c2f:	c1 fa 1f             	sar    $0x1f,%edx
  810c32:	89 d1                	mov    %edx,%ecx
  810c34:	c1 e9 1b             	shr    $0x1b,%ecx
  810c37:	8d 14 08             	lea    (%eax,%ecx,1),%edx
  810c3a:	83 e2 1f             	and    $0x1f,%edx
  810c3d:	29 ca                	sub    %ecx,%edx
  810c3f:	0f b6 4d e7          	movzbl -0x19(%ebp),%ecx
  810c43:	88 4c 13 08          	mov    %cl,0x8(%ebx,%edx,1)
		p->p_wpos++;
  810c47:	83 c0 01             	add    $0x1,%eax
  810c4a:	89 43 04             	mov    %eax,0x4(%ebx)
	for (i = 0; i < n; i++) {
  810c4d:	83 c7 01             	add    $0x1,%edi
  810c50:	eb ac                	jmp    810bfe <devpipe_write+0x20>
	return i;
  810c52:	8b 45 10             	mov    0x10(%ebp),%eax
  810c55:	eb 05                	jmp    810c5c <devpipe_write+0x7e>
				return 0;
  810c57:	b8 00 00 00 00       	mov    $0x0,%eax
}
  810c5c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  810c5f:	5b                   	pop    %ebx
  810c60:	5e                   	pop    %esi
  810c61:	5f                   	pop    %edi
  810c62:	5d                   	pop    %ebp
  810c63:	c3                   	ret    

00810c64 <devpipe_read>:
{
  810c64:	f3 0f 1e fb          	endbr32 
  810c68:	55                   	push   %ebp
  810c69:	89 e5                	mov    %esp,%ebp
  810c6b:	57                   	push   %edi
  810c6c:	56                   	push   %esi
  810c6d:	53                   	push   %ebx
  810c6e:	83 ec 18             	sub    $0x18,%esp
  810c71:	8b 7d 08             	mov    0x8(%ebp),%edi
	p = (struct Pipe*)fd2data(fd);
  810c74:	57                   	push   %edi
  810c75:	e8 e7 ee ff ff       	call   80fb61 <fd2data>
  810c7a:	89 c3                	mov    %eax,%ebx
	for (i = 0; i < n; i++) {
  810c7c:	83 c4 10             	add    $0x10,%esp
  810c7f:	be 00 00 00 00       	mov    $0x0,%esi
  810c84:	3b 75 10             	cmp    0x10(%ebp),%esi
  810c87:	75 14                	jne    810c9d <devpipe_read+0x39>
	return i;
  810c89:	8b 45 10             	mov    0x10(%ebp),%eax
  810c8c:	eb 02                	jmp    810c90 <devpipe_read+0x2c>
				return i;
  810c8e:	89 f0                	mov    %esi,%eax
}
  810c90:	8d 65 f4             	lea    -0xc(%ebp),%esp
  810c93:	5b                   	pop    %ebx
  810c94:	5e                   	pop    %esi
  810c95:	5f                   	pop    %edi
  810c96:	5d                   	pop    %ebp
  810c97:	c3                   	ret    
			sys_yield();
  810c98:	e8 ba e7 ff ff       	call   80f457 <sys_yield>
		while (p->p_rpos == p->p_wpos) {
  810c9d:	8b 03                	mov    (%ebx),%eax
  810c9f:	3b 43 04             	cmp    0x4(%ebx),%eax
  810ca2:	75 18                	jne    810cbc <devpipe_read+0x58>
			if (i > 0)
  810ca4:	85 f6                	test   %esi,%esi
  810ca6:	75 e6                	jne    810c8e <devpipe_read+0x2a>
			if (_pipeisclosed(fd, p))
  810ca8:	89 da                	mov    %ebx,%edx
  810caa:	89 f8                	mov    %edi,%eax
  810cac:	e8 c8 fe ff ff       	call   810b79 <_pipeisclosed>
  810cb1:	85 c0                	test   %eax,%eax
  810cb3:	74 e3                	je     810c98 <devpipe_read+0x34>
				return 0;
  810cb5:	b8 00 00 00 00       	mov    $0x0,%eax
  810cba:	eb d4                	jmp    810c90 <devpipe_read+0x2c>
		buf[i] = p->p_buf[p->p_rpos % PIPEBUFSIZ];
  810cbc:	99                   	cltd   
  810cbd:	c1 ea 1b             	shr    $0x1b,%edx
  810cc0:	01 d0                	add    %edx,%eax
  810cc2:	83 e0 1f             	and    $0x1f,%eax
  810cc5:	29 d0                	sub    %edx,%eax
  810cc7:	0f b6 44 03 08       	movzbl 0x8(%ebx,%eax,1),%eax
  810ccc:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  810ccf:	88 04 31             	mov    %al,(%ecx,%esi,1)
		p->p_rpos++;
  810cd2:	83 03 01             	addl   $0x1,(%ebx)
	for (i = 0; i < n; i++) {
  810cd5:	83 c6 01             	add    $0x1,%esi
  810cd8:	eb aa                	jmp    810c84 <devpipe_read+0x20>

00810cda <pipe>:
{
  810cda:	f3 0f 1e fb          	endbr32 
  810cde:	55                   	push   %ebp
  810cdf:	89 e5                	mov    %esp,%ebp
  810ce1:	56                   	push   %esi
  810ce2:	53                   	push   %ebx
  810ce3:	83 ec 1c             	sub    $0x1c,%esp
	if ((r = fd_alloc(&fd0)) < 0
  810ce6:	8d 45 f4             	lea    -0xc(%ebp),%eax
  810ce9:	50                   	push   %eax
  810cea:	e8 8d ee ff ff       	call   80fb7c <fd_alloc>
  810cef:	89 c3                	mov    %eax,%ebx
  810cf1:	83 c4 10             	add    $0x10,%esp
  810cf4:	85 c0                	test   %eax,%eax
  810cf6:	0f 88 23 01 00 00    	js     810e1f <pipe+0x145>
	    || (r = sys_page_alloc(0, fd0, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  810cfc:	83 ec 04             	sub    $0x4,%esp
  810cff:	68 07 04 00 00       	push   $0x407
  810d04:	ff 75 f4             	pushl  -0xc(%ebp)
  810d07:	6a 00                	push   $0x0
  810d09:	e8 6c e7 ff ff       	call   80f47a <sys_page_alloc>
  810d0e:	89 c3                	mov    %eax,%ebx
  810d10:	83 c4 10             	add    $0x10,%esp
  810d13:	85 c0                	test   %eax,%eax
  810d15:	0f 88 04 01 00 00    	js     810e1f <pipe+0x145>
	if ((r = fd_alloc(&fd1)) < 0
  810d1b:	83 ec 0c             	sub    $0xc,%esp
  810d1e:	8d 45 f0             	lea    -0x10(%ebp),%eax
  810d21:	50                   	push   %eax
  810d22:	e8 55 ee ff ff       	call   80fb7c <fd_alloc>
  810d27:	89 c3                	mov    %eax,%ebx
  810d29:	83 c4 10             	add    $0x10,%esp
  810d2c:	85 c0                	test   %eax,%eax
  810d2e:	0f 88 db 00 00 00    	js     810e0f <pipe+0x135>
	    || (r = sys_page_alloc(0, fd1, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  810d34:	83 ec 04             	sub    $0x4,%esp
  810d37:	68 07 04 00 00       	push   $0x407
  810d3c:	ff 75 f0             	pushl  -0x10(%ebp)
  810d3f:	6a 00                	push   $0x0
  810d41:	e8 34 e7 ff ff       	call   80f47a <sys_page_alloc>
  810d46:	89 c3                	mov    %eax,%ebx
  810d48:	83 c4 10             	add    $0x10,%esp
  810d4b:	85 c0                	test   %eax,%eax
  810d4d:	0f 88 bc 00 00 00    	js     810e0f <pipe+0x135>
	va = fd2data(fd0);
  810d53:	83 ec 0c             	sub    $0xc,%esp
  810d56:	ff 75 f4             	pushl  -0xc(%ebp)
  810d59:	e8 03 ee ff ff       	call   80fb61 <fd2data>
  810d5e:	89 c6                	mov    %eax,%esi
	if ((r = sys_page_alloc(0, va, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  810d60:	83 c4 0c             	add    $0xc,%esp
  810d63:	68 07 04 00 00       	push   $0x407
  810d68:	50                   	push   %eax
  810d69:	6a 00                	push   $0x0
  810d6b:	e8 0a e7 ff ff       	call   80f47a <sys_page_alloc>
  810d70:	89 c3                	mov    %eax,%ebx
  810d72:	83 c4 10             	add    $0x10,%esp
  810d75:	85 c0                	test   %eax,%eax
  810d77:	0f 88 82 00 00 00    	js     810dff <pipe+0x125>
	if ((r = sys_page_map(0, va, 0, fd2data(fd1), PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  810d7d:	83 ec 0c             	sub    $0xc,%esp
  810d80:	ff 75 f0             	pushl  -0x10(%ebp)
  810d83:	e8 d9 ed ff ff       	call   80fb61 <fd2data>
  810d88:	c7 04 24 07 04 00 00 	movl   $0x407,(%esp)
  810d8f:	50                   	push   %eax
  810d90:	6a 00                	push   $0x0
  810d92:	56                   	push   %esi
  810d93:	6a 00                	push   $0x0
  810d95:	e8 27 e7 ff ff       	call   80f4c1 <sys_page_map>
  810d9a:	89 c3                	mov    %eax,%ebx
  810d9c:	83 c4 20             	add    $0x20,%esp
  810d9f:	85 c0                	test   %eax,%eax
  810da1:	78 4e                	js     810df1 <pipe+0x117>
	fd0->fd_dev_id = devpipe.dev_id;
  810da3:	a1 24 43 81 00       	mov    0x814324,%eax
  810da8:	8b 55 f4             	mov    -0xc(%ebp),%edx
  810dab:	89 02                	mov    %eax,(%edx)
	fd0->fd_omode = O_RDONLY;
  810dad:	8b 55 f4             	mov    -0xc(%ebp),%edx
  810db0:	c7 42 08 00 00 00 00 	movl   $0x0,0x8(%edx)
	fd1->fd_dev_id = devpipe.dev_id;
  810db7:	8b 55 f0             	mov    -0x10(%ebp),%edx
  810dba:	89 02                	mov    %eax,(%edx)
	fd1->fd_omode = O_WRONLY;
  810dbc:	8b 45 f0             	mov    -0x10(%ebp),%eax
  810dbf:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%eax)
	pfd[0] = fd2num(fd0);
  810dc6:	83 ec 0c             	sub    $0xc,%esp
  810dc9:	ff 75 f4             	pushl  -0xc(%ebp)
  810dcc:	e8 7c ed ff ff       	call   80fb4d <fd2num>
  810dd1:	8b 4d 08             	mov    0x8(%ebp),%ecx
  810dd4:	89 01                	mov    %eax,(%ecx)
	pfd[1] = fd2num(fd1);
  810dd6:	83 c4 04             	add    $0x4,%esp
  810dd9:	ff 75 f0             	pushl  -0x10(%ebp)
  810ddc:	e8 6c ed ff ff       	call   80fb4d <fd2num>
  810de1:	8b 4d 08             	mov    0x8(%ebp),%ecx
  810de4:	89 41 04             	mov    %eax,0x4(%ecx)
	return 0;
  810de7:	83 c4 10             	add    $0x10,%esp
  810dea:	bb 00 00 00 00       	mov    $0x0,%ebx
  810def:	eb 2e                	jmp    810e1f <pipe+0x145>
	sys_page_unmap(0, va);
  810df1:	83 ec 08             	sub    $0x8,%esp
  810df4:	56                   	push   %esi
  810df5:	6a 00                	push   $0x0
  810df7:	e8 0b e7 ff ff       	call   80f507 <sys_page_unmap>
  810dfc:	83 c4 10             	add    $0x10,%esp
	sys_page_unmap(0, fd1);
  810dff:	83 ec 08             	sub    $0x8,%esp
  810e02:	ff 75 f0             	pushl  -0x10(%ebp)
  810e05:	6a 00                	push   $0x0
  810e07:	e8 fb e6 ff ff       	call   80f507 <sys_page_unmap>
  810e0c:	83 c4 10             	add    $0x10,%esp
	sys_page_unmap(0, fd0);
  810e0f:	83 ec 08             	sub    $0x8,%esp
  810e12:	ff 75 f4             	pushl  -0xc(%ebp)
  810e15:	6a 00                	push   $0x0
  810e17:	e8 eb e6 ff ff       	call   80f507 <sys_page_unmap>
  810e1c:	83 c4 10             	add    $0x10,%esp
}
  810e1f:	89 d8                	mov    %ebx,%eax
  810e21:	8d 65 f8             	lea    -0x8(%ebp),%esp
  810e24:	5b                   	pop    %ebx
  810e25:	5e                   	pop    %esi
  810e26:	5d                   	pop    %ebp
  810e27:	c3                   	ret    

00810e28 <pipeisclosed>:
{
  810e28:	f3 0f 1e fb          	endbr32 
  810e2c:	55                   	push   %ebp
  810e2d:	89 e5                	mov    %esp,%ebp
  810e2f:	83 ec 20             	sub    $0x20,%esp
	if ((r = fd_lookup(fdnum, &fd)) < 0)
  810e32:	8d 45 f4             	lea    -0xc(%ebp),%eax
  810e35:	50                   	push   %eax
  810e36:	ff 75 08             	pushl  0x8(%ebp)
  810e39:	e8 94 ed ff ff       	call   80fbd2 <fd_lookup>
  810e3e:	83 c4 10             	add    $0x10,%esp
  810e41:	85 c0                	test   %eax,%eax
  810e43:	78 18                	js     810e5d <pipeisclosed+0x35>
	p = (struct Pipe*) fd2data(fd);
  810e45:	83 ec 0c             	sub    $0xc,%esp
  810e48:	ff 75 f4             	pushl  -0xc(%ebp)
  810e4b:	e8 11 ed ff ff       	call   80fb61 <fd2data>
  810e50:	89 c2                	mov    %eax,%edx
	return _pipeisclosed(fd, p);
  810e52:	8b 45 f4             	mov    -0xc(%ebp),%eax
  810e55:	e8 1f fd ff ff       	call   810b79 <_pipeisclosed>
  810e5a:	83 c4 10             	add    $0x10,%esp
}
  810e5d:	c9                   	leave  
  810e5e:	c3                   	ret    

00810e5f <devcons_close>:
	return tot;
}

static int
devcons_close(struct Fd *fd)
{
  810e5f:	f3 0f 1e fb          	endbr32 
	USED(fd);

	return 0;
}
  810e63:	b8 00 00 00 00       	mov    $0x0,%eax
  810e68:	c3                   	ret    

00810e69 <devcons_stat>:

static int
devcons_stat(struct Fd *fd, struct Stat *stat)
{
  810e69:	f3 0f 1e fb          	endbr32 
  810e6d:	55                   	push   %ebp
  810e6e:	89 e5                	mov    %esp,%ebp
  810e70:	83 ec 10             	sub    $0x10,%esp
	strcpy(stat->st_name, "<cons>");
  810e73:	68 5a 3e 81 00       	push   $0x813e5a
  810e78:	ff 75 0c             	pushl  0xc(%ebp)
  810e7b:	e8 b8 e1 ff ff       	call   80f038 <strcpy>
	return 0;
}
  810e80:	b8 00 00 00 00       	mov    $0x0,%eax
  810e85:	c9                   	leave  
  810e86:	c3                   	ret    

00810e87 <devcons_write>:
{
  810e87:	f3 0f 1e fb          	endbr32 
  810e8b:	55                   	push   %ebp
  810e8c:	89 e5                	mov    %esp,%ebp
  810e8e:	57                   	push   %edi
  810e8f:	56                   	push   %esi
  810e90:	53                   	push   %ebx
  810e91:	81 ec 8c 00 00 00    	sub    $0x8c,%esp
	for (tot = 0; tot < n; tot += m) {
  810e97:	be 00 00 00 00       	mov    $0x0,%esi
		memmove(buf, (char*)vbuf + tot, m);
  810e9c:	8d bd 68 ff ff ff    	lea    -0x98(%ebp),%edi
	for (tot = 0; tot < n; tot += m) {
  810ea2:	3b 75 10             	cmp    0x10(%ebp),%esi
  810ea5:	73 31                	jae    810ed8 <devcons_write+0x51>
		m = n - tot;
  810ea7:	8b 5d 10             	mov    0x10(%ebp),%ebx
  810eaa:	29 f3                	sub    %esi,%ebx
  810eac:	83 fb 7f             	cmp    $0x7f,%ebx
  810eaf:	b8 7f 00 00 00       	mov    $0x7f,%eax
  810eb4:	0f 47 d8             	cmova  %eax,%ebx
		memmove(buf, (char*)vbuf + tot, m);
  810eb7:	83 ec 04             	sub    $0x4,%esp
  810eba:	53                   	push   %ebx
  810ebb:	89 f0                	mov    %esi,%eax
  810ebd:	03 45 0c             	add    0xc(%ebp),%eax
  810ec0:	50                   	push   %eax
  810ec1:	57                   	push   %edi
  810ec2:	e8 27 e3 ff ff       	call   80f1ee <memmove>
		sys_cputs(buf, m);
  810ec7:	83 c4 08             	add    $0x8,%esp
  810eca:	53                   	push   %ebx
  810ecb:	57                   	push   %edi
  810ecc:	e8 d9 e4 ff ff       	call   80f3aa <sys_cputs>
	for (tot = 0; tot < n; tot += m) {
  810ed1:	01 de                	add    %ebx,%esi
  810ed3:	83 c4 10             	add    $0x10,%esp
  810ed6:	eb ca                	jmp    810ea2 <devcons_write+0x1b>
}
  810ed8:	89 f0                	mov    %esi,%eax
  810eda:	8d 65 f4             	lea    -0xc(%ebp),%esp
  810edd:	5b                   	pop    %ebx
  810ede:	5e                   	pop    %esi
  810edf:	5f                   	pop    %edi
  810ee0:	5d                   	pop    %ebp
  810ee1:	c3                   	ret    

00810ee2 <devcons_read>:
{
  810ee2:	f3 0f 1e fb          	endbr32 
  810ee6:	55                   	push   %ebp
  810ee7:	89 e5                	mov    %esp,%ebp
  810ee9:	83 ec 08             	sub    $0x8,%esp
  810eec:	b8 00 00 00 00       	mov    $0x0,%eax
	if (n == 0)
  810ef1:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  810ef5:	74 21                	je     810f18 <devcons_read+0x36>
	while ((c = sys_cgetc()) == 0)
  810ef7:	e8 d0 e4 ff ff       	call   80f3cc <sys_cgetc>
  810efc:	85 c0                	test   %eax,%eax
  810efe:	75 07                	jne    810f07 <devcons_read+0x25>
		sys_yield();
  810f00:	e8 52 e5 ff ff       	call   80f457 <sys_yield>
  810f05:	eb f0                	jmp    810ef7 <devcons_read+0x15>
	if (c < 0)
  810f07:	78 0f                	js     810f18 <devcons_read+0x36>
	if (c == 0x04)	// ctl-d is eof
  810f09:	83 f8 04             	cmp    $0x4,%eax
  810f0c:	74 0c                	je     810f1a <devcons_read+0x38>
	*(char*)vbuf = c;
  810f0e:	8b 55 0c             	mov    0xc(%ebp),%edx
  810f11:	88 02                	mov    %al,(%edx)
	return 1;
  810f13:	b8 01 00 00 00       	mov    $0x1,%eax
}
  810f18:	c9                   	leave  
  810f19:	c3                   	ret    
		return 0;
  810f1a:	b8 00 00 00 00       	mov    $0x0,%eax
  810f1f:	eb f7                	jmp    810f18 <devcons_read+0x36>

00810f21 <cputchar>:
{
  810f21:	f3 0f 1e fb          	endbr32 
  810f25:	55                   	push   %ebp
  810f26:	89 e5                	mov    %esp,%ebp
  810f28:	83 ec 20             	sub    $0x20,%esp
	char c = ch;
  810f2b:	8b 45 08             	mov    0x8(%ebp),%eax
  810f2e:	88 45 f7             	mov    %al,-0x9(%ebp)
	sys_cputs(&c, 1);
  810f31:	6a 01                	push   $0x1
  810f33:	8d 45 f7             	lea    -0x9(%ebp),%eax
  810f36:	50                   	push   %eax
  810f37:	e8 6e e4 ff ff       	call   80f3aa <sys_cputs>
}
  810f3c:	83 c4 10             	add    $0x10,%esp
  810f3f:	c9                   	leave  
  810f40:	c3                   	ret    

00810f41 <getchar>:
{
  810f41:	f3 0f 1e fb          	endbr32 
  810f45:	55                   	push   %ebp
  810f46:	89 e5                	mov    %esp,%ebp
  810f48:	83 ec 1c             	sub    $0x1c,%esp
	r = read(0, &c, 1);
  810f4b:	6a 01                	push   $0x1
  810f4d:	8d 45 f7             	lea    -0x9(%ebp),%eax
  810f50:	50                   	push   %eax
  810f51:	6a 00                	push   $0x0
  810f53:	e8 02 ef ff ff       	call   80fe5a <read>
	if (r < 0)
  810f58:	83 c4 10             	add    $0x10,%esp
  810f5b:	85 c0                	test   %eax,%eax
  810f5d:	78 06                	js     810f65 <getchar+0x24>
	if (r < 1)
  810f5f:	74 06                	je     810f67 <getchar+0x26>
	return c;
  810f61:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
}
  810f65:	c9                   	leave  
  810f66:	c3                   	ret    
		return -E_EOF;
  810f67:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
  810f6c:	eb f7                	jmp    810f65 <getchar+0x24>

00810f6e <iscons>:
{
  810f6e:	f3 0f 1e fb          	endbr32 
  810f72:	55                   	push   %ebp
  810f73:	89 e5                	mov    %esp,%ebp
  810f75:	83 ec 20             	sub    $0x20,%esp
	if ((r = fd_lookup(fdnum, &fd)) < 0)
  810f78:	8d 45 f4             	lea    -0xc(%ebp),%eax
  810f7b:	50                   	push   %eax
  810f7c:	ff 75 08             	pushl  0x8(%ebp)
  810f7f:	e8 4e ec ff ff       	call   80fbd2 <fd_lookup>
  810f84:	83 c4 10             	add    $0x10,%esp
  810f87:	85 c0                	test   %eax,%eax
  810f89:	78 11                	js     810f9c <iscons+0x2e>
	return fd->fd_dev_id == devcons.dev_id;
  810f8b:	8b 45 f4             	mov    -0xc(%ebp),%eax
  810f8e:	8b 15 40 43 81 00    	mov    0x814340,%edx
  810f94:	39 10                	cmp    %edx,(%eax)
  810f96:	0f 94 c0             	sete   %al
  810f99:	0f b6 c0             	movzbl %al,%eax
}
  810f9c:	c9                   	leave  
  810f9d:	c3                   	ret    

00810f9e <opencons>:
{
  810f9e:	f3 0f 1e fb          	endbr32 
  810fa2:	55                   	push   %ebp
  810fa3:	89 e5                	mov    %esp,%ebp
  810fa5:	83 ec 24             	sub    $0x24,%esp
	if ((r = fd_alloc(&fd)) < 0)
  810fa8:	8d 45 f4             	lea    -0xc(%ebp),%eax
  810fab:	50                   	push   %eax
  810fac:	e8 cb eb ff ff       	call   80fb7c <fd_alloc>
  810fb1:	83 c4 10             	add    $0x10,%esp
  810fb4:	85 c0                	test   %eax,%eax
  810fb6:	78 3a                	js     810ff2 <opencons+0x54>
	if ((r = sys_page_alloc(0, fd, PTE_P|PTE_U|PTE_W|PTE_SHARE)) < 0)
  810fb8:	83 ec 04             	sub    $0x4,%esp
  810fbb:	68 07 04 00 00       	push   $0x407
  810fc0:	ff 75 f4             	pushl  -0xc(%ebp)
  810fc3:	6a 00                	push   $0x0
  810fc5:	e8 b0 e4 ff ff       	call   80f47a <sys_page_alloc>
  810fca:	83 c4 10             	add    $0x10,%esp
  810fcd:	85 c0                	test   %eax,%eax
  810fcf:	78 21                	js     810ff2 <opencons+0x54>
	fd->fd_dev_id = devcons.dev_id;
  810fd1:	8b 45 f4             	mov    -0xc(%ebp),%eax
  810fd4:	8b 15 40 43 81 00    	mov    0x814340,%edx
  810fda:	89 10                	mov    %edx,(%eax)
	fd->fd_omode = O_RDWR;
  810fdc:	8b 45 f4             	mov    -0xc(%ebp),%eax
  810fdf:	c7 40 08 02 00 00 00 	movl   $0x2,0x8(%eax)
	return fd2num(fd);
  810fe6:	83 ec 0c             	sub    $0xc,%esp
  810fe9:	50                   	push   %eax
  810fea:	e8 5e eb ff ff       	call   80fb4d <fd2num>
  810fef:	83 c4 10             	add    $0x10,%esp
}
  810ff2:	c9                   	leave  
  810ff3:	c3                   	ret    

00810ff4 <set_pgfault_handler>:
// at UXSTACKTOP), and tell the kernel to call the assembly-language
// _pgfault_upcall routine when a page fault occurs.
//
void
set_pgfault_handler(void (*handler)(struct UTrapframe *utf))
{
  810ff4:	f3 0f 1e fb          	endbr32 
  810ff8:	55                   	push   %ebp
  810ff9:	89 e5                	mov    %esp,%ebp
  810ffb:	83 ec 08             	sub    $0x8,%esp
	int r;

	if (_pgfault_handler == 0) {
  810ffe:	83 3d 00 e0 b3 00 00 	cmpl   $0x0,0xb3e000
  811005:	74 0a                	je     811011 <set_pgfault_handler+0x1d>
			panic("set_pgfault_handler:sys_env_set_pgfault_upcall failed!\n");
		}
	}

	// Save handler pointer for assembly to call.
	_pgfault_handler = handler;
  811007:	8b 45 08             	mov    0x8(%ebp),%eax
  81100a:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
}
  81100f:	c9                   	leave  
  811010:	c3                   	ret    
		if(sys_page_alloc(0, (void *)(UXSTACKTOP - PGSIZE), PTE_W | PTE_U | PTE_P) < 0){
  811011:	83 ec 04             	sub    $0x4,%esp
  811014:	6a 07                	push   $0x7
  811016:	68 00 f0 bf ee       	push   $0xeebff000
  81101b:	6a 00                	push   $0x0
  81101d:	e8 58 e4 ff ff       	call   80f47a <sys_page_alloc>
  811022:	83 c4 10             	add    $0x10,%esp
  811025:	85 c0                	test   %eax,%eax
  811027:	78 2a                	js     811053 <set_pgfault_handler+0x5f>
		if(sys_env_set_pgfault_upcall(0, _pgfault_upcall) < 0){
  811029:	83 ec 08             	sub    $0x8,%esp
  81102c:	68 67 10 81 00       	push   $0x811067
  811031:	6a 00                	push   $0x0
  811033:	e8 a1 e5 ff ff       	call   80f5d9 <sys_env_set_pgfault_upcall>
  811038:	83 c4 10             	add    $0x10,%esp
  81103b:	85 c0                	test   %eax,%eax
  81103d:	79 c8                	jns    811007 <set_pgfault_handler+0x13>
			panic("set_pgfault_handler:sys_env_set_pgfault_upcall failed!\n");
  81103f:	83 ec 04             	sub    $0x4,%esp
  811042:	68 94 3e 81 00       	push   $0x813e94
  811047:	6a 25                	push   $0x25
  811049:	68 cc 3e 81 00       	push   $0x813ecc
  81104e:	e8 f4 d8 ff ff       	call   80e947 <_panic>
			panic("set_pgfault_handler:sys_page_alloc failed!\n");
  811053:	83 ec 04             	sub    $0x4,%esp
  811056:	68 68 3e 81 00       	push   $0x813e68
  81105b:	6a 22                	push   $0x22
  81105d:	68 cc 3e 81 00       	push   $0x813ecc
  811062:	e8 e0 d8 ff ff       	call   80e947 <_panic>

00811067 <_pgfault_upcall>:

.text
.globl _pgfault_upcall
_pgfault_upcall:
	// Call the C page fault handler.
	pushl %esp			// function argument: pointer to UTF
  811067:	54                   	push   %esp
	movl _pgfault_handler, %eax
  811068:	a1 00 e0 b3 00       	mov    0xb3e000,%eax
	call *%eax
  81106d:	ff d0                	call   *%eax
	addl $4, %esp			// pop function argument
  81106f:	83 c4 04             	add    $0x4,%esp

	// %eip 存储在 40(%esp)
	// %esp 存储在 48(%esp) 
	// 48(%esp) 之前运行的栈的栈顶
	// 我们要将eip的值写入栈顶下面的位置,并将栈顶指向该位置
	movl 48(%esp), %eax
  811072:	8b 44 24 30          	mov    0x30(%esp),%eax
	movl 40(%esp), %ebx
  811076:	8b 5c 24 28          	mov    0x28(%esp),%ebx
	subl $4, %eax
  81107a:	83 e8 04             	sub    $0x4,%eax
	movl %ebx, (%eax)
  81107d:	89 18                	mov    %ebx,(%eax)
	movl %eax, 48(%esp)
  81107f:	89 44 24 30          	mov    %eax,0x30(%esp)

	// Restore the trap-time registers.  After you do this, you
	// can no longer modify any general-purpose registers.
	// LAB 4: Your code here.
	// 跳过fault_va以及err
	addl $8, %esp
  811083:	83 c4 08             	add    $0x8,%esp
	popal
  811086:	61                   	popa   
	// Restore eflags from the stack.  After you do this, you can
	// no longer use arithmetic operations or anything else that
	// modifies eflags.
	// LAB 4: Your code here.
	// 跳过eip,恢复eflags
	addl $4, %esp
  811087:	83 c4 04             	add    $0x4,%esp
	popfl
  81108a:	9d                   	popf   

	// Switch back to the adjusted trap-time stack.
	// LAB 4: Your code here.
	// 恢复esp,如果第一处不将trap-time esp指向下一个位置,这里esp就会指向之前的栈顶
	popl %esp
  81108b:	5c                   	pop    %esp

	// Return to re-execute the instruction that faulted.
	// LAB 4: Your code here.
	// 由于第一处的设置,现在esp指向的值为trap-time eip,所以直接ret即可达到恢复上一次执行的效果
  81108c:	c3                   	ret    

0081108d <pageref>:
#include <inc/lib.h>

int
pageref(void *v)
{
  81108d:	f3 0f 1e fb          	endbr32 
  811091:	55                   	push   %ebp
  811092:	89 e5                	mov    %esp,%ebp
  811094:	8b 45 08             	mov    0x8(%ebp),%eax
	pte_t pte;

	if (!(uvpd[PDX(v)] & PTE_P))
  811097:	89 c2                	mov    %eax,%edx
  811099:	c1 ea 16             	shr    $0x16,%edx
  81109c:	8b 0c 95 00 d0 7b ef 	mov    -0x10843000(,%edx,4),%ecx
		return 0;
  8110a3:	ba 00 00 00 00       	mov    $0x0,%edx
	if (!(uvpd[PDX(v)] & PTE_P))
  8110a8:	f6 c1 01             	test   $0x1,%cl
  8110ab:	74 1c                	je     8110c9 <pageref+0x3c>
	pte = uvpt[PGNUM(v)];
  8110ad:	c1 e8 0c             	shr    $0xc,%eax
  8110b0:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
	if (!(pte & PTE_P))
  8110b7:	a8 01                	test   $0x1,%al
  8110b9:	74 0e                	je     8110c9 <pageref+0x3c>
		return 0;
	return pages[PGNUM(pte)].pp_ref;
  8110bb:	c1 e8 0c             	shr    $0xc,%eax
  8110be:	0f b7 14 c5 04 00 00 	movzwl -0x10fffffc(,%eax,8),%edx
  8110c5:	ef 
  8110c6:	0f b7 d2             	movzwl %dx,%edx
}
  8110c9:	89 d0                	mov    %edx,%eax
  8110cb:	5d                   	pop    %ebp
  8110cc:	c3                   	ret    
  8110cd:	66 90                	xchg   %ax,%ax
  8110cf:	90                   	nop

008110d0 <__udivdi3>:
  8110d0:	f3 0f 1e fb          	endbr32 
  8110d4:	55                   	push   %ebp
  8110d5:	57                   	push   %edi
  8110d6:	56                   	push   %esi
  8110d7:	53                   	push   %ebx
  8110d8:	83 ec 1c             	sub    $0x1c,%esp
  8110db:	8b 54 24 3c          	mov    0x3c(%esp),%edx
  8110df:	8b 6c 24 30          	mov    0x30(%esp),%ebp
  8110e3:	8b 74 24 34          	mov    0x34(%esp),%esi
  8110e7:	8b 5c 24 38          	mov    0x38(%esp),%ebx
  8110eb:	85 d2                	test   %edx,%edx
  8110ed:	75 19                	jne    811108 <__udivdi3+0x38>
  8110ef:	39 f3                	cmp    %esi,%ebx
  8110f1:	76 4d                	jbe    811140 <__udivdi3+0x70>
  8110f3:	31 ff                	xor    %edi,%edi
  8110f5:	89 e8                	mov    %ebp,%eax
  8110f7:	89 f2                	mov    %esi,%edx
  8110f9:	f7 f3                	div    %ebx
  8110fb:	89 fa                	mov    %edi,%edx
  8110fd:	83 c4 1c             	add    $0x1c,%esp
  811100:	5b                   	pop    %ebx
  811101:	5e                   	pop    %esi
  811102:	5f                   	pop    %edi
  811103:	5d                   	pop    %ebp
  811104:	c3                   	ret    
  811105:	8d 76 00             	lea    0x0(%esi),%esi
  811108:	39 f2                	cmp    %esi,%edx
  81110a:	76 14                	jbe    811120 <__udivdi3+0x50>
  81110c:	31 ff                	xor    %edi,%edi
  81110e:	31 c0                	xor    %eax,%eax
  811110:	89 fa                	mov    %edi,%edx
  811112:	83 c4 1c             	add    $0x1c,%esp
  811115:	5b                   	pop    %ebx
  811116:	5e                   	pop    %esi
  811117:	5f                   	pop    %edi
  811118:	5d                   	pop    %ebp
  811119:	c3                   	ret    
  81111a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  811120:	0f bd fa             	bsr    %edx,%edi
  811123:	83 f7 1f             	xor    $0x1f,%edi
  811126:	75 48                	jne    811170 <__udivdi3+0xa0>
  811128:	39 f2                	cmp    %esi,%edx
  81112a:	72 06                	jb     811132 <__udivdi3+0x62>
  81112c:	31 c0                	xor    %eax,%eax
  81112e:	39 eb                	cmp    %ebp,%ebx
  811130:	77 de                	ja     811110 <__udivdi3+0x40>
  811132:	b8 01 00 00 00       	mov    $0x1,%eax
  811137:	eb d7                	jmp    811110 <__udivdi3+0x40>
  811139:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  811140:	89 d9                	mov    %ebx,%ecx
  811142:	85 db                	test   %ebx,%ebx
  811144:	75 0b                	jne    811151 <__udivdi3+0x81>
  811146:	b8 01 00 00 00       	mov    $0x1,%eax
  81114b:	31 d2                	xor    %edx,%edx
  81114d:	f7 f3                	div    %ebx
  81114f:	89 c1                	mov    %eax,%ecx
  811151:	31 d2                	xor    %edx,%edx
  811153:	89 f0                	mov    %esi,%eax
  811155:	f7 f1                	div    %ecx
  811157:	89 c6                	mov    %eax,%esi
  811159:	89 e8                	mov    %ebp,%eax
  81115b:	89 f7                	mov    %esi,%edi
  81115d:	f7 f1                	div    %ecx
  81115f:	89 fa                	mov    %edi,%edx
  811161:	83 c4 1c             	add    $0x1c,%esp
  811164:	5b                   	pop    %ebx
  811165:	5e                   	pop    %esi
  811166:	5f                   	pop    %edi
  811167:	5d                   	pop    %ebp
  811168:	c3                   	ret    
  811169:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  811170:	89 f9                	mov    %edi,%ecx
  811172:	b8 20 00 00 00       	mov    $0x20,%eax
  811177:	29 f8                	sub    %edi,%eax
  811179:	d3 e2                	shl    %cl,%edx
  81117b:	89 54 24 08          	mov    %edx,0x8(%esp)
  81117f:	89 c1                	mov    %eax,%ecx
  811181:	89 da                	mov    %ebx,%edx
  811183:	d3 ea                	shr    %cl,%edx
  811185:	8b 4c 24 08          	mov    0x8(%esp),%ecx
  811189:	09 d1                	or     %edx,%ecx
  81118b:	89 f2                	mov    %esi,%edx
  81118d:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  811191:	89 f9                	mov    %edi,%ecx
  811193:	d3 e3                	shl    %cl,%ebx
  811195:	89 c1                	mov    %eax,%ecx
  811197:	d3 ea                	shr    %cl,%edx
  811199:	89 f9                	mov    %edi,%ecx
  81119b:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  81119f:	89 eb                	mov    %ebp,%ebx
  8111a1:	d3 e6                	shl    %cl,%esi
  8111a3:	89 c1                	mov    %eax,%ecx
  8111a5:	d3 eb                	shr    %cl,%ebx
  8111a7:	09 de                	or     %ebx,%esi
  8111a9:	89 f0                	mov    %esi,%eax
  8111ab:	f7 74 24 08          	divl   0x8(%esp)
  8111af:	89 d6                	mov    %edx,%esi
  8111b1:	89 c3                	mov    %eax,%ebx
  8111b3:	f7 64 24 0c          	mull   0xc(%esp)
  8111b7:	39 d6                	cmp    %edx,%esi
  8111b9:	72 15                	jb     8111d0 <__udivdi3+0x100>
  8111bb:	89 f9                	mov    %edi,%ecx
  8111bd:	d3 e5                	shl    %cl,%ebp
  8111bf:	39 c5                	cmp    %eax,%ebp
  8111c1:	73 04                	jae    8111c7 <__udivdi3+0xf7>
  8111c3:	39 d6                	cmp    %edx,%esi
  8111c5:	74 09                	je     8111d0 <__udivdi3+0x100>
  8111c7:	89 d8                	mov    %ebx,%eax
  8111c9:	31 ff                	xor    %edi,%edi
  8111cb:	e9 40 ff ff ff       	jmp    811110 <__udivdi3+0x40>
  8111d0:	8d 43 ff             	lea    -0x1(%ebx),%eax
  8111d3:	31 ff                	xor    %edi,%edi
  8111d5:	e9 36 ff ff ff       	jmp    811110 <__udivdi3+0x40>
  8111da:	66 90                	xchg   %ax,%ax
  8111dc:	66 90                	xchg   %ax,%ax
  8111de:	66 90                	xchg   %ax,%ax

008111e0 <__umoddi3>:
  8111e0:	f3 0f 1e fb          	endbr32 
  8111e4:	55                   	push   %ebp
  8111e5:	57                   	push   %edi
  8111e6:	56                   	push   %esi
  8111e7:	53                   	push   %ebx
  8111e8:	83 ec 1c             	sub    $0x1c,%esp
  8111eb:	8b 44 24 3c          	mov    0x3c(%esp),%eax
  8111ef:	8b 74 24 30          	mov    0x30(%esp),%esi
  8111f3:	8b 5c 24 34          	mov    0x34(%esp),%ebx
  8111f7:	8b 7c 24 38          	mov    0x38(%esp),%edi
  8111fb:	85 c0                	test   %eax,%eax
  8111fd:	75 19                	jne    811218 <__umoddi3+0x38>
  8111ff:	39 df                	cmp    %ebx,%edi
  811201:	76 5d                	jbe    811260 <__umoddi3+0x80>
  811203:	89 f0                	mov    %esi,%eax
  811205:	89 da                	mov    %ebx,%edx
  811207:	f7 f7                	div    %edi
  811209:	89 d0                	mov    %edx,%eax
  81120b:	31 d2                	xor    %edx,%edx
  81120d:	83 c4 1c             	add    $0x1c,%esp
  811210:	5b                   	pop    %ebx
  811211:	5e                   	pop    %esi
  811212:	5f                   	pop    %edi
  811213:	5d                   	pop    %ebp
  811214:	c3                   	ret    
  811215:	8d 76 00             	lea    0x0(%esi),%esi
  811218:	89 f2                	mov    %esi,%edx
  81121a:	39 d8                	cmp    %ebx,%eax
  81121c:	76 12                	jbe    811230 <__umoddi3+0x50>
  81121e:	89 f0                	mov    %esi,%eax
  811220:	89 da                	mov    %ebx,%edx
  811222:	83 c4 1c             	add    $0x1c,%esp
  811225:	5b                   	pop    %ebx
  811226:	5e                   	pop    %esi
  811227:	5f                   	pop    %edi
  811228:	5d                   	pop    %ebp
  811229:	c3                   	ret    
  81122a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  811230:	0f bd e8             	bsr    %eax,%ebp
  811233:	83 f5 1f             	xor    $0x1f,%ebp
  811236:	75 50                	jne    811288 <__umoddi3+0xa8>
  811238:	39 d8                	cmp    %ebx,%eax
  81123a:	0f 82 e0 00 00 00    	jb     811320 <__umoddi3+0x140>
  811240:	89 d9                	mov    %ebx,%ecx
  811242:	39 f7                	cmp    %esi,%edi
  811244:	0f 86 d6 00 00 00    	jbe    811320 <__umoddi3+0x140>
  81124a:	89 d0                	mov    %edx,%eax
  81124c:	89 ca                	mov    %ecx,%edx
  81124e:	83 c4 1c             	add    $0x1c,%esp
  811251:	5b                   	pop    %ebx
  811252:	5e                   	pop    %esi
  811253:	5f                   	pop    %edi
  811254:	5d                   	pop    %ebp
  811255:	c3                   	ret    
  811256:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  81125d:	8d 76 00             	lea    0x0(%esi),%esi
  811260:	89 fd                	mov    %edi,%ebp
  811262:	85 ff                	test   %edi,%edi
  811264:	75 0b                	jne    811271 <__umoddi3+0x91>
  811266:	b8 01 00 00 00       	mov    $0x1,%eax
  81126b:	31 d2                	xor    %edx,%edx
  81126d:	f7 f7                	div    %edi
  81126f:	89 c5                	mov    %eax,%ebp
  811271:	89 d8                	mov    %ebx,%eax
  811273:	31 d2                	xor    %edx,%edx
  811275:	f7 f5                	div    %ebp
  811277:	89 f0                	mov    %esi,%eax
  811279:	f7 f5                	div    %ebp
  81127b:	89 d0                	mov    %edx,%eax
  81127d:	31 d2                	xor    %edx,%edx
  81127f:	eb 8c                	jmp    81120d <__umoddi3+0x2d>
  811281:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  811288:	89 e9                	mov    %ebp,%ecx
  81128a:	ba 20 00 00 00       	mov    $0x20,%edx
  81128f:	29 ea                	sub    %ebp,%edx
  811291:	d3 e0                	shl    %cl,%eax
  811293:	89 44 24 08          	mov    %eax,0x8(%esp)
  811297:	89 d1                	mov    %edx,%ecx
  811299:	89 f8                	mov    %edi,%eax
  81129b:	d3 e8                	shr    %cl,%eax
  81129d:	8b 4c 24 08          	mov    0x8(%esp),%ecx
  8112a1:	89 54 24 04          	mov    %edx,0x4(%esp)
  8112a5:	8b 54 24 04          	mov    0x4(%esp),%edx
  8112a9:	09 c1                	or     %eax,%ecx
  8112ab:	89 d8                	mov    %ebx,%eax
  8112ad:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  8112b1:	89 e9                	mov    %ebp,%ecx
  8112b3:	d3 e7                	shl    %cl,%edi
  8112b5:	89 d1                	mov    %edx,%ecx
  8112b7:	d3 e8                	shr    %cl,%eax
  8112b9:	89 e9                	mov    %ebp,%ecx
  8112bb:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  8112bf:	d3 e3                	shl    %cl,%ebx
  8112c1:	89 c7                	mov    %eax,%edi
  8112c3:	89 d1                	mov    %edx,%ecx
  8112c5:	89 f0                	mov    %esi,%eax
  8112c7:	d3 e8                	shr    %cl,%eax
  8112c9:	89 e9                	mov    %ebp,%ecx
  8112cb:	89 fa                	mov    %edi,%edx
  8112cd:	d3 e6                	shl    %cl,%esi
  8112cf:	09 d8                	or     %ebx,%eax
  8112d1:	f7 74 24 08          	divl   0x8(%esp)
  8112d5:	89 d1                	mov    %edx,%ecx
  8112d7:	89 f3                	mov    %esi,%ebx
  8112d9:	f7 64 24 0c          	mull   0xc(%esp)
  8112dd:	89 c6                	mov    %eax,%esi
  8112df:	89 d7                	mov    %edx,%edi
  8112e1:	39 d1                	cmp    %edx,%ecx
  8112e3:	72 06                	jb     8112eb <__umoddi3+0x10b>
  8112e5:	75 10                	jne    8112f7 <__umoddi3+0x117>
  8112e7:	39 c3                	cmp    %eax,%ebx
  8112e9:	73 0c                	jae    8112f7 <__umoddi3+0x117>
  8112eb:	2b 44 24 0c          	sub    0xc(%esp),%eax
  8112ef:	1b 54 24 08          	sbb    0x8(%esp),%edx
  8112f3:	89 d7                	mov    %edx,%edi
  8112f5:	89 c6                	mov    %eax,%esi
  8112f7:	89 ca                	mov    %ecx,%edx
  8112f9:	0f b6 4c 24 04       	movzbl 0x4(%esp),%ecx
  8112fe:	29 f3                	sub    %esi,%ebx
  811300:	19 fa                	sbb    %edi,%edx
  811302:	89 d0                	mov    %edx,%eax
  811304:	d3 e0                	shl    %cl,%eax
  811306:	89 e9                	mov    %ebp,%ecx
  811308:	d3 eb                	shr    %cl,%ebx
  81130a:	d3 ea                	shr    %cl,%edx
  81130c:	09 d8                	or     %ebx,%eax
  81130e:	83 c4 1c             	add    $0x1c,%esp
  811311:	5b                   	pop    %ebx
  811312:	5e                   	pop    %esi
  811313:	5f                   	pop    %edi
  811314:	5d                   	pop    %ebp
  811315:	c3                   	ret    
  811316:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  81131d:	8d 76 00             	lea    0x0(%esi),%esi
  811320:	29 fe                	sub    %edi,%esi
  811322:	19 c3                	sbb    %eax,%ebx
  811324:	89 f2                	mov    %esi,%edx
  811326:	89 d9                	mov    %ebx,%ecx
  811328:	e9 1d ff ff ff       	jmp    81124a <__umoddi3+0x6a>
